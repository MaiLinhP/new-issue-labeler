CategoryLabel	ServiceLabel	Title	Body
Client	Event Hubs	[FEATURE REQ] Support reading from a specific partition/offset without a consumer group (Kafka-style Assign)	Library name Azure.Messaging.EventHubs.Consumer Please describe the feature. We distribute transactions on one Event Hub, and dimensions (like Accounts) on another compacted Event Hub. Every consumer of Accounts needs the full, up-to-date snapshot from all partitions. Currently, each consumer must have its own consumer group to read from partitions, which adds unnecessary complexity and maintenance (dynamic consumer-group creation, cleanup,  etc.). It would be much simpler if we could start reading from a specific partition and offset without needing a consumer group, similar to Confluent.Kafka’s API. using var consumer = new ConsumerBuilder<Ignore, string>(config)     .SetValueDeserializer(Deserializers.Utf8)     .SetErrorHandler((_, e) => Console.WriteLine($`Error: {e.Reason}`))     .Build();  consumer.Assign(new TopicPartitionOffset(topic, 0, Offset.End));
Client	Service Bus	[QUERY] Re-subscribing in ServiceBusProcessor.ProcessErrorAsync, avoiding deadlock	Library name and version Azure.Messaging.ServiceBus 7.20.1 Query/Question Summary: What's the recommended way to handle a ServiceBusProcessor that might outlive the Subscription it's listening to? Details:  I'd like to use AutoDeleteOnIdle with my subscriptions On the (unlikely) chance that the subscription goes idle while the application instance is still running, the ServiceBusProcessor will fire an error event with a MessagingEntityNotFound ServiceBusException I'd like to re-create the subscription at that point to continue receiving messages I tried simply re-creating the subscription, but the existing ServiceBusProcessor instance does not seem to automatically continue receiving messages (I'm assuming once the error occurs, it stops polling for updates?) I then tried to create a new processor, but attempting to call processor.StopProcessingAsync() on the old seems to trigger a deadlock, which matches what the docs say: `It is not recommended that the state of the processor be managed directly from within this handler; requesting to start or stop the processor may result in a deadlock scenario.`  Environment No response
Client	Search	[BUG] KnowledgeAgent missing from Azure.Search.Documents 11.7.0	Library name and version Azure.Search.Documents 11.7.0 Describe the bug Azure.Search.Documents 11.7.0-bata.7 (the last beta) had KnowledgeAgent and all the associated classes to go agentic retrieval. when I upgrade from the beta to 11.7.0, those classes are all missing. It seems the Azure.Search.Documents.Agents is missing? Expected behavior Expected KnowledgeAgent to exist since it was added to beta.7. Actual behavior KnowledgeAgent missing from the GA Azure.Search.Documents 11.7.0. Reproduction Steps Include the Azure.Search.Documents 11.7.0 nuget package and try to create a new KnowledgeAgent. Environment No response
Client	Search	[BUG] Azure.Search.Documents 11.7.0 does not support aliases	Library name and version Azure.Search.Documents 11.7.0 Describe the bug 11.7.0 beta versions all supported index aliases.   Upon upgrading from 11.7.0-beta.7 to the final release 11.7.0, indexe aliases no longer worked (error of index was not found).   Downgraded back to 11.7.0-beta.7 to restore it working again. Expected behavior Index aliases should be supported in the final release, like they were in the beta. Actual behavior Index aliases report as not found with final release. Reproduction Steps Use an index alias with 11.7.0-beta.7 and observe it working.  Upgrade to latest 11.7.0 release and observe it failing. Environment dotnet core 9.0, azure container apps
Client	Search	[BUG] Make SearchResult constructor and Document property setter public	Library name and version Azure.Search.Documents 11.7.0 Describe the bug The constructor of Azure.Search.Documents.Models.SearchResult is internal. There is no way to instantiate it from client code. This makes unit testing difficult: I want to create mocks of the search service that returns SearchResult objects. For now the only way(s) to achieve this is to create my own search result class and do some mapping, or use reflection to instantiate SearchResult, both of which are not ideal. Similar to #1776 Expected behavior Azure.Search.Documents.Models.SearchResult default constructor is public; Document property setter is public; I am able to instantiate fake SearchResult objects for unit testing Actual behavior Azure.Search.Documents.Models.SearchResult default constructor is internal; Document property setter is internal; I am unable to instantiate fake SearchResult objects for unit testing Reproduction Steps Observe this .net fiddle, observe it does not compile: https://dotnetfiddle.net/7gajjD Environment No response
Client	Batch	[BUG] When creating a BatchTaskCreateOptions, there is no way to specify ResourceFiles,  ApplicationPackageReferences, EnvironmentSettings, etc	Library name and version Azure.Compute.Batch 1.0.0-beta3 Describe the bug I want to be able to specify all the properties of the BatchTaskCreateOptions. There is only a simply constructor that takes two parameters. The complete constructor is internal so can't call it. The properties like ResourceFiles,  ApplicationPackageReferences, EnvironmentSettings, etc are read only so can't be set. Expected behavior I should be able to change all the properties in a BatchTaskCreateOptions. Actual behavior There is only a simply constructor that takes two parameters. The complete constructor is internal so can't call it. The properties like ResourceFiles,  ApplicationPackageReferences, EnvironmentSettings, etc are read only so can't be set. Reproduction Steps Create a BatchTaskCreateOptions, specify the ResourceFiles,  ApplicationPackageReferences, EnvironmentSettings. Environment Visual Studio 2022. .Net SDK 9.0. .Net Framework 4.8.1. Windows 11 Pro 24H2.
Client	AI Agents	[BUG] FunctionToolDefinition from Azure.AI.Agents.Persistent has broken definition of equality/hash code	Library name and version Azure.AI.Agents.Persistent 1.2.0-beta.5 Describe the bug From https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors  If two objects compare as equal, the GetHashCode() method for each object must return the same value.  Otherwise, when you put one into a collection that buckets based on hash code, you may not be able to find the object that's been stored there. FunctionToolDefinition breaks these rules. Repro: using Azure.AI.Agents.Persistent;  var a = new FunctionToolDefinition(`hello`, `says hello`); var b = new FunctionToolDefinition(`hello`, `says hello`);  Console.WriteLine(a.Equals(b)); Console.WriteLine(a.GetHashCode()); Console.WriteLine(b.GetHashCode()); Expected behavior Either prints true followed by the same number twice, or prints false followed by any two numbers. Actual behavior e.g. True 7043582 24457708  The objects are comparing as equals, but they have different hash codes. Reproduction Steps Run the repro. Environment .NET 9
Client	AI Agents	Missing property in Azure.AI.Agents.Persistent.SubmitToolApprovalUpdate	The type is exposing the Name and Arguments of the MCP tool call: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/ai/Azure.AI.Agents.Persistent/src/Custom/Streaming/SubmitToolApprovalUpdate.cs but it's not exposing the server label, such that the consumer doesn't know which server the tool call is from (there can be multiple servers that all have the same tool name). The underlying RequiredMcpToolCall does expose this:                azure-sdk-for-net/sdk/ai/Azure.AI.Agents.Persistent/src/Generated/RequiredMcpToolCall.cs                   Lines 54 to 58       in       ea4b6a1                                                 public string Arguments { get; }                                           /// <summary> The name of the function used on the MCP server. </summary>                                           public string Name { get; }                                           /// <summary> The label of the MCP server. </summary>                                           public string ServerLabel { get; }                     but that RequiredMcpToolCall instance is private to the SubmitToolApprovalUpdate and not accessible to a consumer.
Client	AI Agents	Confusing parameter/property names in Azure.AI.Agents.Persistent.MCPApproval	The MCPApproval class has a constructor:                azure-sdk-for-net/sdk/ai/Azure.AI.Agents.Persistent/src/Custom/MCPApproval.cs                   Lines 54 to 55       in       ea4b6a1                                                 /// <param name=`trust`>The trust level, can be `always` or `never`</param>                                           public MCPApproval(string trust)                     I read that `trust` parameter being `always` or `never` as meaning whether to always trust a tool or never trust a tool. But it's the opposite. `always` here maps to approval always being required, and `never` maps to approval never being required, which is the opposite of the tool `always` being trusted or `never` being trusted, as highlighted by the subsequent properties:                azure-sdk-for-net/sdk/ai/Azure.AI.Agents.Persistent/src/Custom/MCPApproval.cs                   Lines 61 to 68       in       ea4b6a1                                                 /// <summary>                                           /// Return true if we do not trust all tool and always need to ask for approval before sending data to server.                                           /// </summary>                                           public bool AlwaysApprove{get => string.Equals(_forAllToolsApproval, ALWAYS);}                                           /// <summary>                                           /// Return true if we trust all tools and do not need to ask for approval before before sending data to server.                                           /// </summary>                                           public bool NeverApprove { get => string.Equals(_forAllToolsApproval, NEVER); }                     This parameter should be renamed, e.g. `requireApproval`. I suggest those properties should also be renamed. `AlwaysApprove` reads different to me than `AlwaysRequireApproval`; the former sounds like it's saying the system should always automatically approve of any tool calls, but that's the opposite of which it actually means, which is that all tool calls require approval.
Client	Event Hubs	[QUERY] EventHubs trigger function concurrency & partition lease	Library name and version Microsoft.Azure.Functions.Worker.Extensions.EventHubs 6.3.1 Query/Question Hi team, We need some clarification on the eventhubs trigger function, running on dedicated ASP (so no dynamic scaling). More specifically:   per our understanding, the global concurrency we can achieve should equal to the number of eventhubs partitions which should have nothing to do with the number of workers in the ASP (assuming the workers still have enough compute headroom). So if we only have 3 workers and the eventhubs has 100 partitions, we should still have 100 eventhubs functions running concurrently (assuming there are infinite events in each partitions). Each worker would basically start as many tasks as the partitions it owns to handle events in those partitions concurrently. Is the understanding correct? Is so, is the per-worker concurrency configurable if we want to limit it?   under what situation, the same partition might be processed by different workers? We observed that under high load, the same event (only one, not duplicates of the same event) is processed by multiple workers almost at the same time - it looks like one of the worker just failed to renew the lease and another workers acquire it somehow. We understand that eventhubs only guarantee at least once delivery, and our system is prepared to handle sequential duplicate events, but not duplicate events concurrently due to race condition. Also, is the lease duration configurable?   Thanks in advance Environment No response
Client	AI Agents	[BUG] Serialization error with AI Agents:  Unable to cast object of type 'd__2' to type	Library name and version Azure.AI.Agents.Persistent 1.2.0-beta.4 Describe the bug Message: Unable to cast object of type 'd__2' to type 'System.Collections.Generic.List`1[System.Text.Json.JsonElement]'.  Stack:    at System.Text.Json.JsonSerializer.UnboxOnWrite[T](Object value)    at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.SerializeAsObject(Utf8JsonWriter writer, Object rootValue)    at System.Text.Json.JsonSerializer.WriteStringAsObject(Object value, JsonTypeInfo jsonTypeInfo)    at System.Text.Json.JsonSerializer.Serialize(Object value, JsonTypeInfo jsonTypeInfo)    at Azure.AI.Agents.Persistent.ThreadMessages.CreateMessageAsync(String threadId, MessageRole role, IEnumerable`1 contentBlocks, IEnumerable`1 attachments, IReadOnlyDictionary`2 metadata, CancellationToken cancellationToken)    at Microsoft.SemanticKernel.Agents.AzureAI.Internal.AgentThreadActions.CreateMessageAsync(PersistentAgentsClient client, String threadId, ChatMessageContent message, CancellationToken cancellationToken)    at Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgentThread.OnNewMessageInternalAsync(ChatMessageContent newMessage, CancellationToken cancellationToken)    at Microsoft.SemanticKernel.Agents.AgentThread.OnNewMessageAsync(ChatMessageContent newMessage, CancellationToken cancellationToken)    at Microsoft.SemanticKernel.Agents.Agent.EnsureThreadExistsWithMessagesAsync[TThreadType](ICollection`1 messages, AgentThread thread, Func`1 constructThread, CancellationToken cancellationToken)    at Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync(ICollection`1 messages, AgentThread thread, AzureAIAgentInvokeOptions options, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync(ICollection`1 messages, AgentThread thread, AzureAIAgentInvokeOptions options, CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource.GetResult()  Expected behavior Throws this exception all the time when using  Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync which used to work on the same codebase of ours. Actual behavior Throws the above mentioned exception. Reproduction Steps Invoke Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync method with the following packages. <PackageReference Include=`Azure.AI.Agents.Persistent` Version=`1.2.0-beta.4` /> <PackageReference Include=`Azure.AI.OpenAI` Version=`2.3.0-beta.1` /> <PackageReference Include=`Azure.AI.Projects` Version=`1.0.0-beta.11` /> <PackageReference Include=`System.ClientModel` Version=`1.6.1` /> <PackageReference Include=`System.Linq.Async` Version=`6.0.3` /> <PackageReference Include=`Simplist.Framework.Services.Core` Version=`1.0.0` /> <PackageReference Include=`Simplist.Framework.Bootstrap` Version=`1.0.0` /> <PackageReference Include=`Microsoft.SemanticKernel` Version=`1.64.0` /> <PackageReference Include=`Microsoft.SemanticKernel.Core` Version=`1.64.0` /> <PackageReference Include=`Microsoft.SemanticKernel.Agents.Core` Version=`1.64.0` /> <PackageReference Include=`Microsoft.SemanticKernel.Agents.OpenAI` Version=`1.64.0-preview` /> <PackageReference Include=`Microsoft.SemanticKernel.Agents.AzureAI` Version=`1.64.0-preview` /> <PackageReference Include=`Microsoft.SemanticKernel.Plugins.Web` Version=`1.64.0-alpha` />  Environment .NET
Client	AI Agents	[QUERY]How to add a mcptool to an agent when using agentClient.Administration.GetAgent?	Library name and version Azure.AI.Agents.Persistent 1.2.0-beta.3 Query/Question I created an agent in Azure AI foundry,  and use the code to get it: var agent = agentClient.Administration.GetAgent(`id`);  How can I add the MCPToolDefinition to it? Environment No response
Client	Service Bus	[BUG] ServiceBusReceiver.PeekMessageAsync does not respect cancellation token on connect failure	Library name and version Azure.Messaging.ServiceBus 7.20.1 Describe the bug For cases when the service bus endpoint is not reachable, the cancellation token passed to  PeekMessageAsync is not respected. Expected behavior The call to PeekMessageAsync should timeout on a failed connection attempt in accordance to the cancellation token passed in the call. Actual behavior the connection times out at a fixed 65 seconds. Reproduction Steps Execute the following in an environment where the service bus instance cannot be reached. var service_bus_client = new Azure.Messaging.ServiceBus.ServiceBusClient(`<CSTR>`); var receiver = service_bus_client.CreateReceiver(`ej-file-commands`); CancellationTokenSource cts = new CancellationTokenSource(TimeSpan.FromSeconds(5)); cts.Token.Register(() => Console.WriteLine(`Cancellation requested`)); await receiver.PeekMessageAsync(cancellationToken: cts.Token);  Environment Windows and .net runtime 9.0.8
Client	AI Agents	[BUG] PersistentAgentsClient.Messages.CreateMessageAsync fails with `InvalidCastException`	Library name and version Azure.AI.Agents.Persistent 1.2.0-beta.4 Describe the bug PersistentAgentsClient.Messages.CreateMessageAsync  fails when providing an enumeration of MessageInputContentBlock. Can be easily reproduced with an existing unit-test: Sample_PersistentAgents_ImageFileInputs.ImageFileInMessageExampleAsync  Is this test not running in your pipeline?  Expected behavior Creates a message Actual behavior Throws exception due to a failed serialization System.InvalidCastException:     at System.Text.Json.JsonSerializer.UnboxOnWrite[T](Object value)    at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.SerializeAsObject(Utf8JsonWriter writer, Object rootValue)    at System.Text.Json.JsonSerializer.WriteStringAsObject(Object value, JsonTypeInfo jsonTypeInfo)    at Azure.AI.Agents.Persistent.ThreadMessages.CreateMessageAsync(String threadId, MessageRole role, IEnumerable`1 contentBlocks, IEnumerable`1 attachments, IReadOnlyDictionary`2 metadata, CancellationToken cancellationToken)  Reproduction Steps Run your unit-test: Sample_PersistentAgents_ImageFileInputs.ImageFileInMessageExampleAsync Environment .NET 9.0
Client	Azure.Core	[BUG] When upgrading from Azure.Core 1.46.1 to 1.47.1 System.Memory.Data fails to load on RaspBerryPi (Rasbian Linux-Arm)	Library name and version Azure.Core 1.47.1 Describe the bug When upgrading from Azure.Core 1.46.1 to 1.47.1 System.Memory.Data fails to load on RaspBerryPi (Raspbian Linux-Arm) when trying to create an azure table Sample Code: var tableClient = new TableServiceClient(connectionString); table = tableClient.GetTableClient(`table`);  await table.CreateIfNotExistsAsync(); Exception Could not load file or assembly 'System.Memory.Data, Version=8.0.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.  Note when forcing/including a newer version of the System.Memory.Data, like version 9.0.8 package the issue goes away. Expected behavior The code works and creates a table if not exist Actual behavior Exception is thrown Reproduction Steps Run the code below on a raspberry pi or linux arm using Azure.Core 1.47.1 and System.Memory.Data 8.0.1 Sample Code: var tableClient = new TableServiceClient(connectionString); table = tableClient.GetTableClient(`table`);  await table.CreateIfNotExistsAsync(); Environment RaspberryPi 2 with Raspbian PRETTY_NAME=`Raspbian GNU/Linux 12 (bookworm)` NAME=`Raspbian GNU/Linux` VERSION_ID=`12` .NET 9 Azure.Core 1.47.1 System.Memory.Data 8.0.1
Client	AI Agents	[BUG] Object reference not set to an instance of an object.	Library name and version Azure.AI.Agents.Persistent 1.2.0-beta.1 Describe the bug Message: Object reference not set to an instance of an object.  Stack:     at Azure.AI.Agents.Persistent.AsyncStreamingUpdateCollection.AsyncStreamingUpdateEnumerator.System.Collections.Generic.IAsyncEnumerator.MoveNextAsync()    at Azure.AI.Agents.Persistent.AsyncStreamingUpdateCollection.GetValuesFromPageAsync(ClientResult page)+MoveNext()    at Azure.AI.Agents.Persistent.AsyncStreamingUpdateCollection.GetValuesFromPageAsync(ClientResult page)+MoveNext()    at Azure.AI.Agents.Persistent.AsyncStreamingUpdateCollection.GetValuesFromPageAsync(ClientResult page)+System.Threading.Tasks.Sources.IValueTaskSource.GetResult()    at System.ClientModel.AsyncCollectionResult`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at System.ClientModel.AsyncCollectionResult`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at System.ClientModel.AsyncCollectionResult`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at System.ClientModel.AsyncCollectionResult`1.GetAsyncEnumerator(CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource.GetResult()    at Microsoft.SemanticKernel.Agents.AzureAI.Internal.AgentThreadActions.InvokeStreamingAsync(AzureAIAgent agent, PersistentAgentsClient client, String threadId, IList`1 messages, AzureAIInvocationOptions invocationOptions, ILogger logger, Kernel kernel, KernelArguments arguments, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Agents.AzureAI.Internal.AgentThreadActions.InvokeStreamingAsync(AzureAIAgent agent, PersistentAgentsClient client, String threadId, IList`1 messages, AzureAIInvocationOptions invocationOptions, ILogger logger, Kernel kernel, KernelArguments arguments, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Agents.AzureAI.Internal.AgentThreadActions.InvokeStreamingAsync(AzureAIAgent agent, PersistentAgentsClient client, String threadId, IList`1 messages, AzureAIInvocationOptions invocationOptions, ILogger logger, Kernel kernel, KernelArguments arguments, CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource.GetResult()    at Microsoft.SemanticKernel.Diagnostics.ActivityExtensions.RunWithActivityAsync[TResult](Func`1 getActivity, Func`1 operation, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Diagnostics.ActivityExtensions.RunWithActivityAsync[TResult](Func`1 getActivity, Func`1 operation, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Diagnostics.ActivityExtensions.RunWithActivityAsync[TResult](Func`1 getActivity, Func`1 operation, CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource.GetResult()    at Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync(ICollection`1 messages, AgentThread thread, AzureAIAgentInvokeOptions options, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync(ICollection`1 messages, AgentThread thread, AzureAIAgentInvokeOptions options, CancellationToken cancellationToken)+MoveNext()    at Microsoft.SemanticKernel.Agents.AzureAI.AzureAIAgent.InvokeStreamingAsync(ICollection`1 messages, AgentThread thread, AzureAIAgentInvokeOptions options, CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource.GetResult()  Expected behavior Error should be handled within the library and throw a meaning full error. Actual behavior Null reference error thrown Reproduction Steps we are running Azure AI Agents using Semantic Kernel .NET. This error popped up once and couldn't repro consistently. Environment No response
Client	AI Projects	[BUG] CustomKeys credentials are not serialized correctly	Library name and version Azure.AI.Projects 1.0.0-beta.11 Describe the bug When I use the SDK to get CustomKeys connections, the Credentials part is not serialized correctly. The actual response is compatible with the DeserializeCustomCredential method. https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/ai/Azure.AI.Projects/src/Generated/Models/CustomCredential.Serialization.cs#L71 There is no `keys` properties in the response inside the `credentials` object. The raw response from the api looks like: {   `name` : `**omit**`,   `id` : `**omit**`,   `type` : `CustomKeys`,   `target` : `_`,   `isDefault` : false,   `credentials` : {     `password` : `**CORRECT_VALUE**`,     `type` : `CustomKeys`   },   `metadata` : {     `baseUrl` : `**CORRECT_VALUE**`,     `username` : `**CORRECT_VALUE**`   } } The DeserializeCustomCredential tries to read the key credentials.keys as a nested object to create the Keys property of the CustomCredential.Credentials.Keys Something like that I guess: {   // omit   `credentials`: {     `type`: `CustomKeys`,     `keys`: {       `[KEY_NAME]`: `[KEY_VALUE]`     }   }   // omit } Expected behavior I expect the custom keys defined as `secret` in Azure Foundry available when using the AI Project SDK in the Credentials property of CustomCredential. Actual behavior Only the non secret custom keys are available in the metadata property. Nothing in the Credentials property. Reproduction Steps  Create a AI Foundry Project Add a Custom key connection `test` Add at least one secret key use AiProjectClient.Connections.GetConnectionAsync(`test`, includeCredentials: true) Try to access to ClientResult<ConnectionProperties>.Value.Credentials.Keys See null  Environment Windows 10, Dotnet 9 .NET SDK: Version:           9.0.304 Commit:            f12f5f689e Workload version:  9.0.300-manifests.610a1858 MSBuild version:   17.14.16+5d8159c5f Runtime Environment: OS Name:     Windows OS Version:  10.0.26100 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\9.0.304\ .NET workloads installed: There are no installed workloads to display. Configured to use loose manifests when installing new manifests. Host: Version:      9.0.8 Architecture: x64 Commit:       aae90fa090
Client	AI Agents	[BUG]Get an error message when connect to the Grounding bing custom search	Library name and version Microsoft.SemanticKernel.Agents.AzureAI 1.64.0.0 preview Describe the bug I created the Agent in Azure Ai Foundry, and connected to the grounding bing custom search, then using the following code to get the agent, and send message. var agentModel = this._aiProjectClient.Administration.GetAgent(this._agentId);```  Got this error message, seems the Tools is not the type BingGroundingToolDefinition.  ```Missing required parameter: 'tools[0].bing_custom_search'. Status: 400 (Bad Request) ErrorCode: missing_required_parameter```  ### Expected behavior  I'd like it works without error.  ### Actual behavior  Get an error message: ```Missing required parameter: 'tools[0].bing_custom_search'. Status: 400 (Bad Request) ErrorCode: missing_required_parameter```  ### Reproduction Steps  1. create the Agent in Azure Ai Foundry 2. connect the grounding bing custom search 3. then using the following code to get the agent, and send message. ``` var _aiProjectClient = new PersistentAgentsClient(option.AIServices.AzureAIFoundryProjectEndpoint, credential); var agentModel = this._aiProjectClient.Administration.GetAgent(this._agentId);```   ### Environment  _No response_
Mgmt	Network - Load Balancer	[BUG] Null Reference when creating LoadBalancerInboundNatPool through LoadBalancer CreateOrUpdate()	Library name and version Azure.ResourceManager.Network 1.11.1 - 1.11.3 Describe the bug NullReferenceException when Creating LoadBalancerInboundNatPool When creating a new LoadBalancerInboundNatPool object and attaching it to an existing Load Balancer via lb.CreateOrUpdate(), I encountered a NullReferenceException. I had already set all mandatory properties when constructing the LoadBalancerInboundNatPool.  Repro Example string subscriptionId = `Replace with your subid`; string resourceGroupName = `Replace with your rg`; string lbName = `Replace with your LB name`;  var credential = new DefaultAzureCredential(); var armClient = new ArmClient(credential, subscriptionId);  var lbId = LoadBalancerResource.CreateResourceIdentifier(subscriptionId, resourceGroupName, lbName); var subId = SubscriptionResource.CreateResourceIdentifier(subscriptionId); var lbResource = armClient.GetSubscriptionResource(subId).GetResourceGroup(resourceGroupName).Value; LoadBalancerData nlb = (await lbResource.GetLoadBalancerAsync(lbName)).Value.Data;  // Clear NAT pools nlb.InboundNatPools.Clear(); var frontendIpConfig = nlb.FrontendIPConfigurations[0]; Console.WriteLine($`Frontend IP Config ID: {frontendIpConfig.Id}`);  LoadBalancerInboundNatPool rdpPool = new LoadBalancerInboundNatPool() {     Name = `replace with your pool name`,     BackendPort = <replace with your personal config>,     FrontendPortRangeStart = <replace with your personal config>,     FrontendPortRangeEnd = <replace with your personal config>,     FrontendIPConfigurationId = frontendIpConfig.Id,     Protocol = LoadBalancingTransportProtocol.Tcp, };  nlb.InboundNatPools.Add(rdpPool);  var response = await armClient     .GetResourceGroupResource(ResourceGroupResource.CreateResourceIdentifier(subscriptionId, resourceGroupName))     .GetLoadBalancers()     .CreateOrUpdateAsync(WaitUntil.Completed, lbName, nlb);  Investigation The issue is with the LoadBalancerInboundNatPool constructors:  Public constructor: requires 4 mandatory parameters Internal constructor: requires 10 parameters (used for deserialization) Internal parameterless constructor: for deserialization only  Problem Chain  new LoadBalancerInboundNatPool() calls the parameterless constructor. This constructor does not initialize the Properties field. Setting properties like BackendPort, Protocol, etc. internally calls Properties.BackendPort, Properties.Protocol, etc. Since Properties is null, a NullReferenceException occurs.   Workaround Instead of using the parameterless constructor, explicitly create a new LoadBalancerInboundNatPoolProperties object: LoadBalancerInboundNatPool rdpPool = new LoadBalancerInboundNatPool(     VmssHelper.GetNatPoolName(role, natName),     new LoadBalancerInboundNatPoolProperties(         protocol: LoadBalancingTransportProtocol.Tcp,         frontendPortRangeStart: startPort,         frontendPortRangeEnd: endPort,         backendPort: backendPort     ) );  // Then set the frontend IP configuration rdpPool.Properties.FrontendIPConfigurationId = nlbFeIpCfg.Id; With this approach, the code works as expected. Expected behavior The code example should work without NRE. Actual behavior Exception message： Object reference not set to an instance of an object. Details： boundNatPoolProperties.JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.Models.LoadBalancerInboundNatPoolProperties.System.ClientModel.Primitives.IJsonModel<Azure.ResourceManager.Network.Models.LoadBalancerInboundNatPoolProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.ModelSerializationExtensions.WriteObjectValue[T](Utf8JsonWriter writer, T value, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.Models.LoadBalancerInboundNatPool.JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.Models.LoadBalancerInboundNatPool.System.ClientModel.Primitives.IJsonModel<Azure.ResourceManager.Network.Models.LoadBalancerInboundNatPool>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.ModelSerializationExtensions.WriteObjectValue[T](Utf8JsonWriter writer, T value, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.LoadBalancerData.JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.LoadBalancerData.System.ClientModel.Primitives.IJsonModel<Azure.ResourceManager.Network.LoadBalancerData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.ModelSerializationExtensions.WriteObjectValue[T](Utf8JsonWriter writer, T value, ModelReaderWriterOptions options) at Azure.ResourceManager.Network.LoadBalancersRestOperations.CreateCreateOrUpdateRequest(String subscriptionId, String resourceGroupName, String loadBalancerName, LoadBalancerData data) at Azure.ResourceManager.Network.LoadBalancersRestOperations.d__15.MoveNext() at Azure.ResourceManager.Network.LoadBalancerCollection.d__5.MoveNext() at LbAllocationPolicyTest.Program. Reproduction Steps Repro Example string subscriptionId = `Replace with your subid`; string resourceGroupName = `Replace with your rg`; string lbName = `Replace with your LB name`;  var credential = new DefaultAzureCredential(); var armClient = new ArmClient(credential, subscriptionId);  var lbId = LoadBalancerResource.CreateResourceIdentifier(subscriptionId, resourceGroupName, lbName); var subId = SubscriptionResource.CreateResourceIdentifier(subscriptionId); var lbResource = armClient.GetSubscriptionResource(subId).GetResourceGroup(resourceGroupName).Value; LoadBalancerData nlb = (await lbResource.GetLoadBalancerAsync(lbName)).Value.Data;  // Clear NAT pools nlb.InboundNatPools.Clear(); var frontendIpConfig = nlb.FrontendIPConfigurations[0]; Console.WriteLine($`Frontend IP Config ID: {frontendIpConfig.Id}`);  LoadBalancerInboundNatPool rdpPool = new LoadBalancerInboundNatPool() {     Name = `replace with your pool name`,     BackendPort = <replace with your personal config>,     FrontendPortRangeStart = <replace with your personal config>,     FrontendPortRangeEnd = <replace with your personal config>,     FrontendIPConfigurationId = frontendIpConfig.Id,     Protocol = LoadBalancingTransportProtocol.Tcp, };  nlb.InboundNatPools.Add(rdpPool);  var response = await armClient     .GetResourceGroupResource(ResourceGroupResource.CreateResourceIdentifier(subscriptionId, resourceGroupName))     .GetLoadBalancers()     .CreateOrUpdateAsync(WaitUntil.Completed, lbName, nlb);  Environment No response
Client	AI Agents	[QUESTION] Multiple MCP support for agents?	Library name Azure.AI.Agent Please describe the feature. Does AI Agent work with more than one mcp servers?
Client	AI Agents	[Useability Issue] Unintuitive Serialization of `MCPToolResource.RequireApproval` Leads to Runtime Errors	Package: Azure.AI.Agents.Persistent (1.2.0-beta.2) Namespace: Azure.AI.Agents.Persistent Description (Note - This is a summary of a discussion I had with Gemini while attempting to use the MCPToolResource.RequireApproval property.) The design of the MCPToolResource.RequireApproval property, while flexible in accepting a string or a complex object, creates a significant usability issue that leads developers to a `pit of failure`. Because the property is typed as BinaryData, the developer is forced to manually serialize the MCPApprovalPerTool object. The most intuitive way to do this, using BinaryData.FromObjectAsJson(), invokes the default System.Text.Json.JsonSerializer. This serializer preserves C# PascalCase property names (Never, ToolNames), which do not match the camelCase and snake_case names expected by the API. This mismatch inevitably leads to 400 Bad Request errors that are difficult for developers to diagnose and require a non-obvious, undiscoverable pattern to fix. The Intuitive Path (Which Fails) A developer's first instinct will be to construct the model and serialize it directly, as suggested by the RequireApproval property's own documentation. // 1. Create the strongly-typed SDK model. var approvalConfig = new MCPApprovalPerTool() {     Never = new MCPToolList(new List<string>() { `list_csv_files` }) };  var mcpToolResource = new MCPToolResource(`my-server-label`);  // 2. Serialize it using the standard, intuitive method with no options. // This preserves the C# property names `Never` and `ToolNames`. mcpToolResource.RequireApproval = BinaryData.FromObjectAsJson(approvalConfig);  // 3. This will fail when used in a client.Runs.CreateRun() call. var toolResources = mcpToolResource.ToToolResources();  Resulting Error This intuitive approach produces an incorrect JSON payload, causing the API to return a 400 Bad Request error on the very first mismatched property. {   `error`: {     `message`: `Unknown parameter: 'tool_resources.mcp[0].require_approval.Never'. Did you mean 'never'?`,     `type`: `invalid_request_error`,     `param`: `tool_resources.mcp[0].require_approval.Never`,     `code`: `unknown_parameter`   } } Notably, even if a developer attempts to solve this first error by applying a standard JsonNamingPolicy.CamelCase, they will immediately encounter a second error on the nested ToolNames property, which the API expects as tool_names (snake_case). This demonstrates that the problem cannot be solved with standard serialization techniques and requires a special approach. The Correct (but Undiscoverable) Solution The correct way to serialize the object is to bypass System.Text.Json entirely and explicitly invoke the SDK's internal serialization engine by casting the model to IPersistableModel<T> and using its Write method. using System.ClientModel.Primitives; // Required for IPersistableModel and ModelReaderWriterOptions  // 1. Create the strongly-typed SDK model. var approvalConfig = new MCPApprovalPerTool() {     Never = new MCPToolList(new List<string>() { `list_csv_files` }) };  var mcpToolResource = new MCPToolResource(`my-server-label`);  // 2. Use the non-obvious but correct serialization pattern. // This leverages the SDK's internal serializer which correctly handles all property names. BinaryData correctlySerializedData = ((IPersistableModel<MCPApprovalPerTool>)approvalConfig)     .Write(new ModelReaderWriterOptions(`W`)); // `W` for wire format  // 3. Assign the correctly serialized data. This now works. mcpToolResource.RequireApproval = correctlySerializedData;  var toolResources = mcpToolResource.ToToolResources(); Why This Should Be Considered a Usability Bug While a working path exists, the current design is problematic for a preview SDK that needs to be approachable:  It Fails the Principle of Least Astonishment: The most obvious code path leads directly to a runtime error. The Solution is Undiscoverable: There is no documentation, IntelliSense, or guidance that would lead a developer to the IPersistableModel.Write pattern. It requires inspecting the SDK's source code and understanding its internal architecture. It Creates a Poor Developer Experience: This issue can cause hours of frustrating debugging for what should be a straightforward task. This is precisely the kind of feedback that `Preview` releases are meant to solicit.  Actionable Suggestions for Improvement To improve the developer experience, please consider one of the following changes:   (Best) Add a Strongly-Typed Helper Method: Introduce a method on MCPToolResource that handles the complex serialization internally. This provides a clean, type-safe API and hides the implementation details. // Example of a better API public void SetApprovalConfiguration(MCPApprovalPerTool configuration) {     this.RequireApproval = ((IPersistableModel<MCPApprovalPerTool>)configuration)         .Write(new ModelReaderWriterOptions(`W`)); }   (Good) Update XML Documentation: At a minimum, please update the XML documentation for the RequireApproval property with a code example demonstrating the correct IPersistableModel.Write pattern. This would make the solution discoverable.   Environment VS 2022 and .Net v9
Client	Azure.Identity	[BUG] NullReferenceException in DefaultAzureCredentialFactory	Library name and version Azure.Identity 1.15.0 Describe the bug When I run my project in Visual Studio I'm getting NullReferenceException in this line:                azure-sdk-for-net/sdk/identity/Azure.Identity/src/DefaultAzureCredentialFactory.cs                    Line 326       in       4634e0a                                                 options.IsChainedCredential = true;                     This doesn't happen when I run the project from command line with dotnet run Adding these two options fixes the exception:         ExcludeBrokerCredential = true,         ExcludeVisualStudioCodeCredential = true,  Expected behavior No exception, this works when Azure.Identity is downgraded to 1.14.2 Actual behavior  Exception thrown: 'System.NullReferenceException' in Azure.Identity.dll  Reproduction Steps I can reproduce it in my project just by upgrading Azure.Identity from 1.14.2 to 1.15.0 Environment Latest version of Visual Studio on Windows 11
Client	AI Agents	[QUERY] Azure AI Persistent Agent/Tools	Library name and version Azure.AI.Agents.Persistent Query/Question I have a ai tool which will generate a csv file. I want an Agent to be able to let the user download that file. Basically it has too much data for the AI agent to display, so now I would like some way for it to download the file. Possibly the Tool can return the url which has the file. I am NOT trying to let the Agent use this file for learning/rag/context. I just want it to provide the link directly to the user. Currently the tool is an azure function which posts to the output queue, and the agent is properly showing that data if small. Please point me in the direction which will accomplish the goal. Environment No response
Client	System.ClientModel	[BUG]  Concurrency Bug in System.ClientModel.Primitives.ReflectionContext	Library name and version System.ClientModel version: 1.5.1+ Describe the bug When making concurrent Azure OpenAI SDK calls (in this case through Semantic Kernel), a thread-safety bug in System.ClientModel.Primitives.ReflectionContext causes a dictionary modification exception. The error occurs even when each concurrent operation uses completely separate client instances. The consumer is Semantic Kernel and Azure OpenAI but the issue is with System.ClientModel.Primitives.ReflectionContext. Error Details System.InvalidOperationException: Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state.  The collection's state is no longer correct. at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior) at System.ClientModel.Primitives.ReflectionContext.TryGetTypeBuilderCore(Type type, ModelReaderWriterTypeBuilder& builder) at System.ClientModel.Primitives.ModelReaderWriterContext.TryGetTypeBuilder(Type type, ModelReaderWriterTypeBuilder& builder) at System.ClientModel.Primitives.ModelReaderWriter.Read[T](BinaryData data, ModelReaderWriterOptions options) at Microsoft.SemanticKernel.Connectors.AzureOpenAI.AzureClientCore.CreateChatCompletionOptio ns(...) Root Cause By examining the source code in https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/Connectors/Connectors.AzureOpenAI/Core/AzureClientCore.ChatCompletion.cs, the CreateChatCompletionOptions method uses ModelReaderWriter.Read() to deserialize JSON: ChatCompletionOptions options = ModelReaderWriter.Read(BinaryData.FromString(`{`stream_options`:{`include_usage`:true}}`)!); This triggers reflection-based type caching in System.ClientModel.Primitives.ReflectionContext.TryGetTypeBuilderCore, which uses a non-thread-safe Dictionary for its cache. When multiple threads call this simultaneously, they corrupt the dictionary's internal state. Reproduction  Create multiple unique instances of PersonaKernel/IChatCompletionService Call GetChatMessageContentsAsync concurrently from different threads Each call uses its own unique client instance (verified through extensive logging) The error occurs intermittently when 5+ concurrent calls are active  Environment  System.ClientModel version: 1.5.1+ Azure.AI.OpenAI version: Latest Microsoft.SemanticKernel version: Latest Platform: Windows/.NET 8.0 Occurs in Release mode (not Debug)  Impact This bug prevents safe concurrent use of Azure OpenAI services, even when following best practices of using separate client instances per operation. The static dictionary in ReflectionContext acts as a global bottleneck that breaks thread safety across all client instances. Implemented Workaround We implemented a `reflection cache warm-up` mechanism that pre-populates the type cache before allowing concurrent operations: private static async Task WarmUpReflectionCacheAsync(ILogger logger) {       // Use semaphore to ensure single-threaded warm-up       await _reflectionCacheWarmupSemaphore.WaitAsync();       try       {           // Load Azure.AI.OpenAI assembly and use reflection to call           // ModelReaderWriter.Read<ChatCompletionOptions>() with the same           // JSON that CreateChatCompletionOptions uses           var warmupJson =   BinaryData.FromString(`{\`stream_options\`:{\`include_usage\`:true}}`);            // This populates the static dictionary cache in a thread-safe manner           // before concurrent operations begin       }       finally       {           _reflectionCacheWarmupSemaphore.Release();       } }  This workaround pre-caches the types that would normally cause the race condition, but it's fragile and may break if the SDK implementation changes. Fix Needed System.ClientModel.Primitives.ReflectionContext should use ConcurrentDictionary instead of Dictionary for its type cache, or protect dictionary access with appropriate locking. The Azure SDK documentation states client objects are thread-safe, but this internal static dictionary breaks that guarantee Expected behavior Multiple instances of types that use System.ClientModel.ReflectionContext should be usable in a thread safe manner Actual behavior Exception when using multiple concurrent instances of a type that uses System.ClientModel.ReflectionContext. System.InvalidOperationException: Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state.  The collection's state is no longer correct. at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior) at System.ClientModel.Primitives.ReflectionContext.TryGetTypeBuilderCore(Type type, ModelReaderWriterTypeBuilder& builder) at System.ClientModel.Primitives.ModelReaderWriterContext.TryGetTypeBuilder(Type type, ModelReaderWriterTypeBuilder& builder) at System.ClientModel.Primitives.ModelReaderWriter.Read[T](BinaryData data, ModelReaderWriterOptions options) at Microsoft.SemanticKernel.Connectors.AzureOpenAI.AzureClientCore.CreateChatCompletionOptio ns(...) Reproduction Steps  Create multiple unique instances of PersonaKernel/IChatCompletionService Call GetChatMessageContentsAsync concurrently from different threads Each call uses its own unique client instance (verified through extensive logging) The error occurs intermittently when 5+ concurrent calls are active  Environment System.ClientModel version: 1.5.1 (used through SemanticKernel and Azure.AI.OpenAI libraries). Windows 11, .NET 8, Visual Studio 2022 17.14.11
Client	Cognitive - Form Recognizer	[FEATURE REQ] Azure.AI.Intellgence `BinaryData.FromStreamAsync` should use streaming, not load docs into memory.	Library name and version Azure.AI.DocumentIntelligence 1.0.0 Describe the bug When using the FromStreamAsync function on BinaryData it should save the stream pointer and not load it all into memory with memory stream. Server apps cannot hold all the files in memory that are on its disk.  Known performance issue. It should hold the stream pointer and stream the request in the http body Expected behavior Keep the stream pointer and use CopyToAsync on the http Content property in the http request to the server. Actual behavior It does new MemoryStream and CopyToAsync into the memory stream which can allocate a huge amount of memory.  The large  byte[] array blocks may get stuck on the LOH and cause fragmentation (unused memory) which you can't recover. Plus... streaming from disk straight to the network may have optimizations (below the app layer if we are lucky) that we can take advantage of. Reproduction Steps Create a program: _client = new DocumentClient(....);  // get a client using the api. data = BinaryData.FromStreamAsync(stream); _client.AnalyzeDocumentAsync(..., data, ...).   Big allocation in memory. Environment .Net 8.0, vs code.
Client	Event Hubs	[BUG] Partition ownership is relinquished before OnPartitionProcessingStoppedAsync completes	Library name and version Azure.Messaging.EventHubs 5.12.2 Describe the bug In EventProcessor class, OnPartitionProcessingStoppedAsync is called in a fire-and-forget manner, potentially after partition ownership has been relinquished. This makes implementation of event buffering and delayed checkpointing problematic, as when OnPartitionProcessingStoppedAsync runs, the partition can already be processed by another instance. StopProcessingPartitionAsync returns Task<Task>. The outer task completes when partition processing finishes but the inner task continues running. The returned task potentially needs to be unwrapped before being returned to the caller:                azure-sdk-for-net/sdk/eventhub/Azure.Messaging.EventHubs/src/Primitives/EventProcessor.cs                    Line 2158       in       32a40b6                                                 return stopContinuation;                     needs to be return stopContinuation.Unwrap(); Expected behavior EventProcessor waits until OnPartitionProcessingStoppedAsync completes before relinquishing partition ownership. Actual behavior OnPartitionProcessingStoppedAsync is called in a fire-and-forget manner. Reproduction Steps using Azure.Messaging.EventHubs; using Azure.Messaging.EventHubs.Consumer; using Azure.Messaging.EventHubs.Primitives; using Azure.Messaging.EventHubs.Processor; using Azure.Storage.Blobs;  class Program {     //https://learn.microsoft.com/en-us/azure/event-hubs/test-locally-with-event-hub-emulator     private const string eventHubConnectionString = `Endpoint=sb://localhost;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true;`;     private const string eventHubName = `eh1`;     private const string blobStorageConnectionString = `UseDevelopmentStorage=true`; // Azurite default     private const string blobContainerName = `eventhub-checkpoints`;     private const string consumerGroup = EventHubConsumerClient.DefaultConsumerGroupName;      static async Task Main()     {         var storageClient = new BlobContainerClient(blobStorageConnectionString, blobContainerName);         await storageClient.CreateIfNotExistsAsync();          var processor = new LoggingEventProcessorClient(             storageClient,             consumerGroup,             eventHubConnectionString,             eventHubName);          processor.ProcessEventAsync += async eventArgs =>         {             Console.WriteLine($`Received: {Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray())}`);             await eventArgs.UpdateCheckpointAsync(eventArgs.CancellationToken);         };          processor.ProcessErrorAsync += eventArgs =>         {             Console.WriteLine($`Error: {eventArgs.Exception.Message}`);             return Task.CompletedTask;         };                  processor.PartitionClosingAsync += async eventArgs =>         {             Console.WriteLine($`Partition closing: {eventArgs.PartitionId}`);             await Task.Delay(10_000);             //Not logged, as the application finishes and relinquishes partition ownership before task is completed             Console.WriteLine($`Partition closed: {eventArgs.PartitionId}`);         };          await processor.StartProcessingAsync();         Console.WriteLine(`Processor started. Press Enter to stop...`);         Console.ReadLine();         await processor.StopProcessingAsync();     }          private class LoggingEventProcessorClient : EventProcessorClient     {         public LoggingEventProcessorClient(BlobContainerClient storageClient,             string consumerGroup,             string eventHubConnectionString,             string eventHubName) : base(storageClient, consumerGroup, eventHubConnectionString, eventHubName) {}          protected override Task<IEnumerable<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken)         {             foreach (var item in desiredOwnership)             {                 Console.WriteLine($`Claiming ownership: {item.OwnerIdentifier}`);             }             return base.ClaimOwnershipAsync(desiredOwnership, cancellationToken);         }     } } Environment  .NET SDK: 9.0.303 Visual Studio 17.14.8
Mgmt	Provisioning	CosmosDBAccountCapability to implement IEquatable<CosmosDBAccountCapability>	Background This is a `sub-issue` to one raised in the Aspire repo: Upgrading to 9.4 causes duplicate capabilities in Cosmos DB and fails deployment. Request It would be great if CosmosDBAccountCapability could implement IEquatable<CosmosDBAccountCapability>. It would make the `upserting` of CosmosDB capabilities within the Aspire framework much easier if it were simple to compare 2 CosmosDBAccountCapability for equality based on their Name property alone.
Mgmt	App Services	Misleading description of `GlobalValidation.ExcludedPaths ` property.	Type of issue Typo Description The current description says:  The paths for which unauthenticated flow would not be redirected to the login page.  However, that is only true if the UnauthenticatedClientAction property is set to UnauthenticatedClientActionV2.RedirectToLoginPage. My experience is that a description like this would be more accurate:  `The paths for which unauthenticated flow would not take the UnauthenticatedClientAction.`  Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.resourcemanager.appservice.models.globalvalidation.excludedpaths?view=azure-dotnet#azure-resourcemanager-appservice-models-globalvalidation-excludedpaths Content source URL https://github.com/MicrosoftDocs/azure-docs-sdk-dotnet/blob/master/xml/Azure.ResourceManager.AppService.Models/GlobalValidation.xml Document Version Independent Id efffec04-28f8-a2fa-3b52-f60d010ba4c7 Platform Id fef276ff-44cc-7428-6cbb-6935daa49a2a Article author @azure-sdk Metadata  ID: ac2c80f2-4000-f087-774f-61ce1e1f4fdb PlatformId: fef276ff-44cc-7428-6cbb-6935daa49a2a Service: azure
Mgmt	Monitor	[QUERY] ResourceManager.Monitor does not appear to be exposing all properties	Library name and version Azure.ResourceManager.Monitor 1.3.1 Query/Question channels property missing in GetActivityLogs response of Azure.ResourceManager.Monitor Environment The GetActivityLogs method in the Azure.ResourceManager.Monitor SDK does not expose the channels property, which is present when querying the Azure Monitor Activity Logs via the REST API. This missing field is critical for use cases where logs need to be filtered or analyzed based on the channels value (e.g., Operation, Admin, etc.). RestAPI GET https://management.azure.com/subscriptions/{subscriptionId}/providers/microsoft.insights/eventtypes/management/values?api-version=2015-04-01 Is there a way to access the channels field using the Azure.ResourceManager.Monitor SDK?
Client	AI Agents	[BUG] Azure.AI.Agents.Persistent.ThreadMessages.GetMessagesAsync ignores `after` parameter	Library name and version Azure.AI.Agents.Persistent 1.1.0-beta.4 Describe the bug Azure.AI.Agents.Persistent.ThreadMessages.GetMessagesAsync ignores `after` parameter, this makes it impossible to skip messages during pagination.                azure-sdk-for-net/sdk/ai/Azure.AI.Agents.Persistent/src/Custom/ThreadMessages.cs                    Line 335       in       3e92e8c                                                 public virtual AsyncPageable<PersistentThreadMessage> GetMessagesAsync(string threadId, string runId = null, int? limit = null, ListSortOrder? order = null, string after = null, string before = null, CancellationToken cancellationToken = default)                     Expected behavior `after` parameter is passed correctly to the endpoint Actual behavior `after` parameter is ignored Reproduction Steps Install the library and try to pass `after` parameter. Environment Not important
Client	Functions	[QUERY] Azure Function not processing all Event Hub messages	Library name and version Microsoft.Azure.Functions.Worker.Sdk 1.17.0 Query/Question I'm experiencing an issue where not all messages sent to an Event Hub are processed by an Azure Function that's set up with an Event Hub trigger; the function performs a POST request to an external service using a Polly retry policy, and the external service has internal limits which can result in HTTP 429 (Too Many Requests) responses. Reproduction Steps  Implement an Azure Function with an Event Hub trigger. Configure the function to perform a POST request to an external service, using a Polly retry policy to handle transient failures and HTTP 429 (Too Many Requests) responses. Deploy the function to the Azure environment Send 10,000 messages to the connected Event Hub in a short period of time. Monitor function execution logs and count the number of messages successfully processed and sent via POST.  Expected Behavior All 10,000 messages sent to the Event Hub should be received and processed by the Azure Function. Actual Behavior Only a subset of the messages is received by the function. A significant number of messages (exact number varies) appear to be dropped or never trigger the function. There are no corresponding failures or errors in the logs to suggest why those messages were not processed. Environment The issue reproduces both locally and in the deployed Azure environment.
Mgmt	Data Factory	[FEATURE REQ] Dataverse linked service SDK	Library name CommonDataServiceForAppsLinkedService Please describe the feature. If you create a Dataverse linked service in ADF and you want to use a 'user assigned managed identity' this does not seem to be supported in the above AzureSDK, it seems to only have service principal available see here The option is available to select UAMI in ADF for Dataverse Linked Service, so the SDK code needs to be updated to allow this or a specific Dataverse SDK and not CommonDataServiceForApps that does not seem to be appropriate for Dataverse LS. Below is a sample of code. During debugging we can see that everything else is applied except the credential is not assigned to the linked service.   type                 = `CommonDataServiceForApps` type_properties_json = <<JSON { `deploymentType`: `Online`, `serviceUri`: `${each.value.service_uri}`, `authenticationType`: `ManagedIdentity`, `credential`: { `referenceName`: `${var.applicationName}-${each.value.managed_identity_prefix}-usid`, `type`: `CredentialReference` } } JSON
Client	Service Bus	[BUG] Azure.Messaging.ServiceBus subscription floods error logs when secret expires	Library name and version Azure.Messaging.ServiceBus, 7.20.1 Describe the bug I am using this nuget as in the quickstart guide: https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-get-started-with-queues?tabs=passwordless#add-the-code-to-receive-messages-from-the-queue Except, we have app registrations, so I passed the OAuth client credential in for credentials. When the secret expires, it continually throws errors, a few times a second. With this, our application floods the logs to the tune of a few hundred thousand or a million logs a day. The retry logic or exponential backoff configuration doesn't take effect either. Expected behavior There is some configuration in the Azure.Messaging.ServiceBus library with which we can tell the library `If an error is encountered when establishing or re-establishing (AMQP) connection, give the consumer an error so we can log it. Then stop retrying OR do it a few times and stop retrying.` Actual behavior Hundreds of thousands of retries are performed per day when client secret is incorrect (e.g. on expiry) and the logs get flooded. Reproduction Steps Follow the MS example. Use client credential grant in this case. Give incorrect secret to simulate secret expiry. Notice that the app keeps retrying to establish connection frequently and keeps failing. Please refer the attached sample. SB.Subscription.Logs.zip Environment Windows 11 (for testing) Ubuntu linux (hosting) .net 8 VS 2022 - 17.14.6
Client	AI Agents	[BUG] bing_grounding not handled in Azure.AI.Agents.Persistent.RunStepDetailsUpdate	Library name and version Azure.AI.Agents.Persistent v1.1.0-beta.3 Describe the bug Azure.AI.Agents.Persistent.RunStepDetailsUpdate object has different tool calls properties, but none for bing grounding tool call. Instead, private field _toolCall contains data of type Azure.AI.Agents.Persistent.UnknownRunStepDeltaToolCall. The comment in code for RunStepDeltaToolCall class also only talks about 3 subclasses, so I assume the bing type isn't there at all: RunStepDeltaCodeInterpreterToolCall, RunStepDeltaFileSearchToolCall and RunStepDeltaFunctionToolCall. Expected behavior A proper subclass for bing grounding tool call for RunStepDeltaToolCall + whatever necessary properties in RunStepDetailsUpdate to differentiate it from other types of tool calls. Actual behavior No support at all Reproduction Steps Install the package and run a thread that requires bing search. Environment Doesn't matter
Client	Azure.Core	GitHub release is created before NuGet package is indexed	https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Core_1.47.0 https://www.nuget.org/packages/Azure.Core/1.47.0 currently 404's EDIT: and now it says it's not indexed EDIT2: Now it's indexed
Client	System.ClientModel	[QUERY] System.ClientModel 1.5.0 release note missing info	Library name and version System.ClientModel 1.5.0 Query/Question In the release note for https://github.com/Azure/azure-sdk-for-net/releases/tag/System.ClientModel_1.5.0 The change in System.Memory.Data major version change from 6.0.1 to 8.0.1 is missing. Environment N/A
Mgmt	API Management	[BUG] GetApiManagementUsers().GetAll expandGroups: true does not deserialize groups correctly.	Library name and version Azure.ResourceManager.ApiManagement 1.3.0 Describe the bug Using latst SDK Azure.ResourceManager.ApiManagement 1.3.0 to read Users with expandGroups flag does not populate fields correctly. ApiManagementGroupData.DisplayName is always NULL Seems like deserialization issue. REST API is returning id, nam, description, builtIn, type and externalId first, but ApiManagementGroupData has [WirePath(`properties.displayName`)] public string DisplayName { get; set; } Description field on the other hand is deserialized correctly. Expected behavior ApiManagementGroupData object match REST api JSON object and name and id are propagated correctly Actual behavior Currenlty only Description is populated correctly Reproduction Steps var apiManagementService = GetManagementService(); var users = apiManagementService.GetApiManagementUsers().GetAll(expandGroups: true); Environment .NET 9.0 Windows 11 Azure.ResourceManager.ApiManagement 1.3.0
Client	KeyVault	Community contributions lack details	Library name Azure.Security.KeyVault.Keys Please describe the feature. The release https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Security.KeyVault.Keys_4.8.0 Shows a community contribution but there's no detail for what was contributed I would have expected a link to a specific PR for each line where a community contribution was made.
Client	Cognitive - Form Recognizer	Use DocumentIntelligence's Batch Analyze with Generate Searchable PDF Add-on	Library name and version Azure.AI.DocumentIntelligence 1.0.0 Query/Question Greetings, I'm trying to implement the DocumentIntelligence's Batch Analyze method and, when looking to the API definition here it seems to be possible to request to use the generate the searchable pdf add-on (same with the regular Analyze Document method) However, I am not able to figure out how to retrieve the PDFs later on.  They do not appear in the specified result container (the container where the .json responses appear). When using the operation ID to later invoke the get result pdf ( this one), it only returns a json response saying `running`, with little else attached  If anyone could provide a sample on how to achieve this (or an alternative idea), I'd appreciate it Environment No response
Client	Service Bus	[BUG] WebSocketException leaks while receiving messages using Azure Service Bus client SDK	Library name and version Azure.Messaging.ServiceBus 7.18.4 Describe the bug We are using ServiceBusProcessor to receive messages from Azure Service Bus, and encountering problem where we get WebSocketException with SocketException as inner exception instead of ServiceBusException as documented in official documentation. The communication runs via AMQP protocol and we found that only SocketException is handled in code. Expected behavior Instead of WebSocketException we get ServiceBusException. Actual behavior WebSocketException is thrown after several retries via default retry policy. Stacktrace: ReceiveBatchAsync Exception: System.Net.WebSockets.WebSocketException (0x80004005): Unable to connect to the remote server ---> System.Net.Http.HttpRequestException: An error occurred while sending the request. ---> System.IO.IOException: Unable to read data from the transport connection: Connection reset by peer. ---> System.Net.Sockets.SocketException (104): Connection reset by peer at System.Net.Sockets.NetworkStream.ReadAsync(Memory`1 buffer, CancellationToken cancellationToken) at System.Net.Security.SslStream.EnsureFullTlsFrameAsync[TIOAdapter](CancellationToken cancellationToken, Int32 estimatedSize) at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) at System.Net.Sockets.SocketAsyncEventArgs.TransferCompletionCallbackCore(Int32 bytesTransferred, Memory`1 socketAddress, SocketFlags receivedFlags, SocketError socketError) at System.Net.Sockets.SocketAsyncEngine.System.Threading.IThreadPoolWorkItem.Execute() at System.Threading.ThreadPoolWorkQueue.Dispatch() at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart() --- End of stack trace from previous location ---  --- End of inner exception stack trace --- at System.Net.Security.SslStream.EnsureFullTlsFrameAsync[TIOAdapter](CancellationToken cancellationToken, Int32 estimatedSize) at System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1.StateMachineBox`1.System.Threading.Tasks.Sources.IValueTaskSource<TResult>.GetResult(Int16 token) at System.Net.Security.SslStream.ReadAsyncInternal[TIOAdapter](Memory`1 buffer, CancellationToken cancellationToken) at System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1.StateMachineBox`1.System.Threading.Tasks.Sources.IValueTaskSource<TResult>.GetResult(Int16 token) at System.Net.Http.HttpConnection.InitialFillAsync(Boolean async) at System.Net.Http.HttpConnection.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) --- End of inner exception stack trace --- at System.Net.Http.HttpConnection.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken) at System.Net.Http.DiagnosticsHandler.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.WebSockets.WebSocketHandle.ConnectAsync(Uri uri, HttpMessageInvoker invoker, CancellationToken cancellationToken, ClientWebSocketOptions options) at System.Net.WebSockets.WebSocketHandle.ConnectAsync(Uri uri, HttpMessageInvoker invoker, CancellationToken cancellationToken, ClientWebSocketOptions options) at System.Net.WebSockets.ClientWebSocket.ConnectAsyncCore(Uri uri, HttpMessageInvoker invoker, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result) at Microsoft.Azure.Amqp.Transport.AmqpTransportInitiator.ConnectAsyncResult.End(IAsyncResult result) at Microsoft.Azure.Amqp.Transport.AmqpTransportInitiator.<>c.<ConnectAsync>b__17_1(IAsyncResult r) at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.CreateAndOpenConnectionAsync(Version amqpVersion, Uri serviceEndpoint, Uri connectionEndpoint, ServiceBusTransportType transportType, IWebProxy proxy, String scopeIdentifier, TimeSpan timeout) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenReceiverLinkAsync(String identifier, String entityPath, TimeSpan timeout, UInt32 prefetchCount, ServiceBusReceiveMode receiveMode, String sessionId, Boolean isSessionReceiver, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.OpenReceiverLinkAsync(TimeSpan timeout, UInt32 prefetchCount, ServiceBusReceiveMode receiveMode, String identifier, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, Boolean isProcessor, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, Boolean isProcessor, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsyncInternal(Int32 maxMessages, Nullable`1 maxWaitTime, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsyncInternal(Int32 maxMessages, Nullable`1 maxWaitTime, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<ReceiveMessagesAsync>b__44_0>d.MoveNext() --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken, Boolean logTimeoutRetriesAsVerbose) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken, Boolean logTimeoutRetriesAsVerbose) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, Boolean isProcessor, CancellationToken cancellationToken).  Reproduction Steps This scenario cannot be reliably reproduced, as it occurs randomly. Environment Runtime .NET 8.0.411 Azure Service Bus Standard
Client	Service Bus	[BUG] ServiceBusProcessor.CloseAsync cancellationToken does not propagate to underlying code.	Library name and version Azure.Messaging.ServiceBus 7.20.1 Describe the bug A ServiceBusProcessor.CloseAsync(CancellationToken) call hangs until I eventually receive an exception stating: The operation did not complete within the allocated time 00:01:00 for object drain. Reasons aside, I would assume that calling CloseAsync(CancellationToken) returns somewhat timely on cancelling the token. This does not happen. Upon further inspection, I noticed that the CancellationToken seems to be ignored by the library, as ReceiverManager.CloseReceiverIfNeeded(CancellationToken) calls DisposeAsync() instead of CloseAsync(CancellationToken) on capturedReceiver (see: https://github.com/Azure/azure-sdk-for-net/blob/c5af9dd3ed5bf0d61280d11ea65f48baceef5f85/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ReceiverManager.cs#L75C21-L75C81). Expected behavior ServiceBusProcessor.CloseAsync(CancellationToken) returns promptly when the passed CancellationToken is cancelled. Actual behavior The ServiceBusProcessor.CloseAsync(CancellationToken) call hangs until I eventually receive an exception stating: The operation did not complete within the allocated time 00:01:00 for object drain. Reproduction Steps  Create a ServiceBusProcessor Call CloseAsync(CancellationToken), passing a CancellationToken with a timeout of 1 second, while in a scenario that causes the The operation did not complete within the allocated time 00:01:00 for object drain. exception.  Environment OS: Windows 11 .NET: 8.0.411
Mgmt	ARM	[BUG] Call to GetLocations throws FormatException when machine locale uses `,` as decimal separator	Library name and version Azure.ResourceManager.Resources 1.10.0 Describe the bug A call made like this : armClient.GetSubscriptionResource(SubscriptionResource.CreateResourceIdentifier(this.SubscriptionId)).GetLocations() on a machine with portuguese locale configured for example throws an exception when deserializing latitude and longitude values due to wrong decimal separator, the call made to deserialize is done with double.Parse without specifying locale so it throws exception on locales with decimal separators != `.` Expected behavior The call should succeed Actual behavior The call throws FormatException Reproduction Steps Change the machine locale to portuguese or any other with decimal separator != `.` and make the call Environment No response
Client	AI Agents	[BUG] Azure.AI.Agents.Persistent.ThreadMessages lacks deletion methods	Library name and version Azure.AI.Agents.Persistent 1.1.0-beta.2 Describe the bug Azure.AI.Agents.Persistent.ThreadMessages lacks deletion methods. I've tried to manually trigger the same url that is used for GetMessage(Async) but with DELETE HTTP method and it definitely works. Why the method is missing from the client is not clear. Expected behavior Azure.AI.Agents.Persistent.ThreadMessages has deletion methods Actual behavior Azure.AI.Agents.Persistent.ThreadMessages lacks deletion methods Reproduction Steps Install the package and see for yourself Environment Irrelevant
Mgmt	Authorization	[FEATURE REQ] Role Management Policy Assignments - List For Scope should support $filter	Library name Azure.ResourceManager.Authorization Please describe the feature. ArmClient.GetRoleManagementPolicyAssignments(scope).GetAllAsync(...) does not currently support passing in a $filter argument. This should support the $filter argument similar to other GetAllAsync calls within this library. In fact, the GET https://management.azure.com/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments?api-version=2020-10-01 call is used within the Azure Portal with a filter on role definiton id when managing the role within the scope of an azure resource (in PIM).
Client	Service Bus	[BUG]T race Context Not Propagating from Azure Service Bus to Azure Function Trigger with Application Insights Enabled	Library name and version Azure.Messaging.ServiceBus v7.16.0 , Microsoft.Azure.WebJobs.Extensions.ServiceBus v5.12.0  , Microsoft.ApplicationInsights.AspNetCore v2.22.0 , .NET Runtime: .NET 6 and .NET 8 Describe the bug [Bug] Trace Context Not Propagating from Azure Service Bus to Azure Function Trigger with Application Insights Enabled Summary We are observing broken trace correlation between Azure Service Bus messages and the Azure Function App triggered by those messages, despite having Application Insights instrumentation enabled. This issue affects observability and distributed tracing in event-driven systems, where consistent context propagation is critical for debugging and telemetry correlation. Setup  Azure SDK: Azure.Messaging.ServiceBus Azure Function App (triggered via Service Bus Queue) .NET 6 / .NET 8 (we’ve seen this in both setups) Application Insights SDK enabled via services.AddApplicationInsightsTelemetry() No custom Activity or diagnostic injection code Using standard Azure-hosted Function App with queue trigger binding  Behavior  The sending application publishes a message to the Service Bus with diagnostics headers (as verified in message properties). The Function App is triggered successfully. However, in Application Insights:  The Function App invocation appears as a separate trace, not as a child span of the original sender. No linkage is shown between the Function execution and the message origin.    What We Expected  The Azure SDK and Function App integration should preserve and propagate trace context end-to-end. The Function execution should appear as a child span in the same trace started by the sending application.  Why It Matters This kind of broken trace propagation leads to:  Incomplete observability in distributed systems Higher effort for debugging and postmortem Inconsistent correlation across services and telemetry sources  We’ve implemented manual workarounds in other projects using custom Activity injection and context forwarding, but this adds unnecessary boilerplate and isn't scalable. Additional Notes  We're using ServiceBusClient and ServiceBusSender to send messages. No custom headers are stripped in transport. Function App uses default bindings and configuration, and AI is wired through typical ILogger usage.   Please let us know if this is a known bug or a setup issue — happy to share code samples or minimal reproducer if needed. Thanks again to @christothes  and @mikhailshilkov for the prior guidance! Expected behavior When a message is sent to Azure Service Bus using the Azure.Messaging.ServiceBus SDK with distributed tracing enabled (via Application Insights or OpenTelemetry), and the message is processed by an Azure Function App (triggered via Service Bus), the trace context should be preserved end-to-end. Specifically:  The Azure Function App invocation should appear as a child span of the original sender's trace in Application Insights. The trace-id, parent-id, and other correlation metadata should be automatically extracted and passed into the Function App context. The full operation (Sender → Bus → Function) should be visible as a single distributed trace  Actual behavior Although the Service Bus message is sent with trace context (verified via diagnostics headers or message properties), the Azure Function App that processes the message creates a new, unrelated trace in Application Insights. Observed symptoms:  The Function App invocation appears as an independent trace, not connected to the sending operation. No parent-child relationship is visible in Application Insights. The trace-id and span-id from the original message are not linked to the Function’s telemetry. This results in a broken distributed trace, even with correct SDK instrumentation in  Reproduction Steps   Create a .NET 6 or .NET 8 Azure Function App project using the Service Bus trigger:  Use Microsoft.Azure.WebJobs.Extensions.ServiceBus v5.12.0 Use Microsoft.ApplicationInsights.AspNetCore v2.22.0    Configure Application Insights using default setup: builder.Services.AddApplicationInsightsTelemetry(   Environment  Azure SDK: Azure.Messaging.ServiceBus v7.16.0 Function Binding: Microsoft.Azure.WebJobs.Extensions.ServiceBus v5.12.0 Application Insights SDK: Microsoft.ApplicationInsights.AspNetCore v2.22.0 .NET Runtime: .NET 6 and .NET 8 (tested on both)
Mgmt	Authorization	[BUG] ARM RoleAssignmentSchedules is not reutning linkedRoleEligibilityScheduleId when an assignment is activated from eligible schedule	Library name and version Azure.ResourceManager.Authorization v1.1.4 / REST API api-version 2020-10-01 Describe the bug When I am using ArmClient.RoleAssignmentSchedules, the RoleAssignmentScheduleData class specifies a property that highlights if an active role schedule is linked to an eligible schedule resource.        /// <summary> The id of roleEligibilitySchedule used to activated this roleAssignmentSchedule. </summary> [WirePath(`properties.linkedRoleEligibilityScheduleId`)] public ResourceIdentifier LinkedRoleEligibilityScheduleId { get; } API Reference However, this property is not being populated by the SDK or returned in the REST API call to roleAssignmentSchedules . In roleAssignmentScheduleInstances, this information is being populated, see below: https://management.azure.com/providers/Microsoft.Management/managementGroups//providers/Microsoft.Authorization/roleAssignmentScheduleInstances?api-version=2020-10-01 linkedRoleEligibilityScheduleId`: `/providers/Microsoft.Management/managementGroups/<REDACTED>/providers/Microsoft.Authorization/roleEligibilitySchedules/bed6d07d-a2b2-4413-815f-a509bf234e9c `linkedRoleEligibilityScheduleInstanceId`: `/providers/Microsoft.Management/managementGroups/<REDACTED>/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/d31d3b65-f620-4d4a-9c40-f2d5ceddf7e5`,                         `assignmentType`: `Activated`,                         `scope`: `/providers/Microsoft.Management/managementGroups/<REDACTED>`,                         `roleDefinitionId`: `/providers/Microsoft.Authorization/roleDefinitions/8e3af657-a8ff-443c-a75c-2fe8c4bcb635`,                         `principalId`: `<REDACTED>`,                         `principalType`: `User`,                         `status`: `Provisioned`,                         `startDateTime`: `2025-06-06T05:27:56.55Z`,                         `endDateTime`: `2025-06-06T08:27:55.65Z`,                         `memberType`: `Group`,                         `createdOn`: `2025-06-06T05:27:56.55Z`,  Expected behavior LinkedRoleEligibilityScheduleId should be populated in the response as per API reference. Actual behavior No LinkedRoleEligibilityScheduleId in response. Reproduction Steps  Create eligible ARM schedule using PIM Activate the eligibile role schedule using PIM Query using ArmClient.RoleAssignmentSchedules(scope)  Environment No response
Client	Extensions	[QUERY] Need a clarification on possible `AddAzureClients` call requirement with `ProtectKeysWithAzureKeyVault`	Library name and version Azure.Extensions.AspNetCore.DataProtection.Keys 1.6.0 Query/Question Hello, I have an issue from Brady Gaster (PPM .NET) in the ASP.NET Core docs repo that asks about documenting a potential requirement to call AddAzureClients in order to successfully call ProtectKeysWithAzureKeyVault ... Important missing method call required for wiring up Key Vault dotnet/AspNetCore.Docs#26093 It doesn't seem like there should be such a requirement, but he's reporting it for a specific container deployment case where it might be required. May I ask a team member here to look at that issue and scope any such requirement down to the exact case(s) in which AddAzureClients would be required? I'll incorporate that information into our article. If that looks more like a bug 😈 , then we can close that docs issue in favor of a new issue here describing the missing dependencies that Brady is calling out. Environment ASP.NET Core (all versions)
Client	AI Agents	[BUG]PersistentAgentsClient.Messages.GetMessagesAsync - doesnt limit	Library name and version Azure.AI.Agents.Persistent `1.1.0-beta.1` Describe the bug This code should limit the response to just one message .         AsyncPageable<PersistentThreadMessage> messages = _projectClient.Messages.GetMessagesAsync(                                                         threadId: threadId,                                                         limit: 1                                                         );          await foreach (PersistentThreadMessage threadMessage in messages)         {             Console.Write($`{threadMessage.CreatedAt:yyyy-MM-dd HH:mm:ss} - {threadMessage.Role,10}: `);             foreach (MessageContent contentItem in threadMessage.ContentItems)             {                 if (contentItem is MessageTextContent textItem)                 {                     Console.Write(textItem.Text);                 }                 else if (contentItem is MessageImageFileContent imageFileItem)                 {                     Console.Write($`<image from ID: {imageFileItem.FileId}`);                 }                 Console.WriteLine();             }         }  I'm finding its returning all the messages  Expected behavior Should return the number of messages as specified with the limit parameter Actual behavior Not respecting the Limit parameter Reproduction Steps see code above Environment   <ItemGroup>     <PackageReference Include=`Azure.AI.Agents.Persistent` Version=`1.1.0-beta.1` />     <PackageReference Include=`Azure.AI.Projects` Version=`1.0.0-beta.9` />     <PackageReference Include=`Azure.Identity` Version=`1.14.0` />     <PackageReference Include=`DotNetEnv` Version=`3.1.1` />     <PackageReference Include=`Microsoft.Extensions.Hosting` Version=`10.0.0-preview.4.25258.110` />     <PackageReference Include=`Microsoft.SemanticKernel` Version=`1.54.0` />     <PackageReference Include=`Microsoft.SemanticKernel.Agents.AzureAI` Version=`1.54.0-preview` />     <PackageReference Include=`Microsoft.SemanticKernel.Agents.Core` Version=`1.54.0` />     <PackageReference Include=`Microsoft.SemanticKernel.Process.Abstractions` Version=`1.54.0-alpha` />     <PackageReference Include=`Microsoft.SemanticKernel.Process.Core` Version=`1.54.0-alpha` />     <PackageReference Include=`Microsoft.SemanticKernel.Process.LocalRuntime` Version=`1.54.0-alpha` />     <PackageReference Include=`Polly` Version=`8.5.2` />   </ItemGroup>
Mgmt	Network - Traffic Manager	[FEATURE REQ] Traffic Manager SDK: Type TrafficManagerEndpointData should Include EndpointType Property	Library name Azure.ResourceManager.TrafficManager Please describe the feature. See docs: https://learn.microsoft.com/en-us/dotnet/api/azure.resourcemanager.trafficmanager.trafficmanagerendpointdata?view=azure-dotnet This class should include the endpoint's type as a property (e.g. 'azureEndpoints', 'externalEndpoints', or 'nestedEndpoints') The type is required when calling TrafficManagerEndpointResource.CreateResourceIdentifier(). My workflow here is to read the TrafficManagerProfileResource, find an endpoint by name, get a TrafficManagerEndpointResource instance, and then patch the weight/enablement state. I want to be able to easily get the endpoint type from the TrafficManagerProfileResource's Endpoints property.
Client	Search	[QUERY] Is there an equivalent SearchIndex.serialize() function in the .Net SDK like in the Python SDK?	Library name and version Azure.Search.Documents 11.6.0 Query/Question When I serialize a SearchIndex using JsonSerializer from System.Text.Json, the format is not compatible with the REST API. (E.g. IsSearchable instead of searchable, etc.) I saw that the Python SDK has this feature: Azure/azure-sdk-for-python#30692 . I was wondering if the .Net SDK has a similar feature? Also would anyone be able to explain to me how the SearchIndexClient creates the index? I see in SearchIndexClient.cs it calls IndexesRestClient, if I go to IndexesRestClient.cs I see it creates a UTF8JsonRequestContent, so if I go to that file UTF8JsonRequestContent.cs I see it just writes a stream, but not how it would convert the actual search index to use the proper requestbodyfields. So from my POV it just writes that request body to the endpoint and somehow it works. Thanks! Apologies if this is really obvious I am a bit new to .Net and Azure. Environment OS: Linux (using WSL2) running on Windows 11 .NET SDK: Version:           8.0.116 Commit:            4d8dee1e9e Workload version:  8.0.100-manifests.0b4715a7 Runtime Environment: OS Name:     ubuntu OS Version:  24.04 OS Platform: Linux RID:         ubuntu.24.04-x64 Base Path:   /usr/lib/dotnet/sdk/8.0.116/ .NET workloads installed: Workload version: 8.0.100-manifests.0b4715a7 There are no installed workloads to display. Host: Version:      8.0.16 Architecture: x64 Commit:       efd5742bb5 .NET SDKs installed: 8.0.116 [/usr/lib/dotnet/sdk] .NET runtimes installed: Microsoft.AspNetCore.App 8.0.16 [/usr/lib/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 8.0.16 [/usr/lib/dotnet/shared/Microsoft.NETCore.App] IDE and Version: Visual Studio Code Version: 1.100.2 (user setup)
Client	Service Bus	[QUERY] Details on CreateClient method in IAzureClientFactory	Library name and version Microsoft.Extensions.Azure 1.11.0 Query/Question services.AddAzureClients(builder => {     builder.UseCredential(new DefaultAzureCredential());      var defaultServiceBusRetryOptions = new ServiceBusRetryOptions     {         Mode = ServiceBusRetryMode.Exponential,         MaxRetries = 5,         Delay = TimeSpan.FromSeconds(2),         MaxDelay = TimeSpan.FromSeconds(30)     };      // Setting up service bus connections.     builder     .AddServiceBusClientWithNamespace(<fullyQualifiedNamespace>)     .WithName(<clientname>)     // This is to handle failures in the service bus client creation.     .ConfigureOptions(options =>     {         options.RetryOptions = defaultServiceBusRetryOptions;     }); });  I am using the following code to register the service bus clients. And in my class constructor azureSbClientfactory is a DI'ed instance of IAzureClientFactory<ServiceBusClient> azureSbClientfactory.CreateClient(<same Client name as above>)  I am trying to understand if for all the times I create my class(transient class registered in the service) with the same name would it create a new service bus client or create the client for the first time and reuse from the next calls? I've tried searching around in the code but couldn't find anything concrete. If at all create client creates a new client without caching every time what should I do to create the client once and pass the same every time Environment Production
Client	Event Grid	[BUG] Ambiguity: The type 'HealthcareDicomImageCreatedEventData' exists in both 'Azure.Messaging.EventGrid.SystemEvents' and 'Azure.Messaging.EventGrid'	Library name and version Azure.Messaging.EventGrid 4.31.0 ||| Azure.Messaging.EventGrid.SystemEvents 1.0.0-beta.3 Describe the bug  I need to use both packages However, the HealthcareDicomImageCreatedEventData exists in both packages (see screenshot), which leads to an error and is blocking me   Expected behavior 'HealthcareDicomImageCreatedEventData' class should exist in only one package Actual behavior 'HealthcareDicomImageCreatedEventData' class exists in two different packages Reproduction Steps Import both packages and try to use 'HealthcareDicomImageCreatedEventData' Environment .NET SDK: Version:           9.0.105 Commit:            35890ecb87 Workload version:  9.0.100-manifests.9df47798 MSBuild version:   17.12.32+8314f8fc4 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\9.0.105\
Client	Cognitive - Form Recognizer	[QUERY] DocumentAnalysisClient and DocumentIntelligenceClient	Library name and version DocumentIntelligenceClient.AnalyzeDocument does not accept Stream as a parameter Query/Question Azure says, that DocumentIntelligence and Form Recognizer are the same thing, but they provide different clients: DocumentIntelligenceClient and DocumentAnalysisClient. Form Recognizer supposed to be an older version of Doc Intel, but its client (DocumentAnalysisClient) has an overload for client.AnalyzeDocumentAsync(WaitUntil waitUntil, string model, Stream stream), where one can use stream as a parameter, whereas Doc Intel doesn't, no way to transfer stream using DocumentIntelClient, only binary data. Is that a defect in the code? Because its the only reason i needed to also use Form Recognizer, just for the feature of transferring stream Environment No response
Client	AI Projects	[BUG] Azure.AI.Projects - cannot update the version to the API	Library name and version Azure.AI.Projects Describe the bug When I go to create a thread I get the following issue. It looks the client is created but the version wrong. I tried to set the version using the Client Options but there was only 2024-07-01-preview Unsupported api version '2024-07-01-preview'. The supported versions are 'v1', '2025-05-01', '2025-05-15-preview' Status: 400 (Unsupported api version '2024-07-01-preview'. The supported versions are 'v1', '2025-05-01', '2025-0) ErrorCode: UnsupportedApiVersionValue Expected behavior Should be able to connect and create a thread var thread = (await agentsClient.CreateThreadAsync()).Value; Actual behavior you get the following error Unsupported api version '2024-07-01-preview'. The supported versions are 'v1', '2025-05-01', '2025-05-15-preview' Status: 400 (Unsupported api version '2024-07-01-preview'. The supported versions are 'v1', '2025-05-01', '2025-0) ErrorCode: UnsupportedApiVersionValue Reproduction Steps create agent client and then try tp create a thread var thread = (await agentsClient.CreateThreadAsync()).Value; Environment No response
Client	Storage	[BUG] TokenCredential of AddBlobServiceClient(...) is always DefaultAzureCredential	Library name and version Microsoft.Extensions.Azure 1.11.0 Describe the bug Within the BlobClientBuilderExtensions the method public static IAzureClientBuilder<BlobServiceClient, BlobClientOptions> AddBlobServiceClient<TBuilder>(this TBuilder builder, Uri serviceUri, TokenCredential tokenCredential)     where TBuilder : IAzureClientFactoryBuilderWithCredential {     return builder.RegisterClientFactory<BlobServiceClient, BlobClientOptions>((options, token) => new BlobServiceClient(serviceUri, token, options)); } is not passing down the provided TokenCredential. Expected behavior The provided TokenCredential will be used, maybe like this: public static IAzureClientBuilder<BlobServiceClient, BlobClientOptions> AddBlobServiceClient<TBuilder>(this TBuilder builder, Uri serviceUri, TokenCredential tokenCredential)     where TBuilder : IAzureClientFactoryBuilderWithCredential {     return builder.RegisterClientFactory<BlobServiceClient, BlobClientOptions>((options, _) => new BlobServiceClient(serviceUri, tokenCredential, options)); } Actual behavior The DefaultAzureCredential is always being used, which leads to unnecessary token requests, that mostly cannot be resolved and even throw exceptions when some configuration is missing. Reproduction Steps Add the service to the IServiceCollection like this: services.AddAzureClients(     config =>     {         config.AddBlobServiceClient(             new Uri(`<url to the storage account>`),             new AzureCliCredential());     }); Environment No response
Client	AI Model Inference	EmbeddingsOptions.Input does not have a setter	Library name Azure.AI.Inference 1.0.0-beta.4 Please describe the feature. There are cases where one wants to write the input to the EmbeddingsOptions after initialization and is not currently possible because you can only pass them to the .ctor forcing users to rely on reflection of the C# backing field <Input>k__BackingField. This differs from ChatCompletionsOptions.Messages which does have a setter. Other libraries, like OpenAI enable the scenario by decoupling the inputs from the options in their APIs. See: https://github.com/dotnet/extensions/pull/6433/files#r2087007289
Client	Search	Reopened [BUG] SearchOptions.Select is readonly	The original bug #13875 was just closed. I'd like to reopen it for two reasons: I'm using Azure.Search.Documents version 11.6.0.   The given suggestion is very limited. Literally doing SearchOptions options = new SearchOptions() { Select = { `field1`, `field2` } }; works, but it is not possible to reuse an existing list. var options = new SearchOptions { Select = myOptions.Select}; yields CS0200: Property or indexer 'SearchOptions.Select' cannot be assigned to -- it is read only  We have a guideline to not provide settable collection properties.  You can use C#'s list initializer syntax to achieve the same thing: SearchOptions options = new SearchOptions() { Select = { `field1`, `field2` } };  Originally posted by @tg-msft in #13875   Also, there was a good suggestion to it, which seems not taken into account:  In this case, there should be a constructor that takes the select parameter. Right now, the usage is confusing. Or maybe defined as public IList Select { get; init; }  Originally posted by @xavierjohn in #13875
Client	Azure.Core	[BUG] Add Canary / EUAP regions to AzureLocation (EastUS2EUAP, CentralUSEUAP)	Library name and version Azure.Core (latest version in main) Describe the bug the AzureLocation class doesn't contain the Canary/EUAP regions Expected behavior They should be part of the AzureLocation class just like all the other regions (e.g.  public static AzureLocation EastAsia { get; }) - these don't seem to be secret/internal - They have already been added to other SDK enums:  #32456 https://learn.microsoft.com/en-us/dotnet/api/microsoft.azure.documents.locationnames.centraluseuap?view=azure-dotnet&source=docs  They are well known in the community:  https://stackoverflow.com/questions/50647007/what-is-an-euap-region-in-azure  The EUAP regions concept already appears in public MS docs:  https://learn.microsoft.com/en-us/azure/api-management/configure-service-update-settings#canary-deployment-strategies  Actual behavior These regions are not present in the AzureLocation class: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/src/AzureLocation.cs Reproduction Steps Try writing AzureLocation.EastUS2EUAP  Workaround  new AzureLocation(`eastus2euap`, `East US 2 EUAP`); new AzureLocation(`centraluseuap`, `Central US EUAP`);
Client	AI Model Inference	[BUG] ChatMessageAudioContentItem does not accept audio file data	Library name and version Azure.AI.Inference v1.0.0-beta.4 Describe the bug Using ChatMessageAudioContentItem with a local audio file does not work. Tried in both beta3 and beta4 of the AzureAIInference library versions. Model: Phi-4-multimodal-instruct Expected behavior As per the documentation: Use chat completions with audio var requestOptions = new ChatCompletionsOptions() {     Messages =     {         new ChatRequestSystemMessage(`You are an AI assistant for translating and transcribing audio clips.`),         new ChatRequestUserMessage(             new ChatMessageTextContentItem(`Please translate this audio snippet to spanish.`),             // The line below causes the error             new ChatMessageAudioContentItem(`hello_how_are_you.mp3`, AudioContentFormat.Mp3),     }, };  Response<ChatCompletions> response = client.Complete(requestOptions);  This code is expected to generate a response for the prompt based on the audio. Actual behavior When trying to load an audio file, the following error is returned: {`error`:{     `code`:`Invalid input`,     `status`:422,     `message`:`invalid input error`,     `details`:[{         `type`:`string_type`,         `loc`:[`body`,`messages`,1,`content`,`str`],         `msg`:`Input should be a valid string`,         `input`:[{`type`:`text`,`text`:`Please translate this audio snippet to spanish`},{         `type`:`input_audio`,`input_audio`:{`data`:`<encoded-data>`, `format`:`mp3`}}]}}  Reproduction Steps Reference any local audio file in the request: var requestOptions = new ChatCompletionsOptions() {     Messages =     {         new ChatRequestSystemMessage(`You are an AI assistant for translating and transcribing audio clips.`),         new ChatRequestUserMessage(             new ChatMessageTextContentItem(`Please translate this audio snippet to spanish.`),             // The line below causes the error             new ChatMessageAudioContentItem(`hello_how_are_you.mp3`, AudioContentFormat.Mp3),     }, };  Response<ChatCompletions> response = client.Complete(requestOptions);  Environment IDE: VSCode 1.98.2 .NET 8.0 Windows 11
Client	Tables	[BUG] Func delegate Filter in Tableclient.QueryAsync does not support Equals(x, StringComparison) method	Library name and version Azure.Data.Tables 12.10.0 Describe the bug Before upgrading Azure.Data.Tables to 12.10.0 we used 12.8.3 version where this code worked without errors Tableclient.QueryAsync(x=>x.Equals(`test`, StringComparison.OrdinalIgnoreCase), null, columns, cancellationToken) After upgrading to 12.10.0 we started seeing this error `message`: `Equals method with more than two arguments is not supported.`, `type`: `System.NotSupportedException`,  Expected behavior This code works without error when using Azure.Data.Tables, Version=12.10.0 Tableclient.QueryAsync<T>(x=>x.Equals(`test`, StringComparison.OrdinalIgnoreCase), null, columns, cancellationToken)  Actual behavior After upgrading to Azure.Data.Tables to 12.10.0 we started seeing this error `message`: `Equals method with more than two arguments is not supported.`, `type`: `System.NotSupportedException`,  StackTrace: { `assembly`: `Azure.Data.Tables, Version=12.10.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `method`: `Azure.Data.Tables.Queryable.ExpressionNormalizer.VisitMethodCallNoRewrite`, `level`: 0, `line`: 0 }, { `assembly`: `Azure.Data.Tables, Version=12.10.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `method`: `Azure.Data.Tables.Queryable.ExpressionNormalizer.VisitMethodCall`, `level`: 1, `line`: 0 }, { `assembly`: `System.Linq.Expressions, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `method`: `System.Linq.Expressions.ExpressionVisitor.VisitBinary`, `level`: 2, `line`: 0 }, { `assembly`: `Azure.Data.Tables, Version=12.10.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `method`: `Azure.Data.Tables.Queryable.ExpressionNormalizer.VisitBinary`, `level`: 3, `line`: 0 }, { `assembly`: `System.Linq.Expressions, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `method`: `System.Linq.Expressions.ExpressionVisitor.VisitLambda`, `level`: 4, `line`: 0 }, { `assembly`: `Azure.Data.Tables, Version=12.10.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `method`: `Azure.Data.Tables.TableClient.Bind`, `level`: 5, `line`: 0 }, { `assembly`: `Azure.Data.Tables, Version=12.10.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `method`: `Azure.Data.Tables.TableClient.QueryAsync`, `level`: 6, `line`: 0 }  Reproduction Steps Pass filter Func delegate x=>x.Equals(`test`, StringComparison.OrdinalIgnoreCase)  to the Tableclient.QueryAsync, i.e. Tableclient.QueryAsync<T>(x=>x.Equals(`test`, StringComparison.OrdinalIgnoreCase), null, columns, cancellationToken)  Environment No response
Client	Service Bus	Sporadic connectivity error `The operation is canceled because the owner is being closed.`	Library name and version Azure.Messaging.ServiceBus Version: 7.18.4.0 Query/Question We have an existing onprem service that's connecting to an Azure Service Bus instance using the Azure.Messaging.ServiceBus, but with a low frequency (sometimes with idle times of more than 10 mins) we are seeing recurring error messages that include the following error:   The operation is canceled because the owner is being closed. (ServiceCommunicationProblem). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot  The way we have structure our code is we have created a singleton Sender per node instance:  private static ServiceBusSender GetServiceBusSender()         {             if (_serviceBusClient == null)             {                 lock (_lock)  // Lock to ensure thread-safety during initialization                 {                     // Double-check if initialization is needed                     if (_serviceBusClient == null)                     {                         // Load the configuration (this happens only once)                         LoadConfiguration();                          // Retrieve the credential and initialize the ServiceBusClient                         var credential = AzureCredentialHelper.GetClientCertificateCredential();                         var clientOptions = new ServiceBusClientOptions                         {                             TransportType = ServiceBusTransportType.AmqpWebSockets,                             RetryOptions = new ServiceBusRetryOptions                             {                                 MaxRetries = 3,                                 Mode = ServiceBusRetryMode.Exponential,                                 Delay = TimeSpan.FromSeconds(1)                             }                         };                         _serviceBusClient = new ServiceBusClient($`{_serviceBusNamespace}.servicebus.windows.net`, credential, clientOptions);                     }                 }                             }              // Return the appropriate sender             return _serviceBusClient.CreateSender(_queueName);         } Any idea what we might be doing wrong here in terms of the usage of the sdk? Note, since we are not sending messages frquently, we are not caching the sender, but we could do so if it would help. Environment No response
Client	AI Projects	[BUG] Agent run breaks when a filename with an accent has been uploaded	Library name and version `Azure.AI.Projects` Version=`1.0.0-beta.6` Describe the bug Hello. I found a bug related to file upload. Using the AIProject, when I upload a file with its name containing an accent through UploadFileAsync method (await _agentClient.UploadFileAsync(stream, AgentFilePurpose.Agents, filename, cancellationToken).ConfigureAwait(false)), I have a successful, but weird result. Expected behavior Either the handling of accents in filename or an explicit error Actual behavior Using the file named `test.pdf`  Using the file named `tést.pdf`  When running the thread, it obviously fails  I add my 2 test files here: test.pdf tést.pdf (warning, github removes accents from filename) Reproduction Steps  Upload the tést.pdf file using UploadFileAsync Create a thread Add an user message in the thread, including text content and the fileId of the previously uploaded tést.pdf file  Code rapidly written showing the problem // Create the stream from the file ... var uploadResult = await _agentClient.UploadFileAsync(stream, AgentFilePurpose.Agents, `tést.pdf`).ConfigureAwait(false);  List<MessageAttachment> attachments = []; attachments.Add(new MessageAttachment(uploadResult.Value.Id,  [new FileSearchToolDefinition()]));  var threadResult = await _agentClient.CreateThreadAsync([], cancellationToken: cancellationToken).ConfigureAwait(false);  await _agentClient.CreateMessageAsync(  threadId: threadResult.Value.Id,  role: MessageRole.User,  content: `What is the number ?`,  attachments: attachments,  cancellationToken: cancellationToken ).ConfigureAwait(false); -> The request fails Environment No response
Client	Tables	[BUG] Unable to use StringComparison with table query	Library name and version Azure.Data.Tables 12.10.0 Describe the bug As of v12.10.0 of Azure.Data.Tables, I'm unable to use any string comparison methods with a StringComparison argument passed in for the query filter. Azure.Data.Tables.TableClient.QueryAsync(Expression<Func<TEntity, bool>> filter, ...) tableClient.QueryAsync(t => t.PartitionKey.Equals(partitionKey, StringComparison.OrdinalIgnoreCase)) tableClient.QueryAsync(t => string.Compare(t.PartitionKey, partitionKey, StringComparison.OrdinalIgnoreCase) == 0) Both approaches throw an exception as it is reported that the string equals and comparison methods taking in a StringComparison argument are not supported but they were in 12.9.x. Currently I have only tested with StringComparison.OrdinalIgnoreCase as that is my use case and the error does not indicate an issue with that specific StringComparison but with the number of arguments being passed in. I will, however, do some testing and update this issue if I notice a difference in behaviour with other StringComparison values. Expected behavior The expected behaviour is that the string comparison is evaluated with regards to the StringComparison argument passed in as it did in v12.9.x Actual behavior An exception is thrown if a StringComparison argument is provided. Given two strings, x and y, and a StringComparison comp, In 12.9.0 & 12.9.1: x.Equals(y, comp) works without issue string.Compare(x, y, comparison) == 0 works without issue In 12.10.0: x.Equals(y, comp) => `Equals method with more than two arguments is not supported.` string.Compare(x, y, comp) == 0 => `string.Compare method with more than two arguments is not supported.` Also to mention, string.Equals(x, y, comp) doesn't work in any of the versions listed. In 12.9.x the error message is `Incorrect number of arguments supplied for call to method 'Boolean Equals(System.String, System.String, System.StringComparison)' (Parameter 'method')`, but in 12.10.0 the error message has changed to `string.Equals method with more than two arguments is not supported.` Reproduction Steps Perform a query on a table and for the filter provide an expression that compares the table entity's partition key to a partition key passed in, where the comparison should be case-insensitive. Environment No response
Client	AI Projects	[BUG] Method AgentsClient.GetMessagesAsync() does not filter messages by runId	Library name and version `Azure.AI.Projects` Version=`1.0.0-beta.5` Describe the bug Hi all, I'm not sure whether this is a bug or an intended feature, but I expect that the following method should return only the messages of the given thread that belong to the given run identifier: Azure.AI.Projects.AgentsClient client ... var messages = client.GetMessagesAsync(threadId, runId);  Currently, however, the method always returns all messages of the given thread, regardless of the run ID. Using nuget:   <PackageReference Include=`Azure.AI.Projects` Version=`1.0.0-beta.5` /> Expected behavior Only messages of the given thread with the given runId should be returned. Actual behavior All messages are returned. Reproduction Steps see code above. Environment No response
Client	Extensions	[FEATURE REQ] Expose `ClientFactory.CreateCredential` for direct consumer use	Library name Microsoft.Extensions.Azure Please describe the feature. I'd like to be able to construct a TokenCredential instance from IConfiguration using the same logic that Microsoft.Extensions.Azure uses today here:                azure-sdk-for-net/sdk/extensions/Microsoft.Extensions.Azure/src/Internal/ClientFactory.cs                   Lines 94 to 302       in       58c2f13                                                 internal static TokenCredential CreateCredential(IConfiguration configuration)                                           {                                               var credentialType = configuration[`credential`];                                               var clientId = configuration[`clientId`];                                               var tenantId = configuration[`tenantId`];                                               var serviceConnectionId = configuration[`serviceConnectionId`];                                               var resourceId = configuration[`managedIdentityResourceId`];                                               var objectId = configuration[`managedIdentityObjectId`];                                               var clientSecret = configuration[`clientSecret`];                                               var certificate = configuration[`clientCertificate`];                                               var certificateStoreName = configuration[`clientCertificateStoreName`];                                               var certificateStoreLocation = configuration[`clientCertificateStoreLocation`];                                               var systemAccessToken = configuration[`systemAccessToken`];                                               var additionallyAllowedTenants = configuration[`additionallyAllowedTenants`];                                               var tokenFilePath = configuration[`tokenFilePath`];                                               IEnumerable<string> additionallyAllowedTenantsList = null;                                               if (!string.IsNullOrWhiteSpace(additionallyAllowedTenants))                                               {                                                   // not relying on StringSplitOptions.RemoveEmptyEntries as we want to remove leading/trailing whitespace between entries                                                   additionallyAllowedTenantsList = additionallyAllowedTenants.Split(TenantDelimiter)                                                       .Select(t => t.Trim())                                                       .Where(t => t.Length > 0);                                               }                                                                                          if (string.Equals(credentialType, `managedidentity`, StringComparison.OrdinalIgnoreCase))                                               {                                                   int idCount = 0;                                                   idCount += string.IsNullOrWhiteSpace(clientId) ? 0 : 1;                                                   idCount += string.IsNullOrWhiteSpace(resourceId) ? 0 : 1;                                                   idCount += string.IsNullOrWhiteSpace(objectId) ? 0 : 1;                                                                                              if (idCount > 1)                                                   {                                                       throw new ArgumentException(`Only one of either 'clientId', 'managedIdentityResourceId', or 'managedIdentityObjectId' can be specified for managed identity.`);                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(resourceId))                                                   {                                                       return new ManagedIdentityCredential(new ResourceIdentifier(resourceId));                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(objectId))                                                   {                                                       return new ManagedIdentityCredential(ManagedIdentityId.FromUserAssignedObjectId(objectId));                                                   }                                                                                              return new ManagedIdentityCredential(clientId);                                               }                                                                                          if (string.Equals(credentialType, `workloadidentity`, StringComparison.OrdinalIgnoreCase))                                               {                                                   // The WorkloadIdentityCredentialOptions object initialization populates its instance members                                                   // from the environment variables AZURE_TENANT_ID, AZURE_CLIENT_ID, and AZURE_FEDERATED_TOKEN_FILE                                                   var workloadIdentityOptions = new WorkloadIdentityCredentialOptions();                                                   if (!string.IsNullOrWhiteSpace(tenantId))                                                   {                                                       workloadIdentityOptions.TenantId = tenantId;                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(clientId))                                                   {                                                       workloadIdentityOptions.ClientId = clientId;                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(tokenFilePath))                                                   {                                                       workloadIdentityOptions.TokenFilePath = tokenFilePath;                                                   }                                                                                              if (additionallyAllowedTenantsList != null)                                                   {                                                       foreach (string tenant in additionallyAllowedTenantsList)                                                       {                                                           workloadIdentityOptions.AdditionallyAllowedTenants.Add(tenant);                                                       }                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(workloadIdentityOptions.TenantId) &&                                                       !string.IsNullOrWhiteSpace(workloadIdentityOptions.ClientId) &&                                                       !string.IsNullOrWhiteSpace(workloadIdentityOptions.TokenFilePath))                                                   {                                                       return new WorkloadIdentityCredential(workloadIdentityOptions);                                                   }                                                                                              throw new ArgumentException(`For workload identity, 'tenantId', 'clientId', and 'tokenFilePath' must be specified via environment variables or the configuration.`);                                               }                                                                                          if (string.Equals(credentialType, `azurepipelines`, StringComparison.OrdinalIgnoreCase))                                               {                                                   if (string.IsNullOrWhiteSpace(tenantId) ||                                                       string.IsNullOrWhiteSpace(clientId) ||                                                       string.IsNullOrWhiteSpace(serviceConnectionId) ||                                                       string.IsNullOrWhiteSpace(systemAccessToken))                                                   {                                                       throw new ArgumentException(`For Azure Pipelines, 'tenantId', 'clientId', 'serviceConnectionId', and 'systemAccessToken' must be specified via the configuration.`);                                                   }                                                                                              var options = new AzurePipelinesCredentialOptions();                                                                                              if (additionallyAllowedTenantsList != null)                                                   {                                                       foreach (string tenant in additionallyAllowedTenantsList)                                                       {                                                           options.AdditionallyAllowedTenants.Add(tenant);                                                       }                                                   }                                                                                              return new AzurePipelinesCredential(tenantId, clientId, serviceConnectionId, systemAccessToken, options);                                               }                                                                                          if (!string.IsNullOrWhiteSpace(tenantId) &&                                                   !string.IsNullOrWhiteSpace(clientId) &&                                                   !string.IsNullOrWhiteSpace(clientSecret))                                               {                                                   var options = new ClientSecretCredentialOptions();                                                                                              if (additionallyAllowedTenantsList != null)                                                   {                                                       foreach (string tenant in additionallyAllowedTenantsList)                                                       {                                                           options.AdditionallyAllowedTenants.Add(tenant);                                                       }                                                   }                                                   return new ClientSecretCredential(tenantId, clientId, clientSecret, options);                                               }                                                                                          if (!string.IsNullOrWhiteSpace(tenantId) &&                                                   !string.IsNullOrWhiteSpace(clientId) &&                                                   !string.IsNullOrWhiteSpace(certificate))                                               {                                                   StoreLocation storeLocation = StoreLocation.CurrentUser;                                                                                              if (!string.IsNullOrWhiteSpace(certificateStoreLocation))                                                   {                                                       storeLocation = (StoreLocation)Enum.Parse(typeof(StoreLocation), certificateStoreLocation, true);                                                   }                                                                                              if (string.IsNullOrWhiteSpace(certificateStoreName))                                                   {                                                       certificateStoreName = `MY`; // MY is the default used in X509Store                                                   }                                                                                              using var store = new X509Store(certificateStoreName, storeLocation);                                                   store.Open(OpenFlags.ReadOnly);                                                   X509Certificate2Collection certs = store.Certificates.Find(X509FindType.FindByThumbprint, certificate, false);                                                                                              if (certs.Count == 0)                                                   {                                                       throw new InvalidOperationException($`Unable to find a certificate with thumbprint '{certificate}'`);                                                   }                                                                                              var options = new ClientCertificateCredentialOptions();                                                                                              if (additionallyAllowedTenantsList != null)                                                   {                                                       foreach (string tenant in additionallyAllowedTenantsList)                                                       {                                                           options.AdditionallyAllowedTenants.Add(tenant);                                                       }                                                   }                                                   var credential = new ClientCertificateCredential(tenantId, clientId, certs[0], options);                                                                                              store.Close();                                                                                              return credential;                                               }                                                                                          // TODO: More logging                                                                                          if (!string.IsNullOrWhiteSpace(objectId))                                               {                                                   throw new ArgumentException(`'managedIdentityObjectId' is only supported when the credential type is 'managedidentity'.`);                                               }                                                                                          if (additionallyAllowedTenantsList != null                                                   || !string.IsNullOrWhiteSpace(tenantId)                                                   || !string.IsNullOrWhiteSpace(clientId)                                                   || !string.IsNullOrWhiteSpace(resourceId))                                               {                                                   var options = new DefaultAzureCredentialOptions();                                                                                              if (additionallyAllowedTenantsList != null)                                                   {                                                       foreach (string tenant in additionallyAllowedTenantsList)                                                       {                                                           options.AdditionallyAllowedTenants.Add(tenant);                                                       }                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(tenantId))                                                   {                                                       options.TenantId = tenantId;                                                   }                                                                                              if (!string.IsNullOrWhiteSpace(clientId))                                                   {                                                       options.ManagedIdentityClientId = clientId;                                                   }                                                                                              // validation that both clientId and ResourceId are not set happens in Azure.Identity                                                   if (!string.IsNullOrWhiteSpace(resourceId))                                                   {                                                       options.ManagedIdentityResourceId = new ResourceIdentifier(resourceId);                                                   }                                                                                              return new DefaultAzureCredential(options);                                               }                                               return null;                                           }                     This would enable new scenarios for us, such as being able to create the credentials to access Azure AppConfiguration based on previously configured settings in IConfiguration. We are in a situation currently where we need to support both the VisualStudioCredential (for local development) as well as the ClientSecretCredential for when running in upper environments (beta, staging and production). I'm aware that using DefaultAzureCredentials accomplishes that when paired with environment variables, and this is the setup we have in some of our applications: we set the credential to that, and then add AZURE_TENANT_ID, AZURE_CLIENT_ID and AZURE_CLIENT_SECRET environment variables when needed. This works well but only when using environment variables is possible. We hit a situation now where we'd like to configure both the tenant ID and the client id in appsettings.json, and then use those values, if present, to build the required credential to communicate with Azure AppConfig. Microsoft.Extensions.Azure has this built-in method that can convert a set of keys from IConfiguration into the appropriate TokenCredential instance based on the presence of required settings etc. However, this can only be tapped currently when working with Azure Clients and IServiceCollection. I opened a related issue last year:  #43434  But here I am again, one year later, with a harsher requirement: we are in a position now where using environment variables as a fallback is less desirable. I was told by @jsquire in that issue that the team was already looking into better ways of integrating credentials with IConfiguration, but I've not yet seen any movement towards that (unless I'm missing some package, in which case please let me know). While the team decides on a stronger, more comprehensive way to better integrate IConfiguration with other Azure modules, wouldn't it be possible to just expose that ClientFactory.CreateCredential method either as-is, or just extract it into a public TokenFactory class that is then reused inside ClientFactory and can also be used by consumers of the NuGet package. In the old issue, I said I was trying to avoid creating custom extensions on our side to do this and favored just using environment variables instead, but now with a few new projects this has become more cumbersome to support so I will likely change my stance on that and just copy the code from ClientFactory.CreateCredential into a reusable class library on our own side in the meantime.
Client	Azure.Identity	[BUG] `InteractiveBrowserCredentialBrokerOptions.UseDefaultBrokerAccount` doesn't do what it says	Library name and version Azure.Identity 1.14.0-beta.3 / Azure.Identity.Broker 1.3.0-beta.2 Describe the bug The docs for UseDefaultBrokerAccount  state                azure-sdk-for-net/sdk/identity/Azure.Identity.Broker/src/InteractiveBrowserCredentialBrokerOptions.cs                   Lines 23 to 26       in       c970156                                                 /// <summary>                                           /// Gets or sets whether to authenticate with the default broker account instead of prompting the user with a login dialog.                                           /// </summary>                                           public bool UseDefaultBrokerAccount { get; set; }                     I interpreted this to mean that I shouldn't expect to see the account selection window. Expected behavior I expect to not see the account selection screen, and to be taken straight to the next screen - in my case an MFA prompt. Alternatively if this is the expected behaviour from WAM side, I expect the documentation for UseDefaultBrokerAccount to be clarified. Actual behavior I get a prompt asking me to select an account.  This selection includes a single option which is my windows connected account.  (The redacted value is my account's UPN).  Reproduction Steps new InteractiveBrowserCredential(new InteractiveBrowserCredentialBrokerOptions(IntPtr.Zero)         {             UseDefaultBrokerAccount = true,         }) Environment .NET SDK:  Version:           9.0.201  Commit:            071aaccdc2  Workload version:  9.0.200-manifests.a3a1a094  MSBuild version:   17.13.13+1c2026462  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\9.0.201\  .NET workloads installed:  [aspire]    Installation Source: VS 17.13.35919.96    Manifest Version:    8.2.2/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.2.2\WorkloadManifest.json    Install Type:              Msi  Configured to use loose manifests when installing new manifests.  Host:   Version:      9.0.3   Architecture: x64   Commit:       831d23e561  .NET SDKs installed:   6.0.428 [C:\Program Files\dotnet\sdk]   8.0.408 [C:\Program Files\dotnet\sdk]   9.0.100 [C:\Program Files\dotnet\sdk]   9.0.200 [C:\Program Files\dotnet\sdk]   9.0.201 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Client	Azure.Identity	[BUG]: Brokered Credential spam logs	Library name and version Azure.Identity 1.14.0-beta.3 / Azure.Identity.Broker 1.3.0-beta.2 Describe the bug If you forward logs to ILogger through AzureEventSourceLogForwarder, the getting a token through the WAM broker outputs nearly 200 lines of logs!  This seems a bit excessive. Expected behavior Much of the output logs look like debug level, and are also spread out unnesscarially over several log entries.  I'd expect many of these logs to be at debug level, or for some of the log entries to be combined into one single entry rather than spread out into indivdiual log entries (see LogTelemetryData logs for many examples that could be combined). Actual behavior [18:03:27.918] info: Azure.Identity[1]       InteractiveBrowserCredential.GetToken invoked. Scopes: [ https://management.azure.com/.default ] ParentRequestId: [18:03:28.004] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] MSAL MSAL.NetCore with assembly version '4.69.1.0'. CorrelationId(13410f42-6da3-4f9f-9bf5-314476221b53) [18:03:28.007] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] === AcquireTokenSilent Parameters === [18:03:28.007] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] LoginHint provided: False [18:03:28.007] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Account provided: True [18:03:28.007] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] ForceRefresh: False [18:03:28.014] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53]       === Request Data ===       Authority Provided? - True       Scopes - https://management.azure.com/.default       Extra Query Params Keys (space separated) -       ApiId - AcquireTokenSilent       IsConfidentialClient - False       SendX5C - False       LoginHint ? False       IsBrokerConfigured - True       HomeAccountId - False       CorrelationId - 13410f42-6da3-4f9f-9bf5-314476221b53       UserAssertion set: False       LongRunningOboCacheKey set: False       Region configured:  [18:03:28.015] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] === Token Acquisition (SilentRequest) started:          Scopes: https://management.azure.com/.default         Authority Host: login.microsoftonline.com [18:03:28.016] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Broker is configured and enabled, attempting to use broker instead. [18:03:28.017] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Runtime] Broker supported OS. [18:03:28.044] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Can invoke broker. Will attempt to acquire token with broker. [18:03:28.048] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      INFO     SetAuthorityUri:78      Initializing authority from URI 'https://login.microsoftonline.com/organizations/' without authority type, defaulting to MsSts [18:03:28.052] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      INFO     SetCorrelationId:259    Set correlation ID: 13410f42-6da3-4f9f-9bf5-314476221b53 [18:03:28.052] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      INFO     EnqueueBackgroundRequest:1007   The original authority is 'https://login.microsoftonline.com/organizations' [18:03:28.052] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      INFO     ModifyAndValidateAuthParameters:216     Additional query parameter added successfully. Key: '(pii)' Value: '(pii)' [18:03:28.052] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      INFO     ModifyAndValidateAuthParameters:216     Additional query parameter added successfully. Key: '(pii)' Value: '(pii)' [18:03:28.052] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      INFO     ModifyAndValidateAuthParameters:239     Authority Realm: organizations [18:03:28.052] warn: Azure.Identity[9]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0001]      WARNING  TryEnqueueMsaDeviceCredentialAcquisitionAndContinue:1059        MsaDeviceOperationProvider is not available. Not attempting to register the device. [18:03:28.062] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     SetCanonicalRealm:1233  Normalize realm to: '38f326c0-8eee-4e70-a6a4-a6fcb51a95cd' [18:03:28.062] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     TryUseStorage:146       Try to read account from universal storage. [18:03:28.064] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     StorageTokenResponse:84 StorageTokenResponse account constructor invoked. This is only expected in Runtime flows [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:435    Printing Telemetry for Correlation ID: 13410f42-6da3-4f9f-9bf5-314476221b53 [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: start_time, Value: 2025-04-14T17:03:28.000Z [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: api_name, Value: SignInSilently [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: was_request_throttled, Value: false [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: authority_type, Value: AAD [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: access_token_expiry_time, Value: 2025-04-14T18:00:13.000Z [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: read_token, Value: ID|AT [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: msal_version, Value: 1.1.0+local [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: client_id, Value: 04b07795-8ddb-461a-bbee-02f9e1bf7b46 [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: correlation_id, Value: 13410f42-6da3-4f9f-9bf5-314476221b53 [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: broker_app_used, Value: false [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: stop_time, Value: 2025-04-14T17:03:28.000Z [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: msalruntime_version, Value: 0.18.1 [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: original_authority, Value: https://login.microsoftonline.com/organizations [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: request_eligible_for_broker, Value: true [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: additional_query_parameters_count, Value: 2 [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: normalized_realm, Value: 38f326c0-8eee-4e70-a6a4-a6fcb51a95cd [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: storage_read, Value: DAC|DAT|DID [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: auth_flow, Value: AT [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: is_successful, Value: true [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: authorization_type, Value: WindowsIntegratedAuth [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:443    Key: request_duration, Value: 14 [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:448    Printing Execution Flow: [18:03:28.067] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [MSAL:0002]      INFO     LogTelemetryData:456    {`t`:`646u1`,`tid`:1,`ts`:0,`l`:2},{`t`:`4s7uc`,`tid`:1,`ts`:0,`l`:2},{`t`:`4sufd`,`tid`:1,`ts`:0,`s`:2,`l`:2},{`t`:`4swgg`,`tid`:1,`ts`:0,`s`:1,`l`:2},{`t`:`4swgf`,`tid`:1,`ts`:0,`s`:1,`l`:2},{`t`:`4swgi`,`tid`:2,`ts`:1,`s`:1,`l`:2},{`t`:`8b2yn`,`tid`:2,`ts`:1,`l`:2},{`t`:`8dqkx`,`tid`:2,`ts`:1,`l`:2},{`t`:`8dqil`,`tid`:2,`ts`:1,`l`:2},{`t`:`8b2hr`,`tid`:2,`ts`:1,`l`:2},{`t`:`4q2di`,`tid`:2,`ts`:10,`l`:2},{`t`:`4qnng`,`tid`:2,`ts`:10,`l`:2,`a`:2,`ie`:0},{`t`:`4qnnf`,`tid`:2,`ts`:12,`l`:2,`a`:2,`ie`:1},{`t`:`8dqit`,`tid`:2,`ts`:12,`l`:2},{`t`:`8b2ht`,`tid`:2,`ts`:12,`l`:2},{`t`:`4qnno`,`tid`:2,`ts`:12,`l`:2,`a`:2,`ie`:0},{`t`:`4qnnn`,`tid`:2,`ts`:15,`l`:2,`a`:2,`ie`:1},{`t`:`6xuag`,`tid`:2,`ts`:15,`l`:2} [18:03:28.080] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [RuntimeBroker] WAM response status success [18:03:28.082] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Checking MsalTokenResponse returned from broker. [18:03:28.082] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Success. Response contains an access token. [18:03:28.082] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Checking client info returned from the server.. [18:03:28.111] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Saving token response to cache.. [18:03:28.118] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] [Instance Discovery] Instance discovery is enabled and will be performed [18:03:28.118] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] [Region discovery] Not using a regional authority. [18:03:28.122] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Fetching instance discovery from the network from host login.microsoftonline.com. [18:03:28.142] info: Azure.Core[1]       Request [b38e721d-1237-43ad-95cf-0ea178f6c785] GET https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=REDACTED       x-client-SKU:REDACTED       x-client-Ver:REDACTED       x-client-OS:REDACTED       client-request-id:REDACTED       return-client-request-id:REDACTED       x-ms-client-request-id:b38e721d-1237-43ad-95cf-0ea178f6c785       x-ms-return-client-request-id:true       User-Agent:azsdk-net-Identity/1.14.0-beta.3 (.NET 9.0.3; Microsoft Windows 10.0.22621)       client assembly: Azure.Identity [18:03:28.513] info: Azure.Core[5]       Response [b38e721d-1237-43ad-95cf-0ea178f6c785] 200 OK (00.4s)       Cache-Control:max-age=86400, private       Strict-Transport-Security:REDACTED       X-Content-Type-Options:REDACTED       Access-Control-Allow-Origin:REDACTED       Access-Control-Allow-Methods:REDACTED       P3P:REDACTED       client-request-id:REDACTED       x-ms-request-id:faafbc52-c047-482d-95a2-83001ee7c500       x-ms-ests-server:REDACTED       x-ms-srs:REDACTED       Content-Security-Policy-Report-Only:REDACTED       X-XSS-Protection:REDACTED       Set-Cookie:REDACTED       Date:Mon, 14 Apr 2025 17:03:27 GMT       Content-Type:application/json; charset=utf-8       Content-Length:957  [18:03:28.536] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] [Region discovery] Not using a regional authority. [18:03:28.553] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Clearing user token cache accessor. [18:03:28.554] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] [SaveTokenResponseAsync] Saving Id Token and Account in cache ... [18:03:28.555] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting refresh tokens: 0. PartitionKey  False [18:03:28.558] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting access tokens: 0 [18:03:28.558] warn: Azure.Identity[9]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] [CalculateSuggestedCacheExpiry] No access tokens or refresh tokens found in the accessor. Not returning any expiration. [18:03:28.559] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting access tokens: 0 [18:03:28.559] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting refresh tokens: 0. PartitionKey  False [18:03:28.560] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting accounts: 1. PartitionKey  False [18:03:28.567] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting access tokens: 0 [18:03:28.567] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z] [Internal cache] Total number of cache partitions found while getting refresh tokens: 0. PartitionKey  False [18:03:28.576] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53]         === Token Acquisition finished successfully: [18:03:28.578] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53]  AT expiration time: 04/14/2025 18:00:12 +00:00, scopes: https://management.azure.com/.default https://management.azure.com/user_impersonation. source: Broker [18:03:28.578] info: Azure.Identity[8]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] Fetched access token from host login.microsoftonline.com. [18:03:28.581] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53]       [LogMetricsFromAuthResult] Cache Refresh Reason: NotApplicable       [LogMetricsFromAuthResult] DurationInCacheInMs: 16       [LogMetricsFromAuthResult] DurationTotalInMs: 568       [LogMetricsFromAuthResult] DurationInHttpInMs: 387 [18:03:28.581] info: Azure.Identity[24]       False MSAL 4.69.1.0 MSAL.NetCore .NET 9.0.3 Microsoft Windows 10.0.22621 [2025-04-14 17:03:28Z - 13410f42-6da3-4f9f-9bf5-314476221b53] TokenEndpoint: **** [18:03:28.584] info: Azure.Identity[2]       InteractiveBrowserCredential.GetToken succeeded. Scopes: [ https://management.azure.com/.default ] ParentRequestId:  ExpiresOn: 2025-04-14T18:00:12.5304887+00:00 [18:03:28.585] info: Azure.Identity[13]       DefaultAzureCredential credential selected: Azure.Identity.InteractiveBrowserCredential [18:03:28.585] info: Azure.Identity[2]       DefaultAzureCredential.GetToken succeeded. Scopes: [ https://management.azure.com/.default ] ParentRequestId:  ExpiresOn: 2025-04-14T18:00:12.5304887+00:00  Reproduction Steps Use the following code, ensuring that you credentials are resolved through Brokered Credentials, not an earlier type in the chain: var logger = loggerFactory.CreateLogger<CredentialProvider>(); using var forwarder = new AzureEventSourceLogForwarder(loggerFactory); forwarder.Start(); var credential = new DefaultAzureCredential(new DefaultAzureCredentialOptions() {     // Managed Identity Credentials are slow, and not typically used in docker scenarios     ExcludeManagedIdentityCredential = true,     ExcludeAzureCliCredential = true }); var token = await credential.GetTokenAsync(new(scopes: [`https://management.azure.com/.default`])); Environment using var forwarder = new AzureEventSourceLogForwarder(loggerFactory); //forwarder.Start(); var credential = new DefaultAzureCredential(new DefaultAzureCredentialOptions() {     // Managed Identity Credentials are slow, and not typically used in docker scenarios     ExcludeManagedIdentityCredential = true, }); var token = await credential.GetTokenAsync(new(scopes: [`https://management.azure.com/.default`])); Environment dotnet: .NET SDK:  Version:           9.0.201  Commit:            071aaccdc2  Workload version:  9.0.200-manifests.a3a1a094  MSBuild version:   17.13.13+1c2026462  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\9.0.201\  .NET workloads installed:  [aspire]    Installation Source: VS 17.13.35919.96    Manifest Version:    8.2.2/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.2.2\WorkloadManifest.json    Install Type:              Msi  Configured to use loose manifests when installing new manifests.  Host:   Version:      9.0.3   Architecture: x64   Commit:       831d23e561  .NET SDKs installed:   6.0.428 [C:\Program Files\dotnet\sdk]   8.0.408 [C:\Program Files\dotnet\sdk]   9.0.100 [C:\Program Files\dotnet\sdk]   9.0.200 [C:\Program Files\dotnet\sdk]   9.0.201 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   S:\REDACTED\global.json  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download  Visual Studio: Microsoft Visual Studio Enterprise 2022 Version 17.13.5 VisualStudio.17.Release/17.13.5+35919.96 Microsoft .NET Framework Version 4.8.09032  Installed Version: Enterprise  Visual C++ 2022   00476-80000-00000-AA768 Microsoft Visual C++ 2022  ASP.NET and Web Tools   17.13.124.35287 ASP.NET and Web Tools  Azure App Service Tools v3.0.0   17.13.124.35287 Azure App Service Tools v3.0.0  Azure Functions and Web Jobs Tools   17.13.124.35287 Azure Functions and Web Jobs Tools  C# Tools   4.13.0-3.25167.3+73eff2b5de2ad38ec602c0a9e82f9125fb85992b C# components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used.  Common Azure Tools   1.10 Provides common services for use by Azure Mobile Services and Microsoft Azure Tools.  GitHub Copilot   17.13.441.19478 GitHub Copilot is an AI pair programmer that helps you write code faster and with less work.  Microsoft Azure Tools for Visual Studio   2.9 Support for Azure Cloud Services projects  Microsoft JVM Debugger   1.0 Provides support for connecting the Visual Studio debugger to JDWP compatible Java Virtual Machines  Node.js Tools   1.5.61125.7 Commit Hash:d387982a7546304d617ed77b6d390e04b6558274 Adds support for developing and debugging Node.js apps in Visual Studio  NuGet Package Manager   6.13.2 NuGet Package Manager in Visual Studio. For more information about NuGet, visit https://docs.nuget.org/  Office Developer Tools for Visual Studio   17.10.35513.00 Microsoft Office Developer Tools for Visual Studio  Razor (ASP.NET Core)   17.13.3.2512306+41f62d0b8021cafc33bdefdb7e0198c8d2eb59ac Provides languages services for ASP.NET Core Razor.  SQL Server Data Tools   17.13.3.1 Microsoft SQL Server Data Tools  Test Adapter for Boost.Test   1.0 Enables Visual Studio's testing tools with unit tests written for Boost.Test.  The use terms and Third Party Notices are available in the extension installation directory.  Test Adapter for Google Test   1.0 Enables Visual Studio's testing tools with unit tests written for Google Test.  The use terms and Third Party Notices are available in the extension installation directory.  TypeScript Tools   17.0.31211.2001 TypeScript Tools for Microsoft Visual Studio  Visual Basic Tools   4.13.0-3.25167.3+73eff2b5de2ad38ec602c0a9e82f9125fb85992b Visual Basic components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used.  Visual F# Tools   17.13.0-beta.25154.2+82a3f54f7140a62e6398403451098c4517747c02 Microsoft Visual F# Tools  Visual Studio IntelliCode   2.2 AI-assisted development for Visual Studio.  Workflow Manager Tools 1.0   1.0 This package contains the necessary Visual Studio integration components for Workflow Manager.
Mgmt	ARM	[BUG] RequestFailedException ErrorCode null with net6.0 and System.Text.Json 9+	Library name and version Azure.ResourceManager 1.13.0 Describe the bug We have a helper function that is used all over our code that looks similar to below. It recently broke when updating System.Text.Json to version 9+. We are stuck on .NET 6 for the time so are combining this with up to date System.Text.Json versions. Some combination of these two changes the behavior of RequestFailedException parsing.  .NET6, System.Text.Json 9+: Does not work .NET8, System.Text.Json 9+: Works!! .NET6, System.Text.Json 8: Works!!  The ErrorCode component of RequestFailedException is always null - debugging into the SDK shows that it's using System.Text.Json to construct the exception from the response. Are there any known compatibility issues between these versions of framework/packages? bool IsError(RequestFailedException exception, int statusCode, string errorCode, ILogger logger) {     if (exception != null)     {         bool statusMatch = exception.Status == statusCode;         // Use case-insensitive comparison for ErrorCode matching as in original code         bool errorCodeMatch = string.Equals(exception.ErrorCode, errorCode, StringComparison.OrdinalIgnoreCase);          // Use the passed-in logger         logger.LogDebug($`IsError Check: Target(Status={statusCode}, Code='{errorCode}') | Actual(Status={exception.Status}, Code='{exception.ErrorCode ?? `<NULL>`}') | StatusMatch={statusMatch}, CodeMatch={errorCodeMatch}`);          return statusMatch && errorCodeMatch;     }     else     {         logger.LogDebug(`IsError Check: Exception was null.`);         return false;     } } Thank you so much! Expected behavior ErrorCode should have a text description of the API call, like SubscriptionNotFound, ResourceNotFound, ResourceGroupDeletionBlocked, etc for .NET6 and System.Text.Json 9+. Actual behavior ErrorCode is always null Reproduction Steps Program.cs using Azure; using Azure.Core; using Azure.Identity; using Azure.ResourceManager; using Azure.ResourceManager.Resources; using Microsoft.Extensions.Logging;  // --- Configuration --- // IMPORTANT: Set your Azure Subscription ID here or via Environment Variable const string AZURE_SUBSCRIPTION_ID_ENV_VAR = `AZURE_SUBSCRIPTION_ID`; string subscriptionId = Environment.GetEnvironmentVariable(AZURE_SUBSCRIPTION_ID_ENV_VAR) ?? `<YOUR SUB>`; // <--- CHANGE THIS if not using Env Var string resourceGroupName = $`nonexistent-rg-{Guid.NewGuid()}`; // Guarantees it doesn't exist // ---------------------  // --- Set up Logging --- using var loggerFactory = LoggerFactory.Create(builder => {     builder.AddConsole();     // Optional: Set minimum log level if needed     // builder.SetMinimumLevel(LogLevel.Debug); }); // Create the logger instance that will be passed around ILogger logger = loggerFactory.CreateLogger(`AzureRgCheckTest`); // ----------------------   logger.LogInformation(`Starting Azure Resource Group Check Test...`); logger.LogInformation(`Target Framework: .NET 6`); logger.LogInformation(`System.Text.Json Version: 9.0.3`); // Verify this matches your intent  if (subscriptionId.StartsWith(`YOUR_`)) {     logger.LogError($`Please set the '{AZURE_SUBSCRIPTION_ID_ENV_VAR}' environment variable or update the subscriptionId variable in Program.cs.`);     return 1; // Error exit code }  logger.LogInformation($`Using Subscription ID: {subscriptionId}`); logger.LogInformation($`Checking for Resource Group: {resourceGroupName}`);  // --- Authentication & ArmClient --- // Uses credentials from VS, Azure CLI, Env Vars, Managed Identity etc. TokenCredential credential = new DefaultAzureCredential(); ArmClient armClient = new ArmClient(credential); // ---------------------------------   // --- Call the Test Method --- bool exists = false; try {     // Pass the logger instance down     exists = await ExistsAsync(armClient, subscriptionId, resourceGroupName, logger, CancellationToken.None);     logger.LogInformation($`ExistsAsync Result: {exists}`);      if (exists)     {         logger.LogError(`!!! TEST FAILED: ExistsAsync returned true for a non-existent resource group.`);         return 1;     }     else     {         logger.LogInformation(`>>> TEST SUCCEEDED (Potentially): ExistsAsync correctly returned false because the exception was handled by the catch block.`);         return 0;     } } catch (RequestFailedException finalException) {     logger.LogError(finalException, `!!! TEST FAILED: ExistsAsync threw an unhandled RequestFailedException. This means the 'when' clause likely failed.`);     logger.LogError($`--- Exception Details ---`);     logger.LogError($`Status: {finalException.Status}`);     logger.LogError($`ErrorCode: {finalException.ErrorCode ?? `<NULL OR EMPTY>`}`); // Explicitly show if null/empty     // Log raw response if helpful     try     {         Response? rawResponse = finalException.GetRawResponse();         if (rawResponse != null)         {             Stream? contentStream = rawResponse.ContentStream;             string content = `<Could not read>`;             if (contentStream != null)             {                 // FIX CS0131: Get the stream and check CanSeek before setting Position                 if (contentStream.CanSeek)                 {                     contentStream.Position = 0; // Reset stream position                 }                 // Use using for StreamReader to ensure disposal                 using (var reader = new StreamReader(contentStream)) // Pass the stream object                 {                     content = await reader.ReadToEndAsync();                 }             }             else             {                 content = `<ContentStream is NULL>`;             }             logger.LogError($`Raw Response Content: {content}`);         }         else         {             logger.LogError(`Raw Response Content: <NULL>`);         }      }     catch (Exception ex)     {         logger.LogError(ex, `Failed to read raw response content.`);     }     logger.LogError($`--- End Exception Details ---`);     return 1; // Error exit code } catch (Exception finalException) {     logger.LogError(finalException, `!!! TEST FAILED: ExistsAsync threw an unexpected exception type.`);     return 1; // Error exit code }   // ======================================================================== // Methods copied/adapted from your scenario // ========================================================================  // Wrapper equivalent to your ResourceGroupManager.ExistsAsync // Added ILogger parameter async Task<bool> ExistsAsync(ArmClient client, string subId, string rgName, ILogger log, CancellationToken cancellationToken) {     // FIX Argument Checks for .NET 6     if (string.IsNullOrWhiteSpace(subId))         throw new ArgumentException($`'{nameof(subId)}' cannot be null or whitespace.`, nameof(subId));     if (string.IsNullOrWhiteSpace(rgName))         throw new ArgumentException($`'{nameof(rgName)}' cannot be null or whitespace.`, nameof(rgName));     if (client == null)         throw new ArgumentNullException(nameof(client));      log.LogDebug(`Calling GetResourceGroupAsync...`);     try     {         // Pass logger down         await GetResourceGroupAsync(client, subId, rgName, log, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);         log.LogWarning(`GetResourceGroupAsync unexpectedly succeeded (Resource Group might actually exist?)`);         return true; // Should not happen if RG truly doesn't exist     }     // --- THIS IS THE CRITICAL PART TO TEST ---     // Pass logger to the extension method     catch (RequestFailedException exception) when (IsError(exception, 404, `ResourceGroupNotFound`, log))     {         log.LogInformation(`>>> Correctly caught expected RequestFailedException (404, ResourceGroupNotFound) in 'when' clause.`);         return false; // Resource group does not exist - Correctly handled     }     // If the 'when' clause returns false, the exception propagates and will be caught by the outer handler }   // Equivalent to your AzureResourceManager.GetResourceGroupAsync // Added ILogger parameter async Task<ResourceGroupResource> GetResourceGroupAsync(ArmClient client, string subId, string rgName, ILogger log, CancellationToken cancellationToken) {     // FIX Argument Checks for .NET 6     if (string.IsNullOrWhiteSpace(subId))         throw new ArgumentException($`'{nameof(subId)}' cannot be null or whitespace.`, nameof(subId));     if (string.IsNullOrWhiteSpace(rgName))         throw new ArgumentException($`'{nameof(rgName)}' cannot be null or whitespace.`, nameof(rgName));     if (client == null)         throw new ArgumentNullException(nameof(client));      log.LogDebug($`Attempting to get Subscription Resource for {subId}`);     SubscriptionResource subscription = client.GetSubscriptionResource(SubscriptionResource.CreateResourceIdentifier(subId));     log.LogDebug($`Attempting to get Resource Group '{rgName}'`);      // This is the call that is expected to throw RequestFailedException     var immed = subscription.GetResourceGroups();     ResourceGroupResource resourceGroup = await immed.GetAsync(rgName, cancellationToken);      return resourceGroup; }  bool IsError(RequestFailedException exception, int statusCode, string errorCode, ILogger logger) {     if (exception != null)     {         bool statusMatch = exception.Status == statusCode;         // Use case-insensitive comparison for ErrorCode matching as in original code         bool errorCodeMatch = string.Equals(exception.ErrorCode, errorCode, StringComparison.OrdinalIgnoreCase);          // Use the passed-in logger         logger.LogDebug($`IsError Check: Target(Status={statusCode}, Code='{errorCode}') | Actual(Status={exception.Status}, Code='{exception.ErrorCode ?? `<NULL>`}') | StatusMatch={statusMatch}, CodeMatch={errorCodeMatch}`);          return statusMatch && errorCodeMatch;     }     else     {         logger.LogDebug(`IsError Check: Exception was null.`);         return false;     } } AzureRgCheckTest.csproj <Project Sdk=`Microsoft.NET.Sdk`>    <PropertyGroup>     <OutputType>Exe</OutputType>     <TargetFramework>net6.0</TargetFramework>     <ImplicitUsings>enable</ImplicitUsings>     <Nullable>enable</Nullable>   </PropertyGroup>    <ItemGroup>     <PackageReference Include=`Azure.Identity` Version=`1.13.2` />     <PackageReference Include=`Azure.ResourceManager` Version=`1.13.0` />     <PackageReference Include=`Microsoft.Extensions.Logging.Console` Version=`6.0.0` />     <PackageReference Include=`System.Text.Json` Version=`9.0.4` />   </ItemGroup>  </Project>   Environment On my local machine, not sure if relevant. .NET SDK:  Version:           9.0.203  Commit:            dc7acfa194  Workload version:  9.0.200-manifests.528db46d  MSBuild version:   17.13.20+a4ef1e90f  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.26100  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\9.0.203\  .NET workloads installed:  [maui-windows]    Installation Source: VS 17.13.35931.197    Manifest Version:    9.0.14/9.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.sdk.maui\9.0.14\WorkloadManifest.json    Install Type:              Msi   [android]    Installation Source: VS 17.13.35931.197    Manifest Version:    35.0.50/9.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.sdk.android\35.0.50\WorkloadManifest.json    Install Type:              Msi   [maccatalyst]    Installation Source: VS 17.13.35931.197    Manifest Version:    18.2.9180/9.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.sdk.maccatalyst\18.2.9180\WorkloadManifest.json    Install Type:              Msi   [ios]    Installation Source: VS 17.13.35931.197    Manifest Version:    18.2.9180/9.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.sdk.ios\18.2.9180\WorkloadManifest.json    Install Type:              Msi   [aspire]    Installation Source: VS 17.13.35931.197    Manifest Version:    8.2.2/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.2.2\WorkloadManifest.json    Install Type:              Msi  Configured to use loose manifests when installing new manifests.  Host:   Version:      9.0.4   Architecture: x64   Commit:       f57e6dc747  .NET SDKs installed:   3.1.426 [C:\Program Files\dotnet\sdk]   6.0.428 [C:\Program Files\dotnet\sdk]   8.0.311 [C:\Program Files\dotnet\sdk]   8.0.408 [C:\Program Files\dotnet\sdk]   9.0.200 [C:\Program Files\dotnet\sdk]   9.0.203 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 9.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]
Client	Service Bus	Built-in Compression Support	Feature Request: Built-in Optional Compression Support in Azure Service Bus SDK Is your feature request related to a problem? Please describe. Currently, when working with Azure Service Bus and larger message payloads (approaching the 256 KB limit), developers are forced to manually implement compression and decompression logic. This adds boilerplate code, increases maintenance overhead, and leads to inconsistent implementations across projects and teams. Describe the solution you'd like Introduce optional built-in compression support in the Azure Service Bus SDK (e.g., .NET, Python, Java). This could be implemented as a pluggable compression strategy or simple configuration flag (e.g., EnableCompression = true with CompressionAlgorithm = Gzip | Brotli | ...). The SDK would handle compressing the message body before sending and decompressing upon receiving — when appropriate headers or content types are detected. Describe alternatives you've considered  Manually compressing the payload using GZip/Brotli and setting the appropriate ContentType, then decompressing on the receiving side based on that. Creating custom wrappers or middleware outside the SDK to handle this.  Additional context This feature can remain fully optional and disabled by default to preserve performance and compatibility. It would empower developers with a standard way to handle compression, while still holding them responsible for interoperability across language-specific SDKs. Compression algorithms like GZip and Brotli are well-established and supported across most platforms. If a developer chooses an algorithm not supported on the receiving end (e.g., Brotli from C# to a Python consumer that doesn't support it), the responsibility lies with the developer — not the SDK. This is consistent with other cross-platform concerns. Such a feature would be especially valuable for event-driven architectures where efficient message transmission is critical.
Client	Event Hubs	[BUG] `EventProcessorClient`: 'no offset' is not a valid amqp filter	Library name and version Azure.Messaging.EventHubs.Processor 5.12.0 Describe the bug I just updated this package from v5.11.6 today, and now my EventProcessorClient is throwing this exception non-stop (redacted): Azure.Messaging.EventHubs[43] An exception occurred while processing events for partition '<...>' by processor instance with identifier <...> for Event Hub: <...> and Consumer Group: <...>.  Error Message: 'The filter 'amqp.annotation.x-opt-offset > no offset' is not a valid amqp filter for EventHub entities  TrackingId:b45d3e89-c37c-401b-b053-b2191a34387e_B14, SystemTracker:<...>:eventhub:<...>, Timestamp:2025-04-09T18:12:40  Reference:4807bb18-1ed9-4c2b-aa1b-e32da537045d, TrackingId:b2458eac-aed7-4fe5-91e1-031f872e3807_B14, SystemTracker:<...>:eventhub:<...>|<...>, Timestamp:2025-04-09T18:12:40  TrackingId:64513f0980c44e00899e59beafc6c5cc_G28, SystemTracker:gateway5, Timestamp:2025-04-09T18:12:40   ---> Microsoft.Azure.Amqp.AmqpException: The filter 'amqp.annotation.x-opt-offset > no offset' is not a valid amqp filter for EventHub entities TrackingId:7b38d785-4f99-4bcf-b0fc-c62c3169f120_B35, SystemTracker:<...>:eventhub:<...>, Timestamp:2025-04-09T17:53:36 Reference:bb256fac-0c9a-48db-b172-4817a4440dcb, TrackingId:a05fc152-a060-47bd-864c-0efb4d478c78_B35, SystemTracker:<...>:eventhub:<...>|<...>, Timestamp:2025-04-09T17:53:36 TrackingId:c3b916037db24bc3befd600b584b531a_G17, SystemTracker:gateway5, Timestamp:2025-04-09T17:53:36    at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result)    at Microsoft.Azure.Amqp.AmqpObject.OpenAsyncResult.End(IAsyncResult result)    at Microsoft.Azure.Amqp.AmqpObject.EndOpen(IAsyncResult result)    at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location ---    at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenAmqpObjectAsync(AmqpObject target, Nullable`1 timeout, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenConsumerLinkAsync(String consumerGroup, String partitionId, EventPosition eventPosition, TimeSpan operationTimeout, TimeSpan linkTimeout, UInt32 prefetchCount, Nullable`1 prefetchSizeInBytes, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, String linkIdentifier, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.CreateConsumerLinkAsync(String consumerGroup, String partitionId, String consumerIdentifier, EventPosition eventStartingPosition, UInt32 prefetchCount, Nullable`1 prefetchSizeInBytes, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, TimeSpan timeout, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.CreateConsumerLinkAsync(String consumerGroup, String partitionId, String consumerIdentifier, EventPosition eventStartingPosition, UInt32 prefetchCount, Nullable`1 prefetchSizeInBytes, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, TimeSpan timeout, CancellationToken cancellationToken)    at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)    at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)    at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.ReceiveAsync(Int32 maximumEventCount, Nullable`1 maximumWaitTime, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.ReceiveAsync(Int32 maximumEventCount, Nullable`1 maximumWaitTime, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.<>c__DisplayClass79_0.<<CreatePartitionProcessor>g__performProcessing|2>d.MoveNext() --- End of stack trace from previous location ---    at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.<>c__DisplayClass79_0.<<CreatePartitionProcessor>g__performProcessing|2>d.MoveNext() --- End of stack trace from previous location ---    at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.<>c__DisplayClass79_0.<<CreatePartitionProcessor>g__performProcessing|2>d.MoveNext() --- End of stack trace from previous location ---    at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.<>c__DisplayClass79_0.<<CreatePartitionProcessor>g__performProcessing|2>d.MoveNext()  Execution never reaches my code (in the EventProcessorClient.ProcessEventAsync(...) event handler)—so it appears either I'm missing some new configuration somewhere, or a breaking change was introduced. My setup is pretty basic however, I don't manage any AMQP settings and I don't know where to look. I noticed in this new package version the EventData.Offset property is being obsoleted in favor of EventData.OffsetString. I don't understand the reason for that change, but it seems like it might possibly have something to do with it? Is there something in Azure I need to update to match the new client package? Any help would be appreciated. Expected behavior The EventProcessorClient would handle all the low-level AMQP concerns (which my code is blissfully unaware of) just like it has been doing up to this point. Actual behavior EventProcessorClient throws the exception above for each partition that it tries to read messages from. It then restarts and retries, throwing again. Rinse & repeat forever. Reproduction Steps (A lot involved here. If I really need to create a minimal app from scratch, let me know. I'm hoping the error message will help pinpoint the issue.) Environment .NET SDK: Version:           9.0.203 Commit:            dc7acfa194 Workload version:  9.0.200-manifests.12d79ccf MSBuild version:   17.13.20+a4ef1e90f Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\9.0.203\ .NET workloads installed: [aspire] Installation Source: VS 17.13.35931.197 Manifest Version:    8.2.2/8.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.2.2\WorkloadManifest.json Install Type:              Msi [wasm-tools-net6] Installation Source: VS 17.13.35931.197 Manifest Version:    9.0.4/9.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.workload.mono.toolchain.net6\9.0.4\WorkloadManifest.json Install Type:              Msi [wasm-tools-net7] Installation Source: VS 17.13.35931.197 Manifest Version:    9.0.4/9.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.workload.mono.toolchain.net7\9.0.4\WorkloadManifest.json Install Type:              Msi [wasm-tools] Installation Source: VS 17.13.35931.197 Manifest Version:    9.0.4/9.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\9.0.100\microsoft.net.workload.mono.toolchain.current\9.0.4\WorkloadManifest.json Install Type:              Msi Configured to use loose manifests when installing new manifests. Host: Version:      9.0.4 Architecture: x64 Commit:       f57e6dc747 .NET SDKs installed: 8.0.407 [C:\Program Files\dotnet\sdk] 9.0.104 [C:\Program Files\dotnet\sdk] 9.0.203 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 9.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 9.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.36 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 9.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 9.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set IDE: Microsoft Visual Studio Enterprise 2022 (64-bit) Version 17.13.6
Client	Storage	[FEATURE REQ] Azure.Storage.Blobs - Models with public constructors and setters	Library name Azure.Storage.Blobs Please describe the feature. Hi Team, It's a pity, from the perspective of a developer writing unit tests, that I can not (easily) construct many of the model types in the SDK. Noting that:  Some models have internal constructors (e.g., BlobDownloadResult) Most models have internal setters Model properties are not declared as virtual  Consider BlobDownloadDetails as an example. This is a broadly useful type to construct, with no hidden behavior or footguns - basically just a POCO/Model Type. It doesn't seem unreasonable to allow us to construct our own instances of this type.
Client	Azure.Core	[Insufficient Entropy CWE ID 331 for azure.core.dll]	Library name and version Azure.core 1.40.0 Query/Question We are using below packages in our application  Azure.Identity Azure.Messaging.EventGrid Azure.Security.KeyValuts.Secrets  these packages have one of the child package 'azure.core (1.40.0)' and this causing the above-mentioned Vulnerability in our project We are getting Insufficient Entropy CWE ID 331 Vulnerability in our Project This got detected in the Veracode scans for the application for the mentioned dll and in below locations https://cwe.mitre.org/data/definitions/331.html  azure.core.dll -> location `azure_core_dll.Azure.Core.Pipeline.ThreadSafeRandom` (double NextDouble()) azure.core.dll -> location `azure_core_dll.Azure.Core.DelayStrategy` (System.TimeSpan ApplyJitter(System.TimeSpan)) Environment No response
Client	Azure.Identity	[QUERY] Does InteractiveBrowserCredential in Azure SDK for .NET support PKCE?	Library name and version Azure.Identity v1.13.2 Query/Question Does the InteractiveBrowserCredential class in the Azure SDK for .NET support PKCE? It's not mentioned anywhere in the documentation if it is supported or not. https://learn.microsoft.com/en-us/dotnet/api/azure.identity.interactivebrowsercredential?view=azure-dotnet Environment Namespace: Azure.Identity Assembly: Azure.Identity.dll Package: Azure.Identity v1.13.2 Source: InteractiveBrowserCredential.cs
Mgmt	Logic App	[BUG] LogicWorkflowCollection.CreateOrUpdateAsync does not support setting Parameters property (set to read-only)	Library name and version Logic 1.1.0 Describe the bug There is no constructor that supports setting the Parameters in the logic app data, and the Parameters field is read-only. This prevents me from being able to create logic apps that need service connections defined. https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/logic/Azure.ResourceManager.Logic/src/Generated/LogicWorkflowData.cs#L163 Expected behavior I should be able to set the Parameters property when creating/updating a logic app in Azure. Actual behavior I cannot set the Parameters property when creating/updating a logic app in Azure. Reproduction Steps Code snippet that shows in-line error b/c LogicWorkflowData.Parameters is read-only: var logicWorkflowData = new LogicWorkflowData(azureLocation) {  Definition = BinaryData.FromString(``),  Parameters = new Dictionary<string, LogicWorkflowParameterInfo>() };  ArmOperation<LogicWorkflowResource> operation = await _resourceGroupResource.GetLogicWorkflows()  .CreateOrUpdateAsync(WaitUntil.Completed, request.LogicAppId.Id, logicWorkflowData);  Environment No response
Client	Search	SynonymMapNames on SearchableField only has an internal setter	You can only get the SynonymMapNames property on the SearchableField class. Therefore the example in the docs cannot be used outside the Azure.Search.Documents project. SearchableField code snippet:         /// <summary>         /// Gets a list of names of synonym maps to associate with this field.         /// Currently, only one synonym map per field is supported.         /// </summary>         /// <remarks>         /// Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map.         /// This attribute can be changed on existing fields.         /// </remarks>         public IList<string> SynonymMapNames         {             get => _synonymMapNames;             internal set             {                 _synonymMapNames.Clear();                  if (value != null)                 {                     _synonymMapNames.AddRange(value);                 }             }         }  The example: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/search/Azure.Search.Documents/samples/Sample02_Service.md#create-an-index This line means the code cannot be compiled: new SearchableField(`Country`) { SynonymMapNames = new[] { synonymMapName }, IsFilterable = true, IsSortable = true, IsFacetable = true },  The full example // Create the index string indexName = `hotels`; SearchIndex index = new SearchIndex(indexName) {     Fields =     {         new SimpleField(`HotelId`, SearchFieldDataType.String) { IsKey = true, IsFilterable = true, IsSortable = true },         new SearchableField(`HotelName`) { IsFilterable = true, IsSortable = true },         new SearchableField(`Description`) { AnalyzerName = LexicalAnalyzerName.EnLucene },         new SearchableField(`DescriptionFr`) { AnalyzerName = LexicalAnalyzerName.FrLucene },         new SearchableField(`Tags`, collection: true) { IsFilterable = true, IsFacetable = true },         new ComplexField(`Address`)         {             Fields =             {                 new SearchableField(`StreetAddress`),                 new SearchableField(`City`) { IsFilterable = true, IsSortable = true, IsFacetable = true },                 new SearchableField(`StateProvince`) { IsFilterable = true, IsSortable = true, IsFacetable = true },                 new SearchableField(`Country`) { SynonymMapNames = new[] { synonymMapName }, IsFilterable = true, IsSortable = true, IsFacetable = true },                 new SearchableField(`PostalCode`) { IsFilterable = true, IsSortable = true, IsFacetable = true }             }         }     } };  await indexClient.CreateIndexAsync(index);
Client	Tables	[BUG] Azure Data Tables rejects Microsoft Entra authentication for CosmosDB in National Clouds	Library name and version Azure.Data.Tables 12.9.1 Describe the bug We get a RequestFailedException when authenticating to CosmosDB with AAD-based auth in Fairfax environment It looks like it may be related to the following PR where CosmosScope is hard-coded to use the public cloud endpoint. https://github.com/Azure/azure-sdk-for-net/pull/45934/files Expected behavior Using managed identity, I should be able to communicate with a CosmosDb table in Azure in all environments. Actual behavior We see the following error when authenticating to CosmosDB in Fairfax environment Azure.RequestFailedException: Request blocked by Auth Provided AAD token is intended for [https://cosmos.azure.com]. This database account accepts tokens intended for [https://nfvrpddcosmosbilling.documents.azure.us/, https://nfvrpddcosmosbilling.sql.cosmos.azure.us/, https://nfvrpddcosmosbilling.sqlx.cosmos.azure.us/, https://cosmos.azure.us]. ActivityId: 536dce0f-a4e8-49c0-aecb-bd6975ac63b2, documentdb-dotnet-sdk/2.14.0 Host/64-bit MicrosoftWindowsNT/10.0.20348.0 RequestID:536dce0f-a4e8-49c0-aecb-bd6975ac63b2 Status: 401 (Unauthorized) ErrorCode: Unauthorized Content: {`odata.error`:{`code`:`Unauthorized`,`message`:{`lang`:`en-us`,`value`:`Request blocked by Auth Provided AAD token is intended for [https://cosmos.azure.com]. This database account accepts tokens intended for [https://nfvrpddcosmosbilling.documents.azure.us/, https://nfvrpddcosmosbilling.sql.cosmos.azure.us/, https://nfvrpddcosmosbilling.sqlx.cosmos.azure.us/, https://cosmos.azure.us].\r\nActivityId: 536dce0f-a4e8-49c0-aecb-bd6975ac63b2, documentdb-dotnet-sdk/2.14.0 Host/64-bit MicrosoftWindowsNT/10.0.20348.0\nRequestID:536dce0f-a4e8-49c0-aecb-bd6975ac63b2\n`}}} Reproduction Steps This code to instantiate TableServiceClient should ideally work. We have pre-reqs of granting regionalMsiCredential the following RBAC roles:  DocumentDB Account Contributor Cosmos DB Account Reader Role Microsoft.DocumentDB/databaseAccounts/tableRoleDefinitions (following https://learn.microsoft.com/en-us/azure/cosmos-db/table/security/how-to-grant-data-plane-role-based-access?tabs=built-in-definition%2Ccsharp&pivots=azure-interface-cli)  var accountName = <storageAccountName>; var endpointSuffix = `cosmos.azure.us`; // Endpoint for Fairfax var tablestorageUri = new Uri($`https://{accountName}.table.{endpointSuffix}`); var regionalMsiCredential = new ManagedIdentityCredential(         GetRegionalMsiResourceId(),         new TokenCredentialOptions()         {             AuthorityHost = GetAzureAuthorityHost(),             IsUnsafeSupportLoggingEnabled = false  // Explicitly disable PII logging.         }); var tableServiceClient = new TableServiceClient(tablestorageUri, regionalMsiCredential)  Environment No response
Client	AI Projects	[FEATURE REQ] Allow to set Query type property while adding an IndexResource	Library name Azure.AI.Projects Please describe the feature. I'm currently using Azure.AI.Projects v1.0.0-beta.5 and adding an IndexResource. It only allows the addition of IndexConnectionId and IndexName.  Using AI Foundry, it's possible to define the query type.
Client	AI Projects	[BUG]: No serverless connection error on AIProjectClient.GetChatCompletionsClient	Library name and version Azure.AI.Projects v1.0.0-beta.5 Describe the bug projectClient.GetChatCompletionsClient() results in the following error: No connections found for 'Serverless'. At least one connection is required. Please add a new connection in the Azure AI Foundry portal by following the instructions here: https://aka.ms/azsdk/azure-ai-projects/how-to/connections-add The error does not occur when using 1.0.0-beta.3. Expected behavior Connection is found without error Actual behavior Error: No connections found for 'Serverless'. At least one connection is required. Please add a new connection in the Azure AI Foundry portal by following the instructions here: https://aka.ms/azsdk/azure-ai-projects/how-to/connections-add Reproduction Steps Follow instructions at https://microsoftlearning.github.io/mslearn-ai-studio/Instructions/02a-AI-foundry-sdk.html but use dotnet add package Azure.Identity dotnet add package Azure.AI.Projects --prerelease dotnet add package Azure.AI.Inference --prerelease  instead of dotnet add package Azure.Identity dotnet add package Azure.AI.Projects --version 1.0.0-beta.3 dotnet add package Azure.AI.Inference --version 1.0.0-beta.3  Environment No response
Client	Functions	[FEATURE REQ] ServiceBusTrigger - Options to manage backpressure / consumption rate	Library name Microsoft.Azure.WebJobs.Extensions.ServiceBus Please describe the feature. Problem: If a Function App is consuming a queue or a topic with a ServiceBusTrigger to make REST API calls to a slower service that have a rate limiter (or any other slower operation), this function will suffer backpressure without being able to control/define the rate of message consumption. The problem is even more tricky when considering the Function App horizontal scaling. Feature request: The perfect solution would be to have ServiceBusTrigger parameters that allow to define the expected consumption rate over time, to fully support the queue based load leveling pattern and control the processing cadence. Another option can be that the ServiceBusMessageActions allows us to inform that the message must be retried later so that we can propagate the `Retry-After` information received from targeted service or any other computed time. Ideally, it should not increment the number of tries, as it was not an `error`. Somthing like: DelayMessageAsync(DateTime retryAfter, bool incrementRetries) What we already tried as workaround:  maxConcurrentCalls + delays: Problem is that the maxConcurrentCalls is applied per instance, making the solution unpredictable at scale. The scaling can be blocked to 1 instance, but it makes the solution not viable if a single instance cannot reach the targeted service limits. Message scheduling: We tested a potential solution by re-queuing the message with scheduled time based on Retry-After received from targeted service. On paper, it can look great. But if the Function App is paused for some reason, when restarting, it floods the service before re-scheduling, and in our case, unfortunately, the service rate limiting was quite aggressive and blacklisting in such case. TimerTrigger: By using a TimerTrigger and reading messages with a ServiceBusReceiver we were able to create a processing cadence. But this solution is also suffering scaling issue because the trigger is only executed by one single instance, meaning that the solution is not viable if a single instance cannot reach the targeted service limits.  Note: In this backpressure scenario, it must be considered that the global processing rate over time allows the queue/topic to not permanently grow.
Client	Service Bus	[BUG] OpenTelemetry traces contain System.Threading.Tasks.TaskCanceledException	Library name and version Azure.Messaging.ServiceBus 7.18.4 Describe the bug Use case A worker continuously starts and stops processing on the ServiceBusProcessor. The async MessageHandler creates activities to trace the processing of the messages received. This creates spans in aspire dashboard / Jaeger which is wanted behaviour. Implementation Program.cs // enable experimental tracing AppContext.SetSwitch(`Azure.Experimental.EnableActivitySource`, true); // enable OTEL // this adds tracing.AddSource(`Azure.Messaging.ServiceBus.*`); builder.Services.AddMyOpenTelemetry(builder.Configuration)  Worker.cs protected override async Task ExecuteAsync(CancellationToken stoppingToken) {   while (true)   {   // start processing   await processor.StartProcessingAsync(stoppingToken);   // make sure no more messages are processed in this run   for (int i = 0; i < 10; ++i)   {       if (MessagesProcessed >= MAXMSGS)       {            break;       }       await Task.Delay(100);   }   // stop processing (give room to other threads)   await processor.StopProcessingAsync(stoppingToken);   } }  async Task MessageHandler(ProcessMessageEventArgs args) {     using (var act = _metricsClient.StartMessageReceivingActivity()) {         // processing logic here         await args.CompleteMessageAsync(args.Message);     } }  Actual behaviour The activity (ServiceBusReceiver.Receive) for effectively received messages are linked to the activity span created in the MessageHandler. (👍) The activity (ServiceBusReceiver.Receive) also appears with error: true and error.type: System.Threading.Tasks.TaskCanceledException due to the fact that the processor is stopped in the loop in ExecuteAsync. (👎) Expected behavior Since StartProcessingAsync and StopProcessingAsync operations are normal operations, I'd expect no errors/exceptions in the traces. Actual behavior cfr. `Actual behaviour` in description Reproduction Steps cfr. `Implementation` in description Environment .net 9 Microsoft Visual Studio Enterprise 2022 Version 17.12.1 VisualStudio.17.Release/17.12.1+35514.174 Installed Version: Enterprise
Client	Service Bus	[BUG] Service Bus Processor get stuck when not completing or abandoning messages with prefetch count > 0	Library name and version Azure.Messaging.ServiceBus 7.18.4 Describe the bug When the prefetch count is set to 0 and autocompletemessage is set to false, the code below works as expected. The processor will pick up the next message and continue processing. The message will eventually be unlocked and tried again later. If we set the prefetch count > 0, this does not happen. The processor gets stuck and does not pick up new messages var serviceBusClient = new ServiceBusClient(`xxx`); var processor = serviceBusClient.CreateProcessor(`topic`, `subscription`, new ServiceBusProcessorOptions() {     PrefetchCount = 1,     AutoCompleteMessages = false });  processor.ProcessMessageAsync += async args => {     var success = false;     if (success)     {         await args.CompleteMessageAsync(args.Message);     }     else     {         //We want the message to be retried when the lock expires         //So we don't complete or abandon it         Console.WriteLine($`Not completing message {args.Message.MessageId}`);     } }; Expected behavior The processor does not halt Actual behavior The processor is stuck and does no longer consume messages Reproduction Steps Set the prefetch count to > 0 Environment .NET SDK: Version:           8.0.404 Commit:            7b190310f2 Workload version:  8.0.400-manifests.2877bc3a MSBuild version:   17.11.9+a69bbaaf5 Runtime Environment: OS Name:     Mac OS X OS Version:  15.0 OS Platform: Darwin RID:         osx-x64
Client	Event Hubs	[QUERY]Does GetPartitionPropertiesAsync() have retry mechanism in its implementation?	Library name and version Azure.Messaging.EventHubs 5.11.3 Query/Question One of our customer's jobs is having the following exception when it tried to call Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPartitionPropertiesAsync(String partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken). Exception: System.TimeoutException Message: The operation did not complete within the allocated time 00:01:00 for object request2628. And the symptoms point to a massive increase in connection attempts as that happened, causing SNAT port exhaustion symptoms with 5k connections and many more failed connections, Networking team reported 'Tcp Syn out rate was quite high during the issue'. The question is does GetPartitionPropertiesAsync() have retries in its own implementation when error happens? Thanks a lot. Environment No response
Client	AI Projects	[BUG] Create Vector Store File Batch	Library name and version azure.ai.projects 1.0.0-beta.5 Describe the bug I'm adding a file to Blob Storage to include it in the agent for querying, but the method is throwing an error. Expected behavior Adding a file from Blob Storage. Actual behavior This is the error message. Invalid request. Parameter data_sources is not supported. Status: 400 (Bad Request) Content: { `error`: { `message`: `Invalid request. Parameter data_sources is not supported.`, `type`: `invalid_request_error`, `param`: null, `code`: null } } Headers: Date: Wed, 19 Mar 2025 12:28:56 GMT Connection: keep-alive Request-Context: REDACTED x-ms-response-type: REDACTED x-ms-middleware-request-id: REDACTED openai-version: REDACTED openai-organization: REDACTED X-Request-ID: REDACTED openai-processing-ms: REDACTED Strict-Transport-Security: REDACTED apim-request-id: REDACTED X-Content-Type-Options: REDACTED x-ms-region: REDACTED x-aml-cluster: REDACTED x-request-time: REDACTED Content-Type: application/json Content-Length: 171 Reproduction Steps Here is the code that is generating an error. `AgentsClient clientAgent = new AgentsClient(connectionString, new DefaultAzureCredential(options)); //Vector with blob storage file var ds = new VectorStoreDataSource( assetIdentifier: `https://blobsies.blob.core.windows.net/aivectordata/CiudadanoRUNT.pdf`, assetType: VectorStoreDataSourceAssetType.UriAsset ); var vectorStoreTask = await clientAgent.CreateVectorStoreAsync( name: `runt_blob2_vector_store` ); var vectorStoreBlob = vectorStoreTask.Value; var uploadTask = await clientAgent.CreateVectorStoreFileBatchAsync( vectorStoreId: vectorStoreBlob.Id, dataSources: new List { ds } ); ` this is a error message: Invalid request. Parameter data_sources is not supported. Status: 400 (Bad Request) Content: { `error`: { `message`: `Invalid request. Parameter data_sources is not supported.`, `type`: `invalid_request_error`, `param`: null, `code`: null } } Headers: Date: Wed, 19 Mar 2025 12:28:56 GMT Connection: keep-alive Request-Context: REDACTED x-ms-response-type: REDACTED x-ms-middleware-request-id: REDACTED openai-version: REDACTED openai-organization: REDACTED X-Request-ID: REDACTED openai-processing-ms: REDACTED Strict-Transport-Security: REDACTED apim-request-id: REDACTED X-Content-Type-Options: REDACTED x-ms-region: REDACTED x-aml-cluster: REDACTED x-request-time: REDACTED Content-Type: application/json Content-Length: 171 Environment No response
Client	Tables	[FEATURE REQ] Enable support for secondary RA storage for Tables	Library name Azure.Storage.Tables Please describe the feature. Both Blob and Queue storage clients support reading from secondary RA storage when doing retries. Table client however does not. Add support for the secondary storage for the Table storage client or make GeoRedundantReadPolicy public, so the SDK consumers can configure it manually (the same way it is in StorageClientOptions.Build() method).
Mgmt	App Services	[QUERY] Is GetWebSiteResource().GetAsync().Data.PossibleOutboundIPAddresses able to get the latest outbound ips of an Azure Function App?	Library name and version Azure.ResourceManager.AppService 1.3.0 Query/Question According to this doc: https://learn.microsoft.com/en-us/azure/azure-functions/ip-addresses?tabs=portal#find-outbound-ip-addresses, the outbound ip address will be changed in some conditions (scale). Will the GetWebSiteResource().GetAsync().Data.PossibleOutboundIPAddresses be able to get the latest outbound ips of an Azure Function App, if the ip address are changed? Thanks! Environment No response
Mgmt	Notification Hub	[BUG] `Invalid URI: The format of the URI could not be determined.` Exception. Azure.ResourceManager.NotificationHubs 1.1.0	Library name and version Azure.ResourceManager.NotificationHubs 1.1.0 Describe the bug Hi, I am trying to update the registration ttl on my notification hub. I saw from various online sources that this is only available through this SDK or via the REST API. I tried using the sdk and encountered the below error Request notificationHub.Update(new NotificationHubPatch(notificationHub.Data.Location)                         {                             RegistrationTtl = timespan,                         });  Response {   `Status`: 500,   `Errors`: {     `Error`: [       `Invalid URI: The format of the URI could not be determined.`     ]   } }  Expected behavior Update the registration ttl on the notification hub Actual behavior Exception thrown {   `Status`: 500,   `Errors`: {     `Error`: [       `Invalid URI: The format of the URI could not be determined.`     ]   } }  Reproduction Steps notificationHub.Update(new NotificationHubPatch(notificationHub.Data.Location)                         {                             RegistrationTtl = timespan,                         });  Environment Net8 on windows 11
Client	Service Bus	[QUERY] Azure ServiceBus: Completing messages from another thread	Library name and version Azure.Messaging.ServiceBus 7.10.0 Query/Question Hi We have a scenario where we process tracking related messages from a queue and currently have different issues like race conditions (when having multiple instances) and running out of sql handles. Each message is a part of a longer `chain` of messages that uses the same transaction id (throughout the system), and we update the status of a single unique record in the database for each message with the same transaction id. We usually have around 1 million messages / day. We're experimenting with using a session-enabled queue instead and storing messages for a specific sessionId in memory until they are `old enough` (usually all messages are received within a few seconds), and then process the entire batch at once within the lock duration. This would guarantee it works across instances since a session is locked for all clients and greatly reduce the database traffic (se we can e.g. replace 15 connections and sql statements with a single one). However we just ran into trouble since it seems we cannot commit the message from another thread. We used a ServiceBusSessionProcesser, but that required us to complete the message directly in the message handler. Same limitation seems to be present of using a ServiceBusTrigger in a Function App, the completeMessageAsync() call must be made from the tread that received the message. Is there any `best practice` for a situation like this or is it completely out of the question to complete a message `later in time` (but within the lock duration) from another thread? Part from the completeMessageAsync issue call we're gotten pretty good performance (good enough, ~400ms/s) - but perhaps we need to rethink our architecture... Demo Code using Azure.Messaging.ServiceBus; using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.Linq; using System.Threading.Tasks; using System.Timers;  namespace ServiceBus.DLQ.Reader {    public class Demo     {         public static async Task Main(string[] args)         {             DempoSessionProcessReader reader = new DempoSessionProcessReader(                 new ServiceBusClient(`Endpoint=sb://*****.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=*****`), `mikes.test.queue.session`);              try             {                 //Create 10 processors with 10 concurrent sessions, prefetch 10 messages and set the session timeout to 2s.                 //Do not autocomplete the message                 await reader.CreateSessionProcessors(10, 10, 10, 2, false);                  //To stop!                 Console.ReadKey();                 return;              }             catch (Exception ex)             {             }         }     }      /// <summary>     /// A class for grouping all messages for a particula session.     /// The timestamp is to keep track of when to start processing them (persist)     /// </summary>     public class GroupedSession     {         public DateTime Timestamp { get; set; } //When this was created (i.e. when the first message for a message was added         public List<ProcessSessionMessageEventArgs> Messages { get; set; }          public GroupedSession()         {          }     }     public class DempoSessionProcessReader     {         List<ServiceBusSessionProcessor> processorList =new List<ServiceBusSessionProcessor>();         List<Guid> guids = new List<Guid>();         public ServiceBusClient _client;         public string Queue { get; set; }         private static bool _automcomplete = false;          /// <summary>         /// A list of messages with the sessionId as the key         /// </summary>         public static IDictionary<string, GroupedSession> _messages = new Dictionary<string, GroupedSession>();         static object _lock = new object();         private delegate void FlowHandlerDelegate(string sessionId, ProcessSessionMessageEventArgs[] messages);          static Timer _timer = new Timer();          public DempoSessionProcessReader(ServiceBusClient client, string queue)         {             _client = client;              Queue = queue;              //Generate some guids for testing purposes which we can use when preloading the queue with messages             for(int i=0;i<1000;i++)                 guids.Add(Guid.NewGuid());              //Our timer that continuously checks the list of received messages (grouped by sessionId)              _timer.Elapsed += ProcessMessageTimerTick;             _timer.Interval = 2000;             _timer.Enabled = true;             _timer.Start();         }          /// <summary>         /// Creates one or more ServiceBusSessionProcessor instances         /// </summary>         /// <param name=`numberOfProcesses`>Number of processor instances</param>         /// <param name=`concurrentSessionsPerProcessor`>Number of concurrent sessions per processor</param>         /// <param name=`prefetchCount`>Prefetch count (default = 1)</param>         /// <param name=`sessionTimeout`>Session timeout in seconds</param>         /// <param name=`autocompleteMessage`>Should the messages handler auto-complete the message?</param>         /// <returns></returns>         public async Task CreateSessionProcessors(int numberOfProcesses, int concurrentSessionsPerProcessor, int prefetchCount, int sessionTimeout, bool autocompleteMessage)         {             ServiceBusSessionProcessor processor = null!;              for (int i=0;i<numberOfProcesses;i++)             {                 _automcomplete = autocompleteMessage;                  processor = _client.CreateSessionProcessor(`mikes.test.queue.session`, new ServiceBusSessionProcessorOptions()                 {                     ReceiveMode = ServiceBusReceiveMode.PeekLock,                     PrefetchCount = prefetchCount > 0 ? prefetchCount : 1,                     AutoCompleteMessages = autocompleteMessage,                     SessionIdleTimeout = TimeSpan.FromSeconds(sessionTimeout),                     MaxConcurrentSessions = concurrentSessionsPerProcessor                 });                  processor.ProcessMessageAsync += MessageHandler;                 processor.ProcessErrorAsync += ErrorHandler;                  processorList.Add(processor);             }              for (int i = 0; i < numberOfProcesses; i++) {                 await processorList[i].StartProcessingAsync();             }         }          Task ErrorHandler(ProcessErrorEventArgs args)         {             Console.WriteLine(args.Exception);             return Task.CompletedTask;         }          /// <summary>         /// The message handler adds each message to a dictionary with the sessionId as a key         /// </summary>         /// <param name=`args`></param>         /// <returns></returns>         async Task MessageHandler(ProcessSessionMessageEventArgs args)         {             string sessionId = args.Message.SessionId;              lock (_lock)             {                 if (!_messages.ContainsKey(sessionId))                     _messages.Add(sessionId, new GroupedSession()                      {                          Timestamp = DateTime.Now,                         Messages = new List<ProcessSessionMessageEventArgs>() { args }                     });                 else                     _messages[sessionId].Messages.Add(args);             }              await Task.CompletedTask;         }          /// <summary>         /// Our timer handler that checks the list for sessions that are ready to be processed (persisted)         /// </summary>         /// <param name=`source`></param>         /// <param name=`e`></param>         private void ProcessMessageTimerTick(object source, ElapsedEventArgs e)         {             //Loop over all session Id's and see if any of them are older than 5 seconds             //In that case, remove it from the dictionary, process/persist them and them complete the messages             for (int i = 0; i < _messages.Count; i++) {                 if(_messages.Count > i)                 {                     if (_messages.ElementAt(i).Value.Timestamp.AddSeconds(5) < DateTime.Now)                     {                         lock (_lock)                         {                             string sessionId = _messages.ElementAt(i).Key;                             ProcessSessionMessageEventArgs[] array = new ProcessSessionMessageEventArgs[_messages[sessionId].Messages.Count];                             _messages[sessionId].Messages.CopyTo(array, 0); //we could decorate it as `processed` as well and have another background thread take care of the cleaning                             Array.Sort(array);                             //InsertIntoDatabase(...)                             CompleteMessageList(array).GetAwaiter().GetResult(); //Not allowed to complete here unfortunately :/                              _messages.Remove(sessionId);                         }                     }                 }             }         }          /// <summary>         /// Complets a list of messages         /// </summary>         /// <param name=`messages`>List of ProcessSessionMessageEventArgs that was received by the ServiceBusSessionProcessor handler</param>         /// <returns></returns>         private async Task CompleteMessageList(ProcessSessionMessageEventArgs[] messages)         {             try             {                 if (!_automcomplete) //Just for testing purposes                 {                     for (int i = 0; i < messages.Length; i++)                     {                         await messages[i].CompleteMessageAsync(messages[i].Message);                     }                 }             }             catch(Exception ex)              {                 //Here we get the follow error:                 // `ServiceBusReceiver has already been closed and cannot perform the requested operation.\r\nObject name: 'ServiceBusReceiver'.`             }         }     }      /// <summary>     /// A simple date sorter that sorts in ascending order     /// </summary>     public class DateSorter : IComparer     {          // Calls CaseInsensitiveComparer.Compare with the parameters reversed.         int IComparer.Compare(object x, object y)         {             DateTime a = DateTime.ParseExact((string)((ProcessSessionMessageEventArgs)x).Message.ApplicationProperties[`senttimestamp`], `yyyy-MM-dd HH:mm:ss.fff`, CultureInfo.InvariantCulture);             DateTime b = DateTime.ParseExact((string)((ProcessSessionMessageEventArgs)y).Message.ApplicationProperties[`senttimestamp`], `yyyy-MM-dd HH:mm:ss.fff`, CultureInfo.InvariantCulture);              if (a > b)                 return 1;             if (a < b)                 return -1;              return 0;         }     } }
Client	Tables	[BUG] TableClient.CreateTableIfNotExists uses wrong HTTP Verb (405)	Library name and version Azure.Data.Tables 12.10.0 Describe the bug The TableClient.CreateTableIfNotExists function returns a 405 when trying to call the Storageaccount to set up a new table client. Expected behavior The expected behaviour should be to return the table. Actual behavior Throws an exception: Azure.RequestFailedException HResult=0x80131500 Message=Service request failed. Status: 405 (The resource doesn't support specified Http Verb.) Content: ﻿ UnsupportedHttpVerbThe resource doesn't support specified Http Verb. RequestId:8ab81019-701e-0071-102e-9396a4000000 Time:2025-03-12T09:10:41.8509096Z Headers: Server: Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0 x-ms-error-code: REDACTED x-ms-request-id: 8ab81019-701e-0071-102e-9396a4000000 x-ms-version: REDACTED x-ms-client-request-id: be5ab76a-5a53-4293-88cf-6206a9ae4fbf Date: Wed, 12 Mar 2025 09:10:41 GMT Allow: REDACTED Content-Length: 243 Content-Type: application/xml Source=Azure.Data.Tables 12.10.0 StackTrace: at Azure.Data.Tables.TableServiceClient.CreateTableIfNotExists(String tableName, CancellationToken cancellationToken) at LoggingTester.Logger.AzureTableLogger..ctor(AzureTableLoggerProvider provider) in Y:\Skill\Borregaard\IntegrationPlatform\Logging\LoggingTester\LoggingTester.Logger\AzureTableLogger.cs:line 26 at LoggingTester.Logger.AzureTableLoggerProvider.CreateLogger(String categoryName) in Y:\Skill\Borregaard\IntegrationPlatform\Logging\LoggingTester\LoggingTester.Logger\AzureTableLoggerProvider.cs:line 28 at Microsoft.Extensions.Logging.LoggerFactory.CreateLoggers(String categoryName) at Microsoft.Extensions.Logging.LoggerFactory.CreateLogger(String categoryName) at Microsoft.Extensions.Logging.Logger1..ctor(ILoggerFactory factory) at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) at System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor2.VisitCallSiteMain(ServiceCallSite callSite, TArgument argument) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor2.VisitCallSite(ServiceCallSite callSite, TArgument argument) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite, RuntimeResolverContext context) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor2.VisitCallSiteMain(ServiceCallSite callSite, TArgument argument) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor2.VisitCallSite(ServiceCallSite callSite, TArgument argument) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.Resolve(ServiceCallSite callSite, ServiceProviderEngineScope scope) at Microsoft.Extensions.DependencyInjection.ServiceProvider.CreateServiceAccessor(ServiceIdentifier serviceIdentifier) at System.Collections.Concurrent.ConcurrentDictionary2.GetOrAdd(TKey key, Func2 valueFactory) at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(ServiceIdentifier serviceIdentifier, ServiceProviderEngineScope serviceProviderEngineScope) at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType) at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider, Type serviceType) at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider) at Microsoft.Extensions.Hosting.HostBuilder.<>c__DisplayClass36_0.<PopulateServiceCollection>b__2(IServiceProvider _) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor2.VisitCallSiteMain(ServiceCallSite callSite, TArgument argument) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor2.VisitCallSite(ServiceCallSite callSite, TArgument argument) at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.Resolve(ServiceCallSite callSite, ServiceProviderEngineScope scope) at Microsoft.Extensions.DependencyInjection.ServiceProvider.CreateServiceAccessor(ServiceIdentifier serviceIdentifier) at System.Collections.Concurrent.ConcurrentDictionary2.GetOrAdd(TKey key, Func`2 valueFactory) at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(ServiceIdentifier serviceIdentifier, ServiceProviderEngineScope serviceProviderEngineScope) at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType) at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider, Type serviceType) at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider) at Microsoft.Extensions.Hosting.HostBuilder.ResolveHost(IServiceProvider serviceProvider, DiagnosticListener diagnosticListener) at Microsoft.Extensions.Hosting.HostApplicationBuilder.Build() at Microsoft.AspNetCore.Builder.WebApplicationBuilder.Build() at Program.$(String[] args) in Y:\Skill\Borregaard\IntegrationPlatform\Logging\LoggingTester\LoggingTester.Web\Program.cs:line 35 Reproduction Steps Created a new Storage Account in Azure, and used this code:  public AzureTableLogger(ConfigProvider provider)  {      _tableName = provider.Options.TableNameForApp;      _tableLoggerProvider = provider;       _tableServiceClient = new TableServiceClient(new Uri(provider.Options.Url), new TableSharedKeyCredential(provider.Options.Url, provider.Options.Key));      TableItem table = _tableServiceClient.CreateTableIfNotExists(_tableName);  }  Environment Running locally through Visual Studio 17.13.3
Mgmt	Compute	[FEATURE REQ] Mockable VirtualMachineInstanceView class	Library name Azure.ResourceManager.Compute 1.8.0.0 Please describe the feature. I'm developing a tool that queries Azure virtual machine details, such as power state, which seems to be available only through Azure.ResourceManager.Compute.VirtualMachineResource.InstanceView method which returns Azure.ResourceManager.Compute.Models.VirtualMachineInstanceView object. While InstanceView and InstanceViewAsync methods are virtual and mockable, there is no way to mock VirtualMachineInstanceView class. It doesn't expose any non-internal constructors and none of the members are virtual. My tool requires extensive unit tests to ensure that it runs correctly and I'm hitting a wall with this one class and I have not found any workarounds. Please help. I have mainly worked on version 1.7, but the recent 1.8 didn't seems to bring new features related to this issue.
Client	Cognitive - Form Recognizer	[QUERY] Azure.AI.DocumentIntelligence 1.0.0 breaking changes remove ability to use Features or QueryFields with the SDK	Library name and version Azure.AI.DocumentIntelligence 1.0.0 Query/Question Azure.AI.DocumentIntelligence 1.0.0 introduces a number of changes to DocumentIntelligenceClient including a set of strongly types methods that accept AnalyzeDocumentOptions. The AnalyzeDocumentOptions class however is very restricted. It can only be constructed with a Uri source or BinaryData and both the Features collection and QueryFields collection are read-only. The only remaining method in DocumentIntelligenceClient which accepts a features or queryfields collection also requires an abstract Azure.Core.RequestContent. However the method to convert an AnalyzeDocumentOptions to RequestContent via AnalyzeDocumentOptions.ToRequestContent() is marked internal and it's unclear how to create an Azure.Core.RequestContent without re-creating all of the serialization code that is internal to this class. This seems to leave no way for a customer to provide Features or Queryfields when doing document analysis with the client SDK. Could the constructor of AnalyzeDocumentOptions be expanded to take Feature and QueryFields collections? Environment No response
Client	Azure.Identity	[BUG] OpenTelemetry keeps tracking response code 400 for /metadata/identity/oauth2/token	Library name and version Azure.Identity 1.13.2 Describe the bug Hi, We are using Azure.Identity in our dotnet core apps runnig in AKS to authenticate to various Azure Services. In general everything works but we are seeing a lot of errors with response_code=400 for /metadata/identity/oauth2/token  We were using DefaultAzureCredentials but we have resigned in favor of using a direct ManagedIdentityCredential (#48270) We are mixing together two different identities, maybe that's a reason?  user-assigned ManagedIdentity for authentication to all services except SQL Database (                    var credentials = new ManagedIdentityCredential(appConfigMi); ) Workload Idenity for SQL Server (Server=XXXXX.database.windows.net;Database=YYYYYYY;Authentication=Active Directory Workload Identity;Connect Timeout=60)  Expected behavior no 400 errors in our monitoring Actual behavior a lot of 400 calls, even though authentication seems to be working just fine Reproduction Steps . Environment No response
Mgmt	Network - Front Door	[BUG] Custom rule is not updating for WAF policy	Library name and version Azure.ResourceManager.FrontDoor 1.3.0 Describe the bug I am using following code add the custom rule. I am getting success message. But, custom rule is not being added to the policy.  Please let me know if I miss something. I see that there is no documentation for adding custom rules for the WAF policy. It would be great if it is added. Thanks in advance. // Authenticate using ClientSecretCredential var credential = new ClientSecretCredential(_configuration[`AzureAd:TenantId`], _configuration[`WAFPolicy:ClientId`], _configuration[`WAFPolicy:ClientSecret`]); var client = new ArmClient(credential);  // Get the subscription resource var subscription = client.GetSubscriptionResource(new ResourceIdentifier($`/subscriptions/{_configuration[`WAFPolicy:SubscriptionId`]}`));  // Get the resource group var resourceGroup = await subscription.GetResourceGroups().GetAsync(_configuration[`WAFPolicy:ResourceGroupName`]);  _wafPolicyResource = await resourceGroup.Value.GetFrontDoorWebApplicationFirewallPolicies().GetAsync(_configuration[`WAFPolicy:Name`]);  var ruleMatchCondition = new WebApplicationRuleMatchCondition (     WebApplicationRuleMatchVariable.RemoteAddr,     WebApplicationRuleMatchOperator.Contains,     firewallRule.Values );  var customRule = new WebApplicationCustomRule(         firewallRule.Priority,         WebApplicationRuleType.MatchRule,         new[] { ruleMatchCondition },         RuleMatchActionType.Allow     ) {     Name = `Test` };  _wafPolicyResource.Data.Rules.Add(customRule);  FrontDoorWebApplicationFirewallPolicyPatch patch = new FrontDoorWebApplicationFirewallPolicyPatch {     Tags =     {     [`key1`] = `value1`,     [`key2`] = `value2`     } }; ArmOperation<FrontDoorWebApplicationFirewallPolicyResource> lro = await _wafPolicyResource.UpdateAsync(Azure.WaitUntil.Completed, patch);  Expected behavior Custom rule should be added for the WAF policy on success response of update. Actual behavior Custom rule is not being added. Reproduction Steps // Authenticate using ClientSecretCredential var credential = new ClientSecretCredential(_configuration[`AzureAd:TenantId`], _configuration[`WAFPolicy:ClientId`], _configuration[`WAFPolicy:ClientSecret`]); var client = new ArmClient(credential);  // Get the subscription resource var subscription = client.GetSubscriptionResource(new ResourceIdentifier($`/subscriptions/{_configuration[`WAFPolicy:SubscriptionId`]}`));  // Get the resource group var resourceGroup = await subscription.GetResourceGroups().GetAsync(_configuration[`WAFPolicy:ResourceGroupName`]);  _wafPolicyResource = await resourceGroup.Value.GetFrontDoorWebApplicationFirewallPolicies().GetAsync(_configuration[`WAFPolicy:Name`]);  var ruleMatchCondition = new WebApplicationRuleMatchCondition (     WebApplicationRuleMatchVariable.RemoteAddr,     WebApplicationRuleMatchOperator.Contains,     firewallRule.Values );  var customRule = new WebApplicationCustomRule(         firewallRule.Priority,         WebApplicationRuleType.MatchRule,         new[] { ruleMatchCondition },         RuleMatchActionType.Allow     ) {     Name = `Test` };  _wafPolicyResource.Data.Rules.Add(customRule);  FrontDoorWebApplicationFirewallPolicyPatch patch = new FrontDoorWebApplicationFirewallPolicyPatch {     Tags =     {     [`key1`] = `value1`,     [`key2`] = `value2`     } }; ArmOperation<FrontDoorWebApplicationFirewallPolicyResource> lro = await _wafPolicyResource.UpdateAsync(Azure.WaitUntil.Completed, patch);  Environment OS : Windows IDE : Visual studio dotnet version : 8.0
Client	Event Hubs	[BUG] `PartitionId` is mispelled as `PartionId` in EventHubTriggerInput logs	Library name and version Azure.Messaging.EventHub 6.3.5 Describe the bug Minor issue only observed in logs: In the GetTriggerDetails function, the label for the PartitionId is mispelled as `PartionId`: { `PartionId`, context.PartitionId }, The label appears in various messages in App Insights related to the Event Hub Triggers, as well as the customDimensions field. I am opening this bug entirely because I was trying to put together a query using Partition ID as one of the columns and spent a few minutes wondering why `customDimensions.prop__PartitionId` was showing as empty. Link to the line:                azure-sdk-for-net/sdk/eventhub/Microsoft.Azure.WebJobs.Extensions.EventHubs/src/Triggers/EventHubTriggerInput.cs                    Line 86       in       6fcabfc                                                 { `PartionId`, context.PartitionId },                     Expected behavior The label should be `PartitionId`. It appears it has been mispelled for as long as this file has existed in this repo. Actual behavior Example output from App Insights, message field:  CustomDimensions field:  Reproduction Steps Enable App Insights Logging for any Azure function that uses an Event Hub trigger and the Azure.Messaging.EventHub package. Environment All environments
Client	Azure.Core	[BUG] Azure.Core depends on buggy version of System.Memory.Data	Library name and version Azure.Core 1.45.0 Describe the bug Hi, Azure.Core depends on System.Memory.Data >= 6.0.0 that has a bug in BinaryData.ToString(). When installing the latest version of Azure-relevant SDK such as Azure Storage blob SDK, that uses BinaryData type, it results in null reference exception. The mitigation is explicitly installing a newer version of System.Memory.Data, that is not developer friendly. Can you please upgrade the underlying version of System.Memory.Data to a newer version ? BTW this is the bug in BinaryData.ToString that was fixed in newer versions dotnet/runtime@a685d88 Expected behavior Not getting null reference exception from BinaryData.ToString() when BinaryData is empty Actual behavior empty BinaryData throws null reference exception Reproduction Steps Install latest version of Azure.Core. Then in your project write the following code: var binaryData = new BinaryData(new byte[0]); // throws Null ref exception var x = binaryData.ToString() Environment No response
Client	AI Model Inference	[FEATURE REQ] Allow the API version in AzureAIInferenceClientOptions to be configurable	Library name Azure.AI.Inference 1.0.0-beta.3 Please describe the feature. The Azure.AI.Inference SDK for .NET does not allow us developers to override the API version because it is based on the enum ServiceVersion which contains only the option V2024_05_01_Preview. This API version does not support to set the tool_choice value as required as can be seen in the API definition here: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/cognitiveservices/data-plane/AzureOpenAI/inference/preview/2024-05-01-preview/inference.json When trying to do so, we get the following exception: tool_choice value as required is enabled only for api versions 2024-07-01-preview and later       Status: 400 (BadRequest)       ErrorCode: BadRequest  There are many API versions newer than the version 2024-05-01-preview. Potentially, you could be using a non preview version like 2024-10-21 or simply allow us to override the version in the class AzureAIInferenceClientOptions. Right now, the only solution I found, was to clone the repo and do those changes, but that means obviously that  updating to newer versions will be a pain. Are you planning on adding the ability to override the API version soon?
Client	Service Bus	[QUERY] In what circumstances ReceiveMessagesAsync can return empty collection	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question Our application receives messages using the SDK, but we need to use a batching solution due to a dependency on a database that prefers batch inserts. We collect messages for up to 10 minutes or until a batch size is exceeded. The ServiceBus is in the Standard Tier, and the region where the ServiceBus and application are located is the same (though they are in different resource groups). To receive messages, we connect to a topic with a defined subscription. The traffic is quite low (around a few dozen messages per minute). The lock duration for the subscription is set to the default value of 1 minute. What is our scenario? An ASP.NET Core application creates a ServiceBus client using ASP.NET IoC. A client and receiver are created as singletons. builder     .AddServiceBusClientWithNamespace(productServiceBusOptions.FullyQualifiedNamespace)     .WithName(productServiceBusOptions.ConnectionName); and the receiver: services.AddKeyedSingleton(ServiceBusConstants.ReceiverBatchingStrategyKey, (provider, _) => {     var factory = provider.GetRequiredService<IAzureClientFactory<ServiceBusClient>>();     var client = factory.CreateClient(productServiceBusOptions.ConnectionName);     ServiceBusReceiverOptions options = new()     {         ReceiveMode = ServiceBusReceiveMode.PeekLock,         PrefetchCount = 0 // explanation below     };      return client.CreateReceiver(productServiceBusOptions.Topic, productServiceBusOptions.Subscription, options); }); Basic assumptions: PrefetchCount is set to 0 to avoid locking messages. This prevents messages from being moved to the DLQ. Messages are collected for 10 minutes, so we need to avoid locking messages if traffic is low. const int _maxMessagesCount = 5000; readonly TimeSpan _maxWaitTime = TimeSpan.FromSeconds(30); ... var messages = await _receiver.ReceiveMessagesAsync(_maxMessagesCount, _maxWaitTime, token); Over the course of 3 hours, 3-5 messages (depending on the region) were read, even though the queue had a few dozen messages. Surprisingly, most of the time ReceiveMessagesAsync() returned an empty collection. We noticed that the dead-letter queue received those messages, but ReceiveMessagesAsync() did not throw an exception (no exception was caught). I found that the ServiceBus metrics showed user errors during the test period (I can find anything in logs). The empty collection is returned even when ReceiveMessagesAsync() is executed multiple times, repeatedly, one after another, without a break.  What could be the reason that this method returns 0 messages (in my tests on a different ServiceBus, it returns 30-80 messages each time)? Is it possible to add logging to the ServiceBus receiver to get more detailed logs on why messages were moved to the DLQ? Additional question for the future: When prefetch is set to a value greater than zero, when exactly does the background process start prefetching messages? Is it right after the instance is created, after the first call to ReceiveMessagesAsync(), or is there a different solution for this? According to the documentation, this locks messages, so how can we prevent lock expiration when ReceiveMessagesAsync() is not executed immediately?  Environment It will be hard to get because this is asp.net core app hosted on an AppService and I have no access to check details. .Net 8.0 IDE - Rider or VS 17.13.1
Client	Search	Azure.Search.Documents.SearchOptions should allow to SET the `Select` property	We are working on a solution to backup a large index. To simplify the backup, we are looking for option to select specific fields in the index. We use the SearchClient from sdk. The SearchClient needs the SearchOptions to provide the filter criteria. var searchOptions = new SearchOptions() {     SearchMode = SearchMode.All,     Size = options.Value.SearchOptionsSize,     Filter = `CreatedDateTime ge ` + queryStartTime + ` and CreatedDateTime le ` + queryEndTime };  Response<SearchResults<SearchDocument>> response = await searchClient.SearchAsync<SearchDocument>(`*`, searchOptions, cancellationToken);   The SearchOptions has the property `Select`, but doesnt allow to set it.   /// <summary>  /// The list of fields to retrieve.  If unspecified, all fields marked  /// as retrievable in the schema are included.  /// </summary>  public IList<string> Select { get; internal set; } = new List<string>();  The same property is allowed to be set, if we make Http Calls directly instead of the SearchClient. It would be very helpful if this option is available in SearchClient
Client	Extensions	[BUG] ClientFactory with TestServer cannot build a client from a configsection	Library name and version Azure.Messaging.ServiceBus 7.18.4 Describe the bug I'm trying to build an integration test and add settings to a WebHostBuilder. _factory = new WebApplicationFactory<Program>().         WithWebHostBuilder(config =>         {             config.UseSettings(`ServiceBusConnection:fullyQualifiedNamespace`, uriFromTestContainers);             // other params         });  ServiceBus client is setup with the ServiceBusConnection config section. services.AddAzureClients(builder => {      builder.AddServiceBusClient(configuration.GetSection(`ServiceBusConnection`); }  When resolving the client, it fails. The issue is that at runtime the configuration section is provided by CommandLineConfigurationProvider and it seems this provider always return a an empty value for the section instead of just being null.  So the following code fails because the condition evaluate to true                azure-sdk-for-net/sdk/extensions/Microsoft.Extensions.Azure/src/Internal/ClientFactory.cs                   Lines 33 to 42       in       c1b2d46                                                 if (configuration is IConfigurationSection section && section.Value != null)                                           {                                               var connectionString = section.Value;                                               configuration = new ConfigurationBuilder()                                                   .AddInMemoryCollection(new[]                                                   {                                                       new KeyValuePair<string, string>(ConnectionStringParameterName, connectionString)                                                   })                                                   .Build();                                           }                     This works well outside a test fixture when the configuration is for example provided with env vars or appsettings.json Would it be possible to test that the value is not empty or that section.GetChildren() is empty ? Expected behavior The client is created from the configuration section. Actual behavior It fails complaining about string empty not a valid connection string Reproduction Steps Describe above Environment No response
Client	Service Bus	Would be nice to clarify what `idle` really means in the context of AutoDeleteOnIdle	Type of issue Missing information Description Do we define `idle` as: there is a connection to the subscription but no messages are processed for a given Timespan or there is no connection to the subscription at all for a given Timespan? Thank you in advance for your consideration. Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.administration.createsubscriptionoptions.autodeleteonidle?view=azure-dotnet&devlangs=csharp&f1url=%3FappId%3DDev17IDEF1%26l%3DEN-US%26k%3Dk(Azure.Messaging.ServiceBus.Administration.CreateSubscriptionOptions.AutoDeleteOnIdle)%3Bk(DevLang-csharp)%26rd%3Dtrue Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.Messaging.ServiceBus.Administration/CreateSubscriptionOptions.xml Document Version Independent Id 03691ef7-b699-381b-585c-92b61c38bd26 Article author @azure-sdk Metadata  ID: 9c7f75c4-5827-2fbe-94f6-cfdac60ec93c PlatformId: 5f2c0d68-8a56-8fb5-dec4-fb06d43ce2e3 Service: azure
Client	Azure.Identity	[BUG] Multiple Scopes for `AzureCliCredential` not supported	Library name and version Azure.Identity 1.13.2 Describe the bug Hey team. The AzureCliCredential authentication differs from ManagedIdentity authentication. This only works when deployed to Azure using Managed Identity, obviously not locally, because we're using ManagedIdentityCredential. var credential = new ChainedTokenCredential(                 new ManagedIdentityCredential()); string[] scopes = [`https://graph.microsoft.com/.default`, `Mail.Read`]; graphServiceClient = new GraphServiceClient(credential, scopes);  var result = await graphServiceClient.Users[userId]                 .Messages[emailId]                 .GetAsync(); Snipped simplified But now the problem is that below code should work locally, but does not work. Azure CLI does not seem to know how to use multiple scopes. var credential = new ChainedTokenCredential(                 new AzureCliCredential()); string[] scopes = [`https://graph.microsoft.com/.default`, `Mail.Read`]; graphServiceClient = new GraphServiceClient(credential, scopes);  var result = await graphServiceClient.Users[userId]                 .Messages[emailId]                 .GetAsync(); Snipped simplified The exception is: Exception: Azure.Identity.AuthenticationFailedException: The ChainedTokenCredential failed due to an unhandled exception: AzureCliCredential authentication failed: To convert to a resource string the specified array must be exactly length 1 (Parameter 'scopes') ---> Azure.Identity.AuthenticationFailedException: AzureCliCredential authentication failed: To convert to a resource string the specified array must be exactly length 1 (Parameter 'scopes') ---> System.ArgumentException: To convert to a resource string the specified array must be exactly length 1 (Parameter 'scopes')     at Azure.Identity.ScopeUtilities.ScopesToResource(String[] scopes)     at Azure.Identity.AzureCliCredential.RequestCliAccessTokenAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)     at Azure.Identity.AzureCliCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)  This implementation difference leads to this code working on Azure, but not locally. It may be very big blocker, if this would prevent developers from using Managed Identity, because it's breaking local development. Expected behavior The AzureCliCredential should support multiple scopes and behave at least closely to how ManagedIdentity works. Possible use cases that need this are for example (as shown in the snippets) accessing MS Graph using explicit scopes. Actual behavior AzureCliCredential throws an exception. Exception: Azure.Identity.AuthenticationFailedException: The ChainedTokenCredential failed due to an unhandled exception: AzureCliCredential authentication failed: To convert to a resource string the specified array must be exactly length 1 (Parameter 'scopes') ---> Azure.Identity.AuthenticationFailedException: AzureCliCredential authentication failed: To convert to a resource string the specified array must be exactly length 1 (Parameter 'scopes') ---> System.ArgumentException: To convert to a resource string the specified array must be exactly length 1 (Parameter 'scopes')     at Azure.Identity.ScopeUtilities.ScopesToResource(String[] scopes)     at Azure.Identity.AzureCliCredential.RequestCliAccessTokenAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)     at Azure.Identity.AzureCliCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)  Reproduction Steps var credential = new ChainedTokenCredential(                 new AzureCliCredential()); string[] scopes = [`https://graph.microsoft.com/.default`, `Mail.Read`]; graphServiceClient = new GraphServiceClient(credential, scopes);  var result = await graphServiceClient.Users[userId]                 .Messages[emailId]                 .GetAsync(); Environment .NET SDK: Version:           9.0.102 Commit:            cb83cd4923 Workload version:  9.0.100-manifests.43af17c7 MSBuild version:   17.12.18+ed8c6aec5
Client	KeyVault	[QUERY] Azure.Security.KeyVault.Secrets - latest Package uses outdated System.Text.Json 6.0.10	Library name and version Azure.Security.KeyVault.Secrets Query/Question Mend reports System.Text.Json having a known vulnerability [CVE-2024-43485]. Can you please update to the latest version? Environment No response
Client	Service Bus	[BUG] ServiceBusReceivedMessage.Body.ToString() throws System.ArgumentNullException: Value cannot be null. (Parameter 'bytes')	Library name and version Azure.Messaging.ServiceBus 7.18.3 Describe the bug Using Azure.Messaging.ServiceBus version 7.18.3, a System.ArgumentNullException: Value cannot be null. (Parameter 'bytes')exception is thrown when calling .Body.ToString(); This however works fine if using Azure.Messaging.ServiceBus version 7.18.1. Expected behavior I would expect that even if the message body is null on a ServiceBusReceivedMessage, it would not throw when attempting to get the message body using Body.ToString(). Actual behavior It throws an exception which means we will have to write a method to handle and catch the exception to update our code. Reproduction Steps To duplicate this, create a new MSTest project and add a reference to Azure.Messaging.ServiceBus version 7.18.1. Paste in the following test and run it to confirm it works fine: using Azure.Messaging.ServiceBus;  namespace ServiceBusMessageBodyTestNew {     [TestClass]     public sealed class Test1     {         [TestMethod]         public void Body_ToString_ShouldNotThrow()         {             // Arrange             var message = ServiceBusModelFactory.ServiceBusReceivedMessage(body: null);             var expected = string.Empty;              // Act             var actual = message.Body.ToString();              // Assert             Assert.AreEqual(expected, actual);         }     } } Create a second MSTest project and add a reference to Azure.Messaging.ServiceBus version 7.18.3. Paste the same code into a new test and you will receive the following error:  Body_ToString_ShouldNotThrow    Source: Test1.cs line 9    Duration: 68 ms    Message:  Test method ServiceBusMessageBodyTestNew.Test1.Body_ToString_ShouldNotThrow threw exception:  System.ArgumentNullException: Value cannot be null. (Parameter 'bytes')    Stack Trace:  ArgumentNullException.Throw(String paramName) Encoding.GetString(Byte* bytes, Int32 byteCount) BinaryData.ToString() Test1.Body_ToString_ShouldNotThrow() line 16 RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor) MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)  Environment Using Visual Studio 2022 and OS is Windows 11.
Client	Cognitive - Form Recognizer	Convert JSON to AnalyzeResult	Azure.AI.FormRecognizer 4.1.0 Query/Question Will there ever be more support to mock an AnalyzeResult object from a JSON response obtained from the Document Intelligence Studio? I can use DocumentAnalysisModelFactory.AnalyzeResult to create a mock object but there is no support for populating DocumentTable etc.? For testing purposes we should have support for creating an exact replica of the endpoint response surely? Environment Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\9.0.101\ .NET SDK: Version:           9.0.101 Commit:            eedb237549 Workload version:  9.0.100-manifests.4a280210 MSBuild version:   17.12.12+1cce77968 Visual Studio Version 17.12.3
Client	Service Bus	[BUG] ServiceBusAdministrationClient ignores Port	Library name and version Azure.Messaging.ServiceBus 7.18.3 Describe the bug Hi there, I'm trying to do some Integration tests with ServiceBus and want to use the ServiceBusAdministrationClient to set up my testing environment. When using following ConnectionString every time I will end up with port 80. `DefaultEndpointsProtocol=http;Endpoint=sb://127.0.0.1:5672;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true;`  Actually it should use port 5672, but every time when I use the ServiceBusAdministrationClient I get the following exception: System.AggregateException: Retry failed after 4 tries. Retry settings can be adjusted in ClientOptions.Retry or by configuring a custom retry policy in ClientOptions.RetryPolicy. (Connection refused (127.0.0.1:80)) (Connection refused (127.0.0.1:80)) (Connection refused (127.0.0.1:80)) (Connection refused (127.0.0.1:80))  ---> Azure.RequestFailedException: Connection refused (127.0.0.1:80)  ---> System.Net.Http.HttpRequestException: Connection refused (127.0.0.1:80)  ---> System.Net.Sockets.SocketException (61): Connection refused    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource.GetResult(Int16 token)    at System.Net.Sockets.Socket.<ConnectAsync>g__WaitForConnectWithCancellation|285_0(AwaitableSocketAsyncEventArgs saea, ValueTask connectTask, CancellationToken cancellationToken)    at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken)    --- End of inner exception stack trace --- ...  I tried to find the bug myself and I think I found it, but actually I have no glue what will be affected when changing something here. I think the problem is _fullyQualifiedNamespace only uses the Endpoint.Host. For a namespace this is okay, but this namespace is used in HttpRequestAndResponse to parse the port from. This in combination is likely the bug. I linked both lines below. https://github.com/Azure/azure-sdk-for-net/blob/c83c5e5423e5e9706c959f94682ee1ebf0631c97/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/ServiceBusAdministrationClient.cs#L90C13-L90C81 https://github.com/Azure/azure-sdk-for-net/blob/6229ca62f28b438dc5b8cfe5660040c64a8b720a/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/HttpRequestAndResponse.cs#L43C13-L43C55 Thank you and hopefully it can be fixed Sincerely snailcatcher Expected behavior ServiceBusAdministrationClient use the port specified in the ConnectionString Actual behavior ServiceBusAdministrationClient ignores the port specified in the ConnectionString Reproduction Steps var sb = new ServiceBusAdministrationClient(`DefaultEndpointsProtocol=http;Endpoint=sb://127.0.0.1:5672;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true;`); await sb.TopicExistsAsync(`TOPIC_NAME`, cancellationToken);  Environment dotnet --info .NET SDK: Version:           9.0.102 Commit:            cb83cd4923 Workload version:  9.0.100-manifests.43af17c7 MSBuild version:   17.12.18+ed8c6aec5 Runtime Environment: OS Name:     Mac OS X OS Version:  15.2 OS Platform: Darwin RID:         osx-arm64 Base Path:   /usr/local/share/dotnet/sdk/9.0.102/ .NET workloads installed: There are no installed workloads to display. Configured to use loose manifests when installing new manifests. Host: Version:      9.0.1 Architecture: arm64 Commit:       c8acea2262 .NET SDKs installed: 8.0.405 [/usr/local/share/dotnet/sdk] 9.0.102 [/usr/local/share/dotnet/sdk] .NET runtimes installed: Microsoft.AspNetCore.App 8.0.12 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 9.0.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.25 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.26 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.27 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.28 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.29 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.30 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.31 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.32 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.14 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.15 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.16 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.17 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.18 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.19 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.20 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.2 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.3 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.4 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.7 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.8 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.10 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.11 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.12 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 9.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 9.0.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Other architectures found: x64   [/usr/local/share/dotnet/x64] registered at [/etc/dotnet/install_location_x64] Environment variables: Not set global.json file: Not found Learn more: https://aka.ms/dotnet/info Download .NET: https://aka.ms/dotnet/download
Client	Search	[BUG] [VectorSearchField] attributes specifies a ReadOnlyMemory<float> for vectors but fieldBuilder.Build(typeof()) creates this as a complex object.	Library name and version Azure.Search.Documents 11.6.0 Describe the bug When using FieldBuilder to create a new index ReadOnlyMemory will be created as a complex object instead of a vector. Specifying the vector as a float[] will cause the vector to be created correctly. The attribute documentation says however that it needs to be a ReadOnlyMemory  Expected behavior Either the attribute documentation is wrong and it needs to be an float[] or there is something wrong with FieldBuilder and the documentation is correct. I'd prefer the latter because VectorStoreRecordData from semantic kernel want it to be a ReadOnlyMemory as well and this would unify the objects. Actual behavior ReadOnlyMemory will become a complex object in azure Search.  Reproduction Steps I use the following code to create my Azure AI Search index: The VectorStoreRecordData attribute is for SemanticKernel.     public static async Task CreateAiSearchVectorIndex(this WebApplication app)     {         // Retrieve the Azure AI search settings from the service provider         var searchSettings = app.Services.GetRequiredService<IOptions<AzureAiSearchSettings>>().Value;          // Create a search index client using either a default credential or an API key         var searchIndexClient = searchSettings.ApiKey.IsNullOrEmpty()             ? new SearchIndexClient(searchSettings.AiSearchUri, new DefaultAzureCredential())             : new SearchIndexClient(searchSettings.AiSearchUri, new AzureKeyCredential(searchSettings.ApiKey));          // Build the search fields for the index         var fieldBuilder = new FieldBuilder();         var searchFields = fieldBuilder.Build(typeof(AzureDocumentChunkVectorStoreRecord));          // Create a new search index with the specified fields         var searchIndex = new SearchIndex(searchSettings.DocumentIndexName, searchFields)         {             VectorSearch = new VectorSearch             {                 Algorithms =                 {                     new HnswAlgorithmConfiguration(`vector-config`)                 },                 Profiles =                 {                     new VectorSearchProfile(`vector-profile`, `vector-config`)                 }             }         };                  // Create or update the search index asynchronously         await searchIndexClient.CreateOrUpdateIndexAsync(searchIndex);     } /// <summary> ///     Represents a record for storing document chunks in Azure with vector data. /// </summary> public record AzureDocumentChunkVectorStoreRecord {     /// <summary>     ///     Gets or initializes the unique identifier for the chunk.     /// </summary>     [VectorStoreRecordKey]     [SimpleField(IsKey = true, IsFilterable = true, IsSortable = true)]     public required string ChunkId { get; init; }      /// <summary>     ///     Gets or initializes the unique identifier for the document.     /// </summary>     [VectorStoreRecordData]     [SearchableField(IsFilterable = true, IsSortable = true)]     public required string DocumentId { get; init; }      /// <summary>     ///     Gets or initializes the unique identifier for the tenant.     /// </summary>     [VectorStoreRecordData]     [SearchableField(IsFilterable = true, IsSortable = true)]     public required string TenantId { get; init; }      /// <summary>     ///     Gets or initializes the unique identifier for the policy analysis.     /// </summary>     [VectorStoreRecordData]     [SearchableField(IsFilterable = true, IsSortable = true)]     public required string PolicyAnalysisId { get; init; }      /// <summary>     ///     Gets or initializes the content of the chunk.     /// </summary>     [VectorStoreRecordData]     [SearchableField(IsFilterable = true)]     public required string Chunk { get; init; }      /// <summary>     ///     Gets or initializes the header of the chunk.     /// </summary>     [VectorStoreRecordData]     [SearchableField(IsFilterable = true)]     public required string ChunkHeader { get; init; }      /// <summary>     ///     Gets or sets the page number of the chunk.     /// </summary>     [VectorStoreRecordData]     [SimpleField(IsFilterable = true, IsSortable = true)]     public required int Page { get; init; }      /// <summary>     ///     Gets or sets the vector representation of the chunk with a dimension of 3072.     /// </summary>     [VectorStoreRecordVector(3072)]     [VectorSearchField(VectorSearchDimensions = 3072, VectorSearchProfileName = `vector-profile`)]     public required ReadOnlyMemory<float> ChunkVector { get; init; } } Environment .NET SDK:  Version:           9.0.102  Commit:            cb83cd4923  Workload version:  9.0.100-manifests.d67a1f3e  MSBuild version:   17.12.18+ed8c6aec5  Runtime Environment:  OS Name:     Mac OS X  OS Version:  15.3  OS Platform: Darwin  RID:         osx-arm64  Base Path:   /usr/local/share/dotnet/sdk/9.0.102/  .NET workloads installed:  [aspire]    Installation Source: SDK 9.0.100    Manifest Version:    8.2.2/8.0.100    Manifest Path:       /usr/local/share/dotnet/sdk-manifests/8.0.100/microsoft.net.sdk.aspire/8.2.2/WorkloadManifest.json    Install Type:        FileBased  Configured to use loose manifests when installing new manifests.  Host:   Version:      9.0.1   Architecture: arm64   Commit:       c8acea2262  .NET SDKs installed:   8.0.100 [/usr/local/share/dotnet/sdk]   8.0.204 [/usr/local/share/dotnet/sdk]   9.0.100 [/usr/local/share/dotnet/sdk]   9.0.102 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.4 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 9.0.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.4 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 9.0.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]  Other architectures found:   x64   [/usr/local/share/dotnet/x64]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Client	Cognitive - Form Recognizer	[Question] AnalyzeResult compatibility between FormRecognizer and DocumentIntelligence	I aim to support all versions of the service in some application. Right now, only version 3.* is supported, and the rest of the code works with the AnalyzeResult from the Azure.AI.FormRecognizer package. As I add support for version 4.*, I can't directly use the AnalyzeResult from Azure.AI.DocumentIntelligence. Is there a way to map between the two, or should I create an adapter? edit: I forgot to mention that I'm referring to the .NET SDK.
Mgmt	Network	[FEATURE REQ] LoadBalancer management	Library name Azure.ResourceManager.Network Please describe the feature. We are currently still using Microsoft.Azure.Management.Fluent (which is deprecated). This is because we are not able to switch over to Azure.ResourceManager.Network, this currently only seems to have an API of getting what is currently deployed but no way to configure it. We specifically need to be able to add/update/delete loadbalancer rules and healthprobes.
Mgmt	App Services	[QUERY] Is there a Get for FTPS endpoint of a WebSiteResource?	Library name and version Azure.ResourceManage.AppService 1.3.0.0 Query/Question I'm trying to get the FTPS endpoint from an Azure WebApp, like available in Azure Portal:  I already have the necessary configuration settings for FTP Basic Auth Publishing:  I know one can get it with Azure CLI: az webapp deployment list-publishing-profiles --name SomeWebApp--resource-group SomeResourceGroup But having it directly from the Azure SDK library would be most optimal. I appreciate your help! Best regards, Wesley Environment No response
Client	Functions	[FEATURE REQ] Session-enabled topic support with Batching	Library name Azure.Messaging.ServiceBus Please describe the feature. We consume jobs from 1000 session-id in a session-enabled topic. We want to activate batching while consuming those jobs to minimize the number of function execution. The state as is works, but as soon as we activate the batching, one service plan instance will only consume one session-id. Therefore, in our case, the 4 instances each batch one session-id and the 996 other session-ids accumulate jobs until they reach the DLQ delay. A service plan instance should be able to process batches of jobs for multiple session-ids.
Client	Service Bus	[QUERY] Processor stop flow and time constraints.	Library name and version Azure.Messaging.ServiceBus 7.17.0 Query/Question This question pertains to application lifecycle and message processing.  I'll do my best to lay out some context. I have an application with an api that receives requests to run background jobs.  the api validates the request, adds some system metadata, and queues the job via an azure ServiceBus queue. a BackgroundService /  IHostedService subscribes to this queue, pulls messages off, and processes them via a ServiceBusProcessor. this application is hosted in Azure Container Apps. when the application undergoes a scaling operation, particularly a scale-in, my application receives a request (SIGTERM) to gracefully shut down.  as a result, StopAsync is invoked on my IHostedService.  it's here that expected behavior gets a little murky for me.  The cancellation token provided as an argument to StopAsync represents (via docs) when graceful shutdown is canceled and will now be forced.  I would expect this to occur when the shutdown timeout has elapsed.  I'm aware there are a few layers here.  aspnetcore's generic host has its ShutdownTimeout and ACA has one as well.  fwiw I've cranked both of these to an hour (ACA max) while troubleshooting this. during BackgroundService.StopAsync, I indicate the ServiceBusProcessor should stop processing messages: public override async Task StopAsync(CancellationToken cancellationToken) {     await _processor.StopProcessingAsync(cancellationToken); } according to the docs for StopProcessingAsync - it will stop receiving new messages but allow messages currently being processed to complete - as long as they complete within message TryTimeout.  this makes sense, except that's not the behavior I'm seeing. what I am currently observing is, when StopProcessingAsync is invoked, cancellation is requested of any messages currently being processed.  am I just misunderstanding the docs?  I would expect cancellation would not be requested of message processors until cancellation was requested via the token provided by StopAsync indicating we are no longer gracefully shutting down. I'd be happy to provide a console app to reproduce this if that'd help illustrate the point.  a simple console app with a `long` Task.Delay(...) in ProcessMessageAsync will do the trick. I'm fully ready to concede that I'm misunderstanding something.  or, maybe there really is a bug here.  either way, thanks for taking a look! Environment No response
Mgmt	App Services	[FEATURE REQ] Add InboundIpAddress data to WebSiteData	Library name Azure.ResourceManager.AppService v1.3.0 Please describe the feature. Currently public partial class WebSiteData : TrackedResourceData has some of the properties from a WebApp Resource JSON, but not all. I would like to request that the InboundIpAddress data would be added to the WebSiteData class.  This helps developers to use the inbound ip address to set new custom domains using azure-sdk-for-net.
Client	Communication - Email	[BUG] MSAL information loged when Dependcy injecting EmailClient	Library name and version Azure.Communication.Email v1.01 Describe the bug Injecting the EmailClient causes logs from MSAL for graph packages to be logged. Expected behavior MSAL logs from other graph packages should not be logged. Actual behavior MSAL logs are logged. [2025-01-20T20:20:35.882Z] False MSAL 4.66.2.0 MSAL.NetCore .NET 8.0.4 Microsoft Windows 10.0.22631 [2025-01-20 20:20:35Z - d6debb3b-3798-4d91-8e96-e541d41c3636] [2025-01-20T20:20:35.887Z] === Request Data === [2025-01-20T20:20:35.891Z] Authority Provided? - True [2025-01-20T20:20:35.895Z] Scopes - https://graph.microsoft.com/.default [2025-01-20T20:20:35.899Z] Extra Query Params Keys (space separated) - [2025-01-20T20:20:35.907Z] ApiId - AcquireTokenForClient [2025-01-20T20:20:35.911Z] IsConfidentialClient - True [2025-01-20T20:20:35.916Z] SendX5C - False [2025-01-20T20:20:35.922Z] LoginHint ? False [2025-01-20T20:20:35.927Z] IsBrokerConfigured - False [2025-01-20T20:20:35.932Z] HomeAccountId - False [2025-01-20T20:20:35.934Z] CorrelationId - d6debb3b-3798-4d91-8e96-e541d41c3636 [2025-01-20T20:20:35.939Z] UserAssertion set: False [2025-01-20T20:20:35.943Z] LongRunningOboCacheKey set: False [2025-01-20T20:20:35.947Z] Region configured: [2025-01-20T20:20:35.955Z] [2025-01-20T20:20:35.990Z] False MSAL 4.66.2.0 MSAL.NetCore .NET 8.0.4 Microsoft Windows 10.0.22631 [2025-01-20 20:20:35Z - d6debb3b-3798-4d91-8e96-e541d41c3636] [2025-01-20T20:20:35.994Z] [LogMetricsFromAuthResult] Cache Refresh Reason: NotApplicable [2025-01-20T20:20:35.996Z] [LogMetricsFromAuthResult] DurationInCacheInMs: 0 [2025-01-20T20:20:35.998Z] [LogMetricsFromAuthResult] DurationTotalInMs: 3 [2025-01-20T20:20:36.002Z] [LogMetricsFromAuthResult] DurationInHttpInMs: 0 [2025-01-20T20:20:36.007Z] False MSAL 4.66.2.0 MSAL.NetCore .NET 8.0.4 Microsoft Windows 10.0.22631 [2025-01-20 20:20:35Z - d6debb3b-3798-4d91-8e96-e541d41c3636] TokenEndpoint: **** [2025-01-20T20:20:36.012Z] ClientSecretCredential.GetToken succeeded. Scopes: [ https://graph.microsoft.com/.default ] ParentRequestId:  ExpiresOn: 2025-01-21T20:20:13.1153530+00:00 Reproduction Steps        services.AddAzureClients(b =>        {            b.AddEmailClient(new Uri(SharedEnvironmentVariables.CommunicationServiceEndpoint))             .WithCredential(new ChainedTokenCredential(                     new ManagedIdentityCredential(clientId: SharedEnvironmentVariables.CommunicationServiceUserAssignedClientId),                     new VisualStudioCredential()));        });      public ExceptionHandlerMiddleware(ILoggerFactory loggerFactory, EmailClient emailClient)     {         _logger = loggerFactory.CreateLogger<ExceptionHandlerMiddleware>();         _emailClient = emailClient;     }  Environment .NET 8, Azure Function AppService, Azure Function v4
Client	Azure.Identity	[QUERY] How does the in-memory cache work at 'ManagedIdentityCredential' and 'ClientCertificateCredential'	Library name and version Azure.Identity 1.13.1 Query/Question Hi, as the document:TokenCache.md said, I need to reuse the instance of `TokenCredential` to be benefit from the default in-memory cache. Vice versa, I can create a new instance of TokenCredential to disable the cache if needed. But I read some of source codes of the implementation of `ManagedIdentityCredential` and `ClientCertificateCredential` and MSAL .NET, it seems not the case. For `ManagedIdentityCredential`, it will build a ManagedIdentityApplication with `CacheOptions.EnableSharedCacheOptions`, which means  that it will share a cache in `Class level` instead of `instance level` in the implementation of MSAL(see: screenshot)  But, as for `ClientCertificateCredential`, I didn't find out such similar setting for `using a static shared cache`. It is just like the document said, the cache exist in the instance level of ClientCertificateCredential. So I have a conclusion but also a question that, does it still require to reuse the instance of `ManagedIdentityCredential` explicitly if I want the cache? (We are migrating our service from 'app authentication' to 'MSI authentication'. And there is rate limiting in IMDS. I want to know the cache of Azure.Identity and MSAL more deeply and avoid the rate limiting as posible) Environment No response
Client	Azure.Identity	[FEATURE REQ]Azure.Identity Upgrade System.Text.Json 4.7.2	Library name Azure.Identity Please describe the feature. Upgrade System.Text.Json 4.7.2 System.Text.Json 4.7.2 version is too low
Client	Service Bus	[BUG] Azure.Messaging.ServiceBus 7.18.2 contains a transitive System.Text.Json vulnerability	Library name and version Azure.Messaging.ServiceBus 7.18.2 Describe the bug Azure.Messaging.ServiceBus 7.18.2 depends on Azure.Core 1.44.0 and System.Memory.Data 6.0.0, both of which in turn depend on System.Text.Json 6.0.9 that contains a known, published vulnerability. The fix is simple, release an updated Azure.Messaging.ServiceBus 7.19.0 that takes a dependency on Azure.Core 1.44.1 and System.Memory.Data 6.0.1, both of which no longer contain the System.Text.Json vulnerability. Without this fix in place, customers need to manually take dependencies on transitive packages, and that in turn introduces more management work that should be completely unnecessary. Expected behavior Azure.Messaging.ServiceBus should have a release available for .NET 8 and .NET 9 that does not include transitive vulnerabilities. Actual behavior Azure.Messaging.ServiceBus 7.18.2 is the latest version and taking it on as a dependency means taking on transitive vulnerabilities in your project that need to be worked around until 7.19.0 is released.. Reproduction Steps Create a new C# project. Take a dependency on Azure.Messaging.ServiceBus 7.18.2. Use the NuGet Package Manager or dotnet list packages --include-transitive --vulnerable to see transitive vulnerabilities in your project. Environment Windows 11, .NET 8 or 9, Visual Studio Latest -- updated it yesterday.
Client	Functions	[BUG]	Library name and version Microsoft.Azure.WebJobs.Extensions.EventHubs 6.3.5 Describe the bug  When a consumer is set, in this case the connection is mapped from the settings (environmental varaibles from function app), but the consumer group cannot be mapped and needs to be const (compile time) Expected behavior To be able to map the consumer group same as the connection Actual behavior If the name of the consumer group variable is set, messages are not received. Reproduction Steps Add consumer group in azure portal on the hub, set an environmental variable for a consumer group with value exact like the consumer group name that was added in azure Environment No response
Client	Extensions	[BUG] Can't use named configuration with BlobClientOptions	Library name and version Azure.Storage.Blobs 12.23.0 Describe the bug Hello, I have multiple client and want to use named configuration for BlobClientOptions. I put all the configuration on my appsettings.json file. IOptions<T> does not support named configuration, so either I need to use IOptionsMonitor<T> or IOptionsSnapshot<T> to get registered options. But when I do this it throws the following exception. Can't overrided constructor use instead of providing the default value? System.MissingMethodException with message `Cannot dynamically create an instance of type 'Azure.Storage.Blobs.BlobClientOptions'. Reason: No parameterless constructor defined.`      at System.RuntimeType.ActivatorCache..ctor(RuntimeType rt)      at System.RuntimeType.CreateInstanceOfT()      at System.Activator.CreateInstance[T]()      at Microsoft.Extensions.Options.OptionsFactory`1.CreateInstance(String name)      at Microsoft.Extensions.Options.OptionsFactory`1.Create(String name)      at Microsoft.Extensions.Options.OptionsManager`1.<>c__DisplayClass5_0.<Get>b__0()      at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)      at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)      at System.Lazy`1.CreateValue()      at System.Lazy`1.get_Value()      at Microsoft.Extensions.Options.OptionsCache`1.GetOrAdd(String name, Func`1 createOptions)      at Microsoft.Extensions.Options.OptionsManager`1.Get(String name)  Expected behavior Design of BlobClientOptions should allow to dynamic create the default instance when using named configuration like ServiceBusClientOptions. Actual behavior System.MissingMethodException with message `Cannot dynamically create an instance of type 'Azure.Storage.Blobs.BlobClientOptions'. Reason: No parameterless constructor defined.` at System.RuntimeType.ActivatorCache..ctor(RuntimeType rt) at System.RuntimeType.CreateInstanceOfT() at System.Activator.CreateInstanceT at Microsoft.Extensions.Options.OptionsFactory1.CreateInstance(String name) at Microsoft.Extensions.Options.OptionsFactory1.Create(String name) at Microsoft.Extensions.Options.OptionsManager1.<>c__DisplayClass5_0.<Get>b__0() at System.Lazy1.ViaFactory(LazyThreadSafetyMode mode) at System.Lazy1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor) at System.Lazy1.CreateValue() at System.Lazy1.get_Value() at Microsoft.Extensions.Options.OptionsCache1.GetOrAdd(String name, Func1 createOptions) at Microsoft.Extensions.Options.OptionsManager1.Get(String name) Reproduction Steps // See https://aka.ms/new-console-template for more information  using Azure.Storage.Blobs; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Options;  string namedConfig = `config1`;  var builder = Host.CreateApplicationBuilder(args); builder.Services.Configure<BlobClientOptions>(namedConfig, builder.Configuration.GetSection(`config1:BlobClientOptions`));  ServiceProvider serviceProvider = builder.Services.BuildServiceProvider(); IOptionsSnapshot<BlobClientOptions> options = serviceProvider.GetRequiredService<IOptionsSnapshot<BlobClientOptions>>(); // IOptionsserviceProvider.GetRequiredService<IOptionsMonitor<BlobClientOptions>>();  options.Get(namedConfig);// ThrowException Console.WriteLine(`Hello, World!`); {   `config1`: {     `BlobClientOptions`: {       `Retry`: {         `MaxRetries`: 5,         `Mode`: `Exponential`       }     }   } } Environment No response
Client	Event Hubs	[FEATURE REQ] Alternative Redis Checkpoint Store for Azure Event Hubs .NET SDK	Library name Azure.Messaging.EventHubs.Processor Feature Description The Azure.Messaging.EventHubs.Processor library provides the EventProcessorClient class for processing Azure Event Hubs events in an Event Driven Fashion. The client class only supports Azure Blob as the checkpointing mechanism. The suggestion is that given that checkpointing in Azure Blob can be costly in terms of latency, provide the way to set alternative checkpoint stores such as redis in EventProcessorClient. The Java SDK seems to support this feature. Why not the .NET SDK also? If this feature makes sense, I will be glad to contribute.
Client	Managed Identity	[BUG]  DefaultAzureCredential does not fall back to other credential types unless ManagedIdentityCredential is disabled	Describe the bug The DefaultAzureCredential is supposed to fall back to other credential types when ManagedIdentityCredential is failed, but it doesn't. Details attempting to connect to app configuration with DefaultAzureCredential fails to fall back to other credential options. It was working fine until 21st of december. I am using an Azure VM as my dev environment This code below fails until managedIdentityCredential is disabled builder.Configuration.AddAzureAppConfiguration(options => {     options.Connect(new Uri(endpoint), new DefaultAzureCredential());   });  Error details System.TimeoutException   HResult=0x80131505   Message=The provider timed out while attempting to load.   Source=Microsoft.Extensions.Configuration.AzureAppConfiguration   StackTrace:    at Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureAppConfigurationProvider.<LoadAsync>d__31.MoveNext()    at Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureAppConfigurationProvider.Load()    at Microsoft.Extensions.Configuration.ConfigurationManager.AddSource(IConfigurationSource source)    at Microsoft.Extensions.Configuration.ConfigurationManager.Microsoft.Extensions.Configuration.IConfigurationBuilder.Add(IConfigurationSource source)    at Microsoft.Extensions.Configuration.AzureAppConfigurationExtensions.AddAzureAppConfiguration(IConfigurationBuilder configurationBuilder, Action`1 action, Boolean optional)    at Program.<Main>$(String[] args) in C:\Users\Uche\source\repos\WebApplication1\WebApplication1\Program.cs:line 23     This exception was originally thrown at this call stack:     [External Code]   Inner Exception 1: AggregateException: One or more errors occurred.   Inner Exception 2: RequestFailedException: Service request failed. Status: 403 (Forbidden)   Headers: Date: Tue, 07 Jan 2025 14:07:27 GMT Connection: keep-alive x-ms-request-id: c5da4250-739f-4f90-a58d-44a6795158a3 x-ms-client-request-id: 445a7254-fb5d-4d94-b430-3d3320919ecc x-ms-correlation-request-id: c5da4250-739f-4f90-a58d-44a6795158a3 Strict-Transport-Security: max-age=31536000; includeSubDomains Access-Control-Allow-Origin: * Content-Length: 0
Mgmt	Event Grid	[QUERY] EventGrid NameSpaceTopicEventSubscriptionData-> FilterConfiguration	Library name and version Azure.ResourceManager.EventGrid v1.1.0-beta.5 Query/Question I am attempting to create a Subscription from an azure function as part of a registration process. I've been able to accomplish all portions leading up to creating a filter for the newly created subscription (the subscription creates with no filters just fine), I am unable to find any way to create a new instance of a FiltersConfiguration, or any derived class. Could someone point me in the right direction? Small code snip below for reference NamespaceTopicEventSubscriptionData subscriptionData = new() {   EventDeliverySchema = DeliverySchema.CloudEventSchemaV10,   DeliveryConfiguration = new DeliveryConfiguration()   {       DeliveryMode = DeliveryMode.Queue,       Queue = new()       {           ReceiveLockDurationInSeconds = 60,           MaxDeliveryCount = 10,           EventTimeToLive = TimeSpan.FromDays(7),           DeadLetterDestinationWithResourceIdentity = new()           {               DeadLetterDestination = new StorageBlobDeadLetterDestination()               {                   ResourceId = subscription.GetStorageAccounts().Where(x => x.Data.Name == `tmailstorage`).First().Id,                   BlobContainerName = `deadlettered`,               },               Identity = new()               {                   IdentityType = EventSubscriptionIdentityType.SystemAssigned,               }           },       }   },   //Below is the problem line.   FiltersConfiguration = new() };  Thank you in advance! Environment Visual Studio Version : 17.12.2 Project target framework:  .Net 8.0 Project Type : Azure Function (running locally for testing)
Client	Service Bus	[BUG] Update Azure.Core in Azure.Messaging.ServiceBus	Library name and version Azure.Messaging.ServiceBus 7.18.2 Describe the bug I was wondering why Azure.Core still isn't updated in Azure.Messaging.ServiceBus? It requires >= 1.44.0 while 1.44.1 is referencing a newer version of System.Text.Json without the vulerability. Expected behavior Use a version of System.Text.Json that isn't vulnerable by updating Azure.Core Actual behavior The referenced version is not high enough Reproduction Steps Install Azure.Messaging.ServiceBus 7.18.2 Environment No response
Client	EngSys	[QUERY] This repo contains code for many libraries, isn't it better to split them up to different repos	Library name and version General Query/Question This repo is huge and contains code for many libraries. Isn't better to maintain a shared repo + a repo for each library? For example, if I am debugging a say Azure.AI.DocumentIntelligence, I shouldn't have to pull down the entire repo. Environment N/A
Client	Service Bus	Service Bus Messages Held in AMQP Buffer After Being Dequeued and processed	I am experiencing an issue with Azure Service Bus where messages are dequeued from the subscription and processed successfully by the backend application. However, for some messages, we are missing the status update. Ideally, if a message misses its status update, it should move to the Dead Letter Queue (DLQ). Instead, these messages are not moving to the DLQ and are remaining indefinitely in the AMQP buffer, causing a gradual memory increase in the application. Additionally, these messages persist beyond their Time-to-Live (TTL). Why is this not a Bug or a feature Request? We are not categorizing this as a bug at this point. Instead, we are seeking suggestions or guidance based on the current issue we are experiencing. Setup (please complete the following information if applicable):   OS: Windows   IDE: .NET application targeting net462   Library/Libraries: Azure.Core.Amqp = 1.3.1 Azure.Messaging.ServiceBus = 7.18.2 Project Type: Service Fabric Application Azure Service Bus Namespace Type: Standard Configuration: Topic-Level Settings: Default Message TTL: 1 hour Subscription-Level Settings: Subscription Name: gatewayworker Default Message TTL: 5 minutes Max Delivery Count: 10 Lock Duration: 2 minutes Auto-Delete on Idle: Effectively disabled (106,751 days) Dead-Lettering on TTL Expiration: Enabled Dead-Lettering on Filter Evaluation Error: Enabled   Message Details AMQP library (from debug session): Creation Time: 12/11/2024 5:57:33 PM Absolute Expiry Time: 12/11/2024 6:57:33 PM (matches topic TTL of 1 hour) Delivery Count: 0 Current Status: Active Message Count: 0 (after being dequeue). Dead-Letter Message Count: 0. Some messages are not visible as active in the subscription after being dequeued but are remaining held in the AMQP buffer, causing memory usage to increase. Dump screenshots: This was taken on 12/12/2024 12:10am PST, the message in the buffer was dequed at: 12/11/2024 5:57:33 PM expires at: 12/11/2024 6:57:33 PM Header:  AbsoluteExpiryTime  Additional Observations: Memory Increase: Application memory usage grows gradually. Buffer Stream: From the dump, the Microsoft.Azure.Amqp.AmqpMessage and its buffer stream are holding the message data. No Prefetch: Prefetch is explicitly disabled. No Lock Renewal: Lock renewal is not enabled or performed for messages. Message Behavior After Being Dequeued: Messages are processed successfully by the backend application. For some messages, the status update fails. These messages are not moving to the DLQ, even though they are missing status updates. Instead, they remain in the AMQP buffer, and the TTL and DLQ behavior are not triggered as expected. Questions: 1)Why are the messages that fail status updates not moving to the DLQ? 2)Why do these messages remain held in the AMQP buffer indefinitely instead of being redelivered or discarded? 3)Why are TTL and DLQ behavior not triggered for messages that are neither completed nor abandoned? 4)Could the AMQP library buffer stream retaining data be related to the memory increase? If so, how can it be resolved? 5) what is the best approach to clean the AMQP buffer for the message that are greater than 1hr? am trying to attach dump but since it is 1.30GB it is failing to upload, please suggest where i can upload the dump of it is required for analysis. Information Checklist Kindly make sure that you have added all the following information above and checkoff the required fields otherwise we will treat the issuer as an incomplete report   Query Added  Setup information Added
Client	Event Hubs	[QUERY] Managing event consumption from EventHub in batch mode with multiple consumers	Library name and version Azure.Messaging.EventHubs.Processor 5.11.5 Query/Question In my usage scenario, I need to consume events from an EventHub with 4 partitions. The goal is to process the events in batch mode to optimize the underlying business logic by aggregating queries to handle 'batches' of events rather than individual events. To achieve this, I created a CustomEventProcessor by extending the EventProcessor class because the EventProcessorClient does not allow processing multiple events at once. The issues I am currently facing are as follows: When I kill a consumer and restart it, there is a moment when it seems that multiple consumers read the same data from the same partition. This forces me to perform a check to verify whether the event has already been processed or not. [Currently, this check is done in the database by verifying a unique property of the message.] Is this approach correct, or am I managing it incorrectly? When the situation described in point 1 occurs, I skip that event and process only the events that have not been processed. At the end, I update the checkpoint using UpdateCheckpointAsync for the event [not skipped] with the highest offset. This approach seems to work, but occasionally, I have noticed that some events are 'lost,' as if a checkpoint for a subsequent offset was performed, causing some events to not be correctly processed. This is the code of Consumer EventBatchProcessor.txt The goal is to create a robust consumer that can scale with multiple replicas of the consumers (always a maximum equal to the number of partitions) and to correctly manage checkpoints and duplicate control. Thanks in advance for your help. Environment No response
Mgmt	App Services	[QUERY] How to get all possible AppServicePlan configurations from an Azure subscription?	Library name and version Azure.ResourceManager.AppService 1.3.0 Query/Question I want to get a List with all possible AppService Hosting Plan configuration settings of my Azure subscription(Location, Tier, Size,...). Possibly through skus.  It should be done using Azure SDK for .NET. I already have a SubscriptionResource object to work with. Every sample and code here will assume `subscription` variable to be that object. Essentially, I want to get the app service hosting plan pricing options, like in the portal:   What have I tried?  Using GetSkusAsync() returns null every-time. I've tried with different subscriptions and result is the same.  var skus = await AppServiceExtensions.GetSkusAsync(subscription); foreach (var sku in skus.Value.Skus) {         Console.WriteLine($`- Tier: {sku.Tier}, Size: {sku.Size}, Name: {sku.Name}`); }   I thought maybe was that the SubscriptionResource could not just get the hosting plan configuration plans like in Azure portal because the SubscriptionResource is used to create,store,modify already the resources. So I looked to try with MockableAppServiceSubscriptionResource. But I could't get an object out of it that would make me be able to call the function in the first try(GetSkusAsync).  If you know how to get possible hosting plan configuration. Please do share your knowledge. And if it not currently possible with Azure sdk for .net, I would also appreciate the info. Thank you and best regards, Wesley Environment .Net 8.0 Console Application
Client	OpenAI	[FEATURE REQ] Azure OpenAI make the API version a settable string PLEASE	Library name Azure.AI.OpenAI Please describe the feature. Why is the API version an ENUM and then stored in an interal string that cannot be changed?! This feels way over-engineered and resembles the old Azure SDK packages where we had ENUMs for Azure regions and the package became useless each time a new region was onboarded nor did it work for `private customer regions`. Finally, we made that a string. We have the same situation now. o1 is GA, customers are being onboarded and the SDK doesn't work because the 2024-12-01 API version is not in the ENUM. We have to wait for a new version of the package to come out. At least provide a mechanism to override this in the constructor or make it a get/set property not internal!
Client	Cognitive - Form Recognizer	[QUERY] - How does one analyze a document with Features and QueryFields in Azure Document Intelligence 1.0.0?	Library name and version Azure.AI.DocumentIntelligence 1.0.0 Query/Question In Azure.AI.DocumentIntelligence.1.0.0-beta3, one could pass in features (such as keyValueParis for layout scan) and queryFields through the AnalyzeDocumentAsync() method, which still accepted an AnalyzeDocumentContent object. However, in the official 1.0.0 release, AnalyzeDocumentContent has been replaced by AnalyzeDocumentOptions, and AnalyzeDocumentAsync() no longer accepts features and queryFields in the signatures that expect an AnalyzeDocumentOptions object. public virtual async Task<Operation<AnalyzeResult>> AnalyzeDocumentAsync(WaitUntil waitUntil, AnalyzeDocumentOptions options, CancellationToken cancellationToken = default) AnalyzeDocumentOptions itself has Features and QueryFields properties, but they are read-only (source), so setting them in there is apparently not supported. The other option to pass them on in AnalyzeDocumentAsync() is by passing in a RequestContent object instead. However, that signature only returns a BinaryData object, whereas I was hoping for the original AnalyzeResult, and the one that is returned when passing in AnalyzeDocumentOptions over RequestContent. public virtual async Task<Operation<BinaryData>> AnalyzeDocumentAsync(WaitUntil waitUntil, string modelId, RequestContent content, string pages = null, string locale = null, string stringIndexType = null, IEnumerable<DocumentAnalysisFeature> features = null, IEnumerable<string> queryFields = null, string outputContentFormat = null, IEnumerable<AnalyzeOutputOption> output = null, RequestContext context = null) In DocumentIntelligenceClient.cs I can see that, to return an AnalyzeResult, some internal conversion from BinaryData is taking place: public virtual async Task<Operation<AnalyzeResult>> AnalyzeDocumentAsync(WaitUntil waitUntil, AnalyzeDocumentOptions options, CancellationToken cancellationToken = default) {     Argument.AssertNotNull(options, nameof(options));      using RequestContent content = options.ToRequestContent();     RequestContext context = FromCancellationToken(cancellationToken);     Operation<BinaryData> response = await AnalyzeDocumentAsync(waitUntil, options.ModelId, content, options.Pages, options.Locale, DefaultStringIndexType, options.Features, options.QueryFields, options.OutputContentFormat?.ToString(), options.Output, context).ConfigureAwait(false);     return ProtocolOperationHelpers.Convert(response, FetchAnalyzeResultFromAnalyzeOperation, ClientDiagnostics, `DocumentIntelligenceClient.AnalyzeDocument`); } The simple question is - What's the intended way for a user to specify Features and QueryFields for a document analysis request? Is de-serializing BinaryData into AnalyseResult just an additional one liner? If so, why does the internal deserialization implementation seem to have so many arguments/steps? Was setting the Features and QueryFields properties to read-only in AnalyzeDocumentOptions a mistake that slipped QA? What's the expectation here? Environment .NET SDK:  8.0.300 Microsoft Visual Studio Community 2022 (64-bit) - Current, Version 17.10.2
Client	Cognitive - Form Recognizer	[BUG] Azure.AI.DocumentIntelligence: Deserialize ClassifyDocumentOptions, Erroring out on 'Azure.AI.DocumentIntelligence.ClassifierDocumentTypeDetails'	Library name and version Azure.AI.DocumentIntelligence 1.0.0 Describe the bug Consider the below example: using Azure.AI.DocumentIntelligence; using System.Text.Json;  Dictionary<string, ClassifierDocumentTypeDetails> documentTypes = new() {     { `Document1`, new(new BlobFileListContentSource(new Uri(`https://www.microsoft.com`), `fileList1`)) },     { `Document2`, new(new BlobFileListContentSource(new Uri(`https://www.microsoft.com`), `fileList2`)) } };  BuildClassifierOptions buildClassifierOptions = new(`someClassifierId`, documentTypes);  string json = JsonSerializer.Serialize(buildClassifierOptions, new JsonSerializerOptions { WriteIndented = true }); Console.WriteLine(json); // { //   `ClassifierId`: `someClassifierId`, //   `Description`: null, //   `BaseClassifierId`: null, //   `DocumentTypes`: { //     `Document1`: { //       `BlobSource`: null, //       `BlobFileListSource`: { //         `ContainerUri`: `https://www.microsoft.com`, //         `FileList`: `fileList1` //       }, //       `SourceKind`: null //     }, //     `Document2`: { //       `BlobSource`: null, //       `BlobFileListSource`: { //         `ContainerUri`: `https://www.microsoft.com`, //         `FileList`: `fileList2` //       }, //       `SourceKind`: null //     } //   }, //   `AllowOverwrite`: null // }  buildClassifierOptions = JsonSerializer.Deserialize<BuildClassifierOptions>(json, new JsonSerializerOptions {     PropertyNameCaseInsensitive = true }); This is erroring out on Deserialize; Unhandled exception. System.NotSupportedException: Deserialization of types without a parameterless constructor, a singular parameterized constructor, or a parameterized constructor annotated with 'JsonConstructorAttribute' is not supported. Type 'Azure.AI.DocumentIntelligence.ClassifierDocumentTypeDetails'. Path: $.DocumentTypes.Document1 | LineNumber: 5 | BytePositionInLine: 18.  ---> System.NotSupportedException: Deserialization of types without a parameterless constructor, a singular parameterized constructor, or a parameterized constructor annotated with 'JsonConstructorAttribute' is not supported. Type 'Azure.AI.DocumentIntelligence.ClassifierDocumentTypeDetails'.    --- End of inner exception stack trace ---    at System.Text.Json.ThrowHelper.ThrowNotSupportedException(ReadStack& state, Utf8JsonReader& reader, Exception innerException)    at System.Text.Json.ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(JsonTypeInfo typeInfo, Utf8JsonReader& reader, ReadStack& state)    at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)    at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value, Boolean& isPopulatedValue)    at System.Text.Json.Serialization.JsonDictionaryConverter`3.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TDictionary& value)    at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value, Boolean& isPopulatedValue)    at System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter`5.TryRead[TArg](ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo, TArg& arg)    at System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter`5.ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo)    at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)    at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value, Boolean& isPopulatedValue)    at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, T& value, JsonSerializerOptions options, ReadStack& state)    at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.Deserialize(Utf8JsonReader& reader, ReadStack& state)    at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo`1 jsonTypeInfo, Nullable`1 actualByteCount)    at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo`1 jsonTypeInfo)    at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)    at Program.<Main>$(String[] args) in C:\Users\Jaliya\Desktop\ConsoleApp2\ConsoleApp2\Program.cs:line 16  Expected behavior string is correctly deserialized to given type. Actual behavior Deserialization is erroring out. Reproduction Steps Given above Environment dotnet: 9.0
Mgmt	Compute - VM	How do you set the NIC	Type of issue Typo Description [Enter feedback here] How do you set the NIC when you are crating a virtual machine. It is read only. Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.resourcemanager.connectedvmwarevsphere.virtualmachinedata.networkinterfaces?view=azure-dotnet-preview#azure-resourcemanager-connectedvmwarevsphere-virtualmachinedata-networkinterfaces Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.ResourceManager.ConnectedVMwarevSphere/VirtualMachineData.xml Document Version Independent Id 8752da48-cab5-c171-6852-4ef7d39c3ecb Article author @azure-sdk Metadata  ID: 9dfd1b45-c86f-b232-3ffe-6e34aebbfc57 Service: azure
Client	Azure.Identity	[QUERY] DefaultAzureCredentials AuthenticationFailedException - TaskCanceled in local development	Library name and version Azure.Identity 1.13.1 Query/Question I'm getting TaskCanceledException when using DefaultAzureCredential locally. This exception seems to happen in DefaultAzureCredential+. The exception happens locally when running the service from Visual Studio, connecting to Azurite with DefaultAzureCredential. GetToken sometimes succeeded and sometimes failed. These were the dependency calls related to the failed calls:  These were the dependency calls related to the successful calls:  So it doesn't succeed/ failed on specific operations. Seeing that this happens for both Blob and Table operations, I assumed the problem may be lies in Azure.Identity SDK I've enabled Azure.Identity logs and saw that sometimes the scope requested is https://storage.azure.com/.default and sometimes https://storage.azure.com.//.default. Why does it use different scopes? I can't find https://storage.azure.com.//.default in azure-sdk-for-net repo  In the above image, we see a failed calls for scope https://storage.azure.com.//.default. While there was a successful token for this scope at 08:35:40, expiring at 09:30:52, so why doesn't it used this token? I saw issue #22846 but I don't think this applies in our case because we are passing the same instance of DefaultAzureCredentials to the library where this exception happens (so it's not creating a new DefaultAzureCredentials every time). The exception seems to be thrown in the execution of an external library that we use. Here's how they created the clients: TableServiceClient creation BlobServiceClient creation The azurite setup was done with this guide The exception doesn't happen when I wrote the same code in console application. I've also tried to increase CredentialProcessTimeout to 5 minutes to see if timeout is the issue, but the exception still happens Environment Visual Studio 2022 version 17.11.5 .NET 8 Azurite Azure.Storage.Blobs 12.23.0 Azure.Data.Tables 12.9.1
Mgmt	API Management	[BUG] ApiManagementUserResource.GenerateSsoUriAsync   method returns  incorrect hotsname	Library name and version Azure.ResourceManager.ApiManagement 1.2.0.0 Describe the bug ApiManagementUserResource.GenerateSsoUriAsync   method returns APIM portal  hostname instead of APIM developer portal hostname. As a workaround for this issue , I  replace the correct developer portal  host name  for SSO uri for the solution . var ssoUriObject = new Uri(generatedSsoUri);  string ssoDevPortalUrl = $`{devPortalUrl}{ssoUriObject.PathAndQuery}`;  return ssoDevPortalUrl;   Actual returned  SSO Uri screenshot  Expected behavior ApiManagementUserResource.GenerateSsoUriAsync   should return  APIM  Developer portal  hostname/domain name i.e   https://apim-name.developer.azure-api.net/signin-sso?token=token Actual behavior ApiManagementUserResource.GenerateSsoUriAsync   returns  APIM  portal  hostname/domain name i.e   https://apim-name.portal.azure-api.net/signin-sso?token=token  Reproduction Steps ResourceIdentifier serviceIdentifier = ApiManagementServiceResource.CreateResourceIdentifier(subscriptionId, rg, apimName); ApiManagementServiceResource apiManagementService = client.GetApiManagementServiceResource(serviceIdentifier);  // List all users and filter by email  AsyncPageable<ApiManagementUserResource> pageableUsers = apiManagementService.GetApiManagementUsers().GetAllAsync();  //Get the traget user by  user property email  ApiManagementUserResource targetUser = null;  await foreach (ApiManagementUserResource user in pageableUsers) {     if (user.Data.Email.Equals(userEmail, StringComparison.OrdinalIgnoreCase))     {         targetUser = user;         break;     } }   //Get SSO dev portal URI of that user   var ssoUri = await targetUser.GenerateSsoUriAsync();  var generatedSsoUri = ssoUri.Value.Value;  Environment .NET SDK: Version:           8.0.404 Commit:            7b190310f2 Workload version:  8.0.400-manifests.1c2a2fce MSBuild version:   17.11.9+a69bbaaf5 Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.404\ .NET workloads installed: Configured to use loose manifests when installing new manifests. [aspire] Installation Source: VS 17.10.35122.118 Manifest Version:    8.2.2/8.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.2.2\WorkloadManifest.json Install Type:        FileBased Host: Version:      9.0.0 Architecture: x64 Commit:       9d5a6a9aa4 .NET SDKs installed: 8.0.303 [C:\Program Files\dotnet\sdk] 8.0.307 [C:\Program Files\dotnet\sdk] 8.0.404 [C:\Program Files\dotnet\sdk] 9.0.100 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 9.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]
Client	Azure.Identity	[BUG] InteractiveBrowserCredential does not cache persistently with TokenCachePersistenceOptions	Library name and version Azure.Identity 1.13.1 Describe the bug The docs at https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/samples/TokenCache.md describe how token caching works in Azure.Identity: in-memory caching is offered out-of-the-box, while persistent caching to disk can be activated by passing TokenCachePersistenceOptions = new TokenCachePersistenceOptions() to credentials. However, in my case this option appears to have no effect. Full code: using Azure.Core; using Azure.Identity;  namespace MyApp {     internal class Program     {         static async Task Main(string[] args)         {             var credential = new InteractiveBrowserCredential(                 new InteractiveBrowserCredentialOptions()                 {                     ClientId = `my_clientid`,                     TenantId = `my_tenantid`,                     TokenCachePersistenceOptions = new TokenCachePersistenceOptions(),                 });              var context = new TokenRequestContext([`user.read`]);             Console.WriteLine((await credential.GetTokenAsync(context)).Token);         }     } }  According to the section `Credentials supporting token caching`, InteractiveBrowserCredential supports persistent disk caching. Note that the second described approach - manually caching the AuthenticationRecord - does indeed work, but according to the docs, so should the code I provided above. Here's another user running into this behavior a few months ago. Expected behavior upon first program run the user authenticates in a browser; subsequent program runs require no interaction and just print the cached token Actual behavior every program run starts the browser to authenticate Reproduction Steps  register an app on Entra add `http://localhost` to its redirect URIs replace the client and tenant ID, then build and run the program provided in the description  Environment No response
Client	Functions	[BUG] with TimerTrigger and library System.Memory.Data, Version=6.0.0.0	Library name and version Microsoft.Azure.Functions.Worker.Extensions.Timer 4.3.1 Describe the bug I created empty azure function, dotnet 9, dotnet-isolated, I tried to add timer from library Microsoft.Azure.Functions.Worker.Extensions.Timer. Every time that I run this function there is an error. The listener for function 'abc' was unable to start. Azure.Core: Could not load file or assembly 'System.Memory.Data, Version=6.0.0.0, ...' the system cannot find the file specified. When I replaced by Http trigger everything works fine. I tried different approaches to Include library with version 6.0.0, addition of _FunctionsSkipCleanOutput, but nothing works Expected behavior Function should be executed without any errors with TimerTrigger Actual behavior Function throws an error after exectuin with TimerTrigger Reproduction Steps Create Azure function, dotnet-isolated, .net 9, add latest libraries Microsoft.Azure.Functions.Worker. Add TimerTrigger to example function with some code. Environment .net 9 Dotnet-isolated Visual Studio 2022 17.12.1
Client	Azure.Identity	[QUERY] AuthenticateAsync() causes error invalid_client AADSTS650057	Library name and version Azure.Identity 1.13.1 Query/Question I tryed to persist a AuthenticationRecord like described in section `Silently authenticate a user with AuthenticationRecord and TokenCachePersistenceOptions` of TokenCache But I always ending in getting the error Error details: error invalid_client error_description: AADSTS650057: Invalid resource. The client has requested access to a resource which is not listed in the requested permissions in the client's application registration. Eroor shown in Browser by calling AuthenticationRecord authRecord = await credential.AuthenticateAsync(); I tryed to change the scope and the API Permissions in entry, currently I have File.ReadWrite.All, Application.ReadWrite.All, Directory.ReadWrite.All, AuthenticationContext.Read.All, offline_access, openid, profile, User.read. But that did not help. I have a WPF Desktop App and how may I able to Silently authenticate a user, so he must not login within the browser each time the application is restarted. (Currently I'm using InteractiveBrowserCredentialOptions) Environment Windows 11, .Net 8, WPF Desktop App
Client	Service Bus	[QUERY] What is an acceptable range for MaxConcurrentSessions?	Library name and version Azure.Messaging.ServiceBus 7.17.3 Query/Question What is an acceptable range for MaxConcurrentSessions? It defaults to 8 in this SDK but in the older SDK I think it is ProcessorCount * 1000, which for our server is 64,000 In our current scenario, we seem to get up to maybe 500 sessions and then we stop getting any more sessions (and messages). Our queue just continues building up. This is surprising, as I would think our server could handle a lot more open sessions if they are all just waiting for messages. Our application ends up not doing any message processing, and just waiting for the sessions to timeout before it can process any more messages. Is this expected behaviour? Environment Windows Server 2022 .net 8 2 Processors (16 cores/32 threads) Azure Service Bus Premium
Client	KeyVault	[BUG] Azure KeyVault Secrets does not validate or sanitize user input	Library name and version Azure.Security.KeyVault.Secrets 4.7.0 Describe the bug When doing a Get/Set secret operation the API will send the secret name unsanitized, and unvalidated. The cause of this behavior is here: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/keyvault/Azure.Security.KeyVault.Shared/src/KeyVaultPipeline.cs#L86 foreach (var p in path) {   request.Uri.AppendPath(p, escape: false); } Where it explicitly does not escape path strings. The Secret API's makes no attempt at either validating or sanitizing input. The following code shows the issue: client.GetSecret(`user-foo-secret/../user-bar-secret`) I'm not sure in what capacity this is a security issue, because you would need a system where the user has control over the secrets, but at the very least it's an annoyance, because other Vault systems (like HashiCorp Vault) allows slashes in secret names. Azure Key Vault Client will just do the wrong thing instead of failing on bad input. Expected behavior ArgumentException or 400 Bad Request from Key Vault since the secret name is actually not valid. Actual behavior The provided reproduction returns `hunter2`, i.e. a different secret. Reproduction Steps Create a key vault, and create a secret called `user-foo-secret` and fill it with `******`. Create another secret called `user-bar-secret` and fill it with `hunter2`. using Azure.Identity;  var client = new Azure.Security.KeyVault.Secrets.SecretClient(new Uri(`https://mhsreprokeyvault.vault.azure.net/`), new DefaultAzureCredential());  var secret = client.GetSecret(`user-foo-secret/../user-bar-secret`);  Console.WriteLine(secret.Value.Value); Environment  Windows Azure .NET 9.0.100
Mgmt	ARM	[QUERY] Use arm deploy with armtemplate parameters is exception.	Library name and version Azure.ResourceManager.Resources 1.9.0 Query/Question here is the parameter json file. {     `$schema`: `https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#`,     `contentVersion`: `1.0.0.0`,     `parameters`: {     } } C# code point:  var txtTemplate = await File.ReadAllTextAsync(templateFile); var properties = new ArmDeploymentProperties(ArmDeploymentMode.Incremental) {     Template = BinaryData.FromString(txtTemplate)     Parameters = BinaryData.FromString(txtParameter); }; exception: Azure.RequestFailedException: The request content was invalid and could not be deserialized: 'Error converting value `https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#` to type 'Azure.Deployments.Core.Definitions.DeploymentParameterDefinition'. Path 'properties.parameters.$schema', line 1, position 2412.'. Status: 400 (Bad Request) ErrorCode: InvalidRequestContent  Content: {`error`:{`code`:`InvalidRequestContent`,`message`:`The request content was invalid and could not be deserialized: 'Error converting value \`https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#\` to type 'Azure.Deployments.Core.Definitions.DeploymentParameterDefinition'. Path 'properties.parameters.$schema', line 1, position 2412.'.`}}  Headers: Cache-Control: no-cache Pragma: no-cache x-ms-failure-cause: REDACTED x-ms-ratelimit-remaining-subscription-writes: REDACTED x-ms-ratelimit-remaining-subscription-global-writes: REDACTED x-ms-request-id: 2e6812d4-a331-42c4-8522-0d99f2d86055 x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED Strict-Transport-Security: REDACTED X-Content-Type-Options: REDACTED X-Cache: REDACTED X-MSEdge-Ref: REDACTED Date: Tue, 26 Nov 2024 02:51:12 GMT Content-Length: 366 Content-Type: application/json; charset=utf-8 Expires: -1     at Azure.Core.OperationInternal`1.GetResponseFromState(OperationState`1 state)    at Azure.Core.OperationInternal`1.UpdateStatusAsync(Boolean async, CancellationToken cancellationToken)    at Azure.Core.OperationInternalBase.UpdateStatusAsync(CancellationToken cancellationToken)    at Azure.Core.OperationPoller.WaitForCompletionAsync(Boolean async, OperationInternalBase operation, Nullable`1 delayHint, CancellationToken cancellationToken)    at Azure.Core.OperationInternalBase.WaitForCompletionResponseAsync(Boolean async, Nullable`1 pollingInterval, String scopeName, CancellationToken cancellationToken)    at Azure.Core.OperationInternal`1.WaitForCompletionAsync(Boolean async, Nullable`1 pollingInterval, CancellationToken cancellationToken)    at Azure.Core.OperationInternal`1.WaitForCompletionAsync(CancellationToken cancellationToken)    at Azure.ResourceManager.Resources.ArmDeploymentResource.ValidateAsync(WaitUntil waitUntil, ArmDeploymentContent content, CancellationToken cancellationToken)    at Aicro.AzureDeploy.Services.DefaultArmTemplateDeployProvider.ValidDeployArmTemplateAsync  Environment dotnet8 VS2022
Mgmt	Compute	[QUERY] How to re-invoke a managed RunCommand that has already been created	Library name and version Azure.ResourceManager.Compute 1.6.0 Query/Question Ive created a named Managed RunCommand with VirtualMachineRunCommandCollection.CreateOrUpdateAsync(). It automatically executed the command on create, and gives output when checked with GetAsync(..., expand: `InstanceView`, ...) I've read the output of the command, now I want to call the command again and have it be re-invoked on the server and output updated. How can I do this? running CreateOrUpdateAsync again does not re-execute the command Environment Linux Ubuntu 20.04 Azure VM
Mgmt	App Services	[BUG] AppService GetConnectionStringsAsync Exception	Library name and version Azure.ResourceManager.AppService version 1.0.2 Describe the bug Run into same issue as #46683 and #389 error message: Execution failed. The requested operation requires an element of type 'Object', but the target element has type 'Array'.. Exception: System.InvalidOperationException: The requested operation requires an element of type 'Object', but the target element has type 'Array'. at System.Text.Json.ThrowHelper.ThrowJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType) at Azure.ResourceManager.AppService.Models.ConnectionStringDictionary.DeserializeConnectionStringDictionary(JsonElement element) at Azure.ResourceManager.AppService.WebAppsRestOperations.ListConnectionStringsAsync(String subscriptionId, String resourceGroupName, String name, CancellationToken cancellationToken) at Azure.ResourceManager.AppService.WebSiteResource.GetConnectionStringsAsync(CancellationToken cancellationToken) Expected behavior Successfully get and deserialize connection string dictionary. Actual behavior The requested operation requires an element of type 'Object', but the target element has type 'Array'. Reproduction Steps Error from production log. Correlation ID: afdf60e2-2a37-4df2-bf0c-2e29c82eb0b5 Request: `message`: {`requestMethod`:`POST`,`requestUri`:`https://management.azure.com/subscriptions/3b84045b-7604-4c84-adc7-c57db640b71b/resourceGroups/rg-rat-we-test-kronos/providers/Microsoft.Web/sites/func-rat-we-test-kronos-argus/config/connectionstrings/list?api-version=2021-02-01`,`duration`:1254.7295,`correlationId`:`afdf60e2-2a37-4df2-bf0c-2e29c82eb0b5`,`requestHeaderLengths`:{`Accept`:16,`x-ms-arm-signed-obo-token`:2262,`x-ms-correlation-request-id`:36,`x-ms-client-request-id`:36,`x-ms-return-client-request-id`:4,`User-Agent`:115,`Authorization`:1327},`requestContentLength`:0,`responseCode`:200,`contentLength`:482} Environment No response
Client	Service Bus	[QUERY] How to make a health check for Azure Servicebus AMQP connection?	Library name and version Azure.Messaging.Servicebus - 7.18.1 Query/Question I'm using health checks from the AspNetCore.HealthChecks.AzureServiceBus. I've encountered an issue when there's no AMQP connection between my application and Azure Servicebus, however, the health check is healthy because it's performed over HTTP connection. Unfortunately, I haven't found any well-known approach to the problem on the internet. I have two possible solutions:  Send some message to a topic in ASB which is not matched by filters of any subscription. The message is definitely not delivered to any dead-letter queue. And I can see that the AbandonMessage metric is rising. I wonder if there are any bad consequences with this approach? Could you please clarify what exactly happens with the message here? What abandoned messages are, how do they work, and where are they stored? Create a dedicated queue HealthCheck for the health check messages. Each application will periodically send a health check message with short time-to-live.  I'd rather go with a first approach, because second implies some infrastructure work but I'm not sure if it is a safe approach. Environment No response
Mgmt	Network - DNS	[QUERY] Question about the waitUntil parameter in DnsCnameRecordCollection.CreateOrUpdateAsync	Library name and version Azure.ResourceManager.Dns 1.1.1 Query/Question Hello, I would like to query about the DnsCnameRecordCollection.CreateOrUpdateAsync method - what is the meaning of the `waitUntil` parameter? If I pass `WaitUntil.Started` - what is the mechanism to check when the operation is completed? And if I pass `WaitUntil.Completed` - how long does this operation typically take? Is there a timeout period after which it fails? Environment No response
Mgmt	Container Service	[BUG] Cannot assign zones using ManagedClusterAgentPoolProfile or ContainerServiceAgentPoolData	Library name and version Azure.ResourceManager.ContainerService 1.2.2 Describe the bug When configuring ContainerServiceAgentPoolData or ManagedClusterAgentPoolProfile you can not use any kind of variable substitution with the AvailabilityZones property.  I will only take a hard coded list of zones. AvailabilityZones = { `1`, `2`, `3` }  Expected behavior I expect to be able to use variable substitution to assign to the property based on user input. List<string> zones; zones =  new List<string> { `1` };  AvailabilityZones = zones  Actual behavior trying to use a variable gives CS0200 error Reproduction Steps try to create any node pool where the zones are not hard coded List<string> zones; zones =  new List<string> { `1` };  new ManagedClusterAgentPoolProfile(systemNodePoolName) {     Count = sysNodeCount,     VmSize = buildData.linuxVmSku,     Mode = AgentPoolMode.System,     //VnetSubnetId = (buildData.networkPlugin == `Kubenet`)? null : new ResourceIdentifier(sysNodeSubnetId.Id),     //PodSubnetId = (buildData.networkPluginMode == `Dynamic`) ? new ResourceIdentifier(sysNodePodSubnetId.Id) : null,     //OSDiskType = osDiskType.Managed,     OSType = osType.Linux,     OSSku = (buildData.customVnet) ? systemNodePoolOs : buildData.linuxOs,     MaxPods = maxPods,     AgentPoolType = `VirtualMachineScaleSets`,     EnableNodePublicIP = false,     //NodeTaints = buildData.customVnet ? { `CriticalAddonsOnly=true:NoSchedule` } : new ResourceIdentifier(sysNodeSubnetId.Id) ,     AvailabilityZones = zones  }   Environment No response
Client	Azure.Identity	[FEATURE REQ] Azure.Identity - improve visibility, add logging	Library name Azure.Identity Please describe the feature. It's a common practice to use DefaultAzureCredential(), which under the hood have several different credential providers, which runs one after another. It would be nice to have an option, a switch, to enable logging what's happening - log entries about through which providers code went, which provider had a hit.
Mgmt	App Services	[BUG] How to Set http20ProxyFlag for grpc only	Library name and version Azure.ResourceManager.AppService 1.2.0 Describe the bug How I can use the SDK to set this configuration https://learn.microsoft.com/en-us/azure/app-service/configure-grpc#3-configure-the-http2-port to enable grpc support on my webapp? I did some research and I know that I need to config http20ProxyFlag but I cannot find in the SDK where and how to set this flag. Expected behavior How I can use the SDK to set this configuration https://learn.microsoft.com/en-us/azure/app-service/configure-grpc#3-configure-the-http2-port to enable grpc support on my webapp? I did some research and I know that I need to config http20ProxyFlag but I cannot find in the SDK where and how to set this flag. Actual behavior How I can use the SDK to set this configuration https://learn.microsoft.com/en-us/azure/app-service/configure-grpc#3-configure-the-http2-port to enable grpc support on my webapp? I did some research and I know that I need to config http20ProxyFlag but I cannot find in the SDK where and how to set this flag. Reproduction Steps How I can use the SDK to set this configuration https://learn.microsoft.com/en-us/azure/app-service/configure-grpc#3-configure-the-http2-port to enable grpc support on my webapp? I did some research and I know that I need to config http20ProxyFlag but I cannot find in the SDK where and how to set this flag. Environment .NET SDK: Version:           8.0.403 Commit:            c64aa40a71 Workload version:  8.0.400-manifests.e99c892e MSBuild version:   17.11.9+a69bbaaf5 Runtime Environment: OS Name:     Windows OS Version:  10.0.22631 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.403\ .NET workloads installed: Configured to use loose manifests when installing new manifests. [aspire] Installation Source: VS 17.11.35327.3 Manifest Version:    8.1.0/8.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.1.0\WorkloadManifest.json Install Type:        FileBased Host: Version:      8.0.10 Architecture: x64 Commit:       81cabf2857 .NET SDKs installed: 3.1.426 [C:\Program Files\dotnet\sdk] 5.0.408 [C:\Program Files\dotnet\sdk] 6.0.135 [C:\Program Files\dotnet\sdk] 6.0.321 [C:\Program Files\dotnet\sdk] 6.0.427 [C:\Program Files\dotnet\sdk] 7.0.120 [C:\Program Files\dotnet\sdk] 8.0.306 [C:\Program Files\dotnet\sdk] 8.0.403 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found Learn more: https://aka.ms/dotnet/info Download .NET: https://aka.ms/dotnet/download
Client	Service Bus	ServiceBusSender Identifier not set.	Library name and version Azure.Messaging.ServiceBus v7.18.0+ Describe the bug When creating a ServiceBusSender using ServiceBusClient.CreateSender() the returned Sender does not have its Identifier correctly set based off the queue/topic name. This used to work < 7.18.0. Expected behavior ServiceBusClient.CreateSender() should return ServiceBusSender with Identifier set as -. Actual behavior Identifier is set as `-`. Reproduction Steps using Azure.Identity; using Azure.Messaging.ServiceBus;  namespace ConsoleApp1;  class Program {  static void Main(string[] args)  {   var serviceBusClient = new ServiceBusClient(`service-bus-name.servicebus.windows.net`, new DefaultAzureCredential());   var serviceBusSender = serviceBusClient.CreateSender(`queue-name`);  } } Environment No response
Client	Cognitive - Form Recognizer	[BUG] await AnalyzeBatchDocumentsAsync(WaitUntil.Completed, ..) hangs indefinitely even when operation is completed	Library name and version Azure.AI.DocumentIntelligence 1.0.0-beta.3 Describe the bug I'm experiencing issues getting operation Status after using AnalyzeBatchDocumentsAsync() both with WaitUntil.Completed or WaitUntil.Started. Specifically, my attempts to retrieve the AnalyzeBatchResult are resulting in indefinite waits, despite the operation being completed and the result files being successfully stored in the result container.  Using WaitUntil.Completed:   The await call waits indefinitely and never returns AnalyzeBatchResult, even though the result files are present in the ResultContainer. When checking the operation status separately using Postman, it shows AnalyzeBatchResultOperation with a status of `completed.`   Using WaitUntil.Started followed by WaitForCompletionAsync():   The same indefinite wait issue occurs, even though the result files are correctly generated and saved. Again, the status checked through Postman indicates that the operation is completed.   Using WaitUntil.Started and attempting to retrieve documentOperation.Id:   Attempting to access documentOperation.Id throws a System.NotSupportedException with the message: Specified method is not supported.  Expected behavior   AnalyzeBatchDocumentsAsync should return the AnalyzeBatchResult once the operation is completed.   WaitForCompletionAsync() should correctly wait and return the result.   documentOperation.Id shoud be accessible, to try checking the status through http call to Get Analyze Batch Result   Having a method in DocumentIntelligenceClient for Get Analyze Batch Result   Actual behavior The methods wait indefinitely despite the operation being completed and results being available in the Azure Blob Storage container. I have confirmed that the operation completes by checking Get Analyze Batch Result with Postman, and it returns AnalyzeBatchResultOperation with the status `completed.` Reproduction Steps public async Task GetDocumentTextAsync(string blobPrefix) {     Uri sourceContainerUri = new($`https://{_fileStorageOptions.AccountName}.blob.core.windows.net/{_fileStorageOptions.SourceContainerName}/`);     Uri resultContainerUri = new($`https://{_fileStorageOptions.AccountName}.blob.core.windows.net/{_fileStorageOptions.ProcessedContainerName}/`);      AnalyzeBatchDocumentsContent analyzeBatchRequest = new AnalyzeBatchDocumentsContent(resultContainerUri)     {         AzureBlobSource = new AzureBlobContentSource(sourceContainerUri)         {             Prefix = blobPrefix,         },         ResultPrefix = blobPrefix,         OverwriteExisting = true,     };      try     {         // Using WaitUntil.Completed should return AnalyzeBatchResult, but the operation hangs indefinitely         // Operation<AnalyzeBatchResult> documentOperation = await _documentClient.AnalyzeBatchDocumentsAsync(WaitUntil.Completed, `prebuilt-layout`, analyzeBatchRequest: analyzeBatchRequest);         // AnalyzeBatchResult responseData = documentOperation.Value;         // _logger.LogInformation(`Operation finished: SucceededCount = {SucceededCount}`, responseData.SucceededCount);          // Trying WaitUntil.Started, then WaitForCompletionAsync() also hangs indefinitely         Operation<AnalyzeBatchResult> documentOperation = await _documentClient.AnalyzeBatchDocumentsAsync(WaitUntil.Started, `prebuilt-layout`, analyzeBatchRequest: analyzeBatchRequest);                  // documentOperation.Id throws a System.NotSupportedException with the message: Specified method is not supported.         // _logger.LogInformation(`Operation Started: {OperationId}`, documentOperation.Id);          Response<AnalyzeBatchResult> response = await documentOperation.WaitForCompletionAsync();         AnalyzeBatchResult value = response.Value;         _logger.LogInformation(`Operation finished: SucceededCount = {SucceededCount}`, value.SucceededCount);     }     catch (RequestFailedException ex)     {         _logger.LogError(ex, ex.Message);     } } Environment SDK .NET : Version:           8.0.400 Commit:            36fe6dda56 Workload version:  8.0.400-manifests.b78e89c6 MSBuild version:   17.11.3+0c8610977 Environnement d'exécution : OS Name:     Windows OS Version:  10.0.22631 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.400\ Azure.AI.DocumentIntelligence 1.0.0-beta.3 Aspire.Hosting.AppHost 8.2.1
Mgmt	App Services	[BUG] Create Managed Certificate failed with status code 202	Library name and version Azure.ResourceManager.AppService 1.2.0 Describe the bug I use below code to create a managed certificate but I encounter error 2024-10-27T22:23:57Z   [Error]   Failed to create managed cert 2024-10-27T22:23:57Z   [Error]   Service request failed. Status: 202 (Accepted)  Service request succeeded. Response content and headers are not included to avoid logging sensitive data. 2024-10-27T22:23:57Z   [Error]      at Azure.ResourceManager.AppService.CertificatesRestOperations.CreateOrUpdateAsync(String subscriptionId, String resourceGroupName, String name, AppCertificateData data, CancellationToken cancellationToken)    at Azure.ResourceManager.AppService.AppCertificateCollection.CreateOrUpdateAsync(WaitUntil waitUntil, String name, AppCertificateData data, CancellationToken cancellationToken)  The code is             ResourceGroupResource resourceGroupResource =                 this.client.GetDtmbResourceGroupResource(stamp.ManagedSubscriptionId, stamp.ResourceGroupName);             AppCertificateCollection collection = resourceGroupResource.GetAppCertificates();              string name = $`{req.DtsEnvName}-cert`;             string hostName = req.DomainName;             //DomainNameGenerator.GenerateDomainName(req.DtsEnvName, req.Location, this.dnsConfig.DnsZoneName);             AppCertificateData data = new(new AzureLocation(req.Location))             {                 // HostNames = { hostName },                 CanonicalName = hostName,                  ServerFarmId = new ResourceIdentifier(req.AspResourceId),             };              ArmOperation<AppCertificateResource> lro =                 await collection.CreateOrUpdateAsync(WaitUntil.Completed, name, data);             AppCertificateResource result = lro.Value;             AppCertificateData resourceData = result.Data; Noticed the error code is 202, I don't really see what this error happen as it's supposed to be a long running/async operation, I am using             ArmOperation<AppCertificateResource> lro =                 await collection.CreateOrUpdateAsync(WaitUntil.Completed, name, data); with WaitUntil.Completed set, it should wait till the long running operation finished, but it's not. Later I checked on the azure portal, I saw that the cert was created successfully. So I don't know why my code gives error, it should await and return succeed. Expected behavior The code should work synchronously to create a managed certificate. Actual behavior Gives error 2024-10-27T22:23:57Z   [Error]   Failed to create managed cert 2024-10-27T22:23:57Z   [Error]   Service request failed. Status: 202 (Accepted)  Service request succeeded. Response content and headers are not included to avoid logging sensitive data. 2024-10-27T22:23:57Z   [Error]      at Azure.ResourceManager.AppService.CertificatesRestOperations.CreateOrUpdateAsync(String subscriptionId, String resourceGroupName, String name, AppCertificateData data, CancellationToken cancellationToken)    at Azure.ResourceManager.AppService.AppCertificateCollection.CreateOrUpdateAsync(WaitUntil waitUntil, String name, AppCertificateData data, CancellationToken cancellationToken)  Reproduction Steps try out below code             ResourceGroupResource resourceGroupResource =                 this.client.GetDtmbResourceGroupResource(stamp.ManagedSubscriptionId, stamp.ResourceGroupName);             AppCertificateCollection collection = resourceGroupResource.GetAppCertificates();              string name = $`{req.DtsEnvName}-cert`;             string hostName = req.DomainName;             //DomainNameGenerator.GenerateDomainName(req.DtsEnvName, req.Location, this.dnsConfig.DnsZoneName);             AppCertificateData data = new(new AzureLocation(req.Location))             {                 // HostNames = { hostName },                 CanonicalName = hostName,                  ServerFarmId = new ResourceIdentifier(req.AspResourceId),             };              ArmOperation<AppCertificateResource> lro =                 await collection.CreateOrUpdateAsync(WaitUntil.Completed, name, data);             AppCertificateResource result = lro.Value;             AppCertificateData resourceData = result.Data; Environment .NET SDK:  Version:           8.0.403  Commit:            c64aa40a71  Workload version:  8.0.400-manifests.e99c892e  MSBuild version:   17.11.9+a69bbaaf5  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22631  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.403\  .NET workloads installed: Configured to use loose manifests when installing new manifests.  [aspire]    Installation Source: VS 17.11.35327.3    Manifest Version:    8.1.0/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.1.0\WorkloadManifest.json    Install Type:        FileBased   Host:   Version:      8.0.10   Architecture: x64   Commit:       81cabf2857  .NET SDKs installed:   3.1.426 [C:\Program Files\dotnet\sdk]   5.0.408 [C:\Program Files\dotnet\sdk]   6.0.135 [C:\Program Files\dotnet\sdk]   6.0.321 [C:\Program Files\dotnet\sdk]   6.0.427 [C:\Program Files\dotnet\sdk]   7.0.120 [C:\Program Files\dotnet\sdk]   8.0.306 [C:\Program Files\dotnet\sdk]   8.0.403 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Mgmt	App Services	[QUERY] How to create azure web app with sitecontainers	Library name and version Azure.ResourceManager.AppService 1.2.0 Query/Question How to create a azure container linux webapp with sitecontainer. I don't find a good example how to do that. From Portal I can create such webapp by  With arm template I can create it by {     `$schema`: `https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#`,     `contentVersion`: `1.0.0.0`,     `parameters`: {         `sites_kcasewebapp01_name`: {             `defaultValue`: `kcasewebapp01`,             `type`: `String`         },         `serverfarms_ASP_kcasestamp01_b493_externalid`: {             `defaultValue`: `/subscriptions/b75447b0-caf9-4fde-92ca-ba79a3a32705/resourceGroups/kcasestamp01/providers/Microsoft.Web/serverfarms/ASP-kcasestamp01-b493`,             `type`: `String`         }     },     `variables`: {},     `resources`: [         {             `type`: `Microsoft.Web/sites`,             `apiVersion`: `2023-12-01`,             `name`: `[parameters('sites_kcasewebapp01_name')]`,             `location`: `Australia Central`,             `kind`: `app,linux`,             `properties`: {                 `enabled`: true,                 `hostNameSslStates`: [                     {                         `name`: `[concat(parameters('sites_kcasewebapp01_name'), '.azurewebsites.net')]`,                         `sslState`: `Disabled`,                         `hostType`: `Standard`                     },                     {                         `name`: `[concat(parameters('sites_kcasewebapp01_name'), '.scm.azurewebsites.net')]`,                         `sslState`: `Disabled`,                         `hostType`: `Repository`                     }                 ],                 `serverFarmId`: `[parameters('serverfarms_ASP_kcasestamp01_b493_externalid')]`,                 `reserved`: true,                 `isXenon`: false,                 `hyperV`: false,                 `dnsConfiguration`: {},                 `vnetRouteAllEnabled`: false,                 `vnetImagePullEnabled`: false,                 `vnetContentShareEnabled`: false,                 `siteConfig`: {                     `numberOfWorkers`: 1,                     `linuxFxVersion`: `sitecontainers`,                     `acrUseManagedIdentityCreds`: false,                     `alwaysOn`: true,                     `http20Enabled`: false,                     `functionAppScaleLimit`: 0,                     `minimumElasticInstanceCount`: 0                 },                 `scmSiteAlsoStopped`: false,                 `clientAffinityEnabled`: false,                 `clientCertEnabled`: false,                 `clientCertMode`: `Required`,                 `hostNamesDisabled`: false,                 `vnetBackupRestoreEnabled`: false,                 `customDomainVerificationId`: `7A49CD600E089AE55BA3948338B75D68B25C95371BC7B020B33E1F25051279D7`,                 `containerSize`: 0,                 `dailyMemoryTimeQuota`: 0,                 `httpsOnly`: true,                 `redundancyMode`: `None`,                 `publicNetworkAccess`: `Enabled`,                 `storageAccountRequired`: false,                 `keyVaultReferenceIdentity`: `SystemAssigned`             }         },         {             `type`: `Microsoft.Web/sites/basicPublishingCredentialsPolicies`,             `apiVersion`: `2023-12-01`,             `name`: `[concat(parameters('sites_kcasewebapp01_name'), '/ftp')]`,             `location`: `Australia Central`,             `dependsOn`: [                 `[resourceId('Microsoft.Web/sites', parameters('sites_kcasewebapp01_name'))]`             ],             `properties`: {                 `allow`: false             }         },         {             `type`: `Microsoft.Web/sites/basicPublishingCredentialsPolicies`,             `apiVersion`: `2023-12-01`,             `name`: `[concat(parameters('sites_kcasewebapp01_name'), '/scm')]`,             `location`: `Australia Central`,             `dependsOn`: [                 `[resourceId('Microsoft.Web/sites', parameters('sites_kcasewebapp01_name'))]`             ],             `properties`: {                 `allow`: false             }         },         {             `type`: `Microsoft.Web/sites/config`,             `apiVersion`: `2023-12-01`,             `name`: `[concat(parameters('sites_kcasewebapp01_name'), '/web')]`,             `location`: `Australia Central`,             `dependsOn`: [                 `[resourceId('Microsoft.Web/sites', parameters('sites_kcasewebapp01_name'))]`             ],             `properties`: {                 `numberOfWorkers`: 1,                 `defaultDocuments`: [                     `Default.htm`,                     `Default.html`,                     `Default.asp`,                     `index.htm`,                     `index.html`,                     `iisstart.htm`,                     `default.aspx`,                     `index.php`,                     `hostingstart.html`                 ],                 `netFrameworkVersion`: `v4.0`,                 `linuxFxVersion`: `sitecontainers`,                 `requestTracingEnabled`: false,                 `remoteDebuggingEnabled`: false,                 `httpLoggingEnabled`: false,                 `acrUseManagedIdentityCreds`: false,                 `logsDirectorySizeLimit`: 35,                 `detailedErrorLoggingEnabled`: false,                 `publishingUsername`: `REDACTED`,                 `scmType`: `None`,                 `use32BitWorkerProcess`: true,                 `webSocketsEnabled`: false,                 `alwaysOn`: true,                 `managedPipelineMode`: `Integrated`,                 `virtualApplications`: [                     {                         `virtualPath`: `/`,                         `physicalPath`: `site\\wwwroot`,                         `preloadEnabled`: true                     }                 ],                 `loadBalancing`: `LeastRequests`,                 `experiments`: {                     `rampUpRules`: []                 },                 `autoHealEnabled`: false,                 `vnetRouteAllEnabled`: false,                 `vnetPrivatePortsCount`: 0,                 `publicNetworkAccess`: `Enabled`,                 `localMySqlEnabled`: false,                 `ipSecurityRestrictions`: [                     {                         `ipAddress`: `Any`,                         `action`: `Allow`,                         `priority`: 2147483647,                         `name`: `Allow all`,                         `description`: `Allow all access`                     }                 ],                 `scmIpSecurityRestrictions`: [                     {                         `ipAddress`: `Any`,                         `action`: `Allow`,                         `priority`: 2147483647,                         `name`: `Allow all`,                         `description`: `Allow all access`                     }                 ],                 `scmIpSecurityRestrictionsUseMain`: false,                 `http20Enabled`: false,                 `minTlsVersion`: `1.2`,                 `scmMinTlsVersion`: `1.2`,                 `ftpsState`: `FtpsOnly`,                 `preWarmedInstanceCount`: 0,                 `elasticWebAppScaleLimit`: 0,                 `functionsRuntimeScaleMonitoringEnabled`: false,                 `minimumElasticInstanceCount`: 0,                 `azureStorageAccounts`: {}             }         },         {             `type`: `Microsoft.Web/sites/hostNameBindings`,             `apiVersion`: `2023-12-01`,             `name`: `[concat(parameters('sites_kcasewebapp01_name'), '/', parameters('sites_kcasewebapp01_name'), '.azurewebsites.net')]`,             `location`: `Australia Central`,             `dependsOn`: [                 `[resourceId('Microsoft.Web/sites', parameters('sites_kcasewebapp01_name'))]`             ],             `properties`: {                 `siteName`: `kcasewebapp01`,                 `hostNameType`: `Verified`             }         },         {             `type`: `Microsoft.Web/sites/sitecontainers`,             `apiVersion`: `2023-12-01`,             `name`: `[concat(parameters('sites_kcasewebapp01_name'), '/test-container')]`,             `location`: `Australia Central`,             `dependsOn`: [                 `[resourceId('Microsoft.Web/sites', parameters('sites_kcasewebapp01_name'))]`             ],             `properties`: {                 `image`: `asetestacr.azurecr.io/samples/nginx:latest`,                 `targetPort`: `80`,                 `isMain`: true,                 `authType`: `UserCredentials`,                 `userName`: `asetestacr`,                 `volumeMounts`: [],                 `environmentVariables`: []             }         }     ] } But with SDK I didn't figure out how to do it correctly. Please share me some example for how to creating a linux webapp using container image. Thanks. Environment .NET SDK:  Version:           8.0.403  Commit:            c64aa40a71  Workload version:  8.0.400-manifests.e99c892e  MSBuild version:   17.11.9+a69bbaaf5  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22631  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.403\  .NET workloads installed: Configured to use loose manifests when installing new manifests.  [aspire]    Installation Source: VS 17.11.35327.3    Manifest Version:    8.1.0/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.1.0\WorkloadManifest.json    Install Type:        FileBased   Host:   Version:      8.0.10   Architecture: x64   Commit:       81cabf2857  .NET SDKs installed:   3.1.426 [C:\Program Files\dotnet\sdk]   5.0.408 [C:\Program Files\dotnet\sdk]   6.0.135 [C:\Program Files\dotnet\sdk]   6.0.321 [C:\Program Files\dotnet\sdk]   6.0.427 [C:\Program Files\dotnet\sdk]   7.0.120 [C:\Program Files\dotnet\sdk]   8.0.306 [C:\Program Files\dotnet\sdk]   8.0.403 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.35 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Client	Azure.Core	Azure.Core 1.44.1 with bug on Dependency System.Memory.Data 6.0.0 for instruction BinaryData.Empty.ToString()	Unable to use NuGet package Azure.Core 1.44.1 with Dependency System.Memory.Data 6.0.0 on .NET 8 Application. The previous version Azure.Core 1.43.0 with Dependency System.Memory.Data 1.0.2 is working well. Suggestion: Update Dependency System.Memory.Data to version 8.0.1 for Azure.Core 1.44.1 NuGet package. Steps to reproduce the bug: Create a console app with .NET 8 Install NuGet package Azure.Core 1.44.1 (with Dependency System.Memory.Data 6.0.0) Write this code line: string data = BinaryData.Empty.ToString(); Run... You get: System.ArgumentNullException: 'Value cannot be null. (Parameter 'bytes')'
Mgmt	Network - DNS	[BUG] Cannot create private DNS zone using SDK	Library name and version Azure.ResourceManager.Dns 1.2.0-beta.1 Describe the bug Getting  Creation of private DNS zones using this API is no longer allowed. Please use privatednszones resource instead of dnszones resource.  when trying to create private DNS zone with following codes: var dnsZones = resourceGroupResource.GetDnsZones(); var dnsZoneData = new DnsZoneData(`Global`) {     ZoneType = DnsZoneType.Private };  await dnsZones.CreateOrUpdateAsync(WaitUntil.Completed, `privatelink.redisenterprise.cache.azure.net`, dnsZoneData); Expected behavior Expect DNS Zone to be created successfully Actual behavior DNS Zone does not create successfully Reproduction Steps See bug description Environment No response
Client	Cognitive - Form Recognizer	Can you download a figure similar to the functionality in Document Intelligence Studio?	Library name and version Azure.AI.DocumentIntelligence 1.0.0-beta.3 Query/Question Currently in Document Intelligence Studio, once a document is analyzed you can download figures from the document as .png files   Is this functionality supported by the latest version of this package? If not is this something that is planned for future support? I would like to be able to send a document and extract the images from it for direct handling and use. Environment No response
Client	Event Hubs	[BUG] `EventHubConsumerClient.GetPartitionPropertiesAsync` throws `InvalidOperationException` from AMQP library instead of retrying	Library name and version Azure.Messaging.EventHubs 5.11.5 Describe the bug When calling method GetPartitionPropertiesAsync on type EventHubConsumerClient, exception InvalidOperationException from NuGet Microsoft.Azure.Amqp is thrown with the following message: `Can't create session when the connection is closing` I am pretty sure that we are not closing the EventHubConsumerClient or its EventHubConnection prematurely in our code. This claim is supported by:   The fact that other concurrently called methods on the same EventHubConsumerClient and other clients using the same EventHubConnection are not throwing at the same time.   Historically, there were issues in the Azure's Event Hub and Service Bus SDKs that manifested in the same way:    #8761 #9416  In both cases, the conclusion was that the thrown InvalidOperationException should be treated properly as an transient exception. Both issues were resolved by catching this exception in the client SDK and wrap it into retriable client exception (which would be EventHubsException in this case). Example of such fix: https://github.com/Azure/azure-sdk-for-net/pull/15984/files Stack trace: at Microsoft.Azure.Amqp.AmqpConnection.AddSession(AmqpSession session, Nullable`1 channel)\n      at Microsoft.Azure.Amqp.AmqpConnection.CreateSession(AmqpSessionSettings sessionSettings)\n      at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.CreateManagementLinkAsync(AmqpConnection connection, TimeSpan operationTimeout, TimeSpan linkTimeout, CancellationToken cancellationToken)\n      at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenManagementLinkAsync(TimeSpan operationTimeout, TimeSpan linkTimeout, CancellationToken cancellationToken)\n      at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)\n      at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)\n      at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)\n      at Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPartitionPropertiesAsync(String partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken)\n      at Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPartitionPropertiesAsync(String partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken)\n      at Azure.Messaging.EventHubs.EventHubConnection.GetPartitionPropertiesAsync(String partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken)\n      at Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient.GetPartitionPropertiesAsync(String partitionId, CancellationToken cancellationToken)\n    at [redacted]    Expected behavior The InvalidOperationException should be wrapped into EventHubsException { IsTransient = true } exception which should be properly retried by existing retry policies within the client SDK. Actual behavior The InvalidOperationException is thrown out of the client SDK into the user code unexpectedly. Reproduction Steps I  not able to deterministically reproduce the error but it happens every few days in our stream processing service running in AKS that periodically calls the problematic GetPartitionPropertiesAsync as well as PartitionReceiver.ReceiveBatchAsync (which never throws such exception). Environment  .NET 8. Azure Kubernetes Service. Event Hub Standard tier.
Mgmt	Recovery Services Backup	[BUG] Azure.ResourceManager.RecoveryServicesBackup methods missing	Library name and version Azure.ResourceManager.RecoveryServicesBackup 1.2.0 Describe the bug RecoveryServiceBackupExtensions.RefreshProtectionContainersAsync() method triggers LRO. In method description it is mentioned to use RecoveryServiceBackupExtensions.GetRefreshOperationResul() method to get LRO result. But this method does not exist in the library as well as RecoveryServiceBackupExtensions.GetProtectionContainerRefreshOperationResult() method. Expected behavior The following methods added to RecoveryServiceBackupExtensions:  GetRefreshOperationResul() or GetProtectionContainerRefreshOperationResult() GetRefreshOperationResulAsync() or GetProtectionContainerRefreshOperationResultAsync()  Actual behavior the following methods do not exist in RecoveryServiceBackupExtensions:  GetRefreshOperationResul() GetRefreshOperationResulAsync() GetProtectionContainerRefreshOperationResult() GetProtectionContainerRefreshOperationResultAsync()  Reproduction Steps  install Azure.ResourceManager.RecoveryServicesBackup 1.2.0 nuget package invoke RecoveryServiceBackupExtensions.RefreshProtectionContainersAsync() method try to get refresh operation result  Environment No response
Client	Storage	[BUG] BinaryData.ToString() throws nullreference exception after upgrading Microsoft.Extensions.Azure/Azure.Core	Library name and version Azure.Core 1.44.0 Describe the bug The dependency System.Memory.Data is upgraded in version 1.44.0 to 6.0.0, this version has very annoying bug. When BinaryData is empty, the .ToString() method throws. This is fixed in a later version of the System.Memory.Data library. The previous version (1.42.0) used System.Memory.Data version 1.0.2, this version doesn't have the problem. Expected behavior BinaryData.ToString() should not throw Actual behavior It does :-( Reproduction Steps Add manual package dependency to Microsoft.Extensions.Azure 1.7.6 public async Task UpdateBuildingFileStatusActivity( [BlobInput(`path/to/emptyfile.txt`, Connection = `MadasterStorage`)] BlobClient blob) { var content = await blob.DownloadContentAsync(); var text = content.Value.Content.ToString(); } Environment No response
Mgmt	Network - Front Door	[QUERY] Create Front Door Standard instance with management packages	Library name and version azure-sdk-for-net Query/Question Is there any sdk for .net core for create standard front door? I'm currently working on a project using .NET Core, and I need to create an Azure Front Door Standard instance programmatically. I've explored various Azure SDKs, but I'm unsure which one to use for this specific task. Or is there any way to achieve it? Environment .NET CORE
Client	Service Bus	[BUG] Incorrect batch size estimation	Library name and version Azure.Messaging.ServiceBus 7.18.1 Describe the bug There is some error when estimating batch size. Some batches (with size that almost hit size limit) were created but failed to send. Expected behavior Send created baches. Actual behavior Got the ServiceBusException: The message is larger than is currently allowed (262144 bytes). Reproduction Steps  Create batch(es)  ServiceBusSender sender = _serviceBusClient.CreateSender(queueName); ServiceBusMessageBatch batch = await sender.CreateMessageBatchAsync(ct);  Add messages to almost hit the limit (usign TryAddMessage to hit limit)  ServiceBusMessage sbMessage = GetNextMessage(); while (batch.TryAddMessage(sbMessage)) { sbMessage = GetNextMessage(); } In my case batch.SizeInBytes was 261889 (MaxSizeInBytes == 262144)  Try to send batch  await sender.SendMessagesAsync(batch, ct); Got an exception: Azure.Messaging.ServiceBus.ServiceBusException: The message (id:redacted, size:263525 bytes) is larger than is currently allowed (262144 bytes). (MessageSizeExceeded). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.  The message size became 263525 (was 261889) Workaround: set MaxSizeInBytes when creating batch to 262144 - (2 * 1024) (default max size - 2KB) Environment Windows 11 .NET 8.0.402 / Console App Visual Studio 17.11.4
Client	KeyVault	[BUG] Azure Keyvault GetSecret API timouts	Library name and version Azure.Security.KeyVault.Secrets 4.6.0 Describe the bug We are seeing 2 different scenarios with very GetSecret API calls randomly failing after a significant amount of time. This mostly happen when traffic is quite high. Case 1 : GetSecret API that get cancelled after ~100s and the automated retry is succeeding right after in 23ms delay.  (operation Id 9b3dcb3caafc90843ef1b7612e240807) Case 2  : GetSecret API takes #20s to return 401 error code and the automated retry is succeeding right after. I understand that the initial 401 is expected because of the authentication flow, but i'm surprised it takes ~20s to respsond.  (operation Id 0ac0c16170c7c1c6a7dc6a9a77425753) This issue seem quite similar to 37420, that is Closed. Expected behavior GetSecret call does not fails after long timeout. Actual behavior Call to GetSecret randomly fails after many seconds Reproduction Steps Here is the source code of the class calling getSecret API. public class KeyvaultSecretClient : IKeyvaultSecretClient { private static readonly ActivitySource ActivitySource = new ActivitySource(typeof(KeyvaultSecretClient).FullName!, `1.0.0`); private const string GetSecretActivityName = $`{nameof(KeyvaultSecretClient)}:{nameof(GetSecretAsync)}`; private static readonly Regex KeyvaultSecretUnauthorizedCharaters = new Regex(`[^a-zA-Z0-9]`); private static readonly SecretClientOptions KeyvaultSecretClientOptions = new SecretClientOptions() {     Retry =         {             Delay= TimeSpan.FromSeconds(2),             MaxDelay = TimeSpan.FromSeconds(16),             MaxRetries = 5,             Mode = RetryMode.Exponential         } };  private const string KeyvaultUrlPattern = `https://{0}.vault.azure.net`; private readonly DefaultAzureCredential _azureCredentials; private readonly ILogger<KeyvaultSecretClient> _logger;  public KeyvaultSecretClient(     DefaultAzureCredential azureCredentials,     ILogger<KeyvaultSecretClient> logger) {      ArgumentNullException.ThrowIfNull(azureCredentials, nameof(azureCredentials));     ArgumentNullException.ThrowIfNull(logger, nameof(logger));      _azureCredentials = azureCredentials;     _logger = logger; }  public async Task<string> GetSecretAsync(string keyvaultName, string secretName) {     ArgumentNullException.ThrowIfNullOrEmpty(keyvaultName, nameof(keyvaultName));     ArgumentNullException.ThrowIfNullOrEmpty(secretName, nameof(secretName));      using var activity = ActivitySource.StartActivity(GetSecretActivityName);     activity?.AddTag(nameof(keyvaultName), keyvaultName);     activity?.AddTag(nameof(secretName), secretName);      var keyvaultClient = GetKeyvaultClient(keyvaultName);      var cleanedSecretName = CleanSecretName(secretName);     activity?.AddTag(nameof(cleanedSecretName), cleanedSecretName);      try     {          var response = await keyvaultClient.GetSecretAsync(cleanedSecretName);          if (response.Value == null)         {             activity?.SetStatus(ActivityStatusCode.Error);             _logger.LogError($`Secret {secretName} is empty {keyvaultName}`);              throw new KeyvaultSecretNotFoundException($`Secret {cleanedSecretName} not found in keyvault {keyvaultName}`);         }          activity?.AddTag(`secretSize`, response.Value.Value.Length);          return response.Value.Value;     }     catch(RequestFailedException ex)     {         activity?.SetStatus(ActivityStatusCode.Error);         _logger.LogError(ex, $`Failed to get secret {cleanedSecretName} from keyvault {keyvaultName}`);          throw new KeyvaultSecretNotFoundException($`Failed to get secret {cleanedSecretName} from keyvault {keyvaultName}`, ex);     } }  private SecretClient GetKeyvaultClient(string keyvaultName) {     var keyvaultUri = string.Format(KeyvaultUrlPattern, keyvaultName);      var keyvaultClient = new SecretClient(         new Uri(keyvaultUri),          _azureCredentials,         KeyvaultSecretClientOptions);      return keyvaultClient; }  private string CleanSecretName(string secretName) {     return KeyvaultSecretUnauthorizedCharaters.Replace(secretName, `-`); }  } Environment .net 8.0
Mgmt	App Services	[QUERY] How to import certificate from KeyVault when creating/updating an AppService (CreateOrUpdateWebSiteResource)?	Library name and version Azure.ResourceManager 1.12.0 Query/Question I cannot find a working way to import a certificate from KeyVault when creating/updating an AppService (WebSite). I'm am NOT using the certificate for TLS/SSL host binding. The certificate is used by the application code to authenticate with a database service. I have tried this: // First set up WebSiteData (a function app in my case) var webSiteData = new WebsiteData(...);  new CertificateClient(new Uri(_keyVaultUrl), new DefaultAzureCredential()); KeyVaultCertificateWithPolicy vaultCertificate = await certificateClient.GetCertificateAsync(`cert-name`);  webSiteData.HostNameSslStates.Add(new HostNameSslState {     Name = vaultCertificate.Name,     ThumbprintString = vaultCertificate.Properties.X509ThumbprintString,     SslState = HostNameBindingSslState.SniEnabled });  var webSite = (await resourceGroup.GetWebSites().CreateOrUpdateAsync(     WaitUntil.Completed,     `site-name`,     webSiteData )).Value;  But it doesn't show up in the app service certificates when browsing the portal under `Bring your own certificates (.pfx)`.  I haven't found any example code except similar to the webSiteData.HostNameSslStates.Add. If I add the certificate through the portal it works perfect, I just need to be able to do the same using Azure.ResourceManager Environment No response
Client	Event Hubs	[QUERY] The buffered producer took too long to start	Library name and version Azure.Messaging.EventHubs` Version=`5.11.5` Query/Question Hi, I met this error when call the method in the SDK of eventhub. Azure.Messaging.EventHubs.EventHubsException(ServiceTimeout): The buffered producer took too long to start. (xxxxxx).  For troubleshooting information, see https://aka.ms/azsdk/net/eventhubs/exceptions/troubleshoot at Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient.StartPublishingAsync(CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient.EnqueueEventsAsync(IEnumerable1 events, EnqueueEventOptions options, CancellationToken cancellationToken) at MYSERVICE.EventHubBufferedPublisher.SendAsync[T](IEnumerable1 events, String partitionKey, CancellationToken cancellationToken) I think it is one transient problem, not all time I will get this error. I want to know If I get this error, will the event will be lost. In this scenario, it seems the SendEventBatchFailedAsync is not called. Under what circumstances will the FailedAsync or SucceedAsync methods be called? When will the retrytime we configured be used? Does this scenario experience retry? Do I need to customize a retry at the outermost level? Appreciate for your help. Environment No response
Mgmt	Compute	[QUERY] Details on IJsonModel<ManagedDiskData>.Create	Library name and version Azure.ResourceManager.Compute 1.4.0 Query/Question I'm working on unit tests for a C# script that operates on managed disks, so I need to create some dummy disks and fill them with fake data for testing. The documentation for how to do this has been sparse. The way I have been trying to do this is by creating mock ManagedDiskResource objects, and using the IJsonModel.Create method to turn a json string of the fake data into a ManagedDiskData object that I can add to the mock ManagedDiskResource object. However, when I run the tests, IJsonModel.Create successfully executes, and I can retrieve the data with IJsonModel.Write, but when I try to retrieve the data through normal getter methods, it's not there! The data must be stored in the ManagedDiskData object somewhere, but Create() isn't filling out the object's fields with the data as I need it to. I may be formatting the json object incorrectly, but I could not know since I can't find any guidelines for how to format it; I also couldn't find the implementation for the Create method. I've attached the mock class file for reference with what I've described above included. I would like some guidelines for how to correctly format the json (assuming I'm formating incorrectly) and some advice on the intended what to create dummy ManagedDisksResource objects (assuming I'm overcomplicating it). One last note -- I did look for a factory class to create the ManagedDiskResource objects, but there didn't appear to be one. Thanks. MockManagedDiskResource.txt Environment Windows 10, .NET v8, Visual Studio 2022 17.10.6
Client	Azure.Core	[BUG]: Read only access for retry property in clientoptions.cs file	Library name and version Azure.Core Describe the bug In Client options adding we are having retry property as read only property. Adding link of the code for reference. We are having in docs of  retry samples for changing the retry in client options. Could you please let us know whether this is a bug or not. If it is bug could you please fix it Expected behavior It should be have setter and getter for Retry property in client options. Actual behavior Having only getter for the retry property in the clientoptions.cs Reproduction Steps please go through the code
Client	Communication	[BUG]  Azure.Communication.Chat is not mockable	Library name and version Azure.Communication.Chat 1.3.1 Describe the bug The Azure Communication Chat library is not mockable. Especially for a service that I cannot emulate locally, I need to be able to mock out the interactions with it. Expected behavior I would expect the library to adhere to the design guidlines for testability: https://learn.microsoft.com/en-us/dotnet/azure/sdk/unit-testing-mocking?tabs=csharp Actual behavior I cannot mock:  CreateChatThreadResult ChatThreadProperties there's probably many more  Reproduction Steps n/a Environment No response
Client	Functions	ServiceBusClient.AcceptNextSessionAsync logs ServiceBusException as `exception` (not as verbose)  after ServiceTimeout	@johankson the fix was to reduce the severity of this log message. Are you seeing this logged as Verbose?  Originally posted by @JoshLove-msft in #27976 (comment) in our case this is still logged as exception. how can we provide the logTimeoutResourceAsVerbose parameter? whenever we call ServiceBusClient.AcceptNextSessionAsync the expected ServiceBusException with reason ServiceBusFailureReason.ServiceTimeout is logged as an exception to console and application insights. how can we change this behaviour?
Client	Search	[QUERY] Why were index aliases removed from Azure.Search.Documents 11.6.0?	Library name and version Azure.Search.Documents 11.6.0 Query/Question Could you please explain to me what the reasoning is behind removing index aliases from version 11.6.0? What is the proposed approach to rebuild an index without index aliases and without downtime? Environment No response
Client	KeyVault	GetPropertiesOfSecretVersions order of list of versions	Type of issue Missing information Description [Enter feedback here] The list of SecretVersions returned requires an order. From experimenting I deduce the order is oldest to newest. Making the 2nd last item (if present) the 'previous' version. Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.security.keyvault.secrets.secretclient.getpropertiesofsecretversions?view=azure-dotnet Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.Security.KeyVault.Secrets/SecretClient.xml Document Version Independent Id 3a7d6e3f-aacc-d4c6-070c-4f23261e8ca9 Article author @azure-sdk Metadata  ID: 7573bde6-64f2-e198-ef89-5456ca36d793 Service: azure
Mgmt	SQL	[QUERY] Azure SQL Database 2014-04-01 APIs will be retired on 31 October 2025	Library name and version Microsoft.Azure.Management.Sql Query/Question Hello, Recently we've received a e-mail from Microsoft that `Azure SQL Database 2014-04-01 APIs will be retired on 31 October 2025`. We are not using this API directly, but we use Microsoft.Azure.Management.Sql library. I've found that the latest version of your library uses API that will be retired. https://github.com/Azure/azure-sdk-for-net/blob/Azure.ResourceManager.Sql_1.3.0-beta.6/sdk/sqlmanagement/Microsoft.Azure.Management.Sql/src/Generated/DatabasesOperations.cs So the questions: Is there any work to change api version? When should I expect the release of the library which supports newer API? Thanks in advance! Environment .net 8.0
Client	Azure.Identity	[QUERY] Best practices regarding sharing `DefaultAzureCredential` instances across calls	Library name and version Azure.Identity 1.12.0 Query/Question We have a project setup that has 2 connections to Azure AppConfig, both with Azure Vault support, a connection to cosmos, and another connection to Service Bus. The connections to Cosmos and ServiceBus are handled using Microsoft.Extension.Azure's AddAzureClients, which naturally has a centralized means of providing the credential object (it uses DefaultAzureCredential by default behind the scenes). But the AppConfig configuration does not have such `high-level` API and requires us to pass the credential for both app configuration and vault integration using the Connect and ConfigureKeyVault methods. Currently, we are relying on the DefaultAzureCredential class for all of those, but we specify new DefaultAzureCredential() on every single place where it is needed. My question is in regards to reusing instances of this class: is it safe and advisable to reuse a single instance of the DefaultAzureCredential class in scenarios such as ours? Would it be ok, for instance, if we had a static field defined somewhere where we declared a DefaultAzureCredential object only once, and reused that same field throughout the entire application, or if we registered? I've seen this other issue but it wasn't super conclusive to me. It gives the impression that sharing should be ok, but I wanted to confirm it 100% before applying it to our projects and recommending it as a best practice in all of our code.  #36969  Environment N/A
Client	Service Bus	[BUG] Cannot access a disposed object. Object name: 'ClientRegistration'.	Library name and version Azure.Messaging.ServiceBus, Version=7.17.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8 Describe the bug Randomly we get an exception with the message  `Cannot access a disposed object. Object name: 'ClientRegistration'.`  This occurs when we try to read messages from a topic. Here is the stack trace of the error: System.ObjectDisposedException: at Microsoft.Extensions.Azure.ClientRegistration1.GetClient (Microsoft.Extensions.Azure, Version=1.7.4.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Microsoft.Extensions.Azure.AzureClientFactory2.CreateClient (Microsoft.Extensions.Azure, Version=1.7.4.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Infrastructure.ServiceBus.CommandPublisher+d__8`1.MoveNext (ABCD.Infrastructure.ServiceBus, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) Expected behavior We should be able to consume messages from Azure bus topic. Actual behavior Randomly getting the error. At times 20-30 messages fail in quick succession in a day. We normally get 1 million messages to process in a day. Message consumer is hosted in AKS. Reproduction Steps It is a standard setup of message consumption. Environment No response
Client	Functions	[FEATURE REQ]	Library name Microsoft.Azure.WebJobs.Extensions.EventHubs Please describe the feature. Add a configuration option to set a timeout for the output binding. The output binding should throw an error when the operation takes longer than the configured timeout to complete. Background: We have an azure function that uses a cosmosDBTrigger input binding and an Event Hubs output binding. The output binding typically executes within milliseconds, but sometimes it takes a couple of seconds. A couple of days ago, it took 57 seconds. The Azure Function does not complete until the output binding completes, which means that the function execution just hangs. For some functions that might not be a big issue, but some triggers (including CosmosDBTrigger) do not retrigger the function until the previous execution has completed. This means our (quite critical) function did nothing for almost a minute. I am not mad about the 57 second delay. Weird network hickups happen sometimes. But it really should be possible to set a timeout.
Client	KeyVault	Get Key and Secret Metadata that is not attached to Certificates	Type of issue Other (describe below) Description How can I retrieve metadata for keys and secrets from Azure Key Vault using the .NET SDK while ensuring that I exclude any keys and secrets associated with certificates? I know that the managed property can indicate whether an item is related to a certificate, but is it reliable to use this property exclusively to filter out such items? https://learn.microsoft.com/en-us/dotnet/api/azure.security.keyvault.keys.keyclient.getpropertiesofkeys?view=azure-dotnet Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.security.keyvault.keys.keyproperties.managed?view=azure-dotnet Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.Security.KeyVault.Keys/KeyProperties.xml Document Version Independent Id 5b1997b2-68c9-acb4-2a7d-f05a594c1343 Article author @azure-sdk Metadata  ID: 4f4d100d-c76c-ee92-b419-2c1abe6f0a4f Service: azure
Client	Search	Threshold is missing on VectorizedQuery	Type of issue Typo Description Feedback on Azure.Search.Documents.Models.VectorQuery Package: Azure.Search.Documents v11.6.0 Issue Identified: It seems there is confusion or a possible discrepancy regarding the Threshold property in the VectorQuery class. Details: According to the Microsoft documentation, there is a Threshold property associated with VectorQuery. However, it appears that the VectorizedQuery class should inherit the Threshold property from VectorQuery, but currently, VectorQuery does not contain a Threshold property. Potential Issues:  Documentation Error: There might be an error in the documentation where the Threshold property is mentioned, but the actual implementation does not include it. Code Implementation Bug: Alternatively, the VectorQuery class might be intended to include the Threshold property, and its absence could be a bug in the codebase.  Request for Clarification: Could you please confirm whether this issue is a documentation error or a bug in the code implementation? This clarification is essential for developers relying on the accuracy of both the documentation and the API's functionality. Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.search.documents.models.vectorquery?view=azure-dotnet Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.Search.Documents.Models/VectorQuery.xml Document Version Independent Id 6c4d2760-ba6c-0339-348e-b6705b970ae9 Article author @azure-sdk Metadata  ID: fd72d24a-9347-4442-3820-a89d9ec38739 Service: azure
Mgmt	Container Instances	[QUERY] Connecting to ACR using Managed Identity to create ACI	Library name and version Azure.ResourceManager.ContainerInstance 1.2.1 Query/Question Hi All, I am using the samples to create ACI, while all samples appear to cover the public images to use in ACR, I don't see a way to connect to ACR using Managed Identity. Is there a way to achieve this when creating ACI instance programmatically today or is coming in the near term? Thanks much On another note, also tried using Microsoft.Azure.Management.ContainerInstance.Fluent, there is the WithPrivateImageRegistry option that takes username and password but that also doesn't support managed identity. Environment No response
Client	Service Bus	90% of the ServiceBusReceiver.CloseAsync() calls throws `System.TimeoutException: The operation did not complete within the allocated time 00:01:00 for object drain`	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question **feel free ping mazhao@microsoft.com on Teams to discuss 90% of the ServiceBusReceiver.CloseAsync() calls throws the following exception, why and how to resolve ?** System.TimeoutException: The operation did not complete within the allocated time 00:01:00 for object drain. at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result) at Microsoft.Azure.Amqp.ReceivingAmqpLink.c.DrainAsync b__35_1(IAsyncResult r) at System.Threading.Tasks.TaskFactory1.FromAsyncCoreLogic(IAsyncResult iar, Func2 endFunction, Action1 endAction, Task1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.CloseAsync d__74.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Messaging.ServiceBus.ServiceBusReceiver.CloseAsync d__40.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)      calling code: CloseReceiver(), see below      private ServiceBusReceiver m_Receiver;     public async Task CloseReceiverAsync()     {         if (m_Receiver != null && m_Receiver.IsClosed == false)         {             await m_Receiver.CloseAsync().ConfigureAwait(false);             m_Receiver = null;         }     }      public void CloseReceiver()     {         CloseReceiverAsync().GetAwaiter().GetResult();     }  Environment .NET framework
Client	Functions	[QUERY] Create listener at runtime?	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus Query/Question Hi, I've been using the Microsoft.Azure.WebJobs.Extensions.ServiceBus-package to setup methods that act as triggers for ServiceBus subscriptions and it works great. However, the current setup only seem to allow for defining your triggers using the ServiceBusTrigger-attribute where queue/topic name are defined using compile time constants. I saw that you can also implement your own name resolver to get some more flexibility. But I wonder, is it possible to also register triggers through the DI somehow to avoid befing forced to use the attribute? For example, it would be nice if I could do something like this (assuming that ITrigger is an interface from the package) services.AddSingleton<ITrigger, MyCustomTrigger>(); Environment No response
Client	Azure.Identity	[QUERY] Release an Azure.Identity version with an updated Azure.Core dependency	Library name and version Azure.Identity 1.12.0 Query/Question Azure.Core 1.40.0 had an issue (#44817) which was fixed in 1.41.0 (#44882). This causes tasks/applications to intermittently get stuck. The latest Azure.Identity release (1.12.0) still has a dependency on this `broken` version. There's a workaround by adding a direct reference to Azure.Core. But it's easy often not the case. And this issue only comes up sporadically. When will a version of Azure.Identity be released containing the new dependency? Azure.Identity 1.13.0-beta.1 has a newer dependency version. When is it scheduled to be released? Environment No response
Client	Extensions	What permissions does DPAPI PersistKeysToAzureBlobStorage need, and how to handle expiry?	Library name and version Azure.Extensions.AspNetCore.DataProtection.Blobs 1.3.4 Query/Question I have tried looking for information around what permissions the SAS token for this API needs, but I can't find it anywhere. From what I can see, the available permissions are:  Read Add Create Write Delete List Immutable storage  It looks like SAS tokens also must have an expiry. Even though you can set it far in the future, does that mean we need to rotate the SAS tokens? What method for storing DPAPI keys do you recommend? Environment N/A
Client	Extensions	AddCryptographyClient documentation states incorrectly that it adds a `KeyClient`	Type of issue Typo Description The docs state:  Registers a KeyClient instance with connection options loaded from the provided configuration instance.  But the method adds a CryptographyClient (like the name suggests). Page URL https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.azure.keyclientbuilderextensions.addcryptographyclient?view=azure-dotnet&devlangs=csharp&f1url=%3FappId%3DDev17IDEF1%26l%3DEN-US%26k%3Dk(Microsoft.Extensions.Azure.KeyClientBuilderExtensions.AddCryptographyClient%2560%25601)%3Bk(DevLang-csharp)%26rd%3Dtrue Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Microsoft.Extensions.Azure/KeyClientBuilderExtensions.xml Document Version Independent Id 1053cb0e-b8b1-1800-b133-1364f0f5257b Article author @azure-sdk Metadata  ID: 0914cdec-6fdf-9e88-7f46-d76782c0b08d
Client	OpenAI	Properties doesn't have Setter method. How to set its value	Type of issue Missing information Description Namespace: Azure.AI.OpenAI.Chat Assembly: Azure.AI.OpenAI.dll Package: Azure.AI.OpenAI v2.0.0-beta.2 Here public System.Collections.Generic.IList ContentFieldNames { get; } public System.Collections.Generic.IList VectorFieldNames { get; } both the properties doesn't have a setter method. How to set them? I am using azure search index. There I have defined couple of fields as vector data. I want to perform search only on those fields. How can that be acheived if I am not able to set above properties? Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.ai.openai.chat.datasourcefieldmappings.vectorfieldnames?view=azure-dotnet-preview Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.AI.OpenAI.Chat/DataSourceFieldMappings.xml Document Version Independent Id c605ffd8-8757-7f6d-42fe-52be0da558d7 Article author @azure-sdk Metadata  ID: d289e390-7853-83c2-2f4d-5df7b536d110 Service: azure
Client	Azure.Identity	[QUERY] DefaultAzureCredential.GetToken() cache logic	Library name and version Azure.Identity 1.12.0 Query/Question Hi folks, could you help me understand how the cache logic works when using DefaultAzureCredential to get an access token for an Azure resource? For example, we have a storage account that associates with a user-managed identity and we want to auth our app to it using MSI. string userAssignedClientId = `<your managed identity client ID>`; var credential = new DefaultAzureCredential(     new DefaultAzureCredentialOptions     {         ManagedIdentityClientId = userAssignedClientId     });  var token = credential .GetToken(context, cancellationToken);  After searching across different threads, it looks like this credential instance will cache the credential type, and MSAL will cache the auth token on their side (is that true?) while each .GetToken() call will refresh the token in the credential instance. Questions,  What's the difference between with or without ManagedIdentityClientId = userAssignedClientId We have hundreds of nodes across different vmss deployed in different regions and all of them will refresh the access token by calling .GetToken() every 1 min. Is that a good behavior? Or should we implement some cache logic in the app?  Thanks in advance Environment .NET 7
Client	Service Bus	Service Bus : System.ObjectDisposedException: ServiceBusConnection has already been closed and cannot perform the requested operation.	Library name and version Azure.WebJobs.Extensions.ServiceBus 5.2.0, MassTransist.Azure.ServiceBus.Core 7.3.1 Query/Question In our internal application, we are sending more that 100 requests in a day and only few times we are facing 'Service bus connection closed issue'. Below package-version we have installed - And .Net 6.0 Target Framework    This is code from AutoFacrModule.cs how we register ServiceBusFacade protected override void Load(ContainerBuilder builder) { builder.RegisterType<ServiceBusFacade>().As<IServiceBusFacade>(); } This is from Startup.cs public override void Configure(IFunctionsHostBuilder builder)    {        builder.Services.AddDataProtection();                builder.Services.AddMassTransitForAzureFunctions(configurator =>            {                configurator.AddConsumers(typeof(Startup).Assembly);                configurator.AddServiceBusMessageScheduler();            }, connectionStringConfigurationKey: `AzureWebJobsServiceBus`,            (context, cfg) =>            {                cfg.UseMessageData(messageDataRepository);                cfg.Host(settings.AzureWebJobsServiceBus, h =>                {                });                 var queueName = settings.ServiceBusQueueName;                cfg.ReceiveEndpoint(queueName, ec =>                {                    ec.UseMessageRetry(t=>t.Immediate(2));                    ec.ConfigureConsumers(context);                    ec.ConfigureSagas(context);                });                cfg.ConfigureEndpoints(context);                 DependencyInjectionFilterExtensions.UsePublishFilter(cfg, typeof(PublishApplicationContextHeaderFilter<>), context);                DependencyInjectionFilterExtensions.UseSendFilter(cfg, typeof(SendApplicationContextHeaderFilter<>), context);            });         builder.Services.AddLogging();         IContainer container = ConfigureAndBuildContainer(builder.Services);        var mapper = container.Resolve<IMapper>();        AutoMapperFactory.Initialize(() => mapper.ConfigurationProvider);         //let's load what we need to load        var permissionStore = container.Resolve<IPermissionStore>();        permissionStore.Load();        builder.Services.AddSingleton(container);        builder.Services.AddScoped<LifetimeScopeWrapper>();          builder.Services.Replace(ServiceDescriptor.Singleton(typeof(IJobActivator), typeof(AutofacJobActivator)));        builder.Services.Replace(ServiceDescriptor.Singleton(typeof(IJobActivatorEx), typeof(AutofacJobActivator)));    }       IContainer ConfigureAndBuildContainer(IServiceCollection serviceCollection)     {         var builder = new ContainerBuilder();         builder.Populate(serviceCollection);         var settings = new SettingsProvider(configuration);         SettingsProvider.RegisterCurrentProvider(() => settings);         var connectionString = settings.GetConnectionString();              var blobServiceClient = new BlobServiceClient(settings.AzureStorageConnectionString);         messageDataRepository = blobServiceClient.CreateMessageDataRepository(Constants.Integration.MessageDataContainerName);              builder.RegisterModule(new AutofacDefaultServicesModule(settings));         builder.RegisterModule(new AutofacSecurityModule(settings));         builder.RegisterModule(new AutofacValidationModule(new Assembly[]         {                 typeof(Startup).Assembly,                 typeof(BaseLongEntity).Assembly, typeof(IApplicationService).Assembly         }));              builder.RegisterType<LegacyCachedSettingsProvider>()             .WithParameter(`settingKeysToCache`, new List<string>()             {                 Constants.ApplicationSettingConfigKeys.ApplicationDbConnectionStringName,                 Constants.ApplicationSettingConfigKeys.ApplicationName,                 Constants.ApplicationSettingConfigKeys.LegacyProjectId             })             .As<ILegacyCachedSettingsProvider>();              builder.RegisterType<DataExtractionQueriesProvider>().AsSelf();              builder.RegisterModule(new AutofacAuthorizationModule(settings, connectionString));         builder.RegisterModule(new AutofacBusModule(settings,             new Assembly[]             {                     typeof(IApplicationService).Assembly, typeof(Startup).Assembly             }));              builder.RegisterModule<LoggerModule>();         builder.RegisterModule(new AutofacModule(settings, messageDataRepository));         builder.RegisterInstance(ConnectionMultiplexer.Connect(settings.RedisHost))             .As<IConnectionMultiplexer>();              builder.Register<IDatabase>(c => c.Resolve<IConnectionMultiplexer>()             .GetDatabase(settings.RedisDatabaseId));              builder         .RegisterAssemblyTypes(typeof(Startup).Assembly)         .InNamespace(`APPLICATION`)         .AsSelf() // Azure Functions core code resolves a function class by itself.         .InstancePerLifetimeScope();              builder.Register(ctx =>         {             var cacheProvider = ctx.Resolve<ICacheDataAdapter>();             return new IntegrationIdentityProvider(settings, cacheProvider);         }).As<IIdentityProvider>().AsSelf().InstancePerLifetimeScope();              builder.RegisterType<DefaultApplicationSessionIdProvider>().As<IApplicationSessionIdProvider>();              builder.RegisterAssemblyTypes(typeof(Startup).Assembly)             .InNamespaceOf<Functions.HandleQueueMessage>();                  builder.RegisterType<EmailRetriever>().As<IEmailRetriever>();         builder.RegisterType<EmailDataCommitter>().As<IEmailDataCommitter>();              builder.RegisterType<AzFunctionsLogger>().As<ILogger>();              builder.RegisterType<AzFunctionServiceBusFacade>()             .As<IPubSubServiceBus>()             .As<IQueueableServiceBus>()             .As<IScheduleableServiceBus>()             .As<IServiceBusFacade>()             .AsSelf()             .SingleInstance();         //.InstancePerRequest();         //.InstancePerLifetimeScope();              var container = builder.Build();              return container;     }    My Sample Code from where we publish event public async Task Consume(ConsumeContext<ISampleQueueEvent> context) {           try              {                         ISetupEvent servicebusEvent = new SetupEvent()                         {                             var1 = var1                             EventName = $`{nameof(SampleQueueConsumer)}:{nameof(Consume)}`                         };                                                  await context.Publish(servicebusEvent);                                            }     catch (Exception ex)     {         Logger.LogInfo(             $`ERROR in {nameof(ISampleQueueEvent)} ` +             $`ERROR Message: {ex.Message} StackTrace: {ex.StackTrace}`,             ex)                  } }   Call Stack:     System.ObjectDisposedException:    at Azure.Core.Argument.AssertNotDisposed (Azure.Messaging.ServiceBus, Version=7.5.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Messaging.ServiceBus.ServiceBusSender+<SendMessagesAsync>d__26.MoveNext (Azure.Messaging.ServiceBus, Version=7.5.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.ServiceBusSender+<SendMessageAsync>d__25.MoveNext (Azure.Messaging.ServiceBus, Version=7.5.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at MassTransit.Azure.ServiceBus.Core.Transport.ServiceBusSendTransport+SendPipe`1+<Send>d__5.MoveNext (MassTransit.Azure.ServiceBus.Core, Version=7.3.1.0, Culture=neutral, PublicKeyToken=b8e0e9f2f1e657fa)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at MassTransit.Azure.ServiceBus.Core.Transport.ServiceBusSendTransport+SendPipe`1+<Send>d__5.MoveNext (MassTransit.Azure.ServiceBus.Core, Version=7.3.1.0, Culture=neutral, PublicKeyToken=b8e0e9f2f1e657fa)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at GreenPipes.Agents.PipeContextSupervisor`1+<GreenPipes-IPipeContextSource<TContext>-Send>d__7.MoveNext (GreenPipes, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b800c4cfcdeea87b)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at GreenPipes.Agents.PipeContextSupervisor`1+<GreenPipes-IPipeContextSource<TContext>-Send>d__7.MoveNext (GreenPipes, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b800c4cfcdeea87b)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at GreenPipes.Agents.PipeContextSupervisor`1+<GreenPipes-IPipeContextSource<TContext>-Send>d__7.MoveNext (GreenPipes, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b800c4cfcdeea87b)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at MassTransit.Transports.HostConfigurationRetryExtensions+<Retry>d__0.MoveNext (MassTransit, Version=7.3.1.0, Culture=neutral, PublicKeyToken=b8e0e9f2f1e657fa)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.GetResult (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)   Environment No response ### Tasks
Client	Azure.Identity	[BUG] Occasional ManagedIdentity failures	Library name and version Azure.Storage.Blobs` Version=`12.20.0` Describe the bug When using Managed Identity credential and RBAC, the app running on Azure App Service has the correct credentials and network connections. The application will succeed and get all data from blob storage, but somewhere in the middle when the application is running, Managed Identity fails and gets a bad token. This happens intermittently, but the problem is not resolved until app is restarted services.AddAzureClients(x =>         {             if (EnvironmentEx.IsOffline)             {                 x.AddBlobServiceClient(`UseDevelopmentStorage=true`);             }             else             {                 x.AddBlobServiceClient(new Uri(config[`ApplicationConfiguration:BlobUrl`] ?? throw new Exception(`BlobUrl is missing`)));                 x.UseCredential(EnvironmentEx.IsDevelopment ? new AzureCliCredential() : new ManagedIdentityCredential());             }         }); ManagedIdentityCredential.GetToken invoked. Scopes: [ https://storage.azure.com//.default ] ParentRequestId: 7cb8a1ff-5041-46aa-a693-dcb04a13f0e1 False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] MSAL MSAL.NetCore with assembly version '4.61.3.0'. CorrelationId(d196e687-f152-46b0-bee9-d4bbcd4454ae) False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] === AcquireTokenForClientParameters === SendX5C: False ForceRefresh: False False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] === Request Data === Authority Provided? - True Scopes - https://storage.azure.com//.default Extra Query Params Keys (space separated) - ApiId - AcquireTokenForClient IsConfidentialClient - True SendX5C - False LoginHint ? False IsBrokerConfigured - False HomeAccountId - False CorrelationId - d196e687-f152-46b0-bee9-d4bbcd4454ae UserAssertion set: False LongRunningOboCacheKey set: False Region configured: False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] === Token Acquisition (ClientCredentialRequest) started: Scopes: https://storage.azure.com//.default Authority Host: login.microsoftonline.com False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] [Region discovery] Not using a regional authority. False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] Skipping Instance discovery for Aad authority because it is not enabled. False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:08:02Z - d196e687-f152-46b0-bee9-d4bbcd4454ae] Fetched access token from host login.microsoftonline.com.  ManagedIdentityCredential.GetToken invoked. Scopes: [ https://storage.azure.com//.default ] ParentRequestId: 8755a181-7153-469f-82a8-3e8d354f56f9 False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] MSAL MSAL.NetCore with assembly version '4.61.3.0'. CorrelationId(66d07183-a899-497d-8435-ea84f6ce7862) False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] === AcquireTokenForClientParameters === SendX5C: False ForceRefresh: False False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] === Request Data === Authority Provided? - True Scopes - https://storage.azure.com//.default Extra Query Params Keys (space separated) - ApiId - AcquireTokenForClient IsConfidentialClient - True SendX5C - False LoginHint ? False IsBrokerConfigured - False HomeAccountId - False CorrelationId - 66d07183-a899-497d-8435-ea84f6ce7862 UserAssertion set: False LongRunningOboCacheKey set: False Region configured: False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] === Token Acquisition (ClientCredentialRequest) started: Scopes: https://storage.azure.com//.default Authority Host: login.microsoftonline.com False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] [Region discovery] Not using a regional authority. False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] [Instance Discovery] Skipping Instance discovery because it is disabled. False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] [ClientCredentialRequest] Acquiring a token from the token provider. False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] Checking client info returned from the server.. False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.6 Microsoft Windows 10.0.20348 [2024-08-01 13:14:32Z - 66d07183-a899-497d-8435-ea84f6ce7862] Saving token response to cache..  Expected behavior Managed Identity credential consistently works on App Service Actual behavior Managed Identity disconnects and fails to make calls to blob gateway Reproduction Steps services.AddAzureClients(x =>         {             if (EnvironmentEx.IsOffline)             {                 x.AddBlobServiceClient(`UseDevelopmentStorage=true`);             }             else             {                 x.AddBlobServiceClient(new Uri(config[`ApplicationConfiguration:BlobUrl`] ?? throw new Exception(`BlobUrl is missing`)));                 x.UseCredential(EnvironmentEx.IsDevelopment ? new AzureCliCredential() : new ManagedIdentityCredential());             }         }); Environment No response
Client	OpenAI	[QUERY] Unable to find stable package Azure.AI.OpenAI during Docker build	Library name and version Azure.AI.OpenAI 2.0.0-beta.2 Query/Question Hello, I am encountering an issue while building a Docker image for my .NET 8.0 project that includes the Azure.AI.OpenAI package. Despite having the 2.0.0-beta.2 version specified and allowing for pre-release versions, the Docker build fails with the following error: [...]Detection.Api.csproj : error NU1103: Unable to find a stable package Azure.AI.OpenAI with version [...]Detection.Api.csproj : error NU1103:   - Found 19 version(s) in nuget [ Nearest version: 2.0.0-beta.2 ]  Steps to Reproduce:  The Azure.AI.OpenAI package in Directory.Packages.props:  [...] <PackageVersion Include=`Azure.AI.OpenAI` Version=`2.0.0-beta.2` /> [...]   The nuget.config:  <?xml version=`1.0` encoding=`utf-8`?> <configuration>    <config>     <add key=`globalPackagesFolder` value=`.\packages\nuget` />   </config>    <packageRestore>     <add key=`enabled` value=`True` />     <add key=`automatic` value=`True` />   </packageRestore>     <packageSources>     <clear />     <add key=`nuget` value=`https://api.nuget.org/v3/index.json` />   </packageSources>     [...]  </configuration>   The Docker image using the following Dockerfile:  FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base USER app WORKDIR /app EXPOSE 8080 EXPOSE 8081  FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build ARG BUILD_CONFIGURATION=Release WORKDIR /src COPY [`nuget.config`, `.`] COPY [`[...]Detection.Api.csproj`, `src/cmt.Detection.Api/`] RUN dotnet restore `[...]Detection.Api.csproj` --configfile `./nuget.config` COPY . . WORKDIR `[...]Detection.Api` RUN dotnet build `[...]Detection.Api.csproj` -c $BUILD_CONFIGURATION -o /app/build  FROM build AS publish ARG BUILD_CONFIGURATION=Release RUN dotnet publish `[...]Detection.Api.csproj` -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false  FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [`dotnet`, `[...]Detection.Api.dll`]  Observed Behavior: The Docker build fails with error NU1103 stating that it is unable to find a stable package for Azure.AI.OpenAI, even though the specified version is a pre-release. Expected Behavior: The Docker build should succeed, allowing the usage of the pre-release version 2.0.0-beta.2 of Azure.AI.OpenAI. Additional Information:  Local build and restore processes outside Docker work correctly, recognizing and using the specified pre-release version. The issue appears to be specific to the Docker build environment. All packages are managed centrally via Directory.Packages.props.   Any guidance or suggestions to resolve this issue would be greatly appreciated. **Thank you!** Environment  .NET version: 8.0 Docker base images: mcr.microsoft.com/dotnet/sdk:8.0 and mcr.microsoft.com/dotnet/aspnet:8.0
Client	Extensions	[BUG] Thread starvation in Azure extensions for DataProtection	Library name and version Azure.Identity.dll 1.12.0+75fb76... 1.1200.24.31701 Describe the bug We have Azure Web App service on stage environment based on .net 8 and reproducing thread starvation due to Azure.Extensions.AspNetCore.DataProtection. Unfortunately I can't provide a dump, just because I forgot to do it. We are using  Microsoft.AspNetCore.DataProtection (azure keyvault & azure blob storage) for auth cookie. Azure cients with ExcludeManagedIdentityCredential`: false and all other credentials are excluded for all azure clients  Expected behavior Works without thread starvation. My points:  Looks like it stuck forever in loading keys from azure storage, possible inside in AzureBlobXmlRepository. Asp.net should detect long requests and give result, at least log error etc. Link1 Link2 Looks like UseRequestTimeouts does not help here since it will wait result forever also. Asp.net should not process new request if dont have resources. Link1  Actual behavior  Reproducing thread starvation due to Azure.Extensions.AspNetCore.DataProtection. Requests hang forever  Related links to this problem.  Creating two instances of DefaultAzureCredential causes requests using the credential to never complete Azure.Extensions.AspNetCore.DataProtection.Keys Heavy load causes blocked threads 8.0.5 Change - Improve usage of Type.GetType when activating types in data protection  Reproduction Steps Code for registering data protection services     public static IServiceCollection AddDataProtectionFromConfiguration(         this IServiceCollection serviceDescriptors_,          IConfiguration configuration_)     {         serviceDescriptors_.Configure<KeyManagementOptions>(configuration_.GetRequiredSection(DataProtectionConfigurationSections.KEY_MANAGEMENT));          IDataProtectionBuilder dataProtectionBuilder = serviceDescriptors_.AddDataProtection(configuration_.Bind);          AuthenticatedEncryptorConfiguration encryptorConfiguration = new();         configuration_.GetRequiredSection(DataProtectionConfigurationSections.KEY_MANAGEMENT_ALGORITHMS).Bind(encryptorConfiguration);         dataProtectionBuilder.UseCryptographicAlgorithms(encryptorConfiguration);          var keyVaultOptions = configuration_.GetRequiredSection(DataProtectionConfigurationSections.KEY_VAULT).Get<KeyVaultDataProtectionOptions>()!;         if (keyVaultOptions.Enabled)         {             var credential = new DefaultAzureCredential(keyVaultOptions.Credential);             dataProtectionBuilder.ProtectKeysWithAzureKeyVault(new Uri(keyVaultOptions.KeyIdentifier), credential);         }          var blobsConfiguration = configuration_.GetRequiredSection(DataProtectionConfigurationSections.BLOB_STORAGE);         var blobStorageOptions = blobsConfiguration.Get<BlobStorageOptions>()!;         if (blobStorageOptions.Enabled)         {             serviceDescriptors_.AddAzureClients(clientBuilder =>             {                 var credential = new DefaultAzureCredential(blobStorageOptions.Credential);                 clientBuilder                     .AddBlobServiceClient(blobsConfiguration.GetRequiredSection(DataProtectionConfigurationSections.AZURE_CONNECTION_SUBSECTION))                     .WithCredential(credential)                     ;             });              dataProtectionBuilder.PersistKeysToAzureBlobStorage((serviceProvider) =>             {                 return serviceProvider                     .GetRequiredService<BlobServiceClient>()                     .GetBlobContainerClient(blobStorageOpftions.ContainerName)                     .GetBlobClient(blobStorageOptions.BlobName);             });         }          return serviceDescriptors_;     } Logs We can provide more logs in direct communication. Last succeeded request for this behaviour. Looks like we are validating encrypted auth cookie request. For last succeeded request (where we have Existing cached key ring is expired log) we have next logs --CONTINUE--  2024-07-18 10:41:28.435 +00:00 [Information] Microsoft.AspNetCore.Cors.Infrastructure.CorsService => SpanId:32c0228a778d652b, TraceId:fdc2d24122958bd709302f8b246e24d7, ParentId:0000000000000000 => RequestPath:[redacted] RequestId:4000257e-0000-db00-b63f-84710c7967bb: CORS policy execution successful. 2024-07-18 10:41:28.441 +00:00 [Debug] Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingProvider => SpanId:32c0228a778d652b, TraceId:fdc2d24122958bd709302f8b246e24d7, ParentId:0000000000000000 => RequestPath:[redacted] RequestId:4000257e-0000-db00-b63f-84710c7967bb: Existing cached key ring is expired. Refreshing. 2024-07-18 10:41:28.497 +00:00 [Information] Azure.Identity => SpanId:02f70354d5a1d0d2, TraceId:fdc2d24122958bd709302f8b246e24d7, ParentId:dfa2c7e091c7545e => RequestPath:[redacted] RequestId:4000257e-0000-db00-b63f-84710c7967bb: DefaultAzureCredential.GetToken invoked. Scopes: [ https://storage.azure.com/.default ] ParentRequestId: 7d717c75-7a46-4666-a968-1c4db4b8d34f 2024-07-18 10:41:28.533 +00:00 [Information] Azure.Identity => SpanId:02f70354d5a1d0d2, TraceId:fdc2d24122958bd709302f8b246e24d7, ParentId:dfa2c7e091c7545e => RequestPath:[redacted] RequestId:4000257e-0000-db00-b63f-84710c7967bb: ManagedIdentityCredential.GetToken invoked. Scopes: [ https://storage.azure.com/.default ] ParentRequestId: 7d717c75-7a46-4666-a968-1c4db4b8d34f False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.5 Microsoft Windows 10.0.20348 [2024-07-18 10:41:29Z - ca4d36d6-2a05-490e-be3d-e434e25ed1f0] MSAL MSAL.NetCore with assembly version '4.61.3.0'. CorrelationId(ca4d36d6-2a05-490e-be3d-e434e25ed1f0) 2024-07-18 10:41:29.366 +00:00 [Information] Azure.Identity => SpanId:6294de95aa763653, TraceId:fdc2d24122958bd709302f8b246e24d7, ParentId:e7de5b548e59707b => RequestPath:[redacted] RequestId:4000257e-0000-db00-b63f-84710c7967bb: False MSAL 4.61.3.0 MSAL.NetCore .NET 8.0.5 Microsoft Windows 10.0.20348 [2024-07-18 10:41:29Z - ca4d36d6-2a05-490e-be3d-e434e25ed1f0] === AcquireTokenForClientParameters === SendX5C: False ForceRefresh: False  --CONTINUE--  Hanged request 1. Looks like here we are creating encrypted auth cookie response. --CONTINUE--  2024-07-20 09:41:06.278 +00:00 [Debug] Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingProvider => SpanId:72d050fdab0d874c, TraceId:da82c5991211c4752350cdb006de9ea7, ParentId:0000000000000000 => InternalTraceId:1996DC21-FAD1-0000-0000-E6976594FA5B => RequestPath:[redacted] RequestId:400053e7-0000-db00-b63f-84710c7967bb => [redacted]: Existing cached key ring is expired. Refreshing.  --END--  Hanged request 2. --CONTINUE--  2024-07-24 10:09:10.450 +00:00 [Information] Microsoft.AspNetCore.Cors.Infrastructure.CorsService => SpanId:9c5a31fc1f4c5641, TraceId:0ed50ad12e1fecb6c599c1be21dc1348, ParentId:0000000000000000 => RequestPath:[redacted] RequestId:40004af2-0000-dc00-b63f-84710c7967bb: CORS policy execution successful. 2024-07-24 10:09:10.510 +00:00 [Debug] Microsoft.AspNetCore.DataProtection.DecryptorTypeForwardingActivator => SpanId:9c5a31fc1f4c5641, TraceId:0ed50ad12e1fecb6c599c1be21dc1348, ParentId:0000000000000000 => RequestPath:[redacted] RequestId:40004af2-0000-dc00-b63f-84710c7967bb: Forwarded activator type request from Azure.Extensions.AspNetCore.DataProtection.Keys.AzureKeyVaultXmlDecryptor, Azure.Extensions.AspNetCore.DataProtection.Keys, Version=1.2.3.0, Culture=neutral, PublicKeyToken=92742159e12e44c8 to Azure.Extensions.AspNetCore.DataProtection.Keys.AzureKeyVaultXmlDecryptor, Azure.Extensions.AspNetCore.DataProtection.Keys, Culture=neutral  --END--  Environment  OS version: Microsoft Windows NT 10.0.20348.0 64 bit system: True 64 bit process: False Processor count: 1 CLR version: 4.0.30319.42000 8.0.5 runtime installed by Azure on 7/16/2024 4:35 AM UTC. App deployed and single instance started on 2024-07-16 16:19:44.128 +00:00 and still runs until problem detected.  Lib versions in artifact for this deploy  Azure.Core.dll - 1.40.0+242d8a... 1.4000.24.30605 Azure.Identity.dll - 1.12.0+75fb76... 1.1200.24.31701 Azure.Security.KeyVault.Keys - 4.2.0+1a4ecd4... 4.200.21.31503 Azure.Security.KeyVault.Secrets.dll - 4.2.0+1a4ecd4... 4.200.21.31503 Azure.Extensions.AspNetCore.DataProtection.Blobs - 1.3.4+831c24c... 1.300.424.21702 Azure.Extensions.AspNetCore.DataProtection.Keys - 1.2.3+a3a24ef... 1.200.324.11302  On 27.07.2024 we are using latest stable version for all Microsoft libs.
Client	Storage	[BUG] Azure Storage client experiencing culture issues	Library name and version Azure.Messaging.EventHubs.Processor 5.11.4 Describe the bug Version 5.11.3 works fine, but upgrading to 5.11.4 produces a lot of errors when it tries to connect to Event Hub. Exceptions: System.Globalization.CultureNotFoundException at Azure.Storage.StorageSharedKeyPipelinePolicy..cctor on Azure.Storage.StorageSharedKeyPipelinePolicy..cctor. One or more errors occurred. (Failed to compare two elements in the array.) Error Message: `Only the invariant culture is supported in globalization-invariant mode. See https://aka.ms/GlobalizationInvariantMode for more information. (Parameter 'name') en-US is an invalid culture identifier.` The type initializer for 'Azure.Storage.StorageSharedKeyPipelinePolicy' threw an exception. Failed to compare two elements in the array. It happens only when csproj contains:    <InvariantGlobalization>true</InvariantGlobalization> Expected behavior Azure.Messaging.EventHubs.Processor 5.11.4 should work when .NET Core Globalization Invariant Mode is used (    csproj contains   <InvariantGlobalization>true</InvariantGlobalization>). Actual behavior Azure.Messaging.EventHubs.Processor 5.11.4 works only when .NET Core Globalization Invariant Mode is turned off ( csproj contains   <InvariantGlobalization>false</InvariantGlobalization> or the entry is missing). Reproduction Steps  Setup .net 8 to use .NET Core Globalization Invariant Mode Install Azure.Messaging.EventHubs.Processor 5.11.3 Check if works fine. Install Azure.Messaging.EventHubs.Processor 5.11.4 Observe the error  Environment Checked on: Windows 10, and on Linux Debian.
Client	Service Bus	[QUERY] Is it possible to register different ServiceBus clients in DI with different authentication type	Library name and version Azure.Messaging.ServiceBus 7.15.0 Query/Question Hello, we have a scenario that we have several service bus triggers in our Azure function. Some of them need to connect to a service bus using ClientCertificateCredential while one needs to use managed identity. I have this following setup during DI:  services.AddAzureClients(clientBuilder =>             {                 clientBuilder                     .AddServiceBusClientWithNamespace(`namespace 1`)                     .WithCredential(new ManagedIdentityCredential(`managed identity app id`))                     .WithName(`Queue1`);                  clientBuilder.AddClient<ServiceBusReceiver, ServiceBusClientOptions>((_, _, provider) =>                      provider.GetService<IAzureClientFactory<ServiceBusClient>>()                             .CreateClient(`Queue1`)                             .CreateReceiver(`queue 1`)                 );                  clientBuilder                     .AddServiceBusClientWithNamespace(`namespace 2`)                     .WithCredential(                         new ClientCertificateCredential(                                     tenantId: `tenantId`,                                     clientId: `first party app id`,                                     clientCertificate: certificate,                                     new ClientCertificateCredentialOptions()                                     {                                         SendCertificateChain = true,                                         AuthorityHost = new Uri(`https://login.microsoftonline.com/`)                                     })                         )                     .WithName(`Queue2`);                                  clientBuilder.AddClient<ServiceBusReceiver, ServiceBusClientOptions>((_, _, provider) =>                      provider.GetService<IAzureClientFactory<ServiceBusClient>>()                             .CreateClient(`Queue2`)                             .CreateReceiver(`queue 2`)                 );             });  However this setup doesnt seem working as the service bus triggers are not able to start. Could someone one provide me with some guidance? Exception I am seeing in function: Microsoft.Azure.WebJobs.Host.Listeners.FunctionListenerException : The listener for function {name of the Service bus trigger function} was unable to start.  ---> System.InvalidOperationException : Service Bus account connection string 'ScheduleJobServiceBusPrimaryConnection' does not exist. Make sure that it is a defined App Setting.    at Microsoft.Azure.WebJobs.Extensions.ServiceBus.Config.ServiceBusClientFactory.ResolveConnectionInformation(String connection)    at Microsoft.Azure.WebJobs.Extensions.ServiceBus.Config.ServiceBusClientFactory.CreateClientFromSetting(String connection)    at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)    at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication,Boolean useDefaultConstructor)    at System.Lazy`1.CreateValue()    at Microsoft.Azure.WebJobs.ServiceBus.Listeners.ServiceBusListener.<>c__DisplayClass21_0.<.ctor>b__2()    at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Lazy`1.CreateValue()    at async Microsoft.Azure.WebJobs.ServiceBus.Listeners.ServiceBusListener.StartAsync(CancellationToken cancellationToken)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at async Microsoft.Azure.WebJobs.Host.Listeners.FunctionListener.StartAsync(??) at D:\a\_work\1\s\src\Microsoft.Azure.WebJobs.Host\Listeners\FunctionListener.cs : 68    End of inner exception  Environment No response
Client	Service Bus	Microsoft.Azure.ServiceBus MessageHandlerOptions max retry	while using MessageHandlerOptions, var _options = new MessageHandlerOptions(ExceptionReceivedHandler) what is the max retry when error occurs and trigger ExceptionReceivedHandler? is that defaut as 10 times? is that somegthing can be configured inside of code, or the queue itseft? thanks
Mgmt	ARM	[QUERY] How to properly mock extensions methods for ArmClient	Library name and version Azure.ResourceManager.ServiceFabricManagedClusters 1.2.0 Query/Question Hi team. We are trying to write some UTs, in which we need to mock SFMC extension methods (ServiceFabricManagedClustersExtensions class) on ArmClient (e.g. GetServiceFabricManagedClusterResource). We can see description of the method that mentions: `To mock this method, please mock MockableServiceFabricManagedClustersArmClient.GetServiceFabricManagedApplicationTypeResource(ResourceIdentifier) instead.`, however we can't find a way how to do it properly. Do you have any docs or examples we could follow to get an idea about proper mocking? We can see that MockableServiceFabricManagedClustersArmClient is used on top of ArmClient in the extension methods, but all constructors either protected or internal, are we supposed to create derived class and override method there? If so, how do we `connect` that class with extension methods class? We checked this PR: #37927, but it didn't help with ideas on actual usage, and it seems that official docs are also non-existent. Will appreciate any input, thanks! Environment No response
Mgmt	Logic App	[QUERY] Logic App Standard - List Workflow Run Actions	Library name and version Azure.ResourceManager.AppService 1.0.2 Query/Question Is it possible to list the workflow run actions of a Logic App (Standard)? I cannot find anything related in the Azure.ResourceManager.AppService SDK. The GetLogicWorkflowRunActions in the Azure.ResourceManager.Logic SDK works for Logic App Consumption but doesn't seem to work for Standard LA's. Thanks! Environment Windows .Net 8
Client	Service Bus	Is it possible to limit or control the exception message logs when service bus queue is disabled?	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question When the Azure Service bus 's queue status is disabled, the SDK logs the below exception message for every second till becomes active. [2024-07-22 15.13.54.154 fail: Azure.Messaging.ServiceBus]  [QUEUE-NAME]-8d0c9cd6-b856-4cec-95ce-1ad57b4d3bf8-Receiver: ReceiveBatchAsync Exception: Azure.Messaging.ServiceBus.ServiceBusException: Messaging entity 'sb://[QUEUE_URL]' is currently disabled. For more information please see https://aka.ms/ServiceBusExceptions . TrackingId:3b2425f25e794b098f5973269b1826f9_G4, SystemTracker:gateway7, Timestamp:2024-07-22T09:43:54 (MessagingEntityDisabled). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsyncInternal(Int32 maxMessages, Nullable`1 maxWaitTime, TimeSpan timeout, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<ReceiveMessagesAsync>b__44_0>d.MoveNext() --- End of stack trace from previous location ---    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken, Boolean logTimeoutRetriesAsVerbose)    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken, Boolean logTimeoutRetriesAsVerbose)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.ServiceBusReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, Boolean isProcessor, CancellationToken cancellationToken)  Since it logs every second, we don't want to populate the logs and tried to stop the ServiceBusProcessor using StopProcessingAsync(CancellationToken), CloseAsync(CancellationToken) and DisposeAsync methods but it's not returning or timing out when the service bus's queue status is disabled. Do you guys have any workaround to limit or control the time gap between each log? Environment No response
Client	Service Bus	System.ObjectDisposedException at Azure.Messaging.ServiceBus.ServiceBusReceiver	Library name and version Azure.Messaging.ServiceBus 7.17.4 Query/Question Today I found in logs about 3k items within a minute with the following issues:  ServiceBusReceiver has already been closed and cannot perform the requested operation. Object name: 'ServiceBusReceiver'.  It threw the exceptions at the line: var messages = await _receiver.ReceiveMessagesAsync(_config.MaxMessages, _config.MaxWaitTimeout); Despite the above, the app looks healthy and ServiceBus's queues are being processed. My questions are the following:  Why might this happen? Can ServiceBusReceiver recover from the problem on its own? Should I handle this manually?  Environment No response
Client	Search	In the Azure .Net SDK , VectorQuery.KNearestNeighborsCount it seems that this parameter controls the total number of results from the Vector Search returned[QUERY]	Library name and version Azure AI Search client library for .NET - version 11.5.1 Query/Question If the customer is not using exhaustive search then also this parameter controls the number of search results returned. Also for Hybrid Search this parameter is controlling the total no of search results. Is this the expected behavior Environment Using Azure .Net SDK
Client	Azure.Identity	Azure.Identity/1.12.0 - CVE-2024-30105 -  System.Text.Json4.7.2.	Library name and version Azure.Identity/1.12.0 Describe the bug Azure Identity is using System.Text.Json4.7.2. CVE-2024-30105  is applicable GHSA-hh2w-p6rv-4g7w Expected behavior CVE should not present Actual behavior cve is present Reproduction Steps Binary scan of the product Environment visual studio
Client	Azure.Core	Nugget System.Text.Json has a vulnerability before 8.0.4	azure-sdk-for-net/sdk/core/Azure.Core/src/Azure.Core.csproj                    Line 28       in       442f867                                                 <PackageReference Include=`System.Text.Json` />
Client	Service Bus	[BUG] Errant use of TransactionScope causes messages to be silently dropped	Library name and version Azure.Messaging.ServiceBus 7.14.4 Describe the bug A user program making use of Service bus through an abstract interface used TransactionScope for its internal purposes, not knowing that Service Bus also honors it. Messages were dropped intermittently that were meant to be sent, with no indication back to the user program. Only if    using (AzureEventSourceListener listener = AzureEventSourceListener.CreateConsoleLogger(EventLevel.Verbose))    {     //  o o o user code here is added, Is the warning message issued: [Warning] Azure-Messaging-ServiceBus: RunOperation encountered an exception and will retry. Exception: Azure.Messaging.ServiceBus.ServiceBusException: Transaction hasn't been declared yet, or has already been discharged (GeneralError). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<SendBatchInternalAsync>d__23.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<SendBatchInternalAsync>d__23.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<>c.<<SendAsync>b__24_0>d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<>c__22`1.<<RunOperation>b__22_0>d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Threading.Tasks.ValueTask`1.get_Result()    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<RunOperation>d__23`2.MoveNext()  It would seem that such an error would be raised as an exception.  Also, don't believe there is any retry, so I `expect` this kind of error was added to the wrong exception category. Expected behavior I would expect such a non-transient error to be signalled to the user code so it may be retried.  By definition, a transaction cannot be retried by the SDK. Actual behavior The warning message above is issued, but UNLESS the user turns on all the diagnostic tracing, the sent messages seem to be sent fine, but just go missing. Reproduction Steps For this problem, I don't believe a code example is necessary. Environment This is a Framework 4.7.2 project running on Windows in a VM in Azure running Windows 10, but not sure this matters.
Client	Cognitive - Form Recognizer	[QUERY] How can I write a test against AnalyzeResult which is a result of DocumentIntelligenceClient.AnalyzeDocument	Library name and version AzureAI.DocumentIntelligence 1.0.0-beta.2 Query/Question I want to write a unit test against a result of DocumentIntelligenceClient.AnalyzeDocument, I mean AnalyzeResult. var client = new DocumentIntelligenceClient(new Uri(endpoint), new AzureKeyCredential(apiKey)); var content = new AnalyzeDocumentContent() {     Base64Source = BinaryData.FromBytes(File.ReadAllBytes(`table.pdf`)) }; Operation<AnalyzeResult> operation = client.AnalyzeDocument(WaitUntil.Completed, `prebuilt-layout`, content); AnalyzeResult result = operation.Value;   // <<< I want to write a test against this result.  Please note that I don't need to verify AnalyzeDocument or such, instead I want a test with the AnalyzeResult which contains paragraphs, or tables, or so on. A problem is that I couldn't figure out how to create an instance of AnalyzeResult or mock it since its constructor is internal. https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/documentintelligence/Azure.AI.DocumentIntelligence/src/Generated/AnalyzeResult.cs Environment No response
Client	Azure.Identity	[BUG] Unpredictable behavior that leads to tasks being indefinitely stalled.	Library name and version Azure.Core 1.40.0 Describe the bug We encountered unpredictable behavior and threading issues since upgrading to Azure.Identity 1.12.0, which we believe stems from a bug in Azure.Core 1.40.0. The problem leads to tasks or threads being indefinitely stalled. In our efforts to pinpoint the cause, we analyzed a memory dump of our service, revealing that tasks are stuck in a method at BearerTokenAuthenticationPolicy L425 in Azure.Core. Further examination indicated that a commit to Azure Core in May introduced this bug. The issue occurs under specific conditions when the authentication token has expired, and the background refresh token attempt has failed or been canceled, causing CurrentTokenTcs.Task in L425 to remain unfulfilled and the waiting thread to be permanently blocked. Teams link Expected behavior The task should not get stuck. Actual behavior The problem leads to tasks or threads being indefinitely stalled. Reproduction Steps We were not able to reproduce the issue. Though, from the code, it's obvious that the issue happens when the authentication token has expired, and the background refresh token attempt has failed or been canceled. Environment No response
Mgmt	Cost Management - Query	[BUG] Cost Management Query usage - include Tags column	Library name and version Azure.ResourceManager.CostManagement, 1.0.1 Describe the bug I can generate usage query IF I do not include Tags column via the SDK e.g. query.Dataset.Columns.Add(`Tags`); this can be done via raw JSON/http client and receives 200, c# code as above with the line included gets 400, 200 without this include column looking at the code for this collection of columns and request serialization, there seems to be mismatch in the expected name include (expected) vs configuration (sdk code) Expected behavior http 200 received Actual behavior http 400 received Reproduction Steps full sample code  QueryDefinition query = new(ExportType.ActualCost, TimeframeType.Custom, new QueryDataset())   {      TimePeriod = new QueryTimePeriod(request.ReportRequest.CostFrom, request.ReportRequest.CostTo),                      };   query.Dataset.Granularity = new GranularityType(`None`);  query.Dataset.Columns.Add(`Tags`);  query.Dataset.Aggregation.Add(`totalCost`, new QueryAggregation(`Cost`, `Sum`));  query.Dataset.Grouping.Add(new QueryGrouping(QueryColumnType.Dimension, request.GroupingMode == GroupingMode.Resource ? `ResourceId` : `SubscriptionId`));   var sdkresponse = await armClient.UsageQueryAsync(new ResourceIdentifier(subId), query);  Environment .net core 8 under dapr app .NET SDK: Version:           8.0.302 Commit:            ef14e02af8 Workload version:  8.0.300-manifests.5273bb1c MSBuild version:   17.10.4+10fbfbf2e Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.302\ .NET workloads installed: [aspire] Installation Source: VS 17.10.35013.160 Manifest Version:    8.0.0/8.0.100 Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.0.0\WorkloadManifest.json Install Type:        FileBased Host: Version:      8.0.6 Architecture: x64 Commit:       3b8b000a0e .NET SDKs installed: 8.0.302 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.6 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found
Mgmt	Network	[BUG] Cannot remove WAF policy association from App Gateway HttpListener	Library name and version Azure.ResourceManager.Network 1.8.0 Describe the bug When trying to remove the association of a waf policy from an App Gateway http listener, an exception is thrown Expected behavior The WAF Policy association is removed from HttpListener Actual behavior The WAF Policy association is not removed from HttpListener. Error message:  System.AggregateException: One or more errors occurred. (The activity function 'WafInstancePolicyActivity' failed: `Cannot parse the request. Status: 400 (Bad Request) ErrorCode: InvalidRequestFormat Content: { `error`: { `code`: `InvalidRequestFormat`, `message`: `Cannot parse the request.`, `details`: [ { `code`: `MissingJsonReferenceId`, `message`: `Value for reference id is missing. Path properties.httpListeners[7].properties.firewallPolicy.` } ] } } at Azure.ResourceManager.Network.ApplicationGatewaysRestOperations.CreateOrUpdateAsync(String subscriptionId, String resourceGroupName, String applicationGatewayName, ApplicationGatewayData data, CancellationToken cancellationToken) at Azure.ResourceManager.Network.ApplicationGatewayCollection.CreateOrUpdateAsync(WaitUntil waitUntil, String applicationGatewayName, ApplicationGatewayData data, CancellationToken cancellationToken)  Reproduction Steps Here is the code snippet var appGatewayGroup = `<Gateway_Resource_Group_Name>`; var subscriptionId = `<SUBSCRIPTION_ID>`; var listenerName = `<LISTENER_NAME>`; var appGateWayName = `<APP_GATEWAY_NAME>`;  var credential = new ChainedTokenCredential(new ManagedIdentityCredential(),     new DefaultAzureCredential());  var client = new ArmClient(credential, subscriptionId);   var subscription = await client.GetDefaultSubscriptionAsync().ConfigureAwait(false);   var rg = await subscription.GetResourceGroupAsync(appGatewayGroup).ConfigureAwait(false);  var appGateway = (await rg.Value.GetApplicationGatewayAsync(appGateWayName)                 .ConfigureAwait(false)).Value;       var listener = appGateway.Data.HttpListeners.SingleOrDefault(l => string.Equals( l.Name ,listenerName, StringComparison.OrdinalIgnoreCase));  if (listener != null)  {  listener.FirewallPolicyId = null;  var updateCollection = rg.Value.GetApplicationGateways();  var operation = await updateCollection.CreateOrUpdateAsync(WaitUntil.Completed, appGateWayName, appGateway.Data) .ConfigureAwait(false);              }  Environment .net 6 in-process Azure Function
Client	OpenAI	[BUG] Azure OpenAI Assistants (C#) do not work as expected (mixing up roles etc)	Library name and version Azure.AI.OpenAI.Assistants 1.0.0-beta.4 Describe the bug Assistants created with the SDK do not handle responses as expected. For example, when instructed to act as a customer and user to be the salesperson, it acts as a salesperson and expects the user to be a customer. It other times it returns a paragraph from the instruction prompt (paragraph that contains the examples of interactions). I have tested the same prompt on the same model deployment with Assistants playground and it works as expected. Expected behavior Assistants created with the SDK should respond in the same way assistants created in the playground do. Actual behavior Mixing up roles, replaying back with big parts of the system prompt. Reproduction Steps Can give you the exact prompt but would like to keep it private. So, DM me please. Environment .NET 8.0
Client	Storage	[BUG] Storage operations are hanging	Library name and version Azure.Identity 1.12.0 Describe the bug Azure.Identity version 1.12.0 causes the services to hang upon storage operations Recently i upgraded the Azure.Identity NuGet from version 1.1.14 to 1.12.0 and started to experience problems when performing io operations vs the storage account (mostly reading and writing blobs). the services depending in this NuGet just hanged and didn't complete their read, write operations. i had to downgrade the NuGet back to 1.1.14 where things work as expected. Expected behavior IO operations (read and writing blobs form a storage account) don't hang. i.e calling to BlobClient.OpenWriteAsync will result in a response Actual behavior IO operations (read and writing blobs form a storage account) hang. i.e calling to BlobClient.OpenWriteAsync hangs and no response recieved Reproduction Steps use azure,identity  1.12.0 and try to read io operations on storage blobs such as BlobClient.OpenWriteAsync, the operation hangs (not all the time) Environment No response
Client	Azure.Identity	Regarding misleading  AuthenticationFailedException - The current credential is not configured to acquire tokens for tenant....	Library name and version Azure.Identity 1.7.+ Describe the bug Scenario App => Storage Account/Blob service using AzureIdentity/ClientSecretCredential flow. Our app registered in Azure AD as single tenant only Details We are using this library (ClientSecretCredential) to setup token credentials for calling blob service Below is configuration Library Azure.Identity 1.7.0 Language/Framework  - .NET 8, C# Configuration appsettings.json `AzureAd`: {  `Tenant`: `<Tenant_Domain>` `TenantId`: <Tenant_Guid>   .   .  }  We use below code to setup blob service client. Code snippet var credential = new ClientSecretCredential(**config.Tenant**, config.ClientId, config.ClientSecret, tokenCredentialOptions); BlobServiceClient mainClient = new BlobServiceClient(storageUri, credential);   This will setup credentials so as to call storage service from our app service. This is the setup, and we are using valid Tenant while initializing credentials and our app is also not multitenant or does not require any other tenant Expected behavior AcquireToken calls to storage service should be successful . I Calls working fine for version before 1.7.0 Started giving failures/intermittent issues after 1.7+ Actual behavior Now we are getting Authentication exception while acquiring tokens, its intermittent The current credential is not configured to acquire tokens for tenant  ``. I understand check added in AZure.Idenityt (1.7+) for multitenant apps but due to this our existing apps flow started breaking,  and we need major code changes to fix this  Library should treat Tenant domain/TenantId both as valid while acquiring tenant because both are valid to use for acquiring tenant The exception is misleading as well, because caller itself used <Tenant_Domain> during setup of credentials. App is not multitenant either  Reproduction Steps Provided as above Environment .NET 8 Azure Function App (Isolated)
Client	OpenAI	My version is not in this enum	azure-sdk-for-net/sdk/openai/Azure.AI.OpenAI/src/Custom/AzureOpenAIClientOptions.cs                    Line 24       in       6adc0dc                                                 _version = version switch                     I have access to a private preview version that is not listed. How can I set the version number being sent by the AzureOpenAIClient?
Client	OpenAI	[QUERY] Integrating Azure AD Token Authorization in .NET by passing authorization token	Library name and version Azure.AI.OpenAI --version 2.0.0-beta.2 Query/Question Hello, I am currently using Azure AD token to authorize the client in Python and it's working fine with the Python library. Here is the relevant code snippet from the Python library:  https://github.com/openai/openai-python/blob/6316b7c0f182877e578a3dbed2fd129b63538af5/src/openai/lib/azure.py#L291 However, I am facing difficulties when trying to implement the same in .NET. Currently, my only option is to create my own HTTP client and make REST calls and passing request header Authorization :  Bearer ****   It would be great if you could provide some guidance or point me to the relevant documentation or examples. Any help would be greatly appreciated. Thank you. Environment Windows 11 dotnet 6
Client	Azure.Identity	[BUG] Persistence check failed exception on Windows	Library name and version azure.identity 1.10.4 Describe the bug An error occured while we use .Net Azure.Identiy named persistent token cache options. Code: TokenCredential tokenCredential = new ClientCertificateCredential(              TenantId,              ClientId,              authCert,              new ClientCertificateCredentialOptions              {                 SendCertificateChain = true,                 TokenCachePersistenceOptions = new TokenCachePersistenceOptions                 {                    Name = $`{Id}-{ClientId}`                 }              }          );  TableServiceClient tableServiceClient = new TableServiceClient(                 new Uri(tableUrl),                 tokenCredential,                 DefaultTableClientOptions             );     TableClient tableClient = tableServiceClient.GetTableClient(tableName);  Pageable<EntityNew> records = tableClient.Query<EntityNew>(); List<X> ips = new List<X>(); foreach (EntityNew record in records) {     if (!string.IsNullOrWhiteSpace(record.X))     {     ...         }     } }            Exception: Azure.Identity.AuthenticationFailedException: ClientCertificateCredential authentication failed: Persistence check failed. Data was written but it could not be read. Possible cause: on Linux, LibSecret is installed but D-Bus isn't running because it cannot be started over SSH.  See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/clientcertificatecredential/troubleshoot ---> Microsoft.Identity.Client.Extensions.Msal.MsalCachePersistenceException: Persistence check failed. Data was written but it could not be read. Possible cause: on Linux, LibSecret is installed but D-Bus isn't running because it cannot be started over SSH.     at Microsoft.Identity.Client.Extensions.Msal.Storage.VerifyPersistence()     at Azure.Identity.MsalCacheHelperWrapper.VerifyPersistence()     at Azure.Identity.TokenCache.<GetCacheHelperAsync>d__26.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at Azure.Identity.TokenCache.<GetCacheHelperAsync>d__26.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Identity.TokenCache.<RegisterCache>d__21.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Identity.MsalClientBase`1.<GetClientAsync>d__26.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Identity.MsalConfidentialClient.<AcquireTokenForClientCoreAsync>d__21.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Identity.MsalConfidentialClient.<AcquireTokenForClientAsync>d__20.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Identity.ClientCertificateCredential.GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)     --- End of inner exception stack trace ---     at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable)     at Azure.Identity.ClientCertificateCredential.GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)     at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.<GetHeaderValueFromCredentialAsync>d__9.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.<GetHeaderValueAsync>d__6.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.<GetHeaderValueAsync>d__6.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AuthenticateAndAuthorizeRequest(HttpMessage message, TokenRequestContext context)     at Azure.Data.Tables.TableBearerTokenChallengeAuthorizationPolicy.<AuthorizeRequestInternal>d__6.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Data.Tables.TableBearerTokenChallengeAuthorizationPolicy.AuthorizeRequest(HttpMessage message)     at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.<ProcessAsync>d__11.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.RedirectPolicy.<ProcessAsync>d__7.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Core.Pipeline.RedirectPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__5.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__5.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at Azure.Core.Pipeline.RetryPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)     at Azure.Core.Pipeline.HttpPipeline.Send(HttpMessage message, CancellationToken cancellationToken)     at Azure.Data.Tables.TableRestClient.QueryEntities(String table, Nullable`1 timeout, String nextPartitionKey, String nextRowKey, QueryOptions queryOptions, CancellationToken cancellationToken)     at Azure.Data.Tables.TableClient.<>c__DisplayClass56_0`1.<Query>b__0(Nullable`1 pageSizeHint)     at Azure.Core.PageableHelpers.FuncPageable`1.<AsPages>d__4.MoveNext()     at Azure.Pageable`1.<GetEnumerator>d__8.MoveNext()  Expected behavior No exception Actual behavior threw Persistence check failed exception Reproduction Steps Randomly happened multiple times in multiple services. Most frequently after a reboot of VM. But Not necessarily. Environment Server OS Version 6.3 (20348) - Windows Server 2022 Datacenter .Net Framework 4.7.2 `nuget`: [ { `id`: `azure.core`, `version`: `1.36.0`, `platform`: `windows` }, { `id`: `azure.identity`, `version`: `1.10.4`, `platform`: `windows` }
Client	Service Bus	[QUERY] Monitoring ServiceBusProcessor	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question I am using the ServiceBusProcessor class to handle processing messages in the background of our asp.net application. Is there a way for us to monitor and alert whether the processors are still healthy and attempting to receive messages? I have seen in logs messages like: info: Azure.Messaging.ServiceBus[7] => SpanId:89251b9b75bfa1a2, TraceId:8b65abf017c608b5d3a4640e9b0a4310, ParentId:0000000000000000 Name-Receiver: ReceiveBatchAsync start. MessageCount = 1  Are logged, but is there any similar metric emitted so that we can effectively monitor our receivers to ensure that there's always one or more receivers available? Environment dotnet --info  global.json file:   Not found  Host:   Version:      6.0.31   Architecture: x64   Commit:       e2ca2f8a1c  .NET SDKs installed:   No SDKs were found.  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.31 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.31 [/usr/share/dotnet/shared/Microsoft.NETCore.App]  Download .NET:   https://aka.ms/dotnet-download  Learn about .NET Runtimes and SDKs:   https://aka.ms/dotnet/runtimes-sdk-info
Client	Azure.Core	[BUG] Unable to use Multipart Form data content types with Azure Core functionalities.	Library name and version Azure.Core Describe the bug Here MultiPartFormDataContent is internal class but generally we use MultiPartFromDataContent which comes from System.Net.Http is a public class. How can we utilize Azure's internal MultipartFormDataContent class in our APIs to create an API with multipart content type? Expected behavior MultiPartFormDataContent should be public class right? Actual behavior Unable to get the instance of the class from the Azure.Core namespace Reproduction Steps Create a sample application and try to create likedata =new Azure.Core.MultipartFormDataContent() Environment No response
Client	Azure.Core	Does uploading files by azure core is supported	Library name and version Azure.Core Query/Question I am providing the sample code for uploading PDF file to the server through Http. Conetnt type of API is multimedia format. var client = new HttpClient();  var request = new HttpRequestMessage(HttpMethod.Post, API_end_point); request.Headers.Add(`Authorization`, `Bearer  token`); var content = new MultipartFormDataContent();  string directoryPath = @`C:\folder`;  // File name string fileName = `a.pdf`;  // Combine directory path and file name string filePath = Path.Combine(directoryPath, fileName); var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read); content.Add(new StreamContent(stream), `stream`, fileName);  request.Content = content; var response = await client.SendAsync(request); response.EnsureSuccessStatusCode(); Console.WriteLine(await response.Content.ReadAsStringAsync());   How can I create an API (Multi Part Form Data Content)  using Azure Core functionalities and include client diagnostics? Could you provide a code snippet? Thanks in advance Environment No response
Mgmt	SQL	[FEATURE REQ] SqlDatabaseResource.ExportAsync() / DatabaseExportDefinition to allow Managed Identity	Library name Azure.ResourceManager.Sql Please describe the feature. Currently, the DatabaseExportDefinition class constructor will only accept an Azure Storage access key and SQL Server username and password. Two of the recommendations from Microsoft Defender for Cloud are: `Storage accounts should prevent shared key access` and `Azure SQL Database should have Azure Active Directory Only Authentication enabled`. Both of these are considered `critical` recommendations. We have a WebJob that triggers a database export each night, which I don't think is an un-common scenario. With the export functionality as it is, we could not possibly achieve the two recommendations of Microsoft Defender for Cloud. This seems especially important on the destination storage account, because it contains customer data in .bacpac files not protected in any other way.
Client	KeyVault	[BUG] Clarification on Handling Escape Characters in Azure Key Vault Secrets	Library name and version Azure.Security.KeyVault.Secrets 4.5.0 Describe the bug When storing RSA private keys or any multi-line secrets in Azure Key Vault, the newline characters are being escaped (\n), which leads to the secret being improperly formatted when retrieved. This causes issues when the secret is intended to be used in its original multi-line format, such as with RSA private keys for SSH connections. This issue was first reported here: #39434 but the explanation provided doesn't fully address the practical issue developers face. While it's true that a backslash (\) is an escape character in many languages, Azure Key Vault should store and retrieve secrets exactly as entered, without modifying the data. The escape character handling should be managed within the application code, not by the Key Vault service. This ensures that developers can securely and accurately store and retrieve secrets without additional transformations, which can lead to confusion and potential security risks. Expected behavior Azure Key Vault should store and retrieve secrets exactly as entered, preserving all formatting, including newline characters, without adding escape sequences. Actual behavior When storing multi-line secrets, such as RSA private keys, in Azure Key Vault, newline characters are being escaped (\n) in the retrieved secret. This results in a single-line string with \n literals instead of actual newlines, causing issues with parsing and using the secret in its intended multi-line format. Reproduction Steps  Store a multi-line RSA private key in Azure Key Vault. Retrieve the secret. Observe that newline characters are escaped, leading to a single-line string with \n instead of proper newlines.  Environment I am using the Secrets feature within Azure Container Apps
Client	Cognitive - Form Recognizer	AnalyzeDocumentFromUriAsync Does not exist	Type of issue Code doesn't work Description I'm very confused on which API I should be using using Azure.AI.DocumentIntelligence; using Azure.AI.FormRecognizer; I tried the code sample provided, and it has no method called AnalyzeDocumentFromUriAsync 'DocumentIntelligenceClient' does not contain a definition for 'AnalyzeDocumentFromUriAsync' and no accessible extension method 'AnalyzeDocumentFromUriAsync' accepting a first argument of type 'DocumentIntelligenceClient' could be found (are you missing a using directive or an assembly reference?)CS1061 Sample code: var client = new DocumentIntelligenceClient(new Uri(endpoint), new AzureKeyCredential(apiKey));         Console.WriteLine(`Analyzing document from URL...`);         AnalyzeDocumentOperation operation = await client.AnalyzeDocumentFromUriAsync(WaitUntil.Completed, `prebuilt-layout`, fileUri);         AnalyzeResult result = operation.Value;          foreach (DocumentPage page in result.Pages)         {             Console.WriteLine($`Document Page {page.PageNumber} has {page.Lines.Count} line(s), {page.Words.Count} word(s),`);             Console.WriteLine($`and {page.SelectionMarks.Count} selection mark(s).`);              for (int i = 0; i < page.Lines.Count; i++)             {                 DocumentLine line = page.Lines[i];                 Console.WriteLine($`  Line {i} has content: '{line.Content}'.`);                  Console.WriteLine($`    Its bounding polygon (points ordered clockwise):`);                  for (int j = 0; j < line.BoundingPolygon.Count; j++)                 {                     Console.WriteLine($`      Point {j} => X: {line.BoundingPolygon[j].X}, Y: {line.BoundingPolygon[j].Y}`);                 }             }  Page URL https://learn.microsoft.com/en-us/dotnet/api/overview/azure/ai.formrecognizer-readme?view=azure-dotnet Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/api/overview/azure/latest/ai.formrecognizer-readme.md Document Version Independent Id ed88679a-395f-a658-010c-4fdeea56eade Article author @azure-sdk Metadata  ID: 503d323c-17e3-43dc-2b67-2b8595e5ac84 Service: formrecognizer
Client	Service Bus	[QUERY] `Invalid Audience` error instead of `Entity Not Found`	Library name and version Azure.Messaging.Servicebus 7.14.0 Query/Question Previous Issue 36838 Regarding the previous issue, I should expect ` 404 messaging entity not found` but I am starting to get `401 Invalid Audience`. Did something change at the service level where the exception is reported differently now? This used to work until yesterday when the exception was `messaging entity not found` and I handled it in my code and it has changed to `Invalid Audience`. Note that this happens if I use SasToken generated for a particular queue. Previously, this worked for both connection string and long-lived-sas-connection-string generated for a given queue. Need inputs on whether the service level exception behaviour and if the return error codes have changed. Environment No response
Client	Search	[BUG] EntityRecognitionSkill is deprecated, but EntityRecognitionSkillV3 is not public	Library name and version Azure.Search.Documents 11.6.0-beta.4 Describe the bug I'm trying to check out document indexers and though it would be cool to try EntityRecognitionSkill. I've defined a skillset configuration, but when I tried to push it configuration, I got the following error: Azure.RequestFailedException: Skillset 'docs-v1-skillset' contains a skill of type 'Microsoft.Skills.Text.EntityRecognitionSkill' which is not supported in this API version. Refer https://go.microsoft.com/fwlink/?linkid=2036733 for details and recommendations  Status: 400 (Bad Request)  Content: {`error`:{`code`:``,`message`:`Skillset 'docs-v1-skillset' contains a skill of type 'Microsoft.Skills.Text.EntityRecognitionSkill' which is not supported in this API version. Refer https://go.microsoft.com/fwlink/?linkid=2036733 for details and recommendations`}}  Reading the linked article diagonally, I found that EntityRecognitionSkill is deprecated, but there is EntityRecognitionSkillV3. Unfortunately, I'm unable to reference the type from the library, because it is marked as internal. I'm also unable to recreate v3 skill, since SearchIndexerSkill has no public constructors exposed. Here's a workaround I'm currently using which allows me to create a skillset: typeof(EntityRecognitionSkill)             .GetProperty(`ODataType`, BindingFlags.Instance | BindingFlags.NonPublic)!             .SetValue(skill, `#Microsoft.Skills.Text.V3.EntityRecognitionSkill`); Expected behavior EntityRecognitionSkillV3 is public and able to be referenced from client code. Actual behavior EntityRecognitionSkillV3 is internal and blocked from referencing by client code. Reproduction Steps private static EntityRecognitionSkillV3 CreatePersonsRecognitionSkill() =>         new(             new List<InputFieldMappingEntry>             {                 new(`text`)                 {                     Source = `/document/pages/*`                 }             },             new List<OutputFieldMappingEntry>             {                 new(`persons`)             })         {             Categories =             {                 `Person`             }         }; Environment No response
Client	Service Bus	[QUERY] Calling CloseAsync() or DisposeAsync() on ServiceBusProcessor throws exception with reason ServiceBusFailureReason.MessagingEntityNotFound	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question I keep track of  topic subscriptions in a concurrent dictionary: private readonly ConcurrentDictionary<string, ServiceBusProcessor> _subscriptions = new(); and when I want to clear out an entry from _subscriptions, I call CloseAsync() on the ServiceBusProcessor associated with the topic.   var removed = _subscriptions.TryRemove(topicName, out var servicBusProcessor);   if (servicBusProcessor!= null)   {       await servicBusProcessor.CloseAsync();   }  The call await servicBusProcessor.CloseAsync(); throws ServiceBusException with the reason: ServiceBusFailureReason.MessagingEntityNotFound Is that normal behavior? I wouldn't expect an exception. Environment Windows 11, .NET 8
Client	Search	[BUG] Synonym Maps >> Index, `modelName` Error	Library name and version Azure.Search.Documents 11.6.0-beta.4 Describe the bug When attempting to programmatically create a synonym map on Azure AI Search Index, configured with a vectorizer, an error indicates that the 'modelName' parameter is required in API version '2024-05-01-preview'. Expected behavior The synonym map should be created and added to the specified column. Actual behavior The following error is encountered: Azure.RequestFailedException HResult=0x80131500 Message=The request is invalid. Details: definition : Error in Vectorizer 'myVectorizer' : 'modelName' parameter is required in API version '2024-05-01-preview'. Status: 400 (Bad Request) Content: {`error`:{`code`:``,`message`:`The request is invalid. Details: definition : Error in Vectorizer 'myVectorizer' : 'modelName' parameter is required in API version '2024-05-01-preview'.`}} Headers: Cache-Control: no-cache,no-store Pragma: no-cache Server: Microsoft-IIS/10.0 client-request-id: a637f2e1-0fb7-4012-916c-1c193f2020a3 x-ms-client-request-id: a637f2e1-0fb7-4012-916c-1c193f2020a3 request-id: a637f2e1-0fb7-4012-916c-1c193f2020a3 elapsed-time: 78 Strict-Transport-Security: REDACTED Date: Wed, 19 Jun 2024 18:10:15 GMT Content-Length: 187 Content-Type: application/json; charset=utf-8 Content-Language: REDACTED Expires: -1 Source=Azure.Search.Documents StackTrace: at Azure.Search.Documents.IndexesRestClient.d__15.MoveNext() at Azure.Search.Documents.Indexes.SearchIndexClient.d__48.MoveNext() at AzureSolutions.Helpers.AISearch.SynonymMap.d__0.MoveNext() in C:\Users\rchapler\OneDrive - Microsoft\repos\AzureSolutions_Helpers\AzureSolutions\Helpers\AISearch\SynonymMap.cs:line 36 at Program.<AISearch_Create_SynonymMap>d__9.MoveNext() in C:\Users\rchapler\OneDrive - Microsoft\repos\AzureSolutions_Helpers\Tester\Program.cs:line 201 at Program.d__0.MoveNext() in C:\Users\rchapler\OneDrive - Microsoft\repos\AzureSolutions_Helpers\Tester\Program.cs:line 12 ...specifically at line: await Index.Client(AISearch_Name,AISearch_Key).CreateOrUpdateIndexAsync(index.Value); Reproduction Steps I have a Helper Class named SynonymMap.cs which includes Create: public static async Task Create( string AISearch_Name, string AISearch_Key, string AISearch_Index_Name, string AISearch_SynonymMap_Name, string SynonymsJson_Path ) { string j = File.ReadAllText(Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, SynonymsJson_Path))); var d = JsonSerializer.Deserialize<List<List>>(json: j, options: new() { PropertyNameCaseInsensitive = true }); string synonyms = d == null ? `` : string.Join(`\n`, d.Select(synonymGroup => string.Join(`, `, synonymGroup))); var sm = new Azure.Search.Documents.Indexes.Models.SynonymMap(AISearch_SynonymMap_Name, synonyms); await Index.Client(AISearch_Name,AISearch_Key).CreateOrUpdateSynonymMapAsync(sm); /* ************************* Add to Column in AI Search Index */ var index = Index.Client(AISearch_Name,AISearch_Key).GetIndex(AISearch_Index_Name); var field = index.Value.Fields.FirstOrDefault(f => f.Name == `merged_content`); if (field != null) { field.SynonymMapNames.Add(sm.Name); await Index.Client(AISearch_Name,AISearch_Key).CreateOrUpdateIndexAsync(index.Value); } } Environment Azure.Search.Documents 11.6.0-beta.4
Client	Service Bus	[QUERY] How can we use configuration when registering an Azure client	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question Is there a way to register a new ServiceBusClient while depending on IServiceProvider when calling the builder.AddServiceBusClient*() methods? I am trying to utilize the AddServiceBus* methods to register my client objects, but it does not appear there is an overload that will allow us to access IServiceProvider, am I missing something? I am currently just doing: serviceCollection.AddAzureClients(builder => {     builder.AddClient<ServiceBusClient, ServiceBusClientOptions>((options, provider) =>     {         var config = provider.GetRequiredService<IOptions<MyConfigClass>>();         ...         return new ServiceBusClient(...);     } } I would prefer to be able to use the builder.AddServiceBusClient* methods though, except there is no overload that will give me access to the provider object. If I stick to the example above, will my instances still be cleaned up and managed properly for me? Environment No response
Client	Service Bus	Can I rely on AzureWebJobs:extensions:ServiceBus options?	Library name and version Microsoft.Azure.Webjobs.Extensions.Servicebus 5.16.1 Query/Question Hello, I couldn't find any documentation for setting ServiceBusOptions in app configuration, but looking at the code and debugging it I found that I can place the options under AzureWebJobs:extensions:ServiceBus e.g. AzureWebJobs:extensions:ServiceBus:MessageHandlerOptions:MaxConcurrentCalls. Can I rely on these settings to stay the same and not change in future versions? Thanks, Aleksey Environment Azure AppService, .net 8
Client	Service Bus	[BUG] Azure Service Bus Timeout instead of correct response: MessagingEntityNotFound	Library name and version Azure Service Bus Timeout (7.17.5) Describe the bug We have a big cloud application where we distribute data between queues. Each customer could have multiple queues and we will push data there (all in one azure service bus, premium tier). It could be that a customer does not have a queue, in that case the documentation says that a 404 (Messaging Entity Not Found) will be returned, It could be that at the same time messages are send to houndrtes of different queues. Expected behavior We expect that if the queue does not exist, we get a 404 (MessagingEntityNotFound), which works with less workload. Actual behavior If there is a lot of workload, we are getting timeouts, instead of 404. If a 404 is returned, we will not send any data to that queue for an amount of time (as it does not exists). But if there is a timout, we can not know if there is an existing queue or not, in that case we send more data to that queue. Reproduction Steps I added a small application where you can reproduce the issue. I just decreased the timeout to 10 seconds to let happen the issue with 100 queues after some seconds. If you have more queues, you can also increase the timeout and it will still happens. using Azure.Messaging.ServiceBus;  namespace ConsoleApp50 {     internal class Program     {         static int counter = 0;         static async Task Main(string[] args)         {             var serviceBusClient = new ServiceBusClient(`[CONNECTION_STRING]`, new ServiceBusClientOptions             {                 RetryOptions = new ServiceBusRetryOptions                 {                     TryTimeout = TimeSpan.FromSeconds(10)                 }             });              for(var i = 0; i < 100; i++)             {                 _ = Task.Run(() => Send(serviceBusClient.CreateSender(`queue` + i)));                 await Task.Delay(25);             }              while (true)             {                 Console.ForegroundColor = ConsoleColor.White;                 Console.WriteLine(`Counter: ` + counter);                 Console.ForegroundColor = ConsoleColor.Red;                 await Task.Delay(1000);             }                          Console.WriteLine(`Hello, World!`);         }          static async Task Send(ServiceBusSender serviceBusSender)         {             var message = new ServiceBusMessage(`Hello, World!`);              while (true)             {                 try                 {                     await serviceBusSender.SendMessagesAsync(new List<ServiceBusMessage> { message });                 }                 catch (ServiceBusException ex)                 {                     if (ex.Reason == ServiceBusFailureReason.MessagingEntityNotFound)                     {                         counter++;                     }                     else                     {                         Console.WriteLine(`ERROR: ` + ex.ToString());                     }                 }             }         }     } }  Environment I use Visual Studion 2022 and dotnet 8.
Mgmt	API Management	How can we Enable/Disable APIs and Operations in Azure API Management Using .NET SDK and or in Portal	Library name and version Azure.ResourceManager.ApiManagement 1.1.0 Query/Question I'm currently working on a project that involves managing APIs within Azure API Management programmatically using the .NET SDK. However, I couldn't find explicit documentation or examples on how to enable or disable APIs and their operations or individual operations specifically. Could you please provide guidance or code snippets on how to achieve this functionality using the .NET SDK for Azure API Management? It would be immensely helpful to have clear instructions or references to ensure seamless integration with our existing .NET applications. Environment No response
Client	Event Grid	[QUERY] What is happening with EventGridClient class?	Library name and version Azure.Messaging.EventGrid 4.22.0-beta.1 Query/Question In this page: https://learn.microsoft.com/en-us/answers/questions/1695419/pull-delivery-model-support-in-c-sdk The documentation is clear that I can use .Net SDK to poll ('pull') from the EventGrid. But the class EventGridClient only exists in the package version 4.22.0-beta.1, and does not seem to have made it into 4.22 or any subsequent versions of the package. 4.22.0-beta.1 was published 7 months ago, so I'm wondering whether this is going to be a supported feature at all. Is the feature going to be available in the future? Can you give an indication of when it would be? If not, the documentation above needs to be revised (or removed) so that it doesn't mislead developers. Environment No response
Client	Azure.Identity	APIScan failure on DefaultAzureCredentialOptions several properties	Library name and version Azure.Identity v1.11.3 Describe the bug APIScan is not able to find documentation for below properties on DefaultAzureCredentialOptions SharedTokenCacheTenantId, VisualStudioCodeTenantId, VisualStudioTenantId. We have received several bug reports similar to below Tool: ApiScan: Rule: documentationnotfound (Documentation Not Found). https://aka.ms/apiscan/learnmore?page=protocol%2fdocumentationnotfound.htm azure.identity!Azure.Identity.DefaultAzureCredentialOptions.set_SharedTokenCacheTenantId is either an undocumented HVP API or the documentation is not discoverable.  We were not able to find related source for these properties in published documentation. Expected behavior We would except to find documentation publicly for these properties. APIScan should be able to find the documentation. Actual behavior Tool: ApiScan: Rule: documentationnotfound (Documentation Not Found). https://aka.ms/apiscan/learnmore?page=protocol%2fdocumentationnotfound.htm azure.identity!Azure.Identity.DefaultAzureCredentialOptions.set_SharedTokenCacheTenantId is either an undocumented HVP API or the documentation is not discoverable.  Reproduction Steps There is no specific repro steps. You can try finding public documentation for those properties which leads to nowhere. Environment No response
Mgmt	ARM	[FEATURE REQ] Add ArmDeploymentValidateResult and WhatIfOperationResult to ResourceManagerModelFactory	Library name Azure.ResourceManager Please describe the feature. To enable creation of mocked ArmDeploymentValidateResult and WhatIfOperationResult, please add support to provision instances of those types with ResourceManagerModelFactory.
Client	Search	[QUERY] how can I see http payload sent to azure ai search ?	Library name and version Latest net azure ai search nuget package Query/Question how can I see http payload sent to azure ai search ? Environment Windows ,  net 8
Mgmt	Logic App	[QUERY] Trigger a logic app workflow with a custom payload using logic app management client library	Library name and version Azure.Management.Logic Query/Question I want to developed an azure function in C#. This function will get triggered from an action group and will get a payload as an input. The function is expected to process the payload, runs logic app workflow and pass that payload to the logic app workflow. We are committed to use azure .net sdk to communicate with azure services and want to go away from REST APIs. Can you please provide a way to trigger the logic app workflow using the .net sdk client libraries in C# instead of calling REST api directly? Environment .Net 8 Azure function in C# Visual studio Azure .net sdk
Client	Service Bus	[QUERY]: Is OpenTelemetry Baggage supported	Library name and version Azure.Messaging.ServiceBus 7.17.5 Query/Question @lmolkova wrote here that OpenTelemetry Baggage will be gradually adopted once it is approved. I couldn't find any information if that adoption took place already. Here it sounds like it should work. I couldn't get Baggage propagation over process boundaries working in my local development setup. This is my scenario: Process A, populates Baggage items via Activity.Current?.SetBaggage(``, ``) Process A, sends message to Azure Service Bus Process B, receives message from Azure Service Bus Expected result: Process B, Activity.Current has Baggage items Actual result: Process B, Activity.Current has no baggage Is Baggage propagation already supposed to work? If yes, do I need to turn on specific things (Flags or similar)? Is maybe the transport mechanism to ServiceBus relevant? Thanks for any hints or pointers? Environment  dotnet --info .NET SDK: Version:           8.0.204 Commit:            c338c7548c Workload version:  8.0.200-manifests.7d36c14f Runtime: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.204\
Client	Service Bus	[QUERY] Can ProcessMessageEventArgs.CompleteMessageAsync be throttled?	Library name and version Azure.Messaging.ServiceBus 7.17.1 Query/Question I'm testing  my application in an Azure ServiceBus Standard and while processing a message in a ServiceBusProcessor. I'm getting a throttling error: The request was terminated because the namespace MYNAMESPACE is being throttled At also it seems the message is being duplicated (The sender of the message only sends it once) I'm completing manually the messages. After processing my message i'm calling CompleteMessageAsync Could this method not finalize due to the ASB namespace being throttled, generating a message duplication due to it being abandoned after the message lock is expired? Environment .Net 461
Client	Azure.Core	[FEATURE REQ]Need to support pass HttpMessageHandler when construct client	Library name All Please describe the feature. When using client library, I need to trace all service calls to Azure services with service call details such as API name, elapsed time, success or fail. Usually this is implemented in HttpMessageHandler. Without this functionality, every service call client code needs to copy the same code logic.
Client	OpenAI	[FEATURE REQ] Azure.AI.OpenAI - add `tool_choice = required` option in chat completion options	Library name Azure.AI.OpenAI Please describe the feature. Please add the new tool_choice option required  https://platform.openai.com/docs/api-reference/chat/create#chat-create-tool_choice
Client	Cognitive - Form Recognizer	[BUG] BuildDocumentModelContent.BuildMode is not getting serialized	Library name and version Azure.AI.DocumentIntelligence 1.0.0-beta.2 (preview) Describe the bug Consider the following example code to build a BuildDocumentModelContent. using Azure.AI.DocumentIntelligence; using System.Text.Json;  BuildDocumentModelContent content = new(`some-model-id`, DocumentBuildMode.Neural) {     AzureBlobSource = new AzureBlobContentSource(new Uri(`https://someSasUri`))     {         Prefix = `/somefolder`     },     Description = `Some Description` };  string serializedContent = JsonSerializer.Serialize(content, new JsonSerializerOptions {     WriteIndented = true });  Console.WriteLine(serializedContent); Output: {   `ModelId`: `some-model-id`,   `Description`: `Some Description`,   `BuildMode`: {},   `AzureBlobSource`: {     `ContainerUrl`: `https://someSasUri`,     `Prefix`: `/somefolder`   },   `AzureBlobFileListSource`: null,   `Tags`: {} }  Note the BuildMode is empty. Expected behavior BuildDocumentModelContent.BuildMode should get serialized. Actual behavior BuildDocumentModelContent.BuildMode is not getting serialized. Reproduction Steps Provided above under the description. Environment No response
Mgmt	Monitor - ApplicationInsights	[BUG] Web Test creation fails because of Azure locations	Library name and version Azure.ResourceManager.ApplicationInsights 1.0.0 Describe the bug When creating a web test related to an App Insights component, it fails because of the Azure location. My 2 cents: It uses a list of WebTestGeolocation with a Location property of type AzureLocation struct. However, I created WebTest before using GenericResource and when setting locations for WebTest, it used location under format emea-fr-pra-edge (here for France Central). Expected behavior Web Test creation works, using desired locations. Actual behavior Message:  Azure.RequestFailedException : Value cannot be null. Parameter name: 'properties.Locations[0].Id' - 'northeurope' is not a supported location Status: 400 (Bad Request) ErrorCode: BadRequest  Content: {   `error`: {     `code`: `BadRequest`,     `message`: `Value cannot be null.\r\nParameter name: 'properties.Locations[0].Id' - 'northeurope' is not a supported location`,     `innererror`: {       `trace`: [         `System.ArgumentNullException`       ]     }   } }  Headers: Cache-Control: no-cache Pragma: no-cache Request-Context: REDACTED Access-Control-Expose-Headers: REDACTED Strict-Transport-Security: REDACTED X-Content-Type-Options: REDACTED X-Powered-By: REDACTED x-ms-ratelimit-remaining-subscription-writes: REDACTED x-ms-request-id: 474e4b63-dfcf-4bb5-b9d6-42be499ce457 x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED X-Cache: REDACTED X-MSEdge-Ref: REDACTED Date: Mon, 27 May 2024 14:06:08 GMT Content-Length: 278 Content-Type: application/json; charset=utf-8 Expires: -1  Reproduction Steps await resourceGroup.GetApplicationInsightsWebTests().CreateOrUpdateAsync(     WaitUntil.Completed,     `mywebtestname`,     new ApplicationInsightsWebTestData(appInsights.Data.Location)     {         WebTestName = `mywebtestname`,         SyntheticMonitorId = `mywebtestname`,         IsEnabled = true,         FrequencyInSeconds = 300,         TimeoutInSeconds = 120,         Kind = WebTestKind.Standard,         IsRetryEnabled = true,         Request = new WebTestRequest         {             RequestUri = new Uri(`https://myuri/api/alive`),             HttpVerb = `get`,             ParseDependentRequests = false         },         Locations =         {             new WebTestGeolocation { Location = AzureLocation.FranceCentral },             new WebTestGeolocation { Location = AzureLocation.NorthEurope },             new WebTestGeolocation { Location = AzureLocation.WestEurope },             new WebTestGeolocation { Location = AzureLocation.UKSouth },             new WebTestGeolocation { Location = AzureLocation.WestUS },         },         ValidationRules = new WebTestValidationRules         {             ExpectedHttpStatusCode = 200,             CheckSsl = true,             SslCertRemainingLifetimeCheck = 7         },         Tags =         {             { $`hidden-link:{appInsights.Id}`, `Resource` }         }     },     cancellationToken: cancellationToken); Environment dotnet --info .NET SDK: Version:           8.0.200 Commit:            438cab6a9d Workload version:  8.0.200-manifests.e575128c Runtime Environment: OS Name:     Windows OS Version:  10.0.22631 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.200\ IDE and version : Version 17.9.0
Client	OpenAI	[FEATURE REQ] Upgrade Azure.AI.OpenAI.Assistants to support latest API	Library name Azure.AI.OpenAI.Assistants Please describe the feature. Hi! Are there are any plans for Azure.AI.OpenAI.Assistants API update to support:  Assistant streaming API Assistant token usage API Latest models support like gpt-4o
Client	OpenAI	[FEATURE REQ] Get rid of hardcoded OpenAI-endpoint in OpenAIClient	Library name Azure.AI.OpenAI Please describe the feature. In OpenAIClient.cs the OpenAI-API-Uri is hardcoded and cannot be changed. The constructor for specifying a custom endpoint will always expect an Azure Uri. The private, unchangeable variable called _isConfiguredForAzureOpenAI cannot be changed. This is related to issue #37794, which was closed because it was recommended to use a proxy server instead. This should not be considered a serious solution these days. The OpenAI-API has become the de-factor standard for all LLM APIs. Many solutions such as `Local AI` or `Oobabooga Web UI` ship an OpenAI-compatible API. We should be able to consume those with OpenAIClient. Setting up a proxy isn't a feasible option for something as simple as that. Also it would make it impossible to use multiple different OpenAIClient instances with different endpoints. Suggested solution: Add another constructor or an optional boolean parameter like useAzureOpenAI to the existing constructor that, if set, disables _isConfiguredForAzureOpenAI and does not initialize _pipeline using Azure-stuff while also allowing you to set a custom endpoint.
Mgmt	App Services	[BUG] ArmAppServiceModelFactory is not contained in the Azure.ResourceManager.AppService nuget package	Library name and version Azure.ResourceManager.AppService 1.0.2 Describe the bug ArmAppServiceModelFactory extension methods cannot be used Expected behavior I expected to see the ArmAppServiceModelFactory class in the Azure.ResourceManager.AppService 1.0.2 nuget package to take advantage of the extension methods. I hope that ArmAppServiceModelFactory extension methods will be available in the Azure.ResourceManager.AppService nuget package. Actual behavior I can not use ArmAppServiceModelFactory in the Azure.ResourceManager.AppService 1.0.2, file is not included in the assembly and the required dll is missing Reproduction Steps Install nuget package  Azure.ResourceManager.AppService 1.0.2, and try to use any extension method from ArmAppServiceModelFactory (sdk/websites/Azure.ResourceManager.AppService/src/Generated/ArmAppServiceModelFactory.cs) Environment No response
Mgmt	KeyVault	[FEATURE REQ] Add keys operation to Azure.ResourceManager.KeyVault	Library name Azure.ResourceManager.KeyVault Please describe the feature. In version 1.0.0-beta.8 of the library, there were keys operations such as GetKeyVaultKeys and GetVaultKeyAsync on the vault resource. They disappeared in version 1.0.0 and after. Why is that and is there timeline to bring them back?
Client	Azure.Identity	[BUG] VisualStudioCredential error AADSTS65002 connecting to Azure Monitor Control Service	Library name and version Azure.Identity 1.11.3 Describe the bug An error occurs when attempting to authenticate using VisualStudioCredential credentials. The error message indicates a consent issue between the first-party application and resource, requiring preauthorization. (VisualStudioCredential with Azure Monitor Control Service) Expected behavior The application should successfully authenticate using the credentials. Actual behavior The application fails to authenticate, and the following error message is displayed: AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'e933bd07-d2ee-4f1d-933c-3752b819567b' must be configured via preauthorization. Reproduction Steps Create a new .Net (8) Web API and add application  inishgt as such:         builder.Services.Configure<TelemetryConfiguration>(config =>         {             config.SetAzureTokenCredential(new VisualStudioCredential());         });         builder.Services.AddApplicationInsightsTelemetry(options =>         {             options.ConnectionString = connectionString;         });  Run the API and access some page. Environment Azure Subscription offer: Enterprise Dev/Test Visual Studio Enterprise 17.9.7
Client	OpenAI	[FEATURE REQ] Assistant V2	Library name AssistantsClient.cs Please describe the feature. I am currently trying to use the Assistant v2 API. However, in the code, there is a line: request.Headers.Add(`OpenAI-Beta`, `assistants=v1`); I couldn't find any documentation or option to change this to v2. For my use case, I need to use Assistant v2. It would be great if you could implement this feature!   Add support for specifying the version of the Assistant API in the request headers.    Allow changing the version from v1 to v2 as needed.
Mgmt	ARM	Deployment failed; but get RequestFailedException with bad response message	Library name and version Azure.Core 1.39.0 Azure.ResourceManager 1.11.1 Azure.ResourceManager.Resources 1.7.2 Describe the bug Try to create a spot VM using template deployment, it failed due to low spot price. In Azure activity log, it shows the reason as ` Unable to perform operation 'Create VM' since the provided max price '0.001 USD' is lower than the current spot price '0.0113 USD' for Azure Spot VM size 'Standard_D2ds_v5'.`. However in the exception message from SDK, it says: `Azure.RequestFailedException: At least one resource deployment operation failed. Please list deployment operations for details. Please see https://aka.ms/arm-deployment-operations for usage details. Status: 200 (OK) ErrorCode: DeploymentFailed Service request succeeded. Response content and headers are not included to avoid logging sensitive data.` Why doesn't it include the actual failure message? Expected behavior Previously we get exception with message like: Azure.RequestFailedException: At least one resource deployment operation failed. Please list deployment operations for details. Please see https://aka.ms/arm-deployment-operations for usage details. Status: 200 (OK) ErrorCode: DeploymentFailed Content: {`status`:`Failed`,`error`:{`code`:`DeploymentFailed`,`target`:`/subscriptions/xxx/resourceGroups/xxx/providers/Microsoft.Resources/deployments/xxx`,`message`:`At least one resource deployment operation failed. Please list deployment operations for details. Please see https://aka.ms/arm-deployment-operations for usage details.`,`details`:[{`code`:`OperationNotAllowed`,`message`:`Unable to perform operation 'Create VM' since the provided max price '0.001 USD' is lower than the current spot price '0.0113 USD' for Azure Spot VM size 'Standard_D2ds_v5'. For more information, see http://aka.ms/AzureSpot/errormessages.`}]}} Actual behavior With Azure.Core 1.39.0, we get: Azure.RequestFailedException: At least one resource deployment operation failed. Please list deployment operations for details. Please see https://aka.ms/arm-deployment-operations for usage details. Status: 200 (OK) ErrorCode: DeploymentFailed Service request succeeded. Response content and headers are not included to avoid logging sensitive data. Reproduction Steps at Azure.Core.OperationInternal1.GetResponseFromState(OperationState1 state) at Azure.Core.OperationInternal1.<UpdateStatusAsync>d__20.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Core.OperationInternalBase.<UpdateStatusAsync>d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Azure.Core.OperationPoller.<WaitForCompletionAsync>d__10.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Operation.<WaitForCompletionResponseAsync>d__14.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Threading.Tasks.ValueTask1.get_Result() at Citrix.AzureFacade.AzureResourceManager.ClientWrappers.LongRunningOperationExtensions.d__0.MoveNext() Environment No response
Client	Service Bus	[QUERY] Azure Service Bus `Batch Receive Timeout`	Library name and version Azure.Messaging.ServiceBus Query/Question In the AmqpReceiver, when receiving messages in batch it uses a hard coded value of 20ms as a parameter to the `batch receive timeout`                azure-sdk-for-net/sdk/servicebus/Azure.Messaging.ServiceBus/src/Amqp/AmqpReceiver.cs                    Line 364       in       7c5d478                                                 TimeSpan.FromMilliseconds(20),                     e.g. the behaviour here is if I have set a batch size of 500 but only 100 have been retrieved by the timeout value, then it will return the smaller batch size to the client to allow them to start processing those messages. Is there a reason why this is hard-coded and not configurable? In some scenarios, I'd happily wait for longer if it meant I could receive a larger batch in one go. Environment No response
Client	Service Bus	[QUERY] How to create a SubscriptionProperties in unit tests?	Library name and version Azure.Messaging.ServiceBus Query/Question I was mocking the ServiceBusAdministrationClient and realized I'm not table to create/initialize the SubscriptionProperties class. Both constructors defined for the SubscriptionProperties class are internal... Is there a factory I can use in my unit tests? Or could someone make the constructors public for the SubscriptionProperties class? Environment No response
Mgmt	Network - Traffic Manager	[QUERY] Disable/Enable multi-endpoints in 1 Traffic Manager Profile at once	Library name and version Azure.ResourceManager.TrafficManager 1.1.2 Query/Question Hi, team. I'm trying to update the trafficManagerProfile.Data.Endpoints, but I'm getting an error message that “Details: Azure.RequestFailedException: The 'endpoints' property cannot be specified when updating a profile using PATCH. Please use PUT to update the profile instead.”. I think I should use trafficManagerProfile.CreateOrUpdateAsync instead of trafficManagerProfile.UpdateAsync, but I didn't find it. So I'd like to ask how can I achieve the goal of operating multi-endpoints in 1 profile at only once? Code ResourceIdentifier rid = new ResourceIdentifier(resources.ResourceId); TrafficManagerProfileResource trafficManagerProfile = _armClient.GetTrafficManagerProfileResource(rid); trafficManagerProfile = await trafficManagerProfile.GetAsync(); if (trafficManagerProfile == null) {     throw new Exception($`Traffic Manager Profile not found for ResourceId: {resources.ResourceId}`); } foreach (var endpoint in trafficManagerProfile.Data.Endpoints) {     endpoint.EndpointStatus = enabling ? TrafficManagerEndpointStatus.Enabled : TrafficManagerEndpointStatus.Disabled; } await trafficManagerProfile.UpdateAsync(trafficManagerProfile.Data);  Environment No response
Mgmt	Monitor	[BUG] UnsupportedRequestContent error response when using Azure.ResourceManager.Monitor to create AutoscaleSettingResource	Library name and version Azure.ResourceManager.Monitor 1.3.1, Azure.ResourceManager 1.11.1, Azure.Identity 1.11.2 Describe the bug I'm trying to create a AutoScaleSetting for my already existing App Service plan using the .NET SDKs Azure.ResourceManager.Monitor and Azure.ResourceManager. I was able to create other resources like App service, Web App etc in the same Resource group successfully. I'm using the DefaultAzureCredential() and my own identity(I'm logged into visual studio, where this code is running as a console app) and I'm also owner of the subscription and Resource group and App service plan, for which I'm trying to create the AutoScale setting. But I'm getting exception and exception details are: the 400 error response is not clear on what exactly is the error. Below is the error response: Request content is not well formed or supported. Status: 400 (Bad Request) ErrorCode: UnsupportedRequestContent   Content: {`code`:`UnsupportedRequestContent`,`message`:`Request content is not well formed or supported.`}   {StatusCode: 400, ReasonPhrase: 'Bad Request', Version: 1.1, Content: <null>, Headers: {   Cache-Control: no-cache   Pragma: no-cache   Strict-Transport-Security: max-age=31536000; includeSubDomains   x-ms-request-id: 00000000-0000-0000-0000-000000000000   x-ms-ratelimit-remaining-subscription-writes: 1199   x-ms-correlation-request-id: 0498c1ee-52ff-4dc2-b304-7c22835f916e   x-ms-routing-request-id: CENTRALINDIA:20240508T182214Z:0498c1ee-52ff-4dc2-b304-7c22835f916e   X-Content-Type-Options: nosniff   X-Cache: CONFIG_NOCACHE   X-MSEdge-Ref: Ref A: C29CF5F458C94A8CB637104186C06A56 Ref B: MAA201060515019 Ref C: 2024-05-08T18:22:12Z   Date: Wed, 08 May 2024 18:22:13 GMT }}   My code which I'm using to configure Autoscale setting resource is: // Create Autoscale setting             ResourceIdentifier resourceIdentifierAppSvcPlan = appServicePlanLro.Value.Id;             MonitorScaleCapacity scaleCapacity = new MonitorScaleCapacity(minimum: 3, maximum: 30, @default: 3);              // cpu scale up logic             MetricTrigger metricTriggerCpuScaleUp = new MetricTrigger(                 metricName: `CpuPercentage`,                 metricResourceId: resourceIdentifierAppSvcPlan,                 timeGrain: TimeSpan.FromMinutes(1),                 statistic: MetricStatisticType.Average,                 timeWindow: TimeSpan.FromMinutes(1),                 timeAggregation: MetricTriggerTimeAggregationType.Average,                 @operator: MetricTriggerComparisonOperation.GreaterThan,                 threshold: 50);             metricTriggerCpuScaleUp.MetricNamespace = `microsoft.web/serverfarms`;             metricTriggerCpuScaleUp.IsDividedPerInstance = false;              MonitorScaleAction monitorScaleActionScaleUp = new MonitorScaleAction(                 MonitorScaleDirection.Increase,                 MonitorScaleType.PercentChangeCount,                 cooldown: TimeSpan.FromMinutes(1));             monitorScaleActionScaleUp.Value = `100`;              // cpu scale down logic             // scale down when cpu usage less than 20%             MetricTrigger metricTriggerCpuScaleDown = new MetricTrigger(                 metricName: `CpuPercentage`,                 metricResourceId: resourceIdentifierAppSvcPlan,                 timeGrain: TimeSpan.FromMinutes(1),                 statistic: MetricStatisticType.Average,                 timeWindow: TimeSpan.FromMinutes(5),                 timeAggregation: MetricTriggerTimeAggregationType.Average,                 @operator: MetricTriggerComparisonOperation.LessThan,                 threshold: 20);             metricTriggerCpuScaleDown.MetricNamespace = `microsoft.web/serverfarms`;             metricTriggerCpuScaleDown.IsDividedPerInstance = false;              MonitorScaleAction monitorScaleActionScaleDown = new MonitorScaleAction(                 MonitorScaleDirection.Decrease,                 MonitorScaleType.ChangeCount,                 cooldown: TimeSpan.FromMinutes(5));             monitorScaleActionScaleDown.Value = `1`;               AutoscaleRule autoscaleRuleCpuScaleUp = new AutoscaleRule(metricTriggerCpuScaleUp, monitorScaleActionScaleUp);             AutoscaleRule autoscaleRuleCpuScaleDown = new AutoscaleRule(metricTriggerCpuScaleDown, monitorScaleActionScaleDown);             IEnumerable<AutoscaleRule> autoscaleRules = new List<AutoscaleRule> { autoscaleRuleCpuScaleUp, autoscaleRuleCpuScaleDown };              AutoscaleProfile autoscaleProfile = new AutoscaleProfile(`bhanu sdk app scale profile`, scaleCapacity, autoscaleRules);             IEnumerable<AutoscaleProfile> autoscaleProfiles = new List<AutoscaleProfile> { autoscaleProfile };             AutoscaleSettingData autoscaleSettingData = new AutoscaleSettingData(AzureLocation.WestUS2, autoscaleProfiles);              Console.WriteLine($`Autoscale setting before creation: {JsonConvert.SerializeObject(autoscaleSettingData)}\n`);             Console.ReadLine();              ArmOperation<AutoscaleSettingResource> autoscaleSettingLro = await resourceGroup.GetAutoscaleSettings().CreateOrUpdateAsync(                 Azure.WaitUntil.Completed,                 `bhanu auto scale setting sdk`,                 autoscaleSettingData).ConfigureAwait(false);   Expected behavior 400 error response should have a clear error message. Or the exception thrown by the .NET SDK should clear out what the user error is. Actual behavior Added exception message and x-ms-correlation id above. Reproduction Steps Have added code above. Use the code to repro. Environment OS Windows 11, Visual studio Enterprise 2022 (64-bit), version 17.9.6
Client	Service Bus	Add Uri parameter on AddServiceBusClient	Library name Azure.Messaging.ServiceBus Please describe the feature. When I'm setting up my asp .net core program. I have a good feeling on services.AddAzureClients(x =>x.AddBlobServiceClient(new Uri(configuration.GetValue<string>(`Endpoint`))) But when I'm trying to add service bus  like blob service do. I only have one choice of using connect string  x.AddServiceBusClient(`ConnectString`);
Client	Service Bus	[BUG] NullReferenceException in Microsoft.Azure.Amqp 2.6.5	Library name and version Azure.Messaging.ServiceBus Describe the bug Hi, Microsoft.Azure.Amqp version 2.6.5 contains a bug that could throw an uncatched NullReferenceException in some circonstances. This library was recently fixed and a new version was released: 2.6.6 (see Azure/azure-amqp#258). Azure.Messaging.ServiceBus is still using Microsoft.Azure.Amqp version 2.6.5. Would it be possible to use the latest, fixed, version of Microsoft.Azure.Amqp please? Thank you, Anthony Expected behavior Azure.Messaging.ServiceBus does not crash with a NullReferenceException Actual behavior Azure.Messaging.ServiceBus could crash with a NullReferenceException Reproduction Steps Normal useage of Azure.Messaging.ServiceBus Environment No response
Client	Event Hubs	EventData Data property is null	Library name and version Azure.Messaging.EventHubs 5.10.0.0 Query/Question Hi, we have the following piece of code throwing NullReferenceExceptions suddenly in large amounts: if (eventArgs.Data.Properties.ContainsKey(CommonConstants.EventType))  Judging from the code, the only thing that can be null there is Data property. I can see that in the XML documentation on that property there's a note: Expected to be null if the receive call has timed out.  Could you please elaborate on this, what this means and what is receive timeout and how we can try to reproduce it? Or if you have any ideas why this might be happening it would be helpful. Environment No response
Client	Azure.Identity	[BUG]  Accessing KeyVault with ManagedIdentityCredential (using DefaultAzureCredential) for local development taking several minutes	Library name and version Azure Identity 1.11.2 Describe the bug When launching my ASP.NET API locally I'm accessing a KeyVault to fetch some configuration parameters. This is done using a plain (no options) DefaultAzureCredential instance. This has always been time consuming (around 40 sec to get the API up and running), but last week i started getting timeout errors on the request to the KeyVault. I am suspecting that the problem is related to ManagedIdentityCredentials being extremely slow. Spinning up the API (with some workarounds to prevent timeouts) takes about 2 minutes and 50 seconds now. Additionally some other processes running in the background of the API relying on managed identity for authorization against other APIs have problems with requests timing out. This seems like a problem that only affects a few of the developers, as most of the developers can still access the KeyVault in under a minute, it seems only me and a handful others are affected by this issue. Issues started last Thursday 2.5.2024. Interestingly, sending the request through a proxy (Fiddler) makes the request go back to taking about 40 seconds again (but leads to different complications down the line that i consider unrelated to this issue) Expected behavior Accessing a keyvault using DefaultAzureCredential (ManagedIdentityCredentials) takes a reasonable amount of time and does not timeout without workarounds. Actual behavior Accessing a keyvault using DefaultAzureCredential takes up to 3 minutes and times out unless work arounds are present. Reproduction Steps Instantiating a DefaultAzureCredential to fetch API configuration from a KeyVault. TokenCredential credential =  new DefaultAzureCredential() config.AddAzureAppConfiguration(options => { options.Connect(new Uri(endpoint), credential) .ConfigureKeyVault(kv => { kv.SetCredential(new DefaultAzureCredential()); }); }); Environment No response
Client	Container Registry	Pulling image from public docker registry.	Library name and version Azure.ResourceManager.ContainerRegistry Query/Question I'm failing to retrieve images from public docker.io registry using nuget below: using Azure.Containers.ContainerRegistry; ContainerRegistryClient registryClient = new ContainerRegistryClient(new Uri(`https://registry.docker.io`)); RegistryArtifact? artifact = registryClient.GetArtifact(`registry`, `latest`); if (artifact is not null) { var artifactManifest = artifact.GetManifestProperties(); // https://registry.docker.io => 503 Service Unavailable // https://registry-1.docker.io => 404 Not Found } Is this is just a mishap over the v1/v2 registry standards or hopefully just my code, please let me know. To test that I can get manifest manually I had to use registry v2 on this base url: registry-1.docker.io Before that a bearer token from auth.docker.io/token?service=registry.docker.io&scope=repository:library/registry:pull Environment .NET8, Win10 Visual Studio
Mgmt	App Services	[BUG] Value cannot be null. (Parameter 'resourceId') when calling Arm.GetWebSiteResource(website).GetAllHybridConnectionDataAsync();	Library name and version Azure.ResourceManager.AppService 1.1.0-beta.5 Describe the bug This seems similar to #34745 Seems to get the response back but can't deserialize the response. ` [Informational] Azure-Identity: ClientSecretCredential.GetToken invoked. Scopes: [ https://management.azure.com//.default ] ParentRequestId: 2b6a2ffb-8559-4a45-a280-a6c3c897778d [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:28:59Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] MSAL MSAL.NetCore with assembly version '4.56.0.0'. CorrelationId(4b9ad602-b090-46ba-85f6-e5697ccdf0c6) [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:28:59Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] === AcquireTokenForClientParameters === SendX5C: False ForceRefresh: False [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:28:59Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] === Request Data === Authority Provided? - True Scopes - https://management.azure.com//.default Extra Query Params Keys (space separated) - ApiId - AcquireTokenForClient IsConfidentialClient - True SendX5C - False LoginHint ? False IsBrokerConfigured - False HomeAccountId - False CorrelationId - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6 UserAssertion set: False LongRunningOboCacheKey set: False Region configured: [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:28:59Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] === Token Acquisition (ClientCredentialRequest) started: Scopes: https://management.azure.com//.default Authority Host: login.microsoftonline.com [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:28:59Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] [Instance Discovery] Instance discovery is enabled and will be performed [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:28:59Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] [Region discovery] Not using a regional authority. [Informational] Azure-Core: Request [f96be01d-4156-4279-8f27-051778cd7313] POST https://login.microsoftonline.com/db8e2ba9-95c1-4fbb-b558-6bf8bb1d2981/oauth2/v2.0/token x-client-SKU:REDACTED x-client-Ver:REDACTED x-client-CPU:REDACTED x-client-OS:REDACTED x-client-current-telemetry:REDACTED x-client-last-telemetry:REDACTED x-ms-lib-capability:REDACTED client-request-id:REDACTED return-client-request-id:REDACTED x-app-name:REDACTED x-app-ver:REDACTED Content-Type:application/x-www-form-urlencoded x-ms-client-request-id:f96be01d-4156-4279-8f27-051778cd7313 x-ms-return-client-request-id:true User-Agent:azsdk-net-Identity/1.10.4 (.NET 7.0.14; Microsoft Windows 10.0.22621) client assembly: Azure.Identity [Informational] Azure-Core: Response [f96be01d-4156-4279-8f27-051778cd7313] 200 OK (00.6s) Cache-Control:no-store, no-cache Pragma:no-cache Strict-Transport-Security:REDACTED X-Content-Type-Options:REDACTED P3P:REDACTED client-request-id:REDACTED x-ms-request-id:a006ed51-3f28-48d3-99f5-a23ea9346700 x-ms-ests-server:REDACTED x-ms-clitelem:REDACTED x-ms-srs:REDACTED X-XSS-Protection:REDACTED Set-Cookie:REDACTED Date:Wed, 01 May 2024 23:28:59 GMT Content-Type:application/json; charset=utf-8 Expires:-1 Content-Length:1369 [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] ScopeSet was missing from the token response, so using developer provided scopes in the result. [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] Checking client info returned from the server.. [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] Saving token response to cache.. [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] [SaveTokenResponseAsync] ID Token not present in response. [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] Cannot determine home account id - or id token or no client info and no subject [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] [SaveTokenResponseAsync] Saving AT in cache and removing overlapping ATs... [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] Looking for scopes for the authority in the cache which intersect with https://management.azure.com//.default [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] Intersecting scope entries count - 0 [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] === Token Acquisition finished successfully: [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6]  AT expiration time: 5/2/2024 12:28:59 AM +00:00, scopes: https://management.azure.com//.default. source: IdentityProvider [Informational] Azure-Identity: False MSAL 4.56.0.0 MSAL.NetCore .NET 7.0.14 Microsoft Windows 10.0.22621 [2024-05-01 23:29:00Z - 4b9ad602-b090-46ba-85f6-e5697ccdf0c6] Fetched access token from host login.microsoftonline.com. [Informational] Azure-Identity: ClientSecretCredential.GetToken succeeded. Scopes: [ https://management.azure.com//.default ] ParentRequestId: 2b6a2ffb-8559-4a45-a280-a6c3c897778d ExpiresOn: 2024-05-02T00:28:59.3951101+00:00 [Informational] Azure-Core: Request [2b6a2ffb-8559-4a45-a280-a6c3c897778d] GET https://management.azure.com/subscriptions/XXXXX/resourceGroups/Proxies/providers/Microsoft.Web/sites/sitename/hybridConnectionRelays?api-version=2021-02-01 Accept:application/json x-ms-client-request-id:2b6a2ffb-8559-4a45-a280-a6c3c897778d x-ms-return-client-request-id:true User-Agent:azsdk-net-ResourceManager.AppService/1.1.0-beta.5 (.NET 7.0.14; Microsoft Windows 10.0.22621) Authorization:REDACTED client assembly: Azure.ResourceManager [Informational] Azure-Core: Response [2b6a2ffb-8559-4a45-a280-a6c3c897778d] 200 OK (00.3s) Cache-Control:no-cache Pragma:no-cache Strict-Transport-Security:REDACTED x-ms-request-id:f268e279-723f-4994-97b9-b548f553780f X-AspNet-Version:REDACTED X-Powered-By:REDACTED x-ms-ratelimit-remaining-subscription-reads:REDACTED x-ms-correlation-request-id:REDACTED x-ms-routing-request-id:REDACTED X-Content-Type-Options:REDACTED X-Cache:REDACTED X-MSEdge-Ref:REDACTED Date:Wed, 01 May 2024 23:29:00 GMT Content-Length:4439 Content-Type:application/json Expires:-1 [Verbose] Azure-Core: Response [2b6a2ffb-8559-4a45-a280-a6c3c897778d] content: `value`: [ { `id`: `/subscriptions/XXX/resourceGroups/Proxies/providers/Microsoft.Web/sites/name/hybridConnectionNamespaces/namespace/relays/name1`, `name`: `name1`, `type`: `Microsoft.Web/sites/hybridConnectionNamespaces/relays`, `location`: `West US 2`, `properties`: { `serviceBusNamespace`: `relayName`, `relayName`: `name1`, `relayArmUri`: `/subscriptions/XXX/resourceGroups/TechSupport/providers/Microsoft.Relay/namespaces/relayName/hybridConnections/lhtest3`, `hostname`: `test.test.com`, `port`: 443, `sendKeyName`: `defaultSender`, `sendKeyValue`: ``, `serviceBusSuffix`: `.servicebus.windows.net` } }, { `id`: `/subscriptions/XXX/resourceGroups/Proxies/providers/Microsoft.Web/sites/name/hybridConnectionNamespaces/namespace/relays/name2`, `name`: `name2`, `type`: `Microsoft.Web/sites/hybridConnectionNamespaces/relays`, `location`: `West US 2`, `properties`: { `serviceBusNamespace`: `relayName`, `relayName`: `name2`, `relayArmUri`: `/subscriptions/XXXX/resourceGroups/TechSupport/providers/Microsoft.Relay/namespaces/relayName/hybridConnections/name2`, `hostname`: `test.test.com`, `port`: 443, `sendKeyName`: `defaultSender`, `sendKeyValue`: ``, `serviceBusSuffix`: `.servicebus.windows.net` } } ], `nextLink`: null, `id`: null ` Expected behavior Would expect it to return without error Actual behavior Value cannot be null. (Parameter 'resourceId') at Azure.Core.Argument.AssertNotNullOrEmpty(String value, String name) at Azure.Core.ResourceIdentifier..ctor(String resourceId) at Azure.ResourceManager.AppService.HybridConnectionData.DeserializeHybridConnectionData(JsonElement element) at Azure.ResourceManager.AppService.WebAppsRestOperations.ListHybridConnectionsAsync(String subscriptionId, String resourceGroupName, String name, CancellationToken cancellationToken) at Azure.ResourceManager.AppService.WebSiteResource.GetAllHybridConnectionDataAsync(CancellationToken cancellationToken) Reproduction Steps var website = WebSiteResource.CreateResourceIdentifier(_azureSubscriptionId, resourceGroup, proxy); var armClient = new ArmClient(new ClientSecretCredential(AzureTenantId, AzureClientId, AzureClientSecret),null, new  ArmClientOptions(){Diagnostics = {   IsLoggingContentEnabled = true  }}); var hybridConnectionData=await armClient.GetWebSiteResource(website).GetAllHybridConnectionDataAsync(); Environment linq pad 7 / vs 17.8.2 , win 11
Client	Extensions	[QUERY] - Register custom HttpClient	Library name and version Microsoft.Extensions.Azure Query/Question I'm trying to figure out if it's possible to add a custom HttpClient (typed or untyped) via AddAzureClients configuration method. Something like:  services.AddAzureClients(builder =>  {      builder.AddClient<HttpClient, HttpClientOptions>();      builder.UseCredential(new DefaultAzureCredential());  });  Is that possible or are only the Azure SDK clients allowed here? Background: My application uses Azure.ResourceManager.ApiManagement package to access API Management Gateway. Via that package we're trying to figure out which APIs have an health endpoint. This health endpoint is then called via a custom HttpClient. For both, the API Management client and for the HttpClient we want to use the same configuartion method and the same credentials. Environment No response
Client	Tables	[BUG] etag being ignored in batch operation	Library name and version Azure.Data.Tables 12.8.3 Describe the bug When doing a batch operation, trying to delete x number of records, if any record does not exist I get error Exception: Azure.Data.Tables.TableTransactionFailedException: xxx :The specified resource does not exist., more full stack below. I'm callingTableClient.SubmitTransactionAsync with a list of TableTransactionAction. For each TableTransactionAction, the TableEntity.ETag  is set to *. I am also setting the Etag of the TableTransactionAction directly to *, I would expect this to not fail if an item is missing, however it does. I did not have this issue before with Microsoft.WindowsAzure.Storage.Table but since switching I'm having this problem showing in production logs and can replicate locally with Azurite. I can work around this if I have to but loading the records first, but really hoping I don't need to, can you advise please.  Additional Information: FailedEntity: 0  Content: {`odata.error`:{`code`:`ResourceNotFound`,`message`:{`lang`:`en-US`,`value`:`0:The specified resource does not exist.\nRequestId:b5bf2ade-d002-0052-0711-95e660000000\nTime:2024-04-23T00:00:00.1308738Z`}}}  Headers: X-Content-Type-Options: REDACTED Cache-Control: no-cache DataServiceVersion: 3.0; Content-Type: application/json;odata=minimalmetadata;streaming=true;charset=utf-8     at Azure.Data.Tables.TableRestClient.SendBatchRequestAsync(HttpMessage message, CancellationToken cancellationToken)    at Azure.Data.Tables.TableClient.SubmitTransactionInternalAsync(IEnumerable`1 transactionalBatch, Guid batchId, Guid changesetId, Boolean async, CancellationToken cancellationToken)    at Azure.Data.Tables.TableClient.SubmitTransactionAsync(IEnumerable`1 transactionActions, CancellationToken cancellationToken)  Expected behavior Ignore delete TableTransactionAction in a batch when entity does not exist but etag is * Actual behavior Does not delete TableTransactionAction in a batch when entity does not exist but etag is * but throws error Azure.Data.Tables.TableTransactionFailedException Reproduction Steps CallTableClient.SubmitTransactionAsync with a list of TableTransactionAction. For each TableTransactionAction, the TableEntity.ETag  is set to *. Also setting the Etag of the TableTransactionAction directly to * Create a list of delete options and have one or more of the items not exist Environment Azure Function 4, DotNet 6
Client	Service Bus	[QUERY] Proper Way to Handle Exceptions in ServiceBusProcessor.ProcessMessageAsync Handler	Library name and version Azure.Messaging.ServiceBus 7.17.4 Query/Question I'm testing out trace ids from the publisher through to the consumer. I saw this issue, but I have some follow up to that. In my ServiceBusProcessor.ProcessMessageAsync handler method, I grab the Diagnostic-Id and start a new Activity:     private async Task OnProcessMessageAsync(ProcessMessageEventArgs args)     {         var diagnosticId = string.Empty;         if (args.Message.ApplicationProperties.TryGetValue(`Diagnostic-Id`, out var objectId))         {             diagnosticId = objectId as string ?? string.Empty;         }          using var activitySource = new ActivitySource(`processActivitySource`);         using var activity = activitySource.StartActivity(`ProcessMessage`, default, parentId: diagnosticId);               // process message and log data to activity                  // force exception         throw new ArgumentException(`hello`);     }      private Task OnProcessErrorAsync(ProcessErrorEventArgs args)     {          /// how can we get the traceid from the ArgumentException(`hello`);     }  Mostly I'm trying to just bubble my exceptions from OnProcessMessageAsync to OnProcessErrorAsync, but I don't see a way to trace the exceptions back to the traceid I have coming all the way from the original publisher logic. What is the recommendation here, do I need to add explicit try/catch inside of my OnProcessMessageAsync, or is there a way to trace in the OnProcessErrorAsync? Environment Macbook M1 chip, using Rider for local testing. .NET SDK:  Version:           8.0.101  Commit:            6eceda187b  Workload version:  8.0.100-manifests.69afb982  Runtime Environment:  OS Name:     Mac OS X  OS Version:  14.4  OS Platform: Darwin  RID:         osx-arm64  Base Path:   /usr/local/share/dotnet/sdk/8.0.101/  .NET workloads installed:  Workload version: 8.0.100-manifests.69afb982 There are no installed workloads to display.  Host:   Version:      8.0.1   Architecture: arm64   Commit:       bf5e279d92  .NET SDKs installed:   6.0.418 [/usr/local/share/dotnet/sdk]   8.0.101 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.26 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.26 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]  Other architectures found:   None  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Client	Service Bus	[FEATURE REQ] Align ProcessSessionMessageEventArgs.DeadLetterMessageAsync overload parameter types	Library name Azure.Messaging.ServiceBus Please describe the feature. ProcessSessionMessageEventArgs has three methods which take IDictionary<string, object> propertiesToModify parameters: AbandonMessageAsync, DeferMessageAsync, and DeadLetterMessageAsync.                azure-sdk-for-net/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ProcessSessionMessageEventArgs.cs                   Lines 199 to 202       in       ff64938                                                 public virtual async Task DeadLetterMessageAsync(                                               ServiceBusReceivedMessage message,                                               IDictionary<string, object> propertiesToModify = default,                                               CancellationToken cancellationToken = default)                     However, it also has one DeadLetterMessageAsync overload which takes a Dictionary<string, object>.                azure-sdk-for-net/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ProcessSessionMessageEventArgs.cs                   Lines 213 to 218       in       ff64938                                                 public virtual async Task DeadLetterMessageAsync(                                               ServiceBusReceivedMessage message,                                               Dictionary<string, object> propertiesToModify,                                               string deadLetterReason,                                               string deadLetterErrorDescription = default,                                               CancellationToken cancellationToken = default)                     Can this one be changed to take an IDictionary<string, object>, aligning it with the other three?
Mgmt	ARM	[QUERY] How to deserialize ARM restful API response to new ARM models?	Library name and version Azure.ResourceManager.Resources.Models Query/Question To get a more detailed response, our .net service interacts with ARM via restful API instead of ARM SDK. We deserialize the JSON response to old Azure management SDK-defined models as the sample code shown // provider docs https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/listall var virtualMachines = await armClient.GetResourceListAsync<VirtualMachine>(`Microsoft.Compute/virtualMachines`);  public async Task<List<T>> GetResourceListAsync<T>(string provider, string apiVersion = ``) {     var resourceList = new List<T>();      // Get https://management.azure.com/subscriptions/{subscriptionId}/providers/{provider}/?api-version={apiVersion}     var nextLink = BuildURI($`/subscriptions/{this.credentialHolder.SubscriptionId}/providers/{provider}`, apiVersion);     var httpHolder = new HttpHolder()     {         HttpMethod = HttpMethod.Get,         RequestBody = string.Empty,         RequestUri = nextLink,         EventName = nameof(GetResourceListAsync),     };     do     {         var responseMessage = await this.GetResponseMessageAsync(httpHolder).ConfigureAwait(false);          if (responseMessage.IsSuccessStatusCode)         {             var content = responseMessage.Content.ReadAsStringAsync().GetAwaiter().GetResult();              PagedListResult<T> page = JsonConvert.DeserializeObject<PagedListResult<T>>(content);             resourceList.AddRange(page.Value);             httpHolder.RequestUri = page.NextLink;         }         else         {             throw this.BuildExceptionFromResponse(responseMessage);         }     }     while (!string.IsNullOrEmpty(httpHolder.RequestUri));      return resourceList; }  As we migrate to Track 2 Azure management SDK, we noticed we can't build resource object via JSON deserialize directly. // replace Microsoft.Azure.Management.Compute.Models.VirtualMachine with Azure.ResourceManager.Compute.VirtualMachineData var virtualMachines = await armClient.GetResourceListAsync<VirtualMachineData>(`Microsoft.Compute/virtualMachines`);  Hit JsonSerializationException `ClassName`: `Newtonsoft.Json.JsonSerializationException`,   `Message`: `Error converting value \`/subscriptions/XXX/resourceGroups/XXX/providers/Microsoft.Compute/virtualMachines/XXX\` to type 'Azure.Core.ResourceIdentifier'. Path 'value[0].id', line 1, position 222.`,   `Data`: null,   `InnerException`: {     `ClassName`: `System.ArgumentException`,     `Message`: `Could not cast or convert from System.String to Azure.Core.ResourceIdentifier.`,     `Data`: null,     `InnerException`: null,     `HelpURL`: null,     `StackTraceString`: `   at Newtonsoft.Json.Utilities.ConvertUtils.EnsureTypeAssignable(Object value, Type initialType, Type targetType)\r\n   at Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(Object initialValue, CultureInfo culture, Type targetType)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.EnsureType(JsonReader reader, Object value, CultureInfo culture, JsonContract contract, Type targetType)`,     `RemoteStackTraceString`: null,     `RemoteStackIndex`: 0,     `ExceptionMethod`: null,     `HResult`: -2147024809,     `Source`: `Newtonsoft.Json`,     `WatsonBuckets`: null,     `ParamName`: null   },  May I know the migration guidance here? Environment No response
Mgmt	Synapse	'Null Ref Error' while calling the method	Type of issue Other (describe below) Description We are running NullRef error after executing the delete command, however the IP firewall rule does get deleted during the execution. The error is happening on certain dev machines, and for myself I don't face the problem while executing on my local machine. So my questions are  Does the method always return 'null' object for all results? Can we fire and forget if is always return 'null'? Can we put a try-catch block around the method to continue the execution if null ref error happens?   Page URL https://learn.microsoft.com/en-us/dotnet/api/microsoft.azure.management.synapse.ipfirewallrulesoperationsextensions.deleteasync?view=azure-dotnet-legacy Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Microsoft.Azure.Management.Synapse/IpFirewallRulesOperationsExtensions.xml Document Version Independent Id bca8d18d-3c6b-64fc-376e-b8a56040af21 Article author @azure-sdk Metadata  ID: 60eabb78-f781-8d15-74bb-71d5dd4841e4 Service: synapse-analytics
Client	Extensions	[FEATURE REQ] Add `IConfiguration` integration for `TokenProvider` when using `AddAzureAppConfiguration()`	Library name Microsoft.Extensions.Azure Please describe the feature. I'd like to propose a way to leverage the AzureComponentFactory in contexts where we don't yet have a IServiceProvider in place but we do have an IConfiguration: more specifically, when configuring Azure AppConfiguration. AzureComponentFactory is an abstract class today, and it's only implementation, called AzureComponentFactoryImpl, is internal and thus not accessible from the outside. Essentially, this is what I'd like to have: var builder = WebApplication.CreateBuilder(args); builder.Configuration.AddAzureAppConfiguration(new Uri(`https://our-global-appconfiguration.azconfig.io`)); However, there are a couple of problems there:  There is no overload for AddAzureAppConfiguration that take a Uri: only ones that take string for the connectionString approach. Yes, I know that is handled by Microsoft.Extensions.Configuration.AzureAppConfiguration and is thus not part of this repository One has to manually provide a tokenCredential value, so even if 1 was in place, it would still not work. We have to do this now:  var builder = WebApplication.CreateBuilder(args); builder.AddAzureAppConfiguration(     c => c.Connect(         endpoint: new Uri(`https://our-global-appconfiguration.azconfig.io`),         credential: new DefaultAzureCredential())); This is `mostly fine` (even though I think its excessively verbose and the credential argument should just default to DefaultAzureCredential anyways...), but the main issue starts when we have to deal with apps that are not hosted in Azure. We are in the process of integrating Azure AppConfiguration in a large number of projects, some hosted in Azure, some on-premise services, and even some that are hosted in AWS. Over this past few days, I've been looking into what the cleanest/safest/most manageable way would be to integrate these various services. For anything directly hosted in Azure, the answer has been pretty clearly to leverage Managed Identity as much as possible, which led us to a solution like the above. However, the problem starts with the on-premise services, where we are going with dedicated `service principals` created in Entra ID for the applications. Currently, our code looks exactly the same for those services: var builder = WebApplication.CreateBuilder(args); builder.AddAzureAppConfiguration(     c => c.Connect(         endpoint: new Uri(`https://our-global-appconfiguration.azconfig.io`),         credential: new DefaultAzureCredential())); But now we realized we have a problem: we want to persist some of the non-sensitive values in local configuration, such as appSettings.json. But doing so, breaks the implementation as all 3 of the following are expected to be present as environment variables only:  AZURE_TENANT_ID AZURE_CLIENT_ID AZURE_CLIENT_SECRET  If we move the tenant ID and the client ID (which are not secrets) to some other configuration source, DefaultAzureCredential cannot read them anymore (as it cannot rely on EnvironmentCredential to fetch all 3 values). There is zero integration with IConfiguration at this level. Suddenly, this becomes a huge mess: builder.Configuration.AddAzureAppConfiguration(c =>     c.Connect(         endpoint: new Uri(`https://our-global-appconfiguration.azconfig.io`),         credential: new ClientSecretCredential(             tenantId: builder.Configuration[`AZURE_TENANT_ID`],             clientId: builder.Configuration[`AZURE_CLIENT_ID`],             clientSecret: builder.Configuration[`AZURE_CLIENT_SECRET`]))); Having to read the individual values manually defeats the purpose of using DefaultAzureCredential (you can't even use it). You are then forced into changing the code to create an explicit ClientSecretCredential to pass in the 3 values. Then, if in the near future we want to switch to a cert-based auth, this needs to be changed manually again. And when we move the service from on-premises to inside Azure we have to update it yet again to change it back to either DefaultAzureCredential or the specific ManagedIdentityCredential. This design seems terrible to me. I found this library and immediately though we could use the AzureComponentFactory's CreateTokenCredential(IConfiguration) method. This would put us back into `sane` territory: builder.Configuration.AddAzureAppConfiguration(c =>     c.Connect(         endpoint: new Uri(`https://our-global-appconfiguration.azconfig.io`),         credential: new AzureComponentFactory().CreateTokenCredential(builder.Configuration))); But of course this doesn't work for a number of reasons:  AzureComponentFactory is abstract, and its only implementation, AzureComponentFactoryImpl, is internal Even if the concrete type wasn't internal, it doesn't have a parameterless ctor (and relies on IServiceProvider which we don't have at this point) Even if we were able to instantiate it, the values it expects are in a completely different format than the ones from the environment variables.... no AZURE_ prefix, and camelCase instead of snake_case...                azure-sdk-for-net/sdk/extensions/Microsoft.Extensions.Azure/src/Internal/ClientFactory.cs                   Lines 94 to 106       in       69b6ef7                                                 internal static TokenCredential CreateCredential(IConfiguration configuration)                                           {                                               var credentialType = configuration[`credential`];                                               var clientId = configuration[`clientId`];                                               var tenantId = configuration[`tenantId`];                                               var resourceId = configuration[`managedIdentityResourceId`];                                               var clientSecret = configuration[`clientSecret`];                                               var certificate = configuration[`clientCertificate`];                                               var certificateStoreName = configuration[`clientCertificateStoreName`];                                               var certificateStoreLocation = configuration[`clientCertificateStoreLocation`];                                               var additionallyAllowedTenants = configuration[`additionallyAllowedTenants`];                                               var tokenFilePath = configuration[`tokenFilePath`];                                               IEnumerable<string> additionallyAllowedTenantsList = null;                      At this point was when I decided to create this issue, because this seems extremely convoluted. I understand Microsoft.Extensions.Azure was created more to support clients such as the EventGrid one or direct KeyVault access, but the configuration flow needs some desperate help. Not only is it super verbose, but it is also extremely brittle and inconsistent: each change of direction requires significant code changes, naming changes, etc. This will force me to create some crazy custom extensions to workaround some of those limitations such that we can minimize the number of times we have to touch our code once it is deployed and needs Azure auth changes. At this point I feel like I'm doing something extremely wrong... hopefully that is the case and all of these problems I listed are non-issues with a different approach that I'm not seeing. Slightly related to:  #19664
Client	Communication - Chat	[FEATURE REQ] ACS Chat meta properties	Library name Azure.Communication.Chat Please describe the feature. SendChatMessageOptions.Metadata is for unknown reasons readonly? from docs: `Properties bag for custom attributes to the message in the form of key-value pair.` - readonly gives `custom` another meaning? https://learn.microsoft.com/en-us/dotnet/api/azure.communication.chat.sendchatmessageoptions.metadata?view=azure-dotnet#azure-communication-chat-sendchatmessageoptions-metadata We'd like to be able to set message meta props via SDK, scenario: create a system generated message in backend including meta information for frontend app (SPA) to display message based on meta info, e.g. being able to generate a link within app (without having backend to construct such link, links should be owned by SPA)
Mgmt	Container Service	Container Service: Web Application Routing Addon	Library Azure.ResourceManager.ContainerService 1.2.0 Description I think it is extremely odd that you do not have any documentation on how to implement the addons with ARM/Bicep, RestAPI, and the .net sdk anywhere in the published document echo system. the only thing you get is  but there is no doc on what should be configured.  the closet thing out there is if you come across one of @paolosalvatori scripts that has them defined. There not even documentation on the implementation change. In Azure.ResourceManager.ContainerService 1.2.0-beta.3 this was the way to defind it. managedClusterData.IngressWebAppRouting = new ManagedClusterIngressProfileWebAppRouting() {     IsEnabled = true,      }  which matches it's ARM counter part `ManagedClusterIngressProfileWebAppRouting`: {       `type`: `object`,       `properties`: {         `enabled`: {           `type`: `boolean`,           `description`: `Whether to enable Web App Routing.`         },  in 1.2.0 this no longer valid, and there's now where i can find doc on how to implementation the new changes.  Can we get the addons and their changes like this documented and added to the relevant pages and not off in the web corner somewhere. it's not working like the other addons { `WebAppRouting`, new ManagedClusterAddonProfile(isEnabled: true) }  how do you now enable web application routing now in Azure.ResourceManager.ContainerService 1.2.0?
Client	Azure.Identity	[BUG]  Azure.Identity.AuthenticationFailedException: ClientCertificateCredential authentication failed: Request to the endpoint timed out.	Library name and version Azure.Identity 1.10.4 Describe the bug We are using different Azure clients such as TableServiceClient from Azure.Data.Tables v12.8.3 or SecretClient Azure.Security.KeyVault.Secrets v4.6.0 Constructor of these clients accept TokenCredential and we are using instance of ClientCertificateCredential. Most of the time there is no issues with authentication, i.e. SecretClient using ClientCertificateCredential is able to connect to KeyVault and interact with it. However, occasionally we are seeing this error [03/31/2024 16:30:17] Unexpected error during test execution: Azure.RequestFailedException: Failed to retrieve secret 'https://somekeyvault.vault.azure.net/secrets/somesecret/' from KeyVault even after multiple retries ---> Azure.Identity.AuthenticationFailedException: ClientCertificateCredential authentication failed: Request to the endpoint timed out. ---> MSAL.NetCore.4.59.0.0.MsalServiceException: ErrorCode: request_timeout Microsoft.Identity.Client.MsalServiceException: Request to the endpoint timed out. ---> System.Threading.Tasks.TaskCanceledException: The request was canceled due to the configured HttpClient.Timeout of 100 seconds elapsing. ---> System.TimeoutException: The operation was canceled. ---> System.Threading.Tasks.TaskCanceledException: The operation was canceled. at Azure.Core.CancellationHelper.ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken) at Azure.Core.CancellationHelper.ThrowIfCancellationRequested(CancellationToken cancellationToken) at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout(CancellationToken originalToken, CancellationToken timeoutToken, Exception inner, TimeSpan timeout) at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken) at Azure.Core.HttpPipelineMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) at System.Net.Http.HttpClient.g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) --- End of inner exception stack trace --- --- End of inner exception stack trace --- at System.Net.Http.HttpClient.HandleFailure(Exception e, Boolean telemetryStarted, HttpResponseMessage response, CancellationTokenSource cts, CancellationToken cancellationToken, CancellationTokenSource pendingRequestsCts) at System.Net.Http.HttpClient.g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) at Microsoft.Identity.Client.Http.HttpManager.ExecuteAsync(Uri endpoint, IDictionary2 headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, CancellationToken cancellationToken) at Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendRequestAsync(Uri endpoint, IDictionary2 headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, Boolean doNotThrow, Boolean retry, CancellationToken cancellationToken) --- End of inner exception stack trace --- at Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendRequestAsync(Uri endpoint, IDictionary2 headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, Boolean doNotThrow, Boolean retry, CancellationToken cancellationToken) at Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendRequestAsync(Uri endpoint, IDictionary2 headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, Boolean doNotThrow, Boolean retry, CancellationToken cancellationToken) at Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendPostAsync(Uri endpoint, IDictionary2 headers, HttpContent body, ILoggerAdapter logger, CancellationToken cancellationToken) at Microsoft.Identity.Client.Http.HttpManager.SendPostAsync(Uri endpoint, IDictionary2 headers, IDictionary2 bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken) at Microsoft.Identity.Client.OAuth2.OAuth2Client.ExecuteRequestAsync[T](Uri endPoint, HttpMethod method, RequestContext requestContext, Boolean expectErrorsOn200OK, Boolean addCommonHeaders, Func2 onBeforePostRequestData) at Microsoft.Identity.Client.OAuth2.OAuth2Client.GetTokenAsync(Uri endPoint, RequestContext requestContext, Boolean addCommonHeaders, Func2 onBeforePostRequestHandler) at Microsoft.Identity.Client.OAuth2.TokenClient.SendHttpAndClearTelemetryAsync(String tokenEndpoint, ILoggerAdapter logger) at Microsoft.Identity.Client.OAuth2.TokenClient.SendHttpAndClearTelemetryAsync(String tokenEndpoint, ILoggerAdapter logger) at Microsoft.Identity.Client.OAuth2.TokenClient.SendTokenRequestAsync(IDictionary2 additionalBodyParameters, String scopeOverride, String tokenEndpointOverride, CancellationToken cancellationToken) at Microsoft.Identity.Client.Internal.Requests.RequestBase.SendTokenRequestAsync(IDictionary2 additionalBodyParameters, CancellationToken cancellationToken) at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger) at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.ExecuteAsync(CancellationToken cancellationToken) at Microsoft.Identity.Client.Internal.Requests.RequestBase.RunAsync(CancellationToken cancellationToken) at Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor.ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken) at Azure.Identity.AbstractAcquireTokenParameterBuilderExtensions.ExecuteAsync[T](AbstractAcquireTokenParameterBuilder1 builder, Boolean async, CancellationToken cancellationToken) at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientCoreAsync(String[] scopes, String tenantId, Boolean enableCae, Boolean async, CancellationToken cancellationToken) at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientAsync(String[] scopes, String tenantId, Boolean enableCae, Boolean async, CancellationToken cancellationToken) at Azure.Identity.ClientCertificateCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken) Inner Exception: System.Threading.Tasks.TaskCanceledException: The request was canceled due to the configured HttpClient.Timeout of 100 seconds elapsing. ---> System.TimeoutException: The operation was canceled. ---> System.Threading.Tasks.TaskCanceledException: The operation was canceled. at Azure.Core.CancellationHelper.ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken) at Azure.Core.CancellationHelper.ThrowIfCancellationRequested(CancellationToken cancellationToken) at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout(CancellationToken originalToken, CancellationToken timeoutToken, Exception inner, TimeSpan timeout) at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken) at Azure.Core.HttpPipelineMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) at System.Net.Http.HttpClient.g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) --- End of inner exception stack trace --- --- End of inner exception stack trace --- at System.Net.Http.HttpClient.HandleFailure(Exception e, Boolean telemetryStarted, HttpResponseMessage response, CancellationTokenSource cts, CancellationToken cancellationToken, CancellationTokenSource pendingRequestsCts) at System.Net.Http.HttpClient.g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) at Microsoft.Identity.Client.Http.HttpManager.ExecuteAsync(Uri endpoint, IDictionary2 headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, CancellationToken cancellationToken) at Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendRequestAsync(Uri endpoint, IDictionary2 headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, Boolean doNotThrow, Boolean retry, CancellationToken cancellationToken) StatusCode: 0 ResponseBody: Headers: --- End of inner exception stack trace --- at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable) at Azure.Identity.ClientCertificateCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueFromCredentialAsync(TokenRequestContext context, Boolean async, CancellationToken cancellationToken) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueAsync(HttpMessage message, TokenRequestContext context, Boolean async) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueAsync(HttpMessage message, TokenRequestContext context, Boolean async) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AuthenticateAndAuthorizeRequestAsync(HttpMessage message, TokenRequestContext context) at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.AuthorizeRequestOnChallengeAsyncInternal(HttpMessage message, Boolean async) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken) at Azure.Security.KeyVault.KeyVaultPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken) at Azure.Security.KeyVault.KeyVaultPipeline.SendRequestAsync[TResult](RequestMethod method, Func`1 resultFactory, CancellationToken cancellationToken, String[] path) at Azure.Security.KeyVault.Secrets.SecretClient.GetSecretAsync(String name, String version, CancellationToken cancellationToken) Expected behavior no error is expected Actual behavior We do not do anything special when instantiating ClientCertificateCredential, it is always the same code that instantiates ClientCertificateCredential Reproduction Steps There is no specific steps to reproduce this issue. We see it approximately once in a week. Environment .net core 6.0
Mgmt	API Management	[FEATURE REQ] Add policy fragment handling in Azure.ResourceManager.ApiManagement sdk	Library name Azure.ResourceManager.ApiManagement Please describe the feature. I'd like to manage my API Management Policy fragments in c# with the Azure.ResourceManager.ApiManagement SDK. At this moment I'm able to manage a lot about my API management, but the Policy Fragments seems missing. In the Management REST API API Management Policy Fragment this is available. Please add this functionality to the Azure.ResourceManager.ApiManagement SDK nuget package.
Client	Service Bus	[BUG] Cannot write large messages (>1MB) to Premium Partitioned Namespace	Library name and version Azure.Messaging.ServiceBus 7.17.4 Describe the bug We have been looking into switching to a premium, partitioned service bus namespace in order to deal with throughput issues we are seeing with our current non-partitioned namespace. We receive an error when trying to write a message larger than 1MB to a topic or queue in this new namespace, even when the topic/queue is configured to allow message sizes up to 10MB. Expected behavior We should still be able to write large messages to partitioned queues and topics. The documentation has no mention of this limitation when switching to a partitioned namespace. Actual behavior Azure.Messaging.ServiceBus.ServiceBusException  HResult=0x80131500  Message=The message (id:64923656, size:4194312 bytes) is larger than is currently allowed (1048576 bytes).  Source=Azure.Messaging.ServiceBus  StackTrace:   at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<SendBatchInternalAsync>d__23.MoveNext()   at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<SendBatchInternalAsync>d__23.MoveNext()   at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<>c.<<SendAsync>b__24_0>d.MoveNext()   at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<>c__22`1.<<RunOperation>b__22_0>d.MoveNext()   at System.Threading.Tasks.ValueTask`1.get_Result()   at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<RunOperation>d__23`2.MoveNext()   at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<RunOperation>d__23`2.MoveNext()   at System.Threading.Tasks.ValueTask`1.get_Result()   at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<RunOperation>d__22`1.MoveNext()   at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<SendAsync>d__24.MoveNext()   at Azure.Messaging.ServiceBus.ServiceBusSender.<SendMessagesAsync>d__26.MoveNext()   at Azure.Messaging.ServiceBus.ServiceBusSender.<SendMessageAsync>d__25.MoveNext()   at Program.<<Main>$>d__0.MoveNext() in J:\working\asb-sendmessages\asb-sendmessages\Program.cs:line 22   at Program.<<Main>$>d__0.MoveNext() in J:\working\asb-sendmessages\asb-sendmessages\Program.cs:line 31  Reproduction Steps using Azure.Messaging.ServiceBus; using System.Text;  // the client that owns the connection and can be used to create senders and receivers ServiceBusClient client;  // the sender used to publish messages to the queue ServiceBusSender sender;  var clientOptions = new ServiceBusClientOptions() {     TransportType = ServiceBusTransportType.AmqpWebSockets }; client = new ServiceBusClient(`<NAMESPACE-CONNECTION-STRING>`, clientOptions); sender = client.CreateSender(`test1`);  var message = new ServiceBusMessage(Encoding.UTF8.GetBytes(new string('A', 1024 * 1024 * 4)));  try {     await sender.SendMessageAsync(message);     Console.WriteLine($`A message has been published to the queue.`); } finally {     // Calling DisposeAsync on client types is required to ensure that network     // resources and other unmanaged objects are properly cleaned up.     await sender.DisposeAsync();     await client.DisposeAsync(); }  Console.WriteLine(`Press any key to end the application`); Console.ReadKey();  Environment No response
Client	Search	[BUG] MergeOrUploadDocuments() fails to serialize vectors	Library name and version Azure.Search.Documents 11.6.0.0 Describe the bug Fields that have their vector field counterpart (like string DisplayName,  ReadOnlyMemory DisplayNameVector) break when pushing this document through calling searchClient.MergeOrUploadDocuments(data), I'm getting errors like below. Azure.RequestFailedException HResult=0x80131500 Message=The request is invalid. Details: A node of type 'StartArray' was read from the JSON reader when trying to read the contents of the property 'DisplayNameVector'; however, a 'StartObject' node or 'PrimitiveValue' node with null value was expected. Status: 400 (Bad Request) Content: {`error`:{`code`:``,`message`:`The request is invalid. Details: A node of type 'StartArray' was read from the JSON reader when trying to read the contents of the property 'DisplayNameVector'; however, a 'StartObject' node or 'PrimitiveValue' node with null value was expected.`}} Headers: Content-Language: REDACTED Strict-Transport-Security: REDACTED Preference-Applied: REDACTED client-request-id: 3545775b-17e8-44b1-9e01-109179d0af93 x-ms-client-request-id: 3545775b-17e8-44b1-9e01-109179d0af93 request-id: 3545775b-17e8-44b1-9e01-109179d0af93 elapsed-time: 292 Content-Length: 279 Content-Type: application/json; charset=utf-8 Date: Thu, 28 Mar 2024 21:16:25 GMT Server: Microsoft-IIS/10.0 Source=Azure.Search.Documents StackTrace: at Azure.Search.Documents.SearchClient.d__501.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Search.Documents.SearchClient.IndexDocuments[T](IndexDocumentsBatch1 batch, IndexDocumentsOptions options, CancellationToken cancellationToken) at Azure.Search.Documents.SearchClient.MergeOrUploadDocuments[T](IEnumerable1 documents, IndexDocumentsOptions options, CancellationToken cancellationToken) at Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.ExtensionMethods.Ingest[T](IEnumerable1 data, SearchClient searchClient) in Q:\Repos\Shared\Sql\CloudBI\AS\src\PowerBI\PowerBIArtifactIndex\StorageClients\AzureSearchClient\ExtensionMethods.cs:line 51 at Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.AzureSearchClient.IngestData[T](IEnumerable`1 data) in Q:\Repos\Shared\Sql\CloudBI\AS\src\PowerBI\PowerBIArtifactIndex\StorageClients\AzureSearchClient\AzureSearchClient.cs:line 426 This exception was originally thrown at this call stack: [External Code] Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.ExtensionMethods.Ingest(System.Collections.Generic.IEnumerable, Azure.Search.Documents.SearchClient) in ExtensionMethods.cs Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.AzureSearchClient.IngestData(System.Collections.Generic.IEnumerable) in AzureSearchClient.cs Expected behavior To push the parse the vector's data and push to its index. Actual behavior Exception is thrown. Azure.RequestFailedException HResult=0x80131500 Message=The request is invalid. Details: A node of type 'StartArray' was read from the JSON reader when trying to read the contents of the property 'DisplayNameVector'; however, a 'StartObject' node or 'PrimitiveValue' node with null value was expected. Status: 400 (Bad Request) Content: {`error`:{`code`:``,`message`:`The request is invalid. Details: A node of type 'StartArray' was read from the JSON reader when trying to read the contents of the property 'DisplayNameVector'; however, a 'StartObject' node or 'PrimitiveValue' node with null value was expected.`}} Headers: Content-Language: REDACTED Strict-Transport-Security: REDACTED Preference-Applied: REDACTED client-request-id: 3545775b-17e8-44b1-9e01-109179d0af93 x-ms-client-request-id: 3545775b-17e8-44b1-9e01-109179d0af93 request-id: 3545775b-17e8-44b1-9e01-109179d0af93 elapsed-time: 292 Content-Length: 279 Content-Type: application/json; charset=utf-8 Date: Thu, 28 Mar 2024 21:16:25 GMT Server: Microsoft-IIS/10.0 Source=Azure.Search.Documents StackTrace: at Azure.Search.Documents.SearchClient.d__501.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Search.Documents.SearchClient.IndexDocuments[T](IndexDocumentsBatch1 batch, IndexDocumentsOptions options, CancellationToken cancellationToken) at Azure.Search.Documents.SearchClient.MergeOrUploadDocuments[T](IEnumerable1 documents, IndexDocumentsOptions options, CancellationToken cancellationToken) at Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.ExtensionMethods.Ingest[T](IEnumerable1 data, SearchClient searchClient) in Q:\Repos\Shared\Sql\CloudBI\AS\src\PowerBI\PowerBIArtifactIndex\StorageClients\AzureSearchClient\ExtensionMethods.cs:line 51 at Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.AzureSearchClient.IngestData[T](IEnumerable`1 data) in Q:\Repos\Shared\Sql\CloudBI\AS\src\PowerBI\PowerBIArtifactIndex\StorageClients\AzureSearchClient\AzureSearchClient.cs:line 426 This exception was originally thrown at this call stack: [External Code] Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.ExtensionMethods.Ingest(System.Collections.Generic.IEnumerable, Azure.Search.Documents.SearchClient) in ExtensionMethods.cs Microsoft.PowerBI.ArtifactIndex.AzureSearchClient.AzureSearchClient.IngestData(System.Collections.Generic.IEnumerable) in AzureSearchClient.cs Reproduction Steps Declaring properties like: string DisplayName; ReadOnlyMemory DisplayNameVector; Using Azure.OpenAI client, get the embeddings for DisplayName. var response = openAIClient.GetEmbeddings(new EmbeddingsOptions(`my-text-embedding-ada-002`, [text])); data.displayNameVector = response.Value.Data[0].Embedding; And push: var results = searchClient.MergeOrUploadDocuments(data); Environment Microsoft Visual Studio Enterprise 2022 (64-bit) - Current Version 17.9.3 <PackageVersion Include=`Azure.AI.OpenAI` Version=`1.0.0-beta.15` />
Client	OpenAI	[FEATURE REQ] Add support for streaming responses from assistants (Azure.AI.OpenAI.Assistants)	Library name Azure.AI.OpenAI.Assistants Please describe the feature. OpenAI added streaming support for agents two weeks ago. Would be nice to see this implemented here.
Client	Service Bus	Messages ordering when receiving batch of messages from Service Bus	Library name and version Azure.Messaging.ServiceBus 7.15.0 Query/Question I'm receiving messages in batch from Azure Service Bus: IReadOnlyList<ServiceBusReceivedMessage> receivedMessages = await serviceBusReceiver.ReceiveMessagesAsync(maxMessages: maxMessages, maxWaitTime: TimeSpan.FromSeconds(1), cancellationToken: cancellationToken);  It works fine but I am unsure if it also consider the ordering (FIFO). I know what we can achieve this behaviour using Sessions. But I want to ask if I need to use sessions when receiving batch of messages? I've a single receiver that receives and process messages in batches. But I want to ensure ordering as I am receiving devices info e.g last seen etc and I need to make sure that I've updated the correct info. Also if Sessions is the only way then should I just set the SessionId to DeviceId and that will make sure that the all the messages linked to a single device get processed in order? I've done a quick test and I can see that message are received in sequence. I've added batch of 150 messages to the topic: int numOfMessages = 150; for (int i = 1; i <= numOfMessages; i++) {     // try adding a message to the batch     var msg = new ServiceBusMessage($`Message {i}`);     msg.ApplicationProperties.Add(`Type`, 1);     if (!messageBatch.TryAddMessage(msg))     {         // if it is too large for the batch         throw new Exception($`The message {i} is too large to fit in the batch.`);     } }  try {          await sender.SendMessagesAsync(messageBatch);     Console.WriteLine($`A batch of {numOfMessages} messages has been published.`);      } finally {     // Calling DisposeAsync on client types is required to ensure that network     // resources and other unmanaged objects are properly cleaned up.     await sender.DisposeAsync();     await client.DisposeAsync(); }  After this I added a receiver method that receives and logs the message to the console: private async Task ProcessMessages(int maxMessagesToProcess, CancellationToken cancellationToken) {           while (!cancellationToken.IsCancellationRequested)      {          var receivedMessageList = new List<ServiceBusReceivedMessage>();          IReadOnlyList<ServiceBusReceivedMessage> receivedMessages = await _serviceBusReceiver.ReceiveMessagesAsync(maxMessages: maxMessagesToProcess, maxWaitTime: TimeSpan.FromSeconds(1), cancellationToken: cancellationToken);          if (receivedMessages.Count > 0)          {              receivedMessageList.AddRange(receivedMessages);              foreach (var msg in receivedMessageList)              {                  Debug.WriteLine($`Message: {msg.Body}`);              }              if (receivedMessageList.Count >= ConcurrentMessagesToProcess)              {                  //await ProcessReceivedMessages(receivedMessageList);                   var processAgain = await CheckForMessageProcessing();                  if (!processAgain)                  {                      break;                  }              }          }          else          {              break;          }      }  }  After multiple tests, I get the messages in sequence. I'm unsure if I've missed any scenario or is this expected. Environment .Net Core 3.1 Visual Studio 2022
Client	Schema Registry	[BUG] Microsoft.Azure.Data.SchemaRegistry.ApacheAvro installs with 3 High security vulnerabilities	Library name and version Microsoft.Azure.Data.SchemaRegistry.ApacheAvro 1.0.0 Describe the bug When I install Microsoft.Azure.Data.SchemaRegistry.ApacheAvro 1.0.0 in a net8.0 project I got security vulnerabilities: dotnet new console dotnet add package Microsoft.Azure.Data.SchemaRegistry.ApacheAvro dotnet list package --include-transitive --vulnerable  returns  Transitive Package                    Resolved   Severity   Advisory URL    > Newtonsoft.Json                     10.0.3     High       https://github.com/advisories/GHSA-5crp-9r3c-p9vr    > System.Net.Http                     4.3.0      High       https://github.com/advisories/GHSA-7jgj-8wvc-jh57    > System.Text.RegularExpressions      4.3.0      High       https://github.com/advisories/GHSA-cmhx-cq75-c4mj  Expected behavior Microsoft packages should not include dependencies with High Severity warnings. Actual behavior System.Net.Http, System.Text.RegularExpressions and Newtonsoft.Json are out of date Reproduction Steps dotnet new console dotnet add package Microsoft.Azure.Data.SchemaRegistry.ApacheAvro dotnet list package --include-transitive --vulnerable  Environment .NET SDK:  Version:           8.0.202  Commit:            25674bb2f4  Workload version:  8.0.200-manifests.a7f084b6  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22631  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.202\  .NET workloads installed:  [aspire]    Installation Source: SDK 8.0.200, VS 17.10.34707.107    Manifest Version:    8.0.0-preview.4.24156.9/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.aspire\8.0.0-preview.4.24156.9\WorkloadManifest.json    Install Type:        FileBased
Client	Service Bus	[BUG] Sometimes, after a message sent by service bus client is throttled, all messages are delayed by 10 seconds for an unlimited duration	Library name and version Azure.Messaging.ServiceBus 7.16.2 Describe the bug Sometimes, after a message sent by ServiceBusSender is throttled, the sleep time in case of busy server (10 seconds by default) will be applied to all messages sent with the same ServiceBusSender without time limit, instead of removing the sleep time after the sleep time delay. I think the problem cause is in the Azure.Messaging.ServiceBus.ServiceBusRetryPolicy class. If the CancellationTaken passed to ServiceSender.SendMessage is cancelled when Task.Delay is waiting for the end of sleep time in ScheduleResetServerBusy, the method ResetServerBusy() will never be called. So, _serverBusyState will be busy forever. The problem will probably affect all other classes using ServiceBusRetryPolicy. Expected behavior When a service bus message is throttled, the ServerBusyState should only be applied for ServerBusyBaseSleepTime in ServiceBusRetryPolicy. Actual behavior When a service bus message is throttled and the cancellation token of the throttled message is cancelled, the ServerBusyState is applied forever. Reproduction Steps This code should reproduce the problem if it is possible to have a Service Bus server replying with a server busy error for the first message and a success for the following messages:  var connectionString = ``;  var queueName = `queueName`;    var message = new ServiceBusMessage(string.Empty);    // Creates a cancellation token source to cancel tokens after 500ms  var cts = new CancellationTokenSource(500);    var serviceBusClient = new ServiceBusClient(connectionString);  var sender = serviceBusClient.CreateSender(queueName);   try  {   // Send a message which should throw a ServiceBusException with Reason ServiceBusFailureReason.ServiceBusy   await sender.SendMessageAsync(message, cts.Token);  }  catch (Exception ex)  {  }   // wait 15 seconds to be sure the servce busy sleep time of 10 seconds is elapsed  await Task.Delay(15_000);    var stopWatch = Stopwatch.StartNew();    // Send a 2nd message which should succeed  await sender.SendMessageAsync(message, CancellationToken.None);   // The time to send the 2nd message is longer than 10 seconds because the sender still consider the server as busy:  Console.WriteLine(stopWatch.Elapsed);  Environment Azure AppService Windows x64, .Net 6
Client	Service Bus	[FEATURE REQ] Return object for SendMessageAsync with success or failure state	Library name Azure.Messaging.ServiceBus Please describe the feature. We had some issues on our Cloud environment where messages were not sent to the service bus. This was in fact entirely our fault, we bursted the messages towards the service bus without closing our Sender and Client connection (not using DisposeAsync()). At a certain point, no messages were sent as described above, but also no feedback or error message was given from the call to SendMessageAsync(). We would expect if connection exhausting (which was the issue in our case) or general failure occurs in sending the message, we would get some feedback. Now we could only deduct it from watching the metrics of our service bus in Azure portal. It would be nice to have some sort of object containing a success state when send a message.
Client	Service Bus	Wait Time between receiving batch messages from service bus topic	Library name and version Microsoft.Azure.WebJos.Extensions.ServiceBus Query/Question I have configured an azure function app with ServiceBusTrigger. This Trigger is meant to receive messages in batches. I configured batch size, MaxBatchWaitTime and everything works fine so far. But now I want my trigger to wait for certain amount of time between different batch requests. Is there a configuration like MinBatchWaitTime that I can use? I see that with MaxBatchWaitTime set, the next request wait for sometime to fill the batch before picking up the messages. Is there some configuration available that can be used to make next requests wait like minBatchWaitTime? Please see attached screenshot here:  In the above screenshot, since the batchsize is 3 and total messages in service bus is 10, the last request waits until `MaxBatchWaitTime` (10 secs in my case)  before receiving the batch messages from service bus. I want second request also to be tiggered at 10:55:46 instead of being triggered immediately and third request to be triggered at 10:56:06. How can this be achieved? Could you please help me here? I tried several configuration settings like FixedDelayRetry attribute, setting retryTimeout in host.json. But most of the settings are only for retry scenarios. Also there is something like MaxPollingInterval for queues but not for topics. Even the maxConcurrentCalls works only for receivers receiving single messages not in batch. Environment My application is azure function app hosted in azure. OS: Windows. .Net 6 (in-process Model). IDE: Visual Studio 2022
Client	EngSys	[BUG] Bot closing valid issues	Hi @et1975, we deeply appreciate your input into this project. Regrettably, this issue has remained inactive for over 2 years, leading us to the decision to close it. We've implemented this policy to maintain the relevance of our issue queue and facilitate easier navigation for new contributors. If you still believe this topic requires attention, please feel free to create a new issue, referencing this one. Thank you for your understanding and ongoing support.  Originally posted by @github-actions[bot] in #19167 (comment) I think you should really fix your bot, closing valid issues like 19167 because there is not enough activity, is a terrible developer experience. Can you maybe document what the policy is or how user should do Important Security feature requests? My personal opinion is that security related feature requests should never be closed without human intervention. This issue 19167 specifically, because all the so called `solutions` require the user to again start setting up user secrets during development. Which will eventually lead to them accidentally committing those secrets to the repository again, something you try to discourage. If you instead facilitate the use of DefaultAzureCredential in docker, there would be no need to setup the service principal in the first place.
Client	Service Bus	[FEATURE REQ] Please add an option to set the application properties inside the ServiceBusModelFactory class	Library name Azure.Messaging.ServiceBus Please describe the feature. Hi, for (unit) testing purpose it would be great to set the applicationProperties inside the model factory. Currently there is no option to set it, which causes us some issues as we are not able to write unit tests which are depended on application properties to be there. https://learn.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusmodelfactory?view=azure-dotnet
Client	SignalR	[QUERY] Must use Azure SignalR management SDK with Azure Functions, but no documentation exists.	Library name and version Microsoft.Azure.WebJobs.Extensions.SignalRService 1.13.0 Query/Question According to information in #30218, `serverless hub is not supported in isolated-process model. If you want the similar coding experience in isolated-process, please use Azure SignalR management SDK directly.` The documentation for the SignalRService package still uses the serverless hub model and does not mention it can't be used in isolated-process model. #30218 also mentions that the documentation will be updated to reflect this change. Where is this documentation? Environment No response
Client	OpenAI	[BUG] Add missing streaming support to the Assistants API	Library name and version Azure.AI.OpenAI.Assistants_1.0.0-beta.3 Describe the bug OpenAI added streaming support to the assistant API: https://platform.openai.com/docs/assistants/overview?context=with-streaming. Granted, this shipped today, so I understand if you don't have same-day shipping (we used to have that in Xamarin, heh). But it's a critically important API to support. See changelog at https://platform.openai.com/docs/changelog Expected behavior Support the streaming API Actual behavior No streaming in Assistant API Reproduction Steps Try to invoke the assistant API using streaming Environment No response
Mgmt	Container Service	[BUG] when put resource input empty string, get resource via SDK met `Value cannot be an empty string. (Parameter 'resourceId')` error	Library name and version Azure.ResourceManager.AppContainers Version=1.1.0-beta.1 Describe the bug when PUT containerApp env contains property equal to empty string, then get containerApp env via SDK will fail with error  `Value cannot be an empty string. (Parameter 'resourceId')` Expected behavior SDK get containerApp env succeed. Actual behavior get containerApp env via SDK will fail with error  `Value cannot be an empty string. (Parameter 'resourceId')` Reproduction Steps  PUT containerAPp env with below sample payload  https://management.azure.com/subscriptions/xxxx/resourceGroups/xxxx/providers/Microsoft.App/managedEnvironments/xxxx?api-version=2022-10-01  {`location`: `eastus2`, `tags`: null, `properties`: {`daprAIInstrumentationKey`: null, `vnetConfiguration`: {`infrastructureSubnetId`: ``, `runtimeSubnetId`: ``, `internal`: false}, `appLogsConfiguration`: {`destination`: `log-analytics`, `logAnalyticsConfiguration`: {`customerId`: `xxxxx`, `sharedKey`: `xxxxx`}}, `customDomainConfiguration`: null, `workloadProfiles`: null, `InfrastructureResourceGroup`: null, `zoneRedundant`: false}}    Get via SDK  ContainerAppManagedEnvironmentResource env = client.GetContainerAppManagedEnvironmentResource(envId);  response with stacktrace System.ArgumentException: Value cannot be an empty string. (Parameter 'resourceId')    at Azure.Core.Argument.AssertNotNullOrEmpty(String value, String name)    at Azure.Core.ResourceIdentifier..ctor(String resourceId)    at Azure.ResourceManager.AppContainers.Models.ContainerAppVnetConfiguration.DeserializeContainerAppVnetConfiguration(JsonElement element)    at Azure.ResourceManager.AppContainers.ContainerAppManagedEnvironmentData.DeserializeContainerAppManagedEnvironmentData(JsonElement element)    at Azure.ResourceManager.AppContainers.ManagedEnvironmentsRestOperations.GetAsync(String subscriptionId, String resourceGroupName, String environmentName, CancellationToken cancellationToken)    at Azure.ResourceManager.AppContainers.ContainerAppManagedEnvironmentResource.GetAsync(CancellationToken cancellationToken)  Environment No response
Client	Azure.Identity	[BUG] ManagedIdentityCredential authentication failed: Adding the specified count to the semaphore would cause it to exceed its maximum count	Library name and version Azure.Identity 1.10.4.0 Describe the bug I use the following code to obtain the access token from Azure var credentialsProvider = new DefaultAzureCredential(        new DefaultAzureCredentialOptions{ ManagedIdentityClientId = `XYZ` });  var accessToken = await credentialsProvider.GetTokenAsync(new TokenRequestContext(_scopes), cancellationToken);  From time to time, it throws exception ManagedIdentityCredential authentication failed: Adding the specified count to the semaphore would cause it to exceed its maximum count. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot  Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: Adding the specified count to the semaphore would cause it to exceed its maximum count. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot   ---> System.Threading.SemaphoreFullException: Adding the specified count to the semaphore would cause it to exceed its maximum count.        at System.Threading.SemaphoreSlim.Release(Int32 releaseCount)        at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger)        at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.ExecuteAsync(CancellationToken cancellationToken)        at Microsoft.Identity.Client.Internal.Requests.RequestBase.RunAsync(CancellationToken cancellationToken)        at Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor.ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken)        at Azure.Identity.AbstractAcquireTokenParameterBuilderExtensions.ExecuteAsync[T](AbstractAcquireTokenParameterBuilder`1 builder, Boolean async, CancellationToken cancellationToken)        at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientCoreAsync(String[] scopes, String tenantId, Boolean enableCae, Boolean async, CancellationToken cancellationToken)        at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientAsync(String[] scopes, String tenantId, Boolean enableCae, Boolean async, CancellationToken cancellationToken)        at Azure.Identity.ManagedIdentityClient.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)        at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)         --- End of inner exception stack trace ---        at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable)        at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)        at Azure.Identity.ManagedIdentityCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)        at Azure.Identity.DefaultAzureCredential.GetTokenFromSourcesAsync(TokenCredential[] sources, TokenRequestContext requestContext, Boolean async, CancellationToken cancellationToken)        at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)        at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable)        at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)        at Azure.Identity.DefaultAzureCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)      Expected behavior No exception, access token retrieved Actual behavior From time to time, exception is thrown Reproduction Steps Can't find. I suspected that it is connected to the heavy load or some leak. I tried to reproduce it by calling this method 10k times one by one, I was not able to do that. Also, I tried to do this in multiple threads at the same time, can't reproduce it neither. Environment Azure App Service
Client	OpenAI	[FEATURE REQ] Support for blob image url when using GPT-4 Turbo with Vision	Library name Azure.AI.OpenAI 1.0.0-beta.14 Please describe the feature. When using GPT-4 Turbo with Vision model, I want to have the ability to pass blob url to the image in the image_url field.                 {                  `type`: `image_url`,                  `image_url`: {                                `url`: `<URL of image blob>`                     }                 }   Right now I get 403 forbidden error. `The provided image url can not be accessed. status code: 403.\r\nStatus: 400 (Bad Request)` What I have tried - The base64 image passed in image_url has a size restriction of 64 KB. My service is within VPN, so accessing image from web is a security issue. Please provide ability to pass a blob image url on which the API has Service account access to be used in the image_url field, OR please share any other way to pass the url so that the openai model can access it.
Client	Service Bus	[QUERY] Adding ServiceBusClients and creating ServiceBusSender clients for multiple Service Bus Namespaces	Library name and version Azure.Messaging.ServiceBus 7.17.3 Query/Question I can't work out how I can instantiate ServiceBusSender clients for multiple Service Bus namespaces.  Some of the senders are for queues, and some are for topics. I wanted to iterate through a number of SB namespaces held in config, so create a helper function to create the factories: private static void AddNamedServiceBusSender(IServiceCollection services, IConfiguration configuration, string configSectionName, string senderName) {     var config = configuration.GetSection(configSectionName);     string? serviceBusConnectionString = config.GetValue<string?>(`ConnectionString`));     string? serviceBusNamespace = config.GetValue<string?>(`Namespace`));     string? queueName = config.GetValue<string?>(`QueueName`));     string? topicName = config.GetValue<string?>(`TopicName`));      services.AddAzureClients(builder =>     {         if (!string.IsNullOrEmpty(serviceBusNamespace))         {             builder.AddServiceBusClientWithNamespace(serviceBusNamespace);         }         else         {             builder.AddServiceBusClient(serviceBusConnectionString);         }          builder.AddClient<ServiceBusSender, ServiceBusSenderOptions>((_, _, provider) => provider             .GetService<ServiceBusClient>()!             .CreateSender(queueName ?? topicName))         .WithName(senderName);     }); } I then injected a IAzureClientFactory<ServiceBusSender> instance into the consuming class, and used .CreateClient(namedClient) to create the ServiceBusSender instances as needed. However, the problem with this is that the call to provider.GetService<ServiceBusClient>() is not keyed, so when called, all senders get whatever client was added to the services collection last. I think what I need is the ability to have an AddKeyedServiceBusClient/AddKeyedServiceBusClientWithNamespace, and then be able to use GetKeyedService<ServiceBusClient>(senderName) in the AddClient lambda, but neither of these extension methods exist. I've ended up using AddKeyedSingleton<ServiceBusClient> to add the service bus clients, and then using AddKeyedScoped to add the ServiceBusSender instances, which use GetKeyedRequiredService<ServiceBusClient>(serviceKey), but I don't know whether this is best practice, or not.  My consuming class now has IServiceProvider injected. Is there a way to achieve this with the current AddAzureClients implementation? Environment .Net 8 dotnet-isolated function app
Client	Event Grid	Azure.Messaging.EventGrid 4.22.0 stable ReceiveCloudEvents Missing	Library name Azure.Messaging.EventGrid 4.22.0 Please describe the feature. Hi, In `Azure.Messaging.EventGrid` Version=`4.22.0-beta.1` there was a way for doing pulling from Event Grid using EventGridClient and ReceiveCloudEvents method implementation. When updating to Latest stable 4.22.0 this feature disappeared. Was this moved somewhere else or it was cancelled. Is it planned to be delivered?
Client	OpenAI	Azure OpenAI API version 2023-12-01-preview to be deprecated 2024-04-02	Library name and version Azure.AI.OpenAI 1.0.0-beta.14 Query/Question My team received an email stating that this deprecation would occur, and according to the release notes, the last time the API version was mentioned it was still on 2023-12-01-preview, which is one of the legacy versions slated to be retired. Is there a timeframe to expect a release that uses a supported API version? Thank you in advance! Environment Azure
Client	Event Hubs	[QUERY] Consumers from the same consumer group listen to the same messages twice	Library name and version Azure.Messaging.EventHubs.Processor 5.11.0 Azure.Messaging.EventHubs 5.11.1 Query/Question I have my EventHub instance with 4 partitions. And I sent 10 events with the following PartitionKey: #pk5, #pk3, #pk4, #pk1, #pk4, #pk3, #pk2, #pk1, #pk5, #pk2. Using ServiceBusExplorer I see the following picture how events were distriburted in partitions: PartitionId 0: PartitionKey=[#pk3] SequenceNumber=[0] PartitionKey=[#pk4] SequenceNumber=[1] PartitionKey=[#pk4] SequenceNumber=[2] PartitionKey=[#pk3] SequenceNumber=[3] PartitionId 1: PartitionKey=[#pk1] SequenceNumber=[0] PartitionKey=[#pk2] SequenceNumber=[1] PartitionKey=[#pk1] SequenceNumber=[2] PartitionKey=[#pk2] SequenceNumber=[3] PartitionId 2: PartitionKey=[#pk5] SequenceNumber=[0] PartitionKey=[#pk5] SequenceNumber=[1] PartitionId 3:  no events  I launch 5 consumers in parrallel (5 instances of the EventProcessorClient) in the same $Default consumer group.  ConsumerId: 66f03b54-e395-498a-8e69-5c37036e499d ConsumerId: 801c942f-fde2-4350-9dc0-906b1fa61df1 ConsumerId: 92158784-abc6-40a0-929e-2f5f3482c9e3 ConsumerId: 2fb3e34e-7bb4-444c-bcea-ec50ee503506 ConsumerId: ff9ef0c3-8051-4ade-9bfc-4a0bc953a75d  I expected that all consumers will coordinate to balance work between them and if Consumer: 92158784-abc6-40a0-929e-2f5f3482c9e3 started listening to PartitionKey: #pk2 (PartitionId: 1), then ConsumerId: 2fb3e34e-7bb4-444c-bcea-ec50ee503506 won't listen to the same messages from PartitionKey: #pk2. However based on the log of my application below I see that sometimes different consumers in the same consumer group listen to the same messages ConsumerId: 92158784-abc6-40a0-929e-2f5f3482c9e3;  PartitionKey: #pk2; SequenceNumbers that was listened by the consumer within PartitionKey: [1,3]; PartitionKey: #pk1; SequenceNumbers that was listened by the consumer within PartitionKey: [0,2];  ConsumerId: 801c942f-fde2-4350-9dc0-906b1fa61df1  PartitionKey: #pk3; SequenceNumbers that was listened by the consumer within PartitionKey: [0,3]; PartitionKey: #pk4; SequenceNumbers that was listened by the consumer within PartitionKey: [1,2];  ConsumerId: ff9ef0c3-8051-4ade-9bfc-4a0bc953a75d  PartitionKey: #pk5; SequenceNumbers that was listened by the consumer within PartitionKey: [0,1];  ConsumerId: 2fb3e34e-7bb4-444c-bcea-ec50ee503506;  PartitionKey: #pk2; SequenceNumbers that was listened by the consumer within PartitionKey: [1,3]; PartitionKey: #pk5; SequenceNumbers that was listened by the consumer within PartitionKey: [0,1]; PartitionKey: #pk1; SequenceNumbers that was listened by the consumer within PartitionKey: [0,2];  Is it possible to tune EventProcessorClient in my consumer application to avoid listening the same messages twince from different consumers? See my consumer application code below using Azure.Messaging.EventHubs; using Azure.Messaging.EventHubs.Processor; using Azure.Storage.Blobs; using System.Collections.Concurrent;  internal class Program {     const string storageConnectionString = `......`;     const string blobContainerName = `.....`;      const string eventHubsConnectionString = `.....`;     const string eventHubName = `.......`;     const string consumerGroup = `$Default`;      static object lockResult = new object();      private static async Task Main(string[] args)     {         CancellationTokenSource source = new CancellationTokenSource();         source.CancelAfter(TimeSpan.FromMinutes(1));          var threads = Enumerable.Range(0, 5)                     .Select(_ => new ThreadStart(async () =>                     {                         await Launch(source.Token);                     }))                     .Select(x => new Thread(x))                     .ToList();          foreach (var t in threads) t.Start();          await Task.Delay(Timeout.Infinite);     }      static async Task Launch(CancellationToken token)     {         var consumerId = Guid.NewGuid().ToString();          await Console.Out.WriteLineAsync($`ConsumerId: {consumerId}`);         var partitionKeyToSequenceNumbers = new ConcurrentDictionary<string, List<long>>();          var storageClient = new BlobContainerClient(         storageConnectionString,         blobContainerName);          var processor = new EventProcessorClient(             storageClient,             consumerGroup,             eventHubsConnectionString,             eventHubName,              new EventProcessorClientOptions              {                  LoadBalancingStrategy = LoadBalancingStrategy.Greedy              });          try         {             processor.ProcessEventAsync += processEventHandlerPartitionKeyinDict;             processor.ProcessErrorAsync += (ProcessErrorEventArgs args) => { Console.WriteLine($`Exception: {args.Exception}`); return Task.CompletedTask; };              await processor.StartProcessingAsync(token);             await Task.Delay(Timeout.Infinite, token);              async Task processEventHandlerPartitionKeyinDict(ProcessEventArgs args)             {                 var partitionKey = $`{args.Data.PartitionKey}`;                 partitionKeyToSequenceNumbers.AddOrUpdate(                     partitionKey,                     new List<long> { args.Data.SequenceNumber },                     (key, oldValue) =>                     {                         oldValue.Add(args.Data.SequenceNumber);                         return oldValue;                     });                  await args.UpdateCheckpointAsync();             }         }         catch (Exception ex)         {             lock (lockResult)             {                 Console.WriteLine();                 foreach (var partitionKey in partitionKeyToSequenceNumbers.Keys)                 {                     Console.WriteLine($`ConsumerId: {consumerId}; PartitionKey: {partitionKey}; SequenceNumbers that was listened by the consumer within PartitionKey: [{string.Join(',', partitionKeyToSequenceNumbers[partitionKey])}];`);                 }             }         }     } } Environment OS: Windows net7.0 Azure.Messaging.EventHubs.Processor 5.11.0 Azure.Messaging.EventHubs 5.11.1
Client	KeyVault	Azure Key Vault libraries for .NET broken GitHub links for version 3.x.x	Type of issue Other (describe below) Description The links point to inexistent resources: Version 3.x.x The source code for the Azure Key Vault libraries for .NET is available on GitHub. Use the following version 3.x.x libraries to work with certificates, keys, and secrets:    Library Reference Package Source     Microsoft.Azure.KeyVault.Core Reference NuGet GitHub   Microsoft.Azure.KeyVault.Cryptography Reference NuGet GitHub   Microsoft.Azure.KeyVault.Extensions  NuGet GitHub   Microsoft.Azure.KeyVault.WebKey Reference NuGet GitHub   Microsoft.Azure.KeyVault Reference NuGet GitHub    Page URL https://learn.microsoft.com/en-us/dotnet/api/overview/azure/key-vault?view=azure-dotnet&source=docs Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/api/overview/azure/latest/key-vault.md Document Version Independent Id a3e86a24-3caa-c378-90ac-3e7bcea62828 Article author @azure-sdk Metadata  ID: c3f44732-15c3-8ed7-d153-6d67ec8425cb Service: keyvault
Client	Event Hubs	[QUERY] Connect to eventhubs using sample	Library name and version main - c744877 Query/Question Im trying to connect a eventhubs processor to my clients eventhub using the sample thats provided here: sdk-sample However I keep running into timeout exceptions:  C:/Users/507587/RiderProjects/azure-sdk-for-net/artifacts/bin/Azure.Messaging.EventHubs.Processor.Samples.HostedService/Debug/net6.0/Azure.Messaging.EventHubs.Processor.Samples.HostedService.exe fail: Azure.Messaging.EventHubs.Processor.Samples.HostedService.EventProcessorClientService[0] Error in the EventProcessorClient         Operation: Performing the main Event Processor loop. Azure.Messaging.EventHubs.EventHubsException(GeneralError): WARNING: A load balancing cycle has taken too long to complete.  A slow cycle can cause stability issues with partition ownership.  Consider investigating storage latency and thread pool health.  Common causes are soft delete being enabled for storage and too many partitions owne d.  You may also want to consider increasing the 'PartitionOwnershipExpirationInterval' in the processor options.  Cycle Duration: '86.10' seconds.  Partition Ownership Interval '1:20' seconds. (iot-telemetry).  For troubleshooting information, see https://aka.ms/azsdk/net/eventhubs/exceptions/troubleshoot fail: Azure.Messaging.EventHubs.Processor.Samples.HostedService.EventProcessorClientService[0] Error in the EventProcessorClient         Operation: Retrieving list of partition identifiers from a Consumer Client. System.TimeoutException: Creation of RequestResponseAmqpLink did not complete in 0 milliseconds. at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)                               at Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken)    at Azure.Messaging.EventHubs.EventHubConnection.GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.EventHubConnection.GetPartitionIdsAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken)        at Azure.Messaging.EventHubs.Primitives.EventProcessor1.ListPartitionIdsAsync(EventHubConnection connection, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.RunProcessingAsync(CancellationToken cancellationToken)  I already made sure I'm connecting to a blobclient that does not have soft-delete enabled. I made sure the container is there. Also the eventhub + consumergroups are there. I'm at a loss what to do atm, since the exception does not give much more information.  I also tried with websockets, which gives me a different exception:  System.Net.WebSockets.WebSocketException (0x80004005): Unable to connect to the remote server ---> System.Net.Http.HttpRequestException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. (eventhubname.servicebus.windows.net:443) ---> System.Net.Sockets.SocketException (10060): A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken) at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource.GetResult(Int16 token) at System.Net.Sockets.Socket.g__WaitForConnectWithCancellation|277_0(AwaitableSocketAsyncEventArgs saea, ValueTask connectTask, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken) --- End of inner exception stack trace --- at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.AddHttp11ConnectionAsync(HttpRequestMessage request) at System.Threading.Tasks.TaskCompletionSourceWithCancellation1.WaitWithCancellationAsync(CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.GetHttp11ConnectionAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken) at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.WebSockets.WebSocketHandle.ConnectAsync(Uri uri, CancellationToken cancellationToken, ClientWebSocketOptions options) at System.Net.WebSockets.WebSocketHandle.ConnectAsync(Uri uri, CancellationToken cancellationToken, ClientWebSocketOptions options) at System.Net.WebSockets.ClientWebSocket.ConnectAsyncCore(Uri uri, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.TaskHelpers.WithTimeout(Task task, TimeSpan timeout, Func1 errorMessage, CancellationToken token) at Microsoft.Azure.Amqp.ExceptionDispatcher.Throw(Exception exception) at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result) at Microsoft.Azure.Amqp.Transport.AmqpTransportInitiator.ConnectAsyncResult.End(IAsyncResult result) at Microsoft.Azure.Amqp.Transport.AmqpTransportInitiator.<>c.b__17_1(IAsyncResult r) at System.Threading.Tasks.TaskFactory1.FromAsyncCoreLogic(IAsyncResult iar, Func2 endFunction, Action1 endAction, Task1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location --- at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.CreateAndOpenConnectionAsync(Version amqpVersion, Uri serviceEndpoint, Uri connectionEndpoint, EventHubsTransportType transportType, IWebProxy proxy, Int32 sendBufferSizeBytes, Int32 receiveBufferSizeBytes, RemoteCertificateValidationCallback certificateValidationCallback, String scopeIdentifier, TimeSpan timeout) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenManagementLinkAsync(TimeSpan operationTimeout, TimeSpan linkTimeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpClient.GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.EventHubConnection.GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.EventHubConnection.GetPartitionIdsAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Primitives.EventProcessor1.ListPartitionIdsAsync(EventHubConnection connection, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Primitives.EventProcessor1.RunProcessingAsync(CancellationToken cancellationToken)  Regards, Johan Environment .NET SDK: Version:   7.0.201 Commit:    68f2d7e7a3 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.201\ Host: Version:      8.0.1 Architecture: x64 Commit:       bf5e279d92 .NET SDKs installed: 6.0.302 [C:\Program Files\dotnet\sdk] 6.0.400 [C:\Program Files\dotnet\sdk] 7.0.201 [C:\Program Files\dotnet\sdk] 8.0.101 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] Environment variables: Not set global.json file: C:\Users\507587\RiderProjects\azure-sdk-for-net\global.json IDE: JetBrains Rider 2023.3.2
Client	Event Grid	[BUG] EventGridEvent requires optional Data property	Library name and version Azure.Messaging.EventGrid 4.22.0 Describe the bug According to the documentation at https://learn.microsoft.com/en-us/azure/event-grid/event-schema#event-properties, the `Data` property for EventGridEvent is not required. However, when receiving and deserializing EventGridEvent JSON from a webhook without this property, the deserialization process will crash. Expected behavior It should be capable of parsing the data even without this optional property. Actual behavior  Reproduction Steps         var data = BinaryData.FromString(```             [               {                 `id`: `123e4567-e89b-12d3-a456-426614174000`,                 `eventType`: `Generic.Event.Type.Example`,                 `subject`: `category/123e4567-e89b-12d3-a456-426614174000`,                 `dataVersion`: `1.0`,                 `metadataVersion`: `1`,                 `eventTime`: `2024-02-15T14:30:00+00:00`,                 `topic`: `/subscriptions/123e4567-e89b-12d3-a456-426614174000/resourceGroups/example-rg/providers/Microsoft.EventGrid/domains/example-domain/topics/example-topic`               }             ]             ```);          var events = EventGridEvent.ParseMany(data); Environment No response
Client	Service Bus	[BUG] ServiceBusSessionProcessor fails to stop in a timely manner	Library name and version Azure.Messagin.ServiceBus 7.17.3 Describe the bug Calling processor.StopProcessingAsync(), processor.CloseAsync() or processor.DisposeAsync() takes up to 60 seconds. This has been documented in multiple threads (now closed), and marked as merged/fix for EventHubs (#21242). The issue remains for ServiceBusSessionProcessor. #17734 #19306 #21869 Expected behavior Calling processor.StopProcessingAsync(), processor.CloseAsync() or processor.DisposeAsync() should stop the processing of messages and close the underlying transport immediately. Actual behavior Calling processor.StopProcessingAsync(), processor.CloseAsync() or processor.DisposeAsync() take up to the default 60s polling period of the underlying amqp transport to return. Reproduction Steps var client = new ServiceBusClient(<CONN_STR>); var processor = client.CreateSessionProcessor(`topic`, `subscription`); await processor.StartProcessingAsync();  // Stop processing and unsubscribe from events await processor.StopProcessingAsync(); // ... unhook events  // Close/Dispose await processor.DisposeAsync();  Environment No response
Client	Event Hubs	[BUG] Event Hub Processor Creating Invalid Blob Storage Checkpoints as of v5.11.0	Library name and version Azure.Messaging.EventHubs Describe the bug We recently stood up a new application that processes events from an Event Hub and noticed that the KEDA Event Hub scaler was not working correctly and would over-scale the service even when the hub was inactive. After some investigation, we noticed that the checkpoints that were being written had a null value for the offset field. I debugged the program locally and confirmed that Offset was not null in memory at the time of checkpoint creation, but the offset was never making it to blob storage. After this, I started testing on another application that reads off an Event Hub but on v5.10.0, instead. This application worked as expected and the offset was set correctly in the checkpoint. After downgrading the new app to v5.10.0, pushing that out, and clearing the existing bad checkpoints, the service scaled down correctly to the minimum replica count. Opinion: This seems like a pretty major bug to me, external systems like KEDA rely on the behavior of the checkpointing to scale services correctly. If services at scale were to upgrade the effects could be catastrophic. Expected behavior The expected behavior is that checkpoints are created/updated with valid metadata. Actual behavior The checkpoints were being created with a null offset. Reproduction Steps private async Task ProcessEventAsync(ProcessEventArgs eventArgs) {     await eventArgs.UpdateCheckpointAsync(); // breakpoint here and examine Offset in memory     log.LogInformation(`checkpoint created`); // breakpoint here and examine offset in checkpoint } Environment .NET SDK:  Version:           8.0.100  Commit:            57efcf1350  Workload version:  8.0.100-manifests.6c33ef20  Runtime Environment:  OS Name:     Mac OS X  OS Version:  14.2  OS Platform: Darwin  RID:         osx-arm64  Base Path:   /usr/local/share/dotnet/sdk/8.0.100/  .NET workloads installed:  Workload version: 8.0.100-manifests.6c33ef20 There are no installed workloads to display.  Host:   Version:      8.0.0   Architecture: arm64   Commit:       5535e31a71  .NET SDKs installed:   8.0.100 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
Client	Cognitive - Form Recognizer	[FEATURE REQ] Support for api version 2023-10-31-preview	Library name Azure.AI.FormRecognizer Please describe the feature. Support for latest (preview) api version that is 2023-10-31-preview which adds support for Office documents with the Layout model.
Client	Search	Can't set Normalizer or CustomNormalizer for a field in a search index via SDK?	Library name and version Azure.Search.Documents 11.5.1 Query/Question Hi, I am using the Azure.Search.Documents nuget to create my AI search index, and query the index. When creating the index one can specify a CustomAnalyzer, and one can set a field to use that partical custom analyzer via the attribute [SearchableField(AnalyzerName = `my_custom_analyzer`)]. No problems. But the same does not go for CustomNormalizer (or any pre-defined normalizer for that matter). The class CustomAnalyzer can be found under /Models. The class CustomNormalizer can't. Instead, there is one under Generated/Models, but that's not part of the SDK, right?. I can create the desired index, with a chosen normalizer in the Azure Portal, like so: `fields`: [     {       `name`: `firstName`,       `type`: `Edm.String`,       `searchable`: true,       `filterable`: true,       `retrievable`: true,       `sortable`: true,       `facetable`: true,       `key`: false,       `indexAnalyzer`: null,       `searchAnalyzer`: null,       `analyzer`: `my_custom_analyzer`,       `normalizer`: `my_custom_normalizer`,       `dimensions`: null,       `vectorSearchProfile`: null,       `synonymMaps`: []     }  Is it not possible to set a normalizer for an AI Search index field via the SDK? Environment Visual Studio 17.9 .NET SDK:  Version:           8.0.200  Commit:            438cab6a9d  Workload version:  8.0.200-manifests.e575128c  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22631  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.200\  .NET workloads installed: There are no installed workloads to display.  Host:   Version:      8.0.2   Architecture: x64   Commit:       1381d5ebd2  .NET SDKs installed:   8.0.101 [C:\Program Files\dotnet\sdk]   8.0.200 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.27 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.27 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 6.0.27 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set
Client	OpenAI	[FEATURE REQ] Add support for Logprobs in OpenAI Chat Completions	Library name Azure.AI.OpenAI Please describe the feature. OpenAI has supported logprobs requests and responses in chat completions api since last December. See Create chat completion for reference. There are many valuable use-cases for logprobs, some of where are outlined in Using logprobs. I would like to see Azure.AI.OpenAI support logprobs and top_logprobs in ChatCompletionsOptions for chat requests as well as logprobs property ChatChoice in the subsequent responses.
Client	Azure.Core	[BUG] Inconsistent Region disply name for US GOV locations	Library name and version Azure.Core 1.37.0 Describe the bug We have encountered an issue when comparing the region with its display name for the US GOV location. For example, the region usgovarizona's display name is `USGov Arizona` in the Azure API response of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}/versions/{galleryImageVersionName}?expand=ReplicationStatus. However, the display name for the same region is defined as `US Gov Arizona` in the Azure.Core namespace (link). (Please note the extra space between `US` and `Gov`). So it fails when comparing the region with the display name. Expected behavior Comparing region with display name should success Actual behavior failed Reproduction Steps var client = new ArmClient(...); var resourceId = `<Some gallery image version resource in the usgovarizona region>`; var resource = client.GetGalleryImageVersionResource(resourceId); var resp = await resource.GetAsync(`ReplicationStatus`).ConfigureAwait(false); var imageVersion = resp.Value.Data; var location = new AzureLocation(usgovarizona); foreach (var region in imageVersion.ReplicationStatus.Summary) {     // This will fail     Assert.AreEqual(region.Region, location.DisplayName); }  Environment No response
Client	Event Hubs	[FEATURE REQ] Add CacheControl as a configurable option for new blobs in BlobCheckpointStore	Library name Azure.Messaging.EventHub Please describe the feature. I've also been running into the issue described here: #33635 I was wondering if the BlobCheckpointStore could be updated so CacheControl could be an option that's set when new blobs are created.
Client	Container Registry	[BUG] Storage upload failing.	Library name and version Azure.Container.Regisry:latest Describe the bug I am getting blob upload unknown registry intermittently during upload of tar file. It uploads the image config but fails during client.UploadBlobAsync(); Expected behavior Should get uploaded Actual behavior Not uploading blobs of tar file. Reproduction Steps Create an oci image from a tar file containing layers Environment No response
Client	Event Grid	[QUERY] Initializes EventGridEvent object	Library name and version Azure.Messaging.EventGrid - 4.7.0 Query/Question We are trying to intialize the EventGridEvent constructor and supplying resourceRequestContext as body object which gets serialized as per this constructor                azure-sdk-for-net/sdk/eventgrid/Azure.Messaging.EventGrid/src/EventGridEvent.cs                    Line 39       in       463d0fb                                                 Data = new BinaryData(data, type: dataSerializationType ?? data?.GetType());                      We have a recurring property in the resourceRequestContext which is the cause of the issue when the constructor is called and it throws an error. For example in this we see broadcastAddress is recurring and it goes beyond 64 levels of recurring allowed by BinaryData serialization.  Anyway to resolve this so that we do not need to change our current object? This is the error we get - A possible object cycle was detected. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 64. Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles. Path: $.Resource.Properties.NetworkAcls.AllowedAddressSpaces.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.BroadcastAddress.MaskLength.at System.Text.Json.ThrowHelper.ThrowJsonException_SerializerCycleDetected(Int32 maxDepth)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state) at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Converters.ListOfTConverter2.OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonCollectionConverter2.OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer) at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.Metadata.JsonPropertyInfo1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)at System.Text.Json.Serialization.Converters.ObjectDefaultConverter1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.Serialization.JsonConverter1.WriteCoreAsObject(Utf8JsonWriter writer, Object value, JsonSerializerOptions options, WriteStack& state)at System.Text.Json.JsonSerializer.WriteUsingSerializer[TValue](Utf8JsonWriter writer, TValue& value, JsonTypeInfo jsonTypeInfo)at System.Text.Json.JsonSerializer.WriteBytesUsingSerializer[TValue](TValue& value, JsonTypeInfo jsonTypeInfo)at System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(Object value, Type inputType, JsonSerializerOptions options)at System.BinaryData..ctor(Object jsonSerializable, JsonSerializerOptions options, Type type)at Azure.Messaging.EventGrid.EventGridEvent..ctor(String subject, String eventType, String dataVersion, Object data, Type dataSerializationType)at Microsoft.Sdw.Core.EventGrid.HostedEventPublisher.RpPlatformEventPublisher.EmitResourceRequestContextV2Async[T](String topic, ResourceRequestContext1 resourceRequestContext, CancellationToken cancellationToken) in C:\__w\1\s\src\sdw\Microsoft.Sdw.Core\EventGrid\EventPublisher.cs:line 282at Environment No response
Client	Azure.Identity	[QUERY] How to authenticate as a specific user assigned managed identity with a client secret.	Library name and version Azure.Identity 1.10.4 Query/Question I have an app service it uses two user assigned managed identities: configurationidentity => access key vault for configuration dataidentity => access production data When it starts up in production, I of course use: new ManagedIdentityCredential(clientId: `configurationidentity`) to get to the key vault. new ManagedIdentityCredential(clientId: `dataidentity`) to get to the production data. Because there is > 1 user assigned managed identity (I presume) that is the cause of the exception when you don't explicitly specify clientId. When running in the debugger on a developer box, I authenticate under my user account VisualStudioCredential. If I can load app id and app secret from somewhere using VisualStudioCredential on my devbox. What credentials can I use to authenticate to make the code run locally? ManagedIdentityCredential - doesn't take app ids or secrets, but you can specify the identity id ClientSecretCredential - takes the app id and secret, but the identity to use is ambiguous (because you don't have an id field that I can see). I need something like `new ManagedIdentityCredential(clientId: `configurationidentity`, new ClientSecretCredential(appid, appsecret)); How is it done? Thanks Environment No response
Client	Tables	[BUG] async Task<T> is not defined in QueryAsync method in TableClient class	Library name and version Azure.Data.Tables 12.8.3 Describe the bug In the class 'TableClient' line number 1056 & 1132 for two methods are below inappropriate.  public virtual AsyncPageable QueryAsync(Expression<Func<T, bool>> filter, int? maxPerPage = null, IEnumerable select = null, CancellationToken cancellationToken = default) public virtual AsyncPageable QueryAsync(string filter = null, int? maxPerPage = null, IEnumerable select = null, CancellationToken cancellationToken = default)  methods are used for Async but these are not 'Task'. Ref: https://github.com/Azure/azure-sdk-for-net/blob/Azure.Data.Tables_12.8.3/sdk/tables/Azure.Data.Tables/src/TableClient.cs Expected behavior  public virtual async Task<AsyncPageable> QueryAsync(Expression<Func<T, bool>> filter, int? maxPerPage = null, IEnumerable select = null, CancellationToken cancellationToken = default) public virtual async Task<AsyncPageable> QueryAsync(string filter = null, int? maxPerPage = null, IEnumerable select = null, CancellationToken cancellationToken = default)  Actual behavior Method is not async Task Reproduction Steps // Define the query you want to execute string filter = TableClient.CreateQueryFilter($``); AsyncPageable entities = await tableClient.QueryAsync(filter); Environment No response
Client	Search	[QUERY] Get the Url of a Search Service	Library name and version Azure.Search.Documents Query/Question Is there a way to get the service url of a Search Service without having to compute it like this: https://${searchServiceName}.search.windows.net  I couldn't find the property from this doc: https://learn.microsoft.com/en-us/rest/api/searchmanagement/services/get?view=rest-searchmanagement-2023-11-01&tabs=HTTP But can see it in the portal:  Environment No response
Client	Service Bus	[BUG] Service Bus is not annotated for nullability	Library name and version Azure.Messaging.ServiceBus 7.17.3 Describe the bug The ContentType property of the ServiceBusReceivedMessage class is not declared as nullable but it can be null. Expected behavior The ContentType property should be declared as nullable. public string? ContentType { get; set; } Actual behavior The ContentType property is not declared as nullable. public string ContentType { get; set; } Reproduction Steps var message = await _receiver.PeekMessageAsync(123); if (message.ContentType.StartsWith(`application/`)) { } Environment .NET 8.0.200
Client	Extensions	[BUG] Vulnerable transitive package included with Azure.Extensions.AspNetCore.DataProtection.Blobs 1.3.3	Library name and version Azure.Extensions.AspNetCore.DataProtection.Blobs 1.3.3 Describe the bug When adding the nuget package for Azure.Extensions.AspNetCore.DataProtection.Blobs:1.3.3, I get a vulnerability warning.  Appears to include System.Common.Drawing 4.7.0 with known vulnerabilities. I've already verified that this is added by the Azure.Extensions.AspNetCore.DataProtection.Blobs.  Has me nervous that there is a known vulnerable package being included with this one. Expected behavior Should import without a vulnerable transative package Actual behavior Get a vulnerability warning in the nuget manager  Reproduction Steps Get an empty project Go to nuget package manager Install Azure.Extensions.AspNetCore.DataProtection.Blobs 1.3.3 Refresh Installed (as needed) Environment Windows 11 Visual Studio 2022 .Net 6.0
Client	Azure.Identity	[BUG] Regional Authority not available in ClientCertificateCredentialOptions	Library name and version Azure.Identity 1.10.4 Describe the bug Regional Authority parameter is not present in ClientCertificateCredentialOptions. Looks like it was removed here: 2a009f1#diff-dd3f1b93fd92b1250e2d16929dcf03fc20898ef67fbb604a0d9d10b567c33c76 Is this expected? If yes, is there any other way to pass the Regional Authority parameter? Expected behavior We should be able to set the Regional Authority parameter in ClientCertificateCredentialOptions Actual behavior No such parameter available Reproduction Steps Try setting Regional Authority while creating ClientCertificateCredential Environment No response
Client	Search	[FEATURE REQ] Set Private Execution environment for the SearchIndexerClient for Azure AI Search	Library name Azure.Search.Documents.Indexes Please describe the feature. We are integrating Azure AI Search inside a VNet, and we need to run our indexers within the Private execution environment. We'd like to be able to set this within our SearchIndexerClient: https://learn.microsoft.com/en-us/azure/search/search-indexer-securing-resources Currently there is no way to do this via the .NET SDK: https://learn.microsoft.com/en-us/dotnet/api/azure.search.documents.indexes.searchindexerclient?view=azure-dotnet-preview Would it be possible to introduce a property within the SearchIndexerClient to explicitly set the execution environment?
Mgmt	Event Grid	How to set values for event grid advanced filters such for  StringContainsAdvancedFilter	Library name and version Azure.ResourceManager.EventGrid 1.0.1 Query/Question Creating an event grid subscription using Azure.ResourceManager.EventGrid - confused how to set values for advanced filters using SDK. Specifically for StringContainsAdvancedFilter. There's only a default parameterless constructor and the values list is read only. Ideally I'd like to do data.Filter.AdvancedFilters.Add(new StringContainsAdvancedFilter { Key = `subject`, Values = new List() { `somevalue` } }); but Values is readonly - so how to set values? Environment Visual Studio 17.8.3 dotnet --info .NET SDK: Version:           8.0.100 Commit:            57efcf1350 Workload version:  8.0.100-manifests.8d38d0cc Runtime Environment: OS Name:     Windows OS Version:  10.0.22631 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.100\ .NET workloads installed: Workload version: 8.0.100-manifests.8d38d0cc There are no installed workloads to display. Host: Version:      8.0.0 Architecture: x64 Commit:       5535e31a71 .NET SDKs installed: 8.0.100 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found
Mgmt	Service Bus	[BUG] Any Management SDK call stuck sometimes when using WaitUntil.Completed and never returns back.	Library name and version Azure.ResourceManager.ServiceBus, Azure.ResourceManager.Compute Describe the bug We are observing that sometimes the call to Azure with CreateUpdate methods using the WaitUntil enum as WaitUntil.Completed hangs and never returns back with the result, this is causing our services to block the resources for the infinite time. Following is just one example when SDK with WaitUntil.Completed: ServiceBusTopicResource serviceBusTopic = serviceBusTopicCollection.CreateOrUpdate(WaitUntil.Completed, dynamicTopicName, topicData).Value; Expected behavior The SDK call should return with either a Success or a Failure response. Actual behavior SDK call hangs and never returns. Reproduction Steps Following is just one example when SDK with WaitUntil.Completed: ServiceBusTopicResource serviceBusTopic = serviceBusTopicCollection.CreateOrUpdate(WaitUntil.Completed, dynamicTopicName, topicData).Value; Environment .NET runtime running on Azure Container Instances
Mgmt	SQL	[BUG] SqlDatabaseResource.SetTagsAsync() throws System.ArgumentNullException: Value cannot be null. (Parameter 'id')	Library name and version Azure.ResourceManager.Sql v1.2.0 Describe the bug When calling SetTagsAsync() from an SqlDatabaseResource object, the following error is thrown:  Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware: An unhandled exception has occurred while executing the request.System.ArgumentNullException: Value cannot be null. (Parameter 'id')at Azure.Core.Argument.AssertNotNull[T](T value, String name)at Azure.ResourceManager.ArmResource..ctor(ArmClient client, ResourceIdentifier id)at Azure.ResourceManager.Resources.TagResource..ctor(ArmClient client, ResourceIdentifier id)at Azure.ResourceManager.Resources.TagResource..ctor(ArmClient client, TagResourceData data)at Azure.ResourceManager.Resources.TagResourceOperationSource.Azure.Core.IOperationSource<Azure.ResourceManager.Resources.TagResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)at Azure.Core.NextLinkOperationImplementation.OperationToOperationOfT1.UpdateStateAsync(Boolean async, CancellationToken cancellationToken)at Azure.Core.OperationInternal1.UpdateStatusAsync(Boolean async, CancellationToken cancellationToken)at Azure.Core.OperationInternalBase.UpdateStatusAsync(CancellationToken cancellationToken)at Azure.Core.OperationPoller.WaitForCompletionAsync(Boolean async, OperationInternalBase operation, Nullable`1 delayHint, CancellationToken cancellationToken)  Interestingly, the tags are saved correctly. The error must occur after the save operation. Important points:  The error only occurs when using a user managed identity (I host it in a Windows-based App Service). When running locally using VisualStudioCredential(), no error occurs. The error only occurs when Azure.ResourceManager v1.4 or later is used. By default, Azure.ResourceManager.Sql v1.2.0 targets Azure.ResourceManager v1.3.2 - using these versions together results in no error. Using Azure.ResourceManager.Sql v1.2.0 with Azure.ResourceManager v1.4.0 onwards causes the issue.  Expected behavior I expect that I can use Azure.ResourceManager.Sql v1.2.0 with Azure.ResourceManager v1.4.0 onwards, and not receive an error when saving tags to a SqlDatabaseResource when accessed via a system managed identity. Actual behavior I receive the above error. Reproduction Steps  Create a .Net 6 MVC web application. Import the following NuGet package: Azure.ResourceManager.Sql v1.2.0 Import the following NuGet package: Microsoft.Identity.Web v2.16.1 Add an AzureSql database (I have used DTU-based free tier). Create an App Service in Azure - Windows - .NET 6 runtime. Create a custom role which has `Microsoft.Sql/servers/databases/read` and `Microsoft.Sql/servers/databases/write` permissions. Create a system managed identity which applies the custom role on the database. Associate the system managed identity with the app service.  Add the following code into the home controller of the MVC project (fill in the todo parts with Azure info): public async Task<IActionResult> Privacy() {     await SetTags();      return View(); }  private async Task SetTags() {     SqlDatabaseResource db = await GetDatabase();      var tags = new Dictionary<string, string>()     {         {`tag1`, `tag1val`},         {`tag2`, `tag2val`},     };      await db.SetTagsAsync(tags); }  private async Task<SqlDatabaseResource> GetDatabase() {     ArmClient client = GetClient();      string subscriptionId = `todo`;     string rgName = `todo`;     string serverName = `todo`;     string dbName = `todo`;      ResourceIdentifier resourceId = SqlDatabaseResource.CreateResourceIdentifier(subscriptionId, rgName, serverName, dbName);     SqlDatabaseResource sqlDbResource = client.GetSqlDatabaseResource(resourceId);      SqlDatabaseResource db = await sqlDbResource.GetAsync();      return db; }  private ArmClient GetClient() {     if (_hostEnvironment.IsDevelopment())     {         return new ArmClient(new VisualStudioCredential());     }      string managedIdentityClientId = `todo`;     return new ArmClient(new ManagedIdentityCredential(managedIdentityClientId)); }  Now publish the project to the App Service. At this point, running the code via Visual Studio, or via the App Service will write the tags to the DB correctly when navigating to the Privacy link (no errors). Now Add the following NuGet package: Azure.ResourceManager v1.4.0 (or above). Publish the application to the App Service again. This time, an error will be observed when clicking on the Privacy link when run in the App Service. (Although it works ok when run in Visual Studio still). Environment Visual Studio for running locally. Azure App Service - Windows - .NET 6.0. Azure SQL Database - 5 DTU free DB. Custom Role with read and write permissions on SQL databases (details above). User Managed Identity applying the custom role to the DB.
Client	Service Bus	[QUERY] Documentation for Azure.Messaging.ServiceBus Claim Check Methods	Library name and version Azure.Messaging.ServiceBus 7.17.3 Query/Question Hi I have found two methods in namespace Azure.Messaging.ServiceBus that deal with claims check. ClaimCheckOnSend is in class ServiceBusMessage ClaimCheckOnReceive is in class ServiceBusReceivedMessage I cannot see any mention on them in the documentation https://learn.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusmessage?view=azure-dotnet https://learn.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusreceivedmessage?view=azure-dotnet Are they released for general use? Regards Mark Environment TargetFramework net8.0 AzureFunctionsVersion v4 isolated worker model Microsoft Visual Studio Professional 2022 (64-bit) - Current Version 17.8.4
Client	Azure.Identity	[BUG] VisualStudioCredential error AADSTS65002 connecting to Azure Monitor Control Service	Library name and version Azure.Monitor.Ingestion 1.1.1 Describe the bug Same project as #40334. Using VisualStudioCredential via DefaultAzureCredential to ingest logs into Azure Monitor fails with an error indicating the consent between Visual Studio and Azure Monitor Control Service needs to be approved by Microsoft. Other credential types such as Interactive Browser, and Shared Token Cache work as expected. The issue arose after updating Visual Studio to 17.9.0, and Azure.Security.KeyVault.Secrets to 4.6.0. Expected behavior A user logged in to Visual Studio with an appropriate account should be able to authenticate using VisualStudioCredential. Actual behavior The following error is thrown when attempting to obtain a token for Azure Monitor: CredentialUnavailableException: Process `C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\Asal\TokenService\Microsoft.Asal.TokenService.exe` has failed with unexpected error: TS003: Error, TS004: Unable to get access token. 'AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'e933bd07-d2ee-4f1d-933c-3752b819567b' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API. Trace ID: 4a365923-eb50-46b6-b245-2271544b8f00 Correlation ID: 9f143a51-2375-4459-8a2e-4de16a76a129 Timestamp: 2024-02-15 10:41:55Z'.  Reproduction Steps Log in to Visual Studio as a user with permissions on an Azure Monitor Data Collection Rule. Log out of Azure CLI, Azure PowerShell and other possible credential sources. Use the following code to attempt to upload a log entry: var client = new LogsIngestionClient(new Uri(Endpoint), new DefautAzureCredential()); var logEntry = new {   Hello = `World` }; await client.UploadAsync(DcrImmutableId, DcrStreamName, RequestContent.Create(BinaryData.FromObjectAsJson(new[] { logEntry }))); Environment .NET SDK:  Version:           8.0.200  Commit:            438cab6a9d  Workload version:  8.0.200-manifests.e575128c  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22631  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.200\  .NET workloads installed:  [ios]    Installation Source: VS 17.9.34607.119    Manifest Version:    17.2.8004/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.ios\17.2.8004\WorkloadManifest.json    Install Type:        FileBased   [wasm-tools]    Installation Source: VS 17.9.34607.119    Manifest Version:    8.0.2/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.workload.mono.toolchain.current\8.0.2\WorkloadManifest.json    Install Type:        FileBased   [maui-windows]    Installation Source: VS 17.9.34607.119    Manifest Version:    8.0.6/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.maui\8.0.6\WorkloadManifest.json    Install Type:        FileBased   [android]    Installation Source: VS 17.9.34607.119    Manifest Version:    34.0.52/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.android\34.0.52\WorkloadManifest.json    Install Type:        FileBased   [maccatalyst]    Installation Source: VS 17.9.34607.119    Manifest Version:    17.2.8004/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.sdk.maccatalyst\17.2.8004\WorkloadManifest.json    Install Type:        FileBased   [wasm-tools-net6]    Installation Source: VS 17.9.34607.119    Manifest Version:    8.0.2/8.0.100    Manifest Path:       C:\Program Files\dotnet\sdk-manifests\8.0.100\microsoft.net.workload.mono.toolchain.net6\8.0.2\WorkloadManifest.json    Install Type:        FileBased   Host:   Version:      8.0.2   Architecture: x64   Commit:       1381d5ebd2  .NET SDKs installed:   8.0.200 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.27 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.27 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.0-preview.6.23329.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.27 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found
Mgmt	Container Service	[ContainerApp] Create Container app failed for accessing ACR with user identity	Library name and version Azure.ResourceManager.AppContainers 1.1.1 Describe the bug Create container app using correct UMI to access ACR but it failed with UNAUTHORIZED   ContainerAppData data = new ContainerAppData(new AzureLocation(operation.Location)) // make it variable   {       Identity = acrPullMI,       EnvironmentId = new ResourceIdentifier(environmentId),       WorkloadProfileName = this._configuration[`workloadProfileName`],       Configuration = new ContainerAppConfiguration()       {           Ingress = new ContainerAppIngressConfiguration()           {               External = true,               TargetPort = int.Parse(this._configuration[`targetPort`]),           },        },       Template = new ContainerAppTemplate()       {           Containers =           {               new ContainerAppContainer()               {                   Image = this._configuration[`acrImage`], // env varialbe                   Name = containerAppName,                   Env =                   {                       new ContainerAppEnvironmentVariable()                       {                           Name = this._configuration[`DBConnectionStringName`],                           Value = connectionString,                       }                   }               }           },       },   }; Error  Expected behavior The container app should be create successfully and have right access to the ACR image Actual behavior Creating Container App failed with error       Content:       {`error`:{`code`:`InvalidParameterValueInContainerTemplate`,`message`:`The following field(s) are either invalid or missing. Field 'template.containers.aca02.image' is invalid with details: 'Invalid value: \`durabletasks.azurecr.io/kaibocai/dbtest:fix\`: GET https:?scope=repository%3Akaibocai%2Fdbtest%3Apull&service=durabletasks.azurecr.io: UNAUTHORIZED: authentication required, visit https://aka.ms/acr/authorization for more information.';.`}}   Reproduction Steps  create a ACR create a user identity assign acrPull role to the user identity from you ACR use blow code snippet to create your aca    ResourceGroupResource resourceGroupResource = await subscription.GetResourceGroupAsync(this._stampResourceGroupName);   // get the collection of this ContainerAppResource   ContainerAppCollection collection = resourceGroupResource.GetContainerApps();    // add user identity for pulling image from ACR   var acrPullMIResourceId = UserAssignedIdentityResource.CreateResourceIdentifier(this._stampSubscriptionId, this._configuration[`acrMIResourceGroupName`], this._configuration[`acrMIName`]);   var acrPullMI = new ManagedServiceIdentity(ManagedServiceIdentityType.UserAssigned);   acrPullMI.UserAssignedIdentities.Add(acrPullMIResourceId, new UserAssignedIdentity());     // invoke the operation   ContainerAppData data = new ContainerAppData(new AzureLocation(operation.Location)) // make it variable   {       Identity = acrPullMI,       EnvironmentId = new ResourceIdentifier(environmentId),       WorkloadProfileName = this._configuration[`workloadProfileName`],       Configuration = new ContainerAppConfiguration()       {           Ingress = new ContainerAppIngressConfiguration()           {               External = true,               TargetPort = int.Parse(this._configuration[`targetPort`]),           },        },       Template = new ContainerAppTemplate()       {           Containers =           {               new ContainerAppContainer()               {                   Image = this._configuration[`acrImage`], // env varialbe                   Name = containerAppName,                   Env =                   {                       new ContainerAppEnvironmentVariable()                       {                           Name = this._configuration[`DBConnectionStringName`],                           Value = connectionString,                       }                   }               }           },       },   };   ArmOperation<ContainerAppResource> lro = await collection.CreateOrUpdateAsync(WaitUntil.Completed, containerAppName, data);   ContainerAppResource containerAppResource = lro.Value;   ContainerAppData resourceData = containerAppResource.Data;    // for demo we just print out the id   this._logger.LogInformation($`Succeeded on id: {resourceData.Id}`);    var appUrl = resourceData.LatestRevisionFqdn;   this._logger.LogInformation($`container app app url: {appUrl}`);    return containerApp;  Environment .NET SDK: Version:           8.0.101 Commit:            6eceda187b Workload version:  8.0.100-manifests.825c015e Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win-x64 Base Path:   C:\Program Files\dotnet\sdk\8.0.101\ .NET workloads installed: Workload version: 8.0.100-manifests.825c015e There are no installed workloads to display. Host: Version:      8.0.1 Architecture: x64 Commit:       bf5e279d92 vs2022
Client	Extensions	[QUERY] Why isn't there a AddClient overload that accepts an async factory?	Library name and version Microsoft.Extensions.Azure 1.7.1 Query/Question So recently we were adding some Azure clients using the AddAzureClients method and we wanted to add some configuration values that are currently stored externally. We used the AddClient method that accepts a Func<TOptions, IServiceProvider, TClient> factory to get the let's call it the ICacheService and call the GetValueAsync method that returns a Task<string> to get let's say the connection string, the event hub name, etc. We just called .Result on the tasks and got it working but I would like to know if there is any reason why there is no Func<TOptions, IServiceProvider, Task<TClient>> factory overload to have a factory that calls and awaits async methods. BTW if you think calling .Result on those tasks please let me know but we didn't see any other choice. Environment Hosting platform: .NET 6 in-process Azure Functions IDE and version: Visual Studio 17.8.3
Mgmt	Network - CDN	[QUERY] Asynchronous operations failing unexpectedly	Library name and version Azure.ResourceManager.Cdn Query/Question I have been working with Azure.ResourceManager.Cdn library to manage my CDN resources. Until now, all the operations were working with no issues. Now asynchronous operations are failing with no exception being thrown. For example:         static public async Task CreateCustomDomainAsync(ProfileResource profile, string hostname)         {             FrontDoorCustomDomainCollection customDomains = profile.GetFrontDoorCustomDomains();             FrontDoorCustomDomainData data = new FrontDoorCustomDomainData();             data.HostName = hostname;              var lro = await customDomains.CreateOrUpdateAsync(Azure.WaitUntil.Started, hostname.Replace('.', '-'), data);              FrontDoorCustomDomainResource result = lro.Value;             FrontDoorCustomDomainData resourceData = result.Data;             Console.WriteLine($`Succeeded on id: {resourceData.Id}`);         }  This code used to work, but now the process exits immediately once the `CreateOrUpdateAsync` method gets called. However, when I switch it to the non-async version of the method `CreateOrUpdate` the operation succeeds, so it can't be an issue with the configured identity. It's weird that the process exits with code 0 and no exceptions are thrown. I tested that the same thing happens with other methods in the same library. Is this a known behavior? Is there any additional info that I can provide for debugging? Environment OS: Windows 11 IDE: Visual Studio 2022 version 17.8.6 dotnet --info: .NET SDK:  Version:           8.0.101  Commit:            6eceda187b  Workload version:  8.0.100-manifests.825c015e  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.101\  .NET workloads installed:  Workload version: 8.0.100-manifests.825c015e There are no installed workloads to display.  Host:   Version:      8.0.1   Architecture: x64   Commit:       bf5e279d92  .NET SDKs installed:   3.1.426 [C:\Program Files\dotnet\sdk]   6.0.321 [C:\Program Files\dotnet\sdk]   8.0.101 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.26 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found
Client	Azure.Identity	[BUG] VisualStudioCredential fails with AADSTS65002 when accessing Application Insights	Library name and version Azure.Monitor.OpenTelemetry.Exporter 1.2.0 Describe the bug It looks like the Visual Studio app can't get a token on behalf of the user for Azure Monitor Control Service (App ID - e933bd07-d2ee-4f1d-933c-3752b819567b). Similar to #39220.  AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'e933bd07-d2ee-4f1d-933c-3752b819567b' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API.  The nasty side effect is that the user doesn't know that it internally fails to obtain a token and falls into a retry loop. The end effect is that no telemetry is ingested. The exceptions are swallowed here for example. Expected behavior The token is issued successfully and telemetry is sent to App Insights. Actual behavior An exception is thrown internally and swallowed. No telemetry is ingested into Application Insights as a result of that. Azure.Identity.AuthenticationFailedException   HResult=0x80131500   Message=Process `C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\IDE\CommonExtensions\Microsoft\Asal\TokenService\Microsoft.Asal.TokenService.exe` has failed with unexpected error: TS003: Error, TS004: Unable to get access token.  'AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'e933bd07-d2ee-4f1d-933c-3752b819567b' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API. Trace ID: fa9198d5-9f27-42b5-a841-1186fc8a2a00 Correlation ID: 7418c123-9b27-4720-9f02-b6f1ddc62b33 Timestamp: 2024-01-31 21:30:55Z'.   Source=Azure.Identity   StackTrace:    at Azure.Identity.VisualStudioCredential.<RunProcessesAsync>d__26.MoveNext()    at Azure.Identity.VisualStudioCredential.<GetTokenImplAsync>d__24.MoveNext()    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable)    at Azure.Identity.VisualStudioCredential.<GetTokenImplAsync>d__24.MoveNext()    at System.Threading.Tasks.ValueTask`1.get_Result()    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Identity.VisualStudioCredential.<GetTokenAsync>d__22.MoveNext()    at System.Threading.Tasks.ValueTask`1.get_Result()    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.<GetHeaderValueFromCredentialAsync>d__9.MoveNext()    at System.Threading.Tasks.ValueTask`1.get_Result()    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.<GetHeaderValueAsync>d__6.MoveNext()    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.<GetHeaderValueAsync>d__6.MoveNext()    at System.Threading.Tasks.ValueTask`1.get_Result()    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.<AuthenticateAndAuthorizeRequestAsync>d__12.MoveNext()    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.<ProcessAsync>d__11.MoveNext()    at Azure.Core.Pipeline.RedirectPolicy.<ProcessAsync>d__7.MoveNext()    at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__5.MoveNext()    at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__5.MoveNext()    at Azure.Monitor.OpenTelemetry.Exporter.ApplicationInsightsRestClient.<InternalTrackAsync>d__1.MoveNext() in C:\git\Azure\azure-sdk-for-net\sdk\monitor\Azure.Monitor.OpenTelemetry.Exporter\src\Customizations\ApplicationInsightsRestClient.cs:line 40    This exception was originally thrown at this call stack:     [External Code]  Inner Exception 1: InvalidOperationException: TS003: Error, TS004: Unable to get access token.  'AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'e933bd07-d2ee-4f1d-933c-3752b819567b' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API. Trace ID: fa9198d5-9f27-42b5-a841-1186fc8a2a00 Correlation ID: 7418c123-9b27-4720-9f02-b6f1ddc62b33 Timestamp: 2024-01-31 21:30:55Z'  Reproduction Steps services.AddOpenTelemetry().UseAzureMonitor(options => {     options.ConnectionString = `InstrumentationKey=*;IngestionEndpoint=https://*.in.applicationinsights.azure.com/;LiveEndpoint=https://*.livediagnostics.monitor.azure.com/`;     options.Credential = new VisualStudioCredential(); });  Environment Microsoft Visual Studio Professional 2022, Version 17.8.5
Client	Event Grid	Azure.Messaging.EventGrid 4.22.0 stable?	Library name and version Azure.Messaging.EventGrid 4.22.0-beta.1 Query/Question Hi, Inside my company we have a restriction of using beta nuget packages. We need to make a decision based on what is the expected date of delivering a stable version after 4.22.0-beta.1 for Azure.Messaging.EventGrid. Can you help us with some predictions of this work that you are doing? Environment 4.22.0-beta.1
Mgmt	ARM	[QUERY] How to use az netappfiles account ad update in dotnet	Library name and version Azure.ResourceManager.NetApp 1.4.2 Query/Question We are using azure cli to provide this functionality but would like to use the dotnet sdk. Running into this error: 'Property or indexer 'NetAppAccountPatch.ActiveDirectories' cannot be assigned to -- it is read only' az cli reference: https://learn.microsoft.com/en-us/cli/azure/netappfiles/account/ad?view=azure-cli-latest#az-netappfiles-account-ad-update Environment No response
Client	EngSys	[FEATURE REQ] Remove unnecessary package references for net 6+ TFM	Library name Azure.Core Please describe the feature. I want package references to be framework specific so that i am not adding in un-necessary packages when functionality can be and should be provided by the framework reference. An example of such is System.Text.Json which is included in net 6
Client	Cognitive - Form Recognizer	How am i supposed to moq response that return DocumentTable?	Library name and version azure.ai.formrecognizer: 4.1.0 Query/Question How are we supposed to moq responses form the client when there are no public constructors for objects like DocumentTable and DocumentTableCell? Environment No response
Client	Service Bus	[QUERY] How to use AddServiceBusAdministrationClientWithNamespace()	Library name and version Azure.Messaging.ServiceBus v7.17.2 Query/Question I have an Azure Function, and all I want is just to register an instance of ServiceBusAdministrationClient in the DI container so that my class can access it as a Singleton. In its Startup.cs, I have the following block: public class Startup : FunctionStartup {   public override void Configure(IFunctionsHostBuilder builder)   {     RegisterDep(builder.Services);   }    private static void RegisterDep(IServiceCollection services)   {     services.AddServiceBusAdministrationClientWithNamespace()   }    }  I thought it would be like this but it does not work. I also tried calling in on builder. There is zero document on how to use it. Thank you. Environment Windows 10, Visual Studio 17.7.7
Client	Service Bus	[FEATURE REQ] ServiceBus: TCP Transport without TLS	Library name Azure.Messaging.ServiceBus Please describe the feature. ServiceBus client only supports transport over TLS and it making it challenging to establish a local emulator. This is my attempt to create a service bus emulator, but deploying it on a development machine or a Docker container poses difficulties due to the requirement for trusted self-signed certificates. Enabling TCP connectivity for Azure service bus client can significantly enhance the installation process or emulators, making it more straightforward and user-friendly.
Mgmt	Data Factory	Is .Net6 not supported by Azure.ResourceMabager.DataFactory ?	Library name and version Azure.ResourceMabager.DataFactory 1.0.0-beta.5 Query/Question Hello, Currently, we are using Microsoft.Azure.Management.DataFactory version 9.3.0. However, this version has been marked as deprecated, and therefore, we need to switch to Azure.ResourceManager.DataFactory instead. The issue we are facing is that our projects are based on .NET6, and according to the new NuGet documentation, this version is not yet supported. My question is, when will Azure.ResourceManager.DataFactory be supported for .NET6? Additionally, what are the downsides of continuing to use the old NuGet package? Thank you for your support. Kind Regards, Ons.Ch Environment Hosting platform : Windows SDK .NET Version:   8.0.100 IDE: Visual Studio 17.8.3 for Devolopement mode, but not that all our projects are on production mode
Client	Service Bus	[FEATURE REQ] ServiceBusMessageActions - Add ScheduleMessageAsync method	Library name Microsoft.Azure.Functions.Worker Please describe the feature. To implement retry logic like an exponential backoff retry policy, it would be great to have ScheduleMessageAsync to return the message to the service bus and increment the delivery count instead of having to create a new message and add an Application Property to manage the retries. The expected code should be: public Task ScheduleMessageAsync(ServiceBusReceivedMessage message, ServiceBusMessageActions actions, CancellationToken cancellationToken = default) {     if (retryCount > message.DeliveryCount)     {         return actions.DeadLetterMessageAsync(message, null, `MAX_RETRIES`, `Max retry count reached`, cancellationToken);     }      DateTimeOffset now = DateTimeOffset.Now;     DateTimeOffset possibleDelay = now.Add(TimeSpan.FromSeconds(Math.Pow(3, retryCount) + 10));     DateTimeOffset maxDelay = now.Add(_maxDelay);     DateTimeOffset scheduledDatetime = possibleDelay < maxDelay ? possibleDelay : maxDelay;      return actions.ScheduleMessageAsync(message, scheduledDatetime, cancellationToken); } Currently you need to do something like this: public Task ScheduleMessageAsync(ServiceBusReceivedMessage message, ServiceBusMessageActions actions, CancellationToken cancellationToken = default) {     object? retryCountProperty = message.ApplicationProperties.GetValueOrDefault(RETRY_PROPERTY);     int retryCount = Int32.Parse(retryCountProperty?.ToString() ?? `0`);      if (retryCount > _maxRetries)     {         return actions.DeadLetterMessageAsync(message, null, `MAX_RETRIES`, `Max retry count reached`, cancellationToken);     }      DateTimeOffset now = DateTimeOffset.Now;     DateTimeOffset possibleDelay = now.Add(TimeSpan.FromSeconds(Math.Pow(3, retryCount) + 10));     DateTimeOffset maxDelay = now.Add(_maxDelay);     DateTimeOffset scheduledDatetime = possibleDelay < maxDelay ? possibleDelay : maxDelay;      ServiceBusSender sender = _client.CreateSender(_queueName);     ServiceBusMessage retryMessage = new(message);     retryMessage.ApplicationProperties.Remove(RETRY_PROPERTY);     retryMessage.ApplicationProperties.Add(RETRY_PROPERTY, ++retryCount);      return sender.ScheduleMessageAsync(retryMessage, scheduledDatetime, cancellationToken); }
Client	Cognitive - Form Recognizer	[FEATURE REQ] - QueryFields for the C# SDK	Library name Azure.AI.FormRecognizer Please describe the feature. QueryFields have been added to the Document Intelligence API and Studio starting with the 2023-10-31-preview version. The current latest (preview & stable) .NET/C# SDK release - 4.1.0 - is still using 2022_07_31 inside, and does not allow for using a higher version than 2022_08_31:  When will this functionality be released to the C# SDK package (even as a preview)? Is there a plan for this even? The repo has last been updated 5 months ago.
Mgmt	Compute	[QUERY] Is it possible to serialze a ManagedDiskData to json?	Library name and version Azure.ResourceManager.Computer 1.3.0 Query/Question I noticed the class ManagedDiskData implements IUtf8JsonSerializable. However, the interface IUtf8JsonSerializable is internal so I am not able to call IUtf8JsonSerializable.Write on this class to serialize it to json. Is there a possible approach or workaround that I can utilize to accomplish my objective? Thanks! Environment No response
Client	Service Bus	[Service bus Administration] Unit test cases mocking for GetNamespacePropertiesAsync() & GetSubscriptionsAsync()	Library name and version Azure.Messaging.ServiceBus.Administration 7.17.1 Query/Question Hi I am using Azure.Messaging.ServiceBus 7.17.1 nuget package. Trying Mock 'ServiceBusAdministrationClient' class and invoking GetNamespacePropertiesAsync() & GetSubscriptionsAsync() and expecting value as true, but it is returning null values. please refer below screen code Below are the mocking method, but getting issue, can you please help us out to resolve this mocking issue. GetNamespacePropertiesAsync() var mockResponseNamespace = new Mock<Azure.Response>(); NamespaceProperties namespaceProperties = null; mockResponseNamespace.SetupGet(response => response.Value).Returns(namespaceProperties); mockClient.Setup(e => e.GetNamespacePropertiesAsync(new System.Threading.CancellationToken())).ReturnsAsync(mockResponseNamespace.Object); var rest = mockClient.Object.GetNamespacePropertiesAsync().Result.Value.MessagingSku; GetSubscriptionsAsync() var mockResponseSubscription = new Mock<AsyncPageable>(); mockResponseSubscription.SetupGet(response => response).Returns(new AsyncPageable()); mockClient.Setup(e => e.GetSubscriptionsAsync(It.IsAny(), It.IsAny())).ReturnsAsync(mockResponseSubscription.Object); Above are the mocking method, but getting issue, can you please help us out to resolve this mocking issue. Thanks in advance. Environment No response
Client	Search	How to use this HighlightFields property	Type of issue Missing information Description How it is set? When it is set? Why is Highlight property is missing in this Class but it is available when searching through REST API? Kindly help in understanding how this field works? Page URL https://learn.microsoft.com/en-us/dotnet/api/azure.search.documents.searchoptions.highlightfields?view=azure-dotnet Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.Search.Documents/SearchOptions.xml Document Version Independent Id d00fdd93-4e86-4044-6642-dff568d46af9 Article author @azure-sdk Metadata  ID: 0127c4fe-2b05-7b59-37f6-6f92e672c538 Service: azure
Client	OpenAI	[QUERY] Is there support for OpenAI Assistants API?	Library name and version Azure.AI.OpenAI 1.0.0-beta.12 Query/Question Are assistants supported? If not, when can we expect support? Environment No response
Client	Cognitive - Form Recognizer	[QUERY] Azure Form Recognizer DocumentFieldType always returns Unknown but expecting DocumentFieldType.Double	Library name and version Azure.AI.FormRecognizer 4.0.0 Query/Question Trying to map some values from Azure form recognizer Custom Extraction Model. Within Form Recognizer studio the field is type number -> not-specified. I would imagine this would map to the DocumentFieldType.Double within the C# library but it keeps returning as DocumentFieldType.Unknown. What is the correct way to map non-currency numeric values? Updating the library version to 4.1.0 does not help. Here is the output json from the recognition for a field. I'd imagine it not having a valueNumber field might have something to do with it but I don't quite understand why it doesn't have one. `WaterMeterReadingFrom`: {  `type`: `number`,  `content`: `2568`,  `boundingRegions`: [   {    `pageNumber`: 2,    `polygon`: [     4.868,     1.6141,     5.1725,     1.6141,     5.1725,     1.7562,     4.868,     1.7562    ]   }  ],  `confidence`: 0.964,  `spans`: [   {    `offset`: 1866,    `length`: 4   }  ] },  Environment Windows 11 .NET7.0 JetBrains Rider 2023.3.2
Mgmt	Container Service	How do I update specific properties on a ContainerApp?	Library name and version Azure.ResourceManager.AppContainers 1.1.1 Query/Question I'm trying to pull down an existing container app definition, update a couple properties (custom domains) and then save the changes. This does not seem to work as the Get does not seem to populate secrets or container registry passwords, so when I try to save the object i get Invalid Request: Container app secret(s) with name(s) 'container-registry-password' are invalid: value or keyVaultUrl and identity should be provided  My code does not directly have access to these secrets and I don't want to risk resetting these properties. How do I do a patch operations on just the properties I need to update as Update seems to do a put? Environment No response
Client	Service Bus	[QUERY] Message ordering when calling SendMessageAsync in fire-and-forget approach	Library name and version Azure.Messaging.ServiceBus 7.17.1 Query/Question Hi, In my application I have a list of messages that I need to send to different entities depending on some properties. On one hand this complicates things for sending messages in batches (I cannot group the messages of the list becuase its an Enumerable that i'm streaming from a query). The other approach that comes to my mind is calling SendMessageAsync but without awaiting (and probably keeping the tasks in a list so when I stop the application I wait for all tasks completion). If I have a lot of messages how will spanning a lot tasks will affect? I could limit the amount of tasks with a SempahoreSlim or something like that. If i'm not awaiting the tasks can these cause unordering of messages? I have some queues with only one consumer that needs to keep ordering. While doing some testing, when sending 10 messages the first one is sent after the other ones. It seems is happening because the first it is taking more time (I guess from some extra operation in the threadpool). So I guess the ordering is not guaranteed if I send them without awaiting? Regards Environment No response
Client	Service Bus	ServiceBusAdministrationClient Mocking	Library name and version Azure.Messaging.ServiceBus.Administration Query/Question Hi I am using Azure.Messaging.ServiceBus 7.17.1 nuget package. Trying Mock 'ServiceBusAdministrationClient' class and invoking TopicExistsAsync() and expecting value as true, but it is returning null values. please refer below screen code var blobContainerClientResponseMock = new Mock(); blobContainerClientResponseMock.Setup(e => e.Status).Returns(200); blobContainerClientResponseMock.Setup(e => e.ReasonPhrase).Returns(`OK`); var test = Response.FromValue(true, blobContainerClientResponseMock.Object); var mockManagementClient = new Mock(`Endpoint=sb://abcdservicebus.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=NdfdfefefegpblMv5hiUTQ=`); var var = mockManagementClient.Setup(e => e.TopicExistsAsync(`ops/achive`, new System.Threading.CancellationToken())).Returns(result); But its it returning null. refer below screen shot  Please help on this Environment No response
Mgmt	Logic App	[BUG] Azure.ResourceManager.Logic EDI Maps Creation	Library name and version Azure.ResourceManager.Logic 1.1.0 Describe the bug Hi there! While dabbling in the Sample_IntegrationAccountMapResource.cs for EDI Map creation I found out that the method Update_CreateOrUpdateAMap is not working for creating a new Map. Using the map resource with the data provided in the example gives an error (System.Exception: '1' is invalid after a single JSON value. Expected end of data. LineNumber: 0 | BytePositionInLine: 16.) for the `Content` property of the `IntegrationAccountMapData` class. Looking deeper into the library I saw that the Content is expected to be JSON, but the provided example is in XML with the comments being: To assign an object to this property use <see cref=`BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)`. and To assign an already formatted json string to this property use <see cref=`BinaryData.FromString(string)`. , which leads me to believe that maybe some changes have been made that do not accept XML anymore. Expected behavior Being able to pass XML into the `Content` property as we are expected to pass an Xslt. Actual behavior Passing an XML into the Content property gives the following error: System.Exception: '1' is invalid after a single JSON value. Expected end of data. LineNumber: 0 | BytePositionInLine: 16. Reproduction Steps Run the sample mentioned in the `Describe the bug` section Environment Visual Studio 2022 - 17.4 OS Name: Windows OS Version: 10.0.22621 .NET SDK: Version: 8.0.100 .NET runtimes installed: Microsoft.AspNetCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.19 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.19 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Mgmt	Websites	Codgo se inicia sesion	Type of issue Typo Description [Escriba sus comentarios aquí] Page URL https://learn.microsoft.com/es-es/dotnet/api/microsoft.azure.management.websites.models.facebook.enabled?view=azure-dotnet-legacy#microsoft-azure-management-websites-models-facebook-enabled Content source URL https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Microsoft.Azure.Management.WebSites.Models/Facebook.xml Document Version Independent Id aa2dc48c-4085-7e05-274b-b59ba92978f1 Article author @azure-sdk Metadata  ID: eeb0b5f2-243d-796f-cf9e-63ef557ab842 Service: app-service Sub-service: web-apps
Client	Azure.Core	[BUG] Authentication signature invalid for hosts with non-default port	Library name and version Azure.Data.AppConfiguration 1.3.0 Describe the bug I would like to thank you for your work on the Azure SDK for .NET. I am developing an emulator for Azure App Configuration however I have encountered an issue with how the authentication signature is generated in the Azure SDK for .NET compared with the Azure SDK for other languages. When constructing a ConfigurationClient with a connection string that has an endpoint that has a host with a non-default port the generated authentication signature is invalid because the host does not include the non-default port. This causes an authentication error when validating the signature because the host in the signature does not include the non-default port but the host header in the request does include the non-default port. Expected behavior I would expect the port to be included in the host if it is non-default (e.g. not 80 nor 443) in order to match the host header. Actual behavior The port is not included in the host if it is non-default (e.g. not 80 nor 443) which does not match the host header. Reproduction Steps https://github.com/tnc1997/azure-app-configuration-issue-reproduction Environment No response
Client	Service Bus	What is the replacement of the the NamespaceManager class from Microsoft.ServiceBus?	Library name and version Azure.Messaging.ServiceBus latest version Query/Question I need to get the active message count from a topic subscription, and so far I have only found this class can do the job: https://learn.microsoft.com/en-us/dotnet/api/microsoft.servicebus.namespacemanager?view=azure-dotnet-legacy What's the equivalent in the recommended SDK? Thanks. Environment Azure Function App, .NET Core 6 or 7 Visual Studio 2022
Client	Service Bus	[BUG] ServiceBusReceiver.CompleteMessage taking ~100ms to complete	Library name and version Azure.Messaging.ServiceBus 7.12.0 Describe the bug I've noticed from our logs that completing a message in Service Bus takes ~100ms. I'm not saying it always takes ~100ms, but around 60% of the time it takes ~100ms, and other times it takes <50ms.    Expected behavior The time taken to complete messages ideally should remain consistent for completing same type of messages and >100ms seems too much to me. Actual behavior Completing same type of messages takes inconsistent times and majority of the times takes ~100ms. Reproduction Steps Try completing a few service bus messages: await messageActions.CompleteMessageAsync(message); Environment Azure Functions are being used to receive a trigger for Service Bus Message and then mark messages as completed.
Client	Service Bus	[QUERY] How to migrate WindowsAzure.ServiceBus to Azure.Messaging.ServiceBus in given condition?	Library name and version Azure.Messaging.ServiceBus (7.15.0); WindowsAzure.ServiceBus (4.1.1) Query/Question Hi, this is maomaomqiu! I am now working on deprecating codes of WindowsAzure.ServiceBus to Azure.Messaging.ServiceBus of existing codebase. for WindowsAzure.ServiceBus (4.1.1), we have below operation before that parts' logic is to handle received msg class WrappedMessage {   private BrokeredMessage msg;      ...   // if we have it, return it   if (msg != null)   {       // TimeStamp should be scheduled time i.e. when this        // message should become visible in service bus queue        msg.ScheduledEnqueueTimeUtc = (t0.HasValue) ? t0.Value : CreationTime;          return  msg;   }      // otherwsie create it    msg = new BrokeredMessage(SerializeToJsonString())   {       ContentType = typeof(string).FullName,       ScheduledEnqueueTimeUtc = (t0.HasValue) ? t0.Value : CreationTime,       CorrelationId = CorrelationIdValue   };      // Add Type information to Properties   Type type = this.GetType();    msg.Properties[MessageTypeName] = type.FullName + TypeSeparator + type.Assembly.FullName.Split(TypeSeparator)[0];      if (!string.IsNullOrEmpty(SessionId))   {        msg.SessionId = SessionId;        msg.MessageId = Id;   }      return msg;   ...   /// <summary>   /// Serialized JSON string of WrappedMessage   /// </summary>   public string SerializeToJsonString()   {       return JsonConvert.SerializeObject(this, this.GetType(), DefaultJsonSerializerSettings);   }    private static JsonSerializerSettings DefaultJsonSerializerSettings { get; } = new JsonSerializerSettings() { TypeNameHandling = TypeNameHandling.None };  I notice, in  Azure.Messaging.ServiceBus, the ServiceBusReceivedMessage should be proper migration candidate for BrokeredMessage, but for  ServiceBusReceivedMessage, it has ScheduledEnqueueTime for ScheduledEnqueueTimeUtc (WindowsAzure.ServiceBus (4.1.1)), but can not set directly, so I think up this way to migrate var propertyInfo = typeof(ServiceBusReceivedMessage).GetProperty(`ScheduledEnqueueTime`); propertyInfo.SetValue(msg, (t0.HasValue) ? t0 : CreationTime);  Do you have any suggestions on migrating this part (all in WrappedMessage) code? Greatly thanks in advance : ) Environment No response
Client	Search	[Poor results for RAG with Vector/Hybrid/Semantic search]	Library name and version Azure.Search.Documents and Azure.AI.OpenAI Query/Question I put together a RAG system. I segmented 2 Word documents on paragraph boundaries using only full sentences and successfully ingested them with Azure API. My search has a choice of Vector, Hybrid (vector + text), and Semantic (vector + text + semantic reordering). Those 2 documents are my resume and my friend's resume. When I ask `Who is [my name]?` I get a decent answer. However, when I ask `Who is [my friend's name] I get nothing in the form of `Based on provided information there is no data on...`. I tried that as either of 3 modes of search I mentioned above. The code that defines my search is : `  public SearchOptions? CreateSearchOptions(int searchTypeInt, int k, ReadOnlyMemory<float> embeddings)    {        _logger.LogInformation(`CreateSearchOptions entered`);         SearchOptions? searchOptions = null;        try        {            SearchType searchType = (SearchType)searchTypeInt;             searchOptions = new SearchOptions            {                //Filter = filter, will be set later                Size = k,                 // fields to retrieve, if not specified then all are retrieved if retrievable                Select = { `SegmentText`, `NamedEntities` },            };             if ((searchType & SearchType.Vector) == SearchType.Vector)            {                searchOptions.VectorSearch = new VectorSearchOptions                {                    Queries = { new VectorizedQuery(embeddings) { KNearestNeighborsCount = k, Fields = { `SegmentTextVector` } } },                };            }             if ((searchType & SearchType.Semantic) == SearchType.Semantic)            {                // This is going to invoke semantic ranking, if its resource is enable in Azure                searchOptions.SemanticSearch = new SemanticSearchOptions                {                    SemanticConfigurationName = `my-semantic-config`, // Is it a new name that we give?                    QueryCaption = new QueryCaption(QueryCaptionType.Extractive),                    QueryAnswer = new QueryAnswer(QueryAnswerType.Extractive),                };                searchOptions.QueryType = SearchQueryType.Semantic; // Set the QueryType for Semantic Search            }        }        catch (Exception ex)        {            _logger.LogError(ex, ex.Message);            _logger.LogInformation(`CreateSearchOptions exiting`);            return null;        }         _logger.LogInformation(`CreateSearchOptions exiting`);         return searchOptions;    }`  An here is how the index is constructed: `   public SearchIndex? GetOrCreateSearchIndex(int searchTypeInt,                                                SearchIndexClient searchIndexClient,                                                string searchIndexName)     {         SearchIndex? searchIndex = null;          SearchType searchType = (SearchType)searchTypeInt;          try         {             // Get index if exists             searchIndex = searchIndexClient.GetIndex(searchIndexName);         }         catch (RequestFailedException ex) when (ex.Status == 404)         {             try             {                 // The search index schema (local definition of index) does not exist - create one                 FieldBuilder builder = new FieldBuilder();                 searchIndex = new SearchIndex(searchIndexName, builder.Build(typeof(SegmentObj)));                  // VECTOR OPTION                 if ((searchType & SearchType.Vector) == SearchType.Vector)                 {                     //string vectorProfileFilePath = Path.Combine(InstallDir, mVectorProfileFileName);                     string jsonStr = File.ReadAllText(`VectorProfile.json`);                      searchIndex.VectorSearch = new VectorSearch                     {                         Profiles =                         {                             // using 11.5.0-beta5 of Azure.Search.Documents, in 11.5.0 it will be different ???                             //new VectorSearchProfile(`my-default-vector-profile`, `my-hnsw-config-2`)                             new VectorSearchProfile(`my-vector-profile`, `my-hnsw-config`)                             {                                  Name = `my-vector-profile`,                                  AlgorithmConfigurationName =`my-hnsw-config`                             }                         },                         Algorithms =                         {                             // using 11.5.0-beta5 of Azure.Search.Documents, in 11.5.0 it will be different ???                             //new HnswAlgorithmConfiguration(`my-hnsw-config-2`) // using 11.5.0-beta5 of Azure.Search.Documents                             new HnswAlgorithmConfiguration(`my-hnsw-config`)                             {                                  Name = `my-hnsw-config`,                                  Parameters = new HnswParameters()                                  {                                       Metric = `cosine`,                                        EfSearch = 800,                                         EfConstruction = 800,                                          M = 8                                  }                             },                         }                     };                  }                  // SEMANTIC OPTION                 if ((searchType & SearchType.Semantic) == SearchType.Semantic)                 {                     SemanticSearch semanticSearch = new SemanticSearch                     {                         Configurations =                         {                             // Looks line `my-semantic-config` is not a file name by a name I give                             // to new semantic configuration I am creating...Not sure about it...                             // https://learn.microsoft.com/en-us/azure/search/semantic-how-to-query-request?tabs=rest%2Crest-query                             // The above documentation says: Set `semanticConfiguration` to a                             // predefined semantic configuration that's embedded in your index.                             //                             new SemanticConfiguration(`my-semantic-config`, new()                             {                                 //TitleField = new SemanticField(`HotelName`),                                 ContentFields =                                 {                                     new SemanticField(`SegmentText`),                                     new SemanticField(`NamedEntities`)                                 },                                 KeywordsFields =                                 {                                     new SemanticField(`NamedEntities`)                                 }                             })                         }                     };                      searchIndex.SemanticSearch = semanticSearch;                 }                  // Create SearchIndex in Azure                 if (searchIndex != null)                     searchIndex = searchIndexClient.CreateIndex(searchIndex);             }             catch (Exception ex2)             {                 _logger.LogError(ex2, ex2.Message);                 return null;             }         }          return searchIndex;     }  ` As you can see, in addition to all I use Analytics (not shown in the displayed code) in order to extract Named Entities from every text segment and populate NamedEntities field for every segment I ingest, and KeywordsFields accordingly. When I use Calling the code is as follows: `            searchOptions = CreateSearchOptions(searchTypeInt, k, embeddings);             if (searchOptions != null)             {                 if (!String.IsNullOrWhiteSpace(filter.Trim()))                     searchOptions.Filter = $`NamedEntities eq '{filter}'`;             }              SearchResults<SegmentObj>? response = null;             if (searchOptions != null)                 response = await searchClient.SearchAsync<SegmentObj>(searchText, searchOptions);`  Now, I get responses that are relevant, that is, valid responses, where some of them have valid description who the person is, professionally. But when I feed the prompt along with the 8 results that I get above from vector search into Completion API, I get nothing. I do use GPT-3.5-turbo-16k, because for whatever reason GPT-4 is not available to me at this time in Azure. So, my first suspicion is: is it because I do not use GPT-4? Is there any other reason you could think about? If you'd like you I can provide you with prompt and the context (8 results from vector search). Environment Windows 11, VS2022, Azure.Search.Document 11.5.1, Azure.AI.OpenAI 1.0.0-beta.11, Embeddings 1.0.0-beta.9, Microsoft.AspNetCore.OpenAI 7.0.13
Client	Service Bus	[QUERY] Message completion slower with AMQP vs NetMessaging transport	Library name and version Azure.Messaging.ServiceBus 7.16.2 Query/Question Background I have an application that makes heavy use of ServiceBus sessions.  I'm updating the application's ServiceBus client library from WindowsAzure.ServiceBus to Azure.Messaging.ServiceBus and testing is showing a reduction (roughly half as many messages/second) in performance using the newer Azure.Messaging.ServiceBus client.  After significant tinkering and benchmarking, it appears the performance reduction is related to the `transport type` being used by the client; the AMQP transport takes roughly twice as long to perform the message Complete operation. This `slow completion` (aka. message settlement) behavior is alluded to in #13920 as well, but doesn't have any resolution.  My goal is to get the Azure.Messaging.ServiceBus client to the same performance level as the older WindowsAzure.ServiceBus client, but all the experiments I've tried... aside from scaling out the number of concurrent sessions... have proved fruitless.  I've tried client-per-thread (instead of singleton), I've tried a range of Prefetch (0 to 100, settled on 10), I've tried using the Processor (instead of Receiver), and I've tested just a single session w/single thread... across all the experiments, the client's Complete method is significantly slower when using AMQP transport. Benchmark Scenario Setup  Topic (duplicate detection enabled, message ordering enabled) Subscription (requires session enabled) Publish 1000 messages (10 sessions with 100 messages each) into Topic  Client Pseudocode  Construct a single Subscription Client  Use default client options except increase PrefetchCount to 10   Construct 10 threads which do the following  Using the (singleton) subscription client, Accept a message session Using the (accepted) message session, enter the receive loop:  Receive a single message (using PeekLock) Process the message (simple deserialize + log) Complete the message Repeat the receive loop until Receive returns null (no message)     Capture (via stopwatch) the execution time for every ServiceBus library call  Benchmark Results WindowsAzure.ServiceBus 7.0.1 TransportType: NetMessaging (client default): Completed [10] sessions containing [1000] messages in [00:00:05.722] (174.735 msg/sec) Receive  - Minimum:[0.000 ms], Average:[4.496 ms], Maximum:[148.000] ms Process  - Minimum:[0.000 ms], Average:[0.501 ms], Maximum:[51.000] ms Complete - Minimum:[33.000 ms], Average:[51.870 ms], Maximum:[241.000] ms  TransportType: Amqp (set via connection string): Completed [10] sessions containing [1000] messages in [00:00:12.478] (80.135 msg/sec) Receive - Minimum:[0.000 ms], Average:[0.819 ms], Maximum:[52.000] ms Process - Minimum:[0.000 ms], Average:[0.355 ms], Maximum:[35.000] ms Complete - Minimum:[63.000 ms], Average:[123.271 ms], Maximum:[398.000] ms  Azure.Messaging.ServiceBus 7.16.2 TransportType: Amqp (client default): Completed [10] sessions containing [1000] messages in [00:00:11.846] (84.410 msg/sec) Receive - Minimum:[0.000 ms], Average:[0.991 ms], Maximum:[86.000] ms Process - Minimum:[0.000 ms], Average:[0.612 ms], Maximum:[61.000] ms Complete - Minimum:[38.000 ms], Average:[116.760 ms], Maximum:[259.000] ms  Observation Comparing the NetMessaging transport (WindowsAzure.ServiceBus) against the Amqp transport (both old and new) libraries, the old NetMessaging Receive average is slightly slower... but the Complete is much faster. Question I've tuned the client's options within the constraints of the application's design.  Is there anything that can be done to improve the Azure.Messaging.ServiceBus client's Complete performance? Environment Windows 10, .NET Framework 4.8.9181.0, x64
Mgmt	Logic App	Logic App Standard - Run Http Trigger	Library name and version Azure.ResourceManager.AppService 1.0.2 Query/Question I want to run HttpTrigger in Logic App (Standard) but I don't find correct way. I want to get Workflow URL and than trigger my HTTP Trigger  Environment dotnet 8
Client	Azure.Identity	[QUERY] Not Sure If Customized TokenCredential in ArmClient Should Meet Multi Tenant Requirement	Library name and version Azure.ResourceManager 1.9.0 Query/Question When creating a new ArmClient, we passed our own class as the TokenCredential implementation instead of using the ones provided by Azure.Identity. Is it possible that in the future, the trend will be to use TokenCredentials which provided by Azure to catch up with the latest security requirements? Additionally, is it possible that there will be a KPI check for ArmClient's TokenCredential parameter, and that the customized implementation class will need to meet various latest security requirements? We have this question because we noticed that the ClientSecretCredential code handles multi-tenant scenarios using AdditionallyAllowedTenantIds, as described in this document. Our own implementation of TokenCredential uses a first party app to obtain tokens in the GetToken method. However, we only pass the tenant ID in the constructor and do not pass any other tenant from the GetToken method. The class and tenant are a 1:1 relationship, so we did not set AdditionallyAllowedTenantIds. Since the first-party app itself is multi-tenant app, we are not sure if this approach has any security risks. The code is like: public class ArmTokenCredential : TokenCredential {     private IAppTokenProvider appTokenProvider; // This uses MSAL and first party app to get token      public ArmTokenCredential(IAppTokenProvider appTokenProvider, string tenantId, AzureEnvironment azureEnvironment)     {         this.appTokenProvider = appTokenProvider;         this.TenantId = tenantId;         this.AzureEnvironment = azureEnvironment;         this.ResourceUrl = azureEnvironment.ArmEnvironment.Audience;     }      internal AzureEnvironment AzureEnvironment { get; }      internal string TenantId { get; }      internal string ResourceUrl { get; }      public override AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)     {         var authenticationResult = this.appTokenProvider.GetAuthenticationResultByTenantIdAsync(this.AzureEnvironment, this.TenantId, this.ResourceUrl).GetAwaiter().GetResult();         return new AccessToken(authenticationResult.AccessToken, authenticationResult.ExpiresOn);     }      public async override ValueTask<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)     {         var authenticationResult = await this.appTokenProvider.GetAuthenticationResultByTenantIdAsync(this.AzureEnvironment, this.TenantId, this.ResourceUrl);         return new AccessToken(authenticationResult.AccessToken, authenticationResult.ExpiresOn);     } } Also, we would like to ask why ArmClient and BearerTokenAuthenticationPolicy code do not pass the tenant ID when creating a new TokenRequestContext. In my understanding, ArmClient should have an owner tenant, all resources is under that tenant. So why not pass this tenant directly into the TokenRequestContext constructor? This way, we can directly use the TokenRequestContext's tenantID in the GetToken method. Like: public async override ValueTask<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken) {     var authenticationResult = await this.appTokenProvider.GetAuthenticationResultByTenantIdAsync(this.AzureEnvironment, **requestContext.TenantId**, this.ResourceUrl);     return new AccessToken(authenticationResult.AccessToken, authenticationResult.ExpiresOn); } Environment No response
Mgmt	ARM	[Doc] Add an example how to update a resource - Migrating from old to new management SDK	Hello, Our internal project uses Microsoft.Azure.Management._.Fluent packages. We are planning the migration to Azure.ResourceManager._ packages to be up to date. We're using your migration docs which explain how to migrate between the packages. Unfortunatelly we haven't seen any information on how to update a resource in the new way, using the ResourceManager. For example, let's say I have a virtual machine resource. I want to change its network profile by setting first network interface as primary. I don't want to change other properties of the virtual machine. Which way to handle it is correct? a) Get the vm resorce by name, modify its Data property and then call VirtualMachineCollection.CreateOrUpdate(WaitUntil.Completed, `myVmName`, myVm.Data)  myVm is a VirtualMachineResource variable for which I've set network interface as primary.  b) Create a new object of VirtualMachineData, set there a properties which I want to modify, and then call VirtualMachineCollection.CreateOrUpdate(WaitUntil.Completed, `myVmName`, virtualMachineDataToModify)  virtualMachineDataToModify is a new VirtualMachineData variable which only contains the prop to set first nic as primary.  Your documentation only contains examples how to create and delete resources. Can you add there a small example regarding to resource updates?
Mgmt	Marketplace Ordering	[QUERY] Marketplace.SaaS.Client vs Azure.ResourceManager.Marketplace	Library name and version Marketplace.SaaS.Client 1.2.0 / Azure.ResourceManager.Marketplace 1.1.1 Query/Question Hello there, I'm introducing an Azure Marketplace SaaS offer for my organization. We have implemented a test offer including an integration with the Marketplace.SaaS.Client v1.2.0 package in our solution. Yesterday I found another nuget package - Azure.ResourceManager.Marketplace. I tried to get a bit more information about the package - mainly related to its capabilities. And here is my questions: Does Azure.ResourceManager.Marketplace have the same features and responsibility as Marketplace.SaaS.Client? If so, do I need migrate? Currently used package: https://www.nuget.org/packages/Marketplace.SaaS.Client The package I want to use: https://www.nuget.org/packages/Azure.ResourceManager.Marketplace Environment No response
Client	Service Bus	[QUERY] Is MessagingCommunicationException(WindowsAzure.ServiceBus (4.1.1)) equal to ServiceBusFailureReason.ServiceCommunicationProblem (Azure.Messaging.ServiceBus (7.15.0)))	Library name and version Azure.Messaging.ServiceBus (7.15.0);WindowsAzure.ServiceBus (4.1.1) Query/Question Hi, this is maomaomqiu, thanks for your previous timely and kind help : ) ! I am still doing migration work from WindowsAzure.ServiceBus (4.1.1) to Azure.Messaging.ServiceBus (7.15.0) Before WindowsAzure.ServiceBus (4.1.1) if (exception is MessagingCommunicationException) { do something }   PS: I search latest versin of WindowsAzure.ServiceBus, MessagingCommunicationException seems renamed After I search source code of Azure.Messaging.ServiceBus (7.15.0), find the possible proper override way is if (exception is ServiceBusException sbEx && (sbEx.Reason == ServiceBusFailureReason.ServiceCommunicationProblem)) {do something}  Could you tell me is my understanding right? Environment No response
Client	Service Bus	[QUERY] How processor deal with dead letter queue by default?	Library name and version Azure.Messaging.ServiceBus (7.15.0) Query/Question How processor deal with dead letter queue by default? This question is ask from my colleague @AbeGeMS We use processor in out part of code, we initialize it like below    //  ServiceBusProcessorOptionAdapter is class defined by ourselves to package ServiceBusProcessorOptions, it's Inner is ServiceBusProcessorOptions     var optionAdapter = ServiceBusProcessorOptionAdapter.Create();     optionAdapter.MaxConcurrentCalls = 10;     optionAdapter.ReceiveMode = FormServiceBusReceiveMode.PeekLock;     optionAdapter.SubQueue =FormServiceBusSubQueue.None;           var newProcessor = Client.CreateProcessor(queueName, options: processorOptionAdapter.Inner);  And we observer a phenomenon, this is Dead-Letter amount  after several seconds, the deadletter count will be  decreased nearly a half.. We did not create dead letter processor to handle dead letter, so how processor handle dead letter by default? If you could point out key points in source code, we would be really grateful, greatly thanks in advance! Environment No response
Client	Search	Missing initialization of variable	Library name and version Azure.Search.Documents Query/Question In the code there is a line ReadOnlyMemory vectorizedResult = VectorSearchEmbeddings.SearchVectorizeDescription; VectorSearchEmbeddings is not found any where earlier, where is it instantiated ? Environment https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/search/Azure.Search.Documents/samples/Sample07_VectorSearch_UsingSemanticHybridQuery.md
Client	Service Bus	[Question] Dose the Service bus processor support pick derral message	Library name and version Azure.Messaging.ServiceBus Query/Question I used ServiceBusSessionProcessor to handle my session queue's message. while I deferred a message like below:   await args.DeferMessageAsync(args.Message, new Dictionary<string, object>(1) { { `ScheduledEnqueueTime`, DateTime.UtcNow.AddMinutes(1) } }); Then I would like to pick this message 1 minutes later. However, I wait for a long time(30minutes+) but this message has never been picked by the processor. So,  I would like to know whether the service bus processor support `deferred message`? If so how should I set the processor? If not, would you please recommend a best practice about My case: my app respossible for upload the messages to a website. However as to the volume of the message is very large. So, the website sometime throttle my request. that means I need to wait 20minutes to upload then again. So, I would like to reschedule the message and pick then 20 minute again. my app haven't storage. So, I couldn't maintain the sequence number and I don't want maintain a timer for this cause the message is too large. I need to handle other message immediately. the best solution is I could use DeferMessageAsync method to reschedule the message. but it looks like the server bus processor doesn't work. My workaround ugly solution is that remove the current message and create a new one with schedule time and send them to service bus again. Environment No response
Client	Service Bus	[BUG] Singular peek and receive message operations on a receiver should return a nullable message.	Library name and version Azure.Messaging.ServiceBus 7.16.2 Describe the bug Nullability hints incorrect for singular Peek and Receive methods. Expected behavior If the API is expected to return null, the return value should be nullable. Actual behavior Both singular Peek and Receive methods on the receiver return non-nullable messages, but the return value is null when there are no messages in the message container. Reproduction Steps create a servicebus namespace create a queue connect a receiver to the queue peek the empty queue Environment No response
Client	Search	[BUG] Azure.Search.Documents 11.5.1 removed Vectorizer from VectorSearchProfile	Library name and version Azure.Search.Documents 11.5.1 Describe the bug Azure.Search.Documents 11.5.1 removed Vectorizer in VectorSearchProfile without clear explanation, seems Devloper needs to use external component to embed text again, instead of integration method introduced from 2023-10-01-preview Expected behavior 11.5.0-beta.5 uses Vectorizer in VectorSearchProfile. This matches the description in  https://learn.microsoft.com/en-us/rest/api/searchservice/indexes/create-or-update?view=rest-searchservice-2023-10-01-preview&tabs=HTTP#vectorsearch. 11.5.1 removed Vectorizer from VectorSearchProfile, and also matches the description in https://learn.microsoft.com/en-us/rest/api/searchservice/indexes/create-or-update?view=rest-searchservice-2023-11-01&tabs=HTTP#vectorsearch The problem is there is not detailed reason to explain the change, and even from the official document, it said 2023-11-01, it has no break change based on https://learn.microsoft.com/en-us/azure/search/search-api-migration If you added vector support using 2023-10-01-preview, there are no breaking changes And this official document link, it still uses Vecorizer: https://learn.microsoft.com/en-us/azure/search/vector-search-how-to-configure-vectorizer The latest SDK contains conflicting logic with API usage and description. Actual behavior Azure.Search.Documents 11.5.1 removed Vectorizer caused project compilation and break changes from 11.5.0-beta5 Reproduction Steps Build this sample with 11.5.1 https://github.com/Azure/azure-search-vector-samples/blob/main/demo-dotnet/DotNetIntegratedVectorizationDemo/Program.cs#L123 Environment No response
Client	Service Bus	[QUERY] How to migrate WindowsAzure.ServiceBus to Azure.Messaging.ServiceBus in given condition?	Library name and version Azure.Messaging.ServiceBus (7.15.0); WindowsAzure.ServiceBus (4.1.1) Query/Question Hi, this is maomaomqiu! I am a newcomer, don't know this question is too stupid : ) .. I am now working on deprecating codes of WindowsAzure.ServiceBus to Azure.Messaging.ServiceBus of existing codebase. Here is previous mainly code logic (1) initial queue client queueClient (2) call queueClient.AcceptMessageSessionAsync() to get session in loop, until new session acquired is null, then get group of session -> sessions (List<MessageSession>) (3) for each session (let's call it session0) in sessions, according to it's sessionId, get the session (let's call it session1) by queueClient.AcceptMessageSessionAsync(sessionId) (4) use session.ReceiveBatchAsync(int messageCount, TimeSpan serverWaitTime) to batch receive messages (session here use session1) ... later logic Here I want to do after Here for our codebase, we now have moved part of code to Azure.Messaging.ServiceBus, and wrap ServiceBusSessionProcessor and ServiceBusProcessor, I want to know whether processor can achieve (1) to (4) ? (my concern is (4)) PS: I see part of source code, for processor, it actually will call ServiceBusProcessor.cs#StartProcessingAsync -> RunReceiveTaskAsync -> ReceiveAndProcessMessagesAsync -> ReceiveAndProcessMessagesAsync -> ReceiverManager.cs#ReceiveAndProcessMessagesAsync, maxMessages is assigned as 1,  Based on my limit knowledge, 1 solution is introducing Receiver? Environment No response
Client	Storage	[BUG] ExistsAsync, WaitForCompletionAsync and/or DeleteIfExistsAsync terminate unexpectedly	Library name and version Azure.Storage.Blobs v12.19.1 Describe the bug Debugger fully terminates after either:  Checking if Blob exists via async method `ExistsAsync` After calling WaitForCompletionAsync when copy of Blob has started After Deleting Blob from container with `DeleteIfExistsAsync`  Expected behavior Debugger doesn't terminate and continues with the copy of the rest of the files which are present in the container with the given prefix Actual behavior Debugger terminates fully after calling ExistsAsync on BlobClient: Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T08:26:17.3481331Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`b2db59fbfec45194a418138e391fb14a`,`ai.operation.parentId`:`624ab8e0508c8321`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`HEAD /devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_11.png`,`id`:`6fe8656fe17f70a6`,`data`:` [http://127.0.0.1:10000/devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_11.png`,`duration`:`00:00:00.0041505`,`resultCode`:`200`,`success`:true,`type`:`Http`,`target`:`127.0.0.1:10000`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies'](http://127.0.0.1:10000/devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_11.png%22,%22duration%22:%2200:00:00.0041505%22,%22resultCode%22:%22200%22,%22success%22:true,%22type%22:%22Http%22,%22target%22:%22127.0.0.1:10000%22,%22properties%22:%7B%22AspNetCoreEnvironment%22:%22Development%22,%22_MS.ProcessedByMetricExtractors%22:%22(Name:%27Dependencies%27) , Ver:'1.1')`,`ServerRequestId`:`bf99ccc3-e462-43d6-b0b6-c6526f8d067b`,`DeveloperMode`:`true`,`ClientRequestId`:`337988ce-ff02-4d31-b6ca-a4ced1a84708`}}}} The thread 0x7704 has exited with code 0 (0x0). Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T08:26:17.3446061Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`b2db59fbfec45194a418138e391fb14a`,`ai.operation.parentId`:`e9f3ca6465d26453`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`BlobBaseClient.Exists`,`id`:`624ab8e0508c8321`,`duration`:`00:00:00.0359072`,`success`:true,`type`:`InProc | Microsoft.Storage`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`}}}} The program '[26616] testhost.exe' has exited with code 4294967295 (0xffffffff). Debugger fully terminates after calling WaitForCompletionAsync on CopyFromUriOperation: Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:42:21.0521313Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d4a9d9ae3d4c5a65db1ebd5e90be27f7`,`ai.operation.parentId`:`3eaf322e6f91d1c4`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`PUT /devstoreaccount1/handleidingen/old/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_16.png`,`id`:`01d75ce76a0c5ddc`,`data`:`http://127.0.0.1:10000/devstoreaccount1/handleidingen/old/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_16.png`,`duration`:`00:00:00.0028789`,`resultCode`:`202`,`success`:true,`type`:`Http`,`target`:`127.0.0.1:10000`,`properties`:{`ServerRequestId`:`03dcd1e1-8daa-4540-a0a7-1b7eeef34c16`,`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`,`ClientRequestId`:`f1fe1791-b726-452d-92e5-ddfe7332e127`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:42:21.0503918Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d4a9d9ae3d4c5a65db1ebd5e90be27f7`,`ai.operation.parentId`:`82cd73ebfe5c02d8`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`BlobBaseClient.StartCopyFromUri`,`id`:`3eaf322e6f91d1c4`,`duration`:`00:00:00.0270861`,`success`:true,`type`:`InProc | Microsoft.Storage`,`properties`:{`AspNetCoreEnvironment`:`Development`,`MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`}}}} The thread 0x5664 has exited with code 0 (0x0). Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:42:22.0078869Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d4a9d9ae3d4c5a65db1ebd5e90be27f7`,`ai.operation.parentId`:`e7e80bf1e5700f5d`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`HEAD /devstoreaccount1/handleidingen/old/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard%28%3DBerekeningsmodellen%29_16.png`,`id`:`5fce3302ca54e18a`,`data`:`http://127.0.0.1:10000/devstoreaccount1/handleidingen/old/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_16.png`,`duration`:`00:00:00.0041548`,`resultCode`:`200`,`success`:true,`type`:`Http`,`target`:`127.0.0.1:10000`,`properties`:{`ServerRequestId`:`4abffa89-3366-4304-8749-b3d29129ba29`,`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`,`ClientRequestId`:`ac8a5eed-2959-4d42-aa9e-80ecb18bce2c`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:42:22.0077577Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d4a9d9ae3d4c5a65db1ebd5e90be27f7`,`ai.operation.parentId`:`82cd73ebfe5c02d8`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`BlobBaseClient.GetProperties`,`id`:`e7e80bf1e5700f5d`,`duration`:`00:00:00.0069656`,`success`:true,`type`:`InProc | Microsoft.Storage`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`}}}} The program '[19768] testhost.exe' has exited with code 4294967295 (0xffffffff). Debugger fully terminates after calling DeleteIfExists on BlobClient: The thread 0x68e8 has exited with code 0 (0x0). Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:30:48.1242649Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d85530bc4a3b10875a3f268ad5990f71`,`ai.operation.parentId`:`e26cdb896c2bb0f6`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`HEAD /devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_14.png`,`id`:`b0d03387aeacfa6f`,`data`:`http://127.0.0.1:10000/devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_14.png`,`duration`:`00:00:00.0081296`,`resultCode`:`200`,`success`:true,`type`:`Http`,`target`:`127.0.0.1:10000`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`,`ClientRequestId`:`5b18189b-cf40-4156-bb5d-854d1f06639f`,`ServerRequestId`:`ce8885b2-1f61-4126-af00-e19c3645db54`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:30:48.1241440Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d85530bc4a3b10875a3f268ad5990f71`,`ai.operation.parentId`:`46cd031e7c44b040`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`BlobBaseClient.Exists`,`id`:`e26cdb896c2bb0f6`,`duration`:`00:00:00.0133180`,`success`:true,`type`:`InProc | Microsoft.Storage`,`properties`:{`AspNetCoreEnvironment`:`Development`,`MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:30:48.1414945Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d85530bc4a3b10875a3f268ad5990f71`,`ai.operation.parentId`:`a4ea859bb9708dfa`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`HEAD /devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard%28%3DBerekeningsmodellen%29_14.png`,`id`:`0f6cfd96a9aa7561`,`data`:`http://127.0.0.1:10000/devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_14.png`,`duration`:`00:00:00.0014581`,`resultCode`:`200`,`success`:true,`type`:`Http`,`target`:`127.0.0.1:10000`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`,`ClientRequestId`:`bda3b41a-b0dc-4fd5-b6f3-10b7d2eb1159`,`ServerRequestId`:`9871f3a5-048d-4969-9e43-cab8dc7628a2`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:30:48.1413875Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d85530bc4a3b10875a3f268ad5990f71`,`ai.operation.parentId`:`46cd031e7c44b040`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`BlobBaseClient.GetProperties`,`id`:`a4ea859bb9708dfa`,`duration`:`00:00:00.0039784`,`success`:true,`type`:`InProc | Microsoft.Storage`,`properties`:{`AspNetCoreEnvironment`:`Development`,`MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:30:48.1517064Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d85530bc4a3b10875a3f268ad5990f71`,`ai.operation.parentId`:`b109a059f689819c`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`DELETE /devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard%28%3DBerekeningsmodellen%29_14.png`,`id`:`53bf429c6dc1bcb1`,`data`:`http://127.0.0.1:10000/devstoreaccount1/handleidingen/nl/Handleiding%20Accountancy%20Dashboard/HTML/images/Anlisa_Handleiding___Accountancy_Dashboard_%28%3DBerekeningsmodellen%29_14.png`,`duration`:`00:00:00.0446928`,`resultCode`:`202`,`success`:true,`type`:`Http`,`target`:`127.0.0.1:10000`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`,`ClientRequestId`:`5dff996f-f3b3-452d-afbd-5e674360a954`,`ServerRequestId`:`da97349b-c4c2-4589-8610-8dc0dc0464ba`}}}} Application Insights Telemetry: {`name`:`AppDependencies`,`time`:`2023-12-22T09:30:48.1500018Z`,`iKey`:`f1315be9-97ed-4882-bafb-7eadc677640a`,`tags`:{`ai.application.ver`:`15.0.0.0`,`ai.cloud.roleInstance`:`JeroenDesmetWr`,`ai.operation.id`:`d85530bc4a3b10875a3f268ad5990f71`,`ai.operation.parentId`:`46cd031e7c44b040`,`ai.internal.sdkVersion`:`dotnetc:2.21.0-429`,`ai.internal.nodeName`:`JeroenDesmetWr`},`data`:{`baseType`:`RemoteDependencyData`,`baseData`:{`ver`:2,`name`:`BlobBaseClient.DeleteIfExists`,`id`:`b109a059f689819c`,`duration`:`00:00:00.0514180`,`success`:true,`type`:`InProc | Microsoft.Storage`,`properties`:{`AspNetCoreEnvironment`:`Development`,`_MS.ProcessedByMetricExtractors`:`(Name:'Dependencies', Ver:'1.1')`,`DeveloperMode`:`true`}}}} The program '[21652] testhost.exe' has exited with code 4294967295 (0xffffffff). Reproduction Steps This is the code I used to produce the bug, bear in mind that I replaced the containernames and filenames with dummy data: `try { var containerClient = await GetBlobContainerClient(`xyz`, cancellationToken); var blobs = containerClient.GetBlobsAsync(BlobTraits.All, BlobStates.All, `prefix`, cancellationToken); await foreach (var blob in blobs) { var sourceBlob = containerClient.GetBlobClient(`prefix/filename`); if (await sourceBlob.ExistsAsync(cancellationToken)) { var destinationBlob = containerClient.GetBlobClient(`newPrefix/Filename`); var operation = await destinationBlob.StartCopyFromUriAsync(sourceBlob.Uri, cancellationToken: cancellationToken); await operation.WaitForCompletionAsync(cancellationToken); if (await IsBlobLocked(sourceBlob, cancellationToken)) throw new AzureStorageException(AzureStorageExceptionReason.FileLocked); await sourceBlob.DeleteIfExistsAsync(DeleteSnapshotsOption.IncludeSnapshots, cancellationToken: cancellationToken); } else { _logger.LogWarning(`Copy file async, source file does not exist`); } } } catch (Exception) { throw;  }` Environment .NET SDK: Version:   7.0.403 Commit:    142776d834 Runtime Environment: OS Name:     Windows OS Version:  10.0.22631 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.403\ Host: Version:      7.0.13 Architecture: x64 Commit:       3f73a2f186 .NET SDKs installed: 7.0.403 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.24 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.24 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.24 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found
Mgmt	App Services	[BUG] StaticSitePatch missing Identity property to update managed identity	Library name and version Azure.ResourceManager.AppService 1.0.2 Describe the bug The StaticSitePatch object is missing the Identity property, which makes it unable to update the resource's managed identity. Expected behavior StaticSitePatch should include the Identity property to enable updating of managed identity. Actual behavior The StaticSitePatch object is missing the Identity property, which makes it unable to update the resource's managed identity. Reproduction Steps    Environment No response
Service	Azure.Identity	[BUG] AuthenticationFailedException: ManagedIdentityCredential authentication failed. An unexpected error occured while fetching the AAD Token	Library name and version Azure.Identity 1.10.4 Describe the bug Hi all! I'm trying to setup API-to-API authorization using Managed identities. I have two web APIs, let's say Client.API and Server.API. In Azure AD Managed Identity service principal for Client.API has appropriate role assigned for Server.API. I'm using the next code snippet in Client.API (.NET 6) to get an access token and perform request from Client.API to Server.API: var credentials = new DefaultAzureCredential(new DefaultAzureCredentialOptions {     ExcludeSharedTokenCacheCredential = true,     ExcludeVisualStudioCodeCredential = true,     ExcludeVisualStudioCredential = true,     VisualStudioTenantId = `<my-tenant-id>`, });  var tokenResult = credentials.GetToken(new Azure.Core.TokenRequestContext(new[] { `<server-api-app-id>/.default` }));   And it failes on the last line with the next error: [AuthenticationFailedException] ManagedIdentityCredential authentication failed: Service request failed.\r\nStatus: 500 (Internal Server Error)\r\n\r\nContent:\r\n{\`statusCode\`:500,\`message\`:\`An unexpected error occured while fetching the AAD Token.\`,\`correlationId\`:\`d61c989c-ca38-4ab1-aad1-fc1443b89887\`}\r\n\r\nHeaders:\r\nDate: Tue, 19 Dec 2023 11:48:16 GMT\r\nServer: Kestrel\r\nTransfer-Encoding: chunked\r\nX-CORRELATION-ID: REDACTED\r\nContent-Type: application/json; charset=utf-8\r\n\nSee the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot` Stack stace: Expected behavior Authentication through Azure AD Managed Identity works well Actual behavior The next exception was thrown: `exception`: {         `ClassName`: `Azure.Identity.AuthenticationFailedException`,         `Message`: `ManagedIdentityCredential authentication failed: Service request failed.\r\nStatus: 500 (Internal Server Error)\r\n\r\nContent:\r\n{\`statusCode\`:500,\`message\`:\`An unexpected error occured while fetching the AAD Token.\`,\`correlationId\`:\`d61c989c-ca38-4ab1-aad1-fc1443b89887\`}\r\n\r\nHeaders:\r\nDate: Tue, 19 Dec 2023 11:48:16 GMT\r\nServer: Kestrel\r\nTransfer-Encoding: chunked\r\nX-CORRELATION-ID: REDACTED\r\nContent-Type: application/json; charset=utf-8\r\n\nSee the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot`,         `Data`: null,         `InnerException`: {             `Status`: 500,             `ErrorCode`: null,             `ClassName`: `Azure.RequestFailedException`,             `Message`: `Service request failed.\r\nStatus: 500 (Internal Server Error)\r\n\r\nContent:\r\n{\`statusCode\`:500,\`message\`:\`An unexpected error occured while fetching the AAD Token.\`,\`correlationId\`:\`d61c989c-ca38-4ab1-aad1-fc1443b89887\`}\r\n\r\nHeaders:\r\nDate: Tue, 19 Dec 2023 11:48:16 GMT\r\nServer: Kestrel\r\nTransfer-Encoding: chunked\r\nX-CORRELATION-ID: REDACTED\r\nContent-Type: application/json; charset=utf-8\r\n`,             `Data`: null,             `InnerException`: null,             `HelpURL`: null,             `StackTraceString`: `   at Azure.Identity.ManagedIdentitySource.HandleResponseAsync(Boolean async, TokenRequestContext context, Response response, CancellationToken cancellationToken)\r\n   at Azure.Identity.ManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)\r\n   at Azure.Identity.ManagedIdentityClient.AuthenticateCoreAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)\r\n   at Azure.Identity.ManagedIdentityClient.AppTokenProviderImpl(AppTokenProviderParameters parameters)\r\n   at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.SendTokenRequestToAppTokenProviderAsync(ILoggerAdapter logger, CancellationToken cancellationToken)\r\n   at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger)\r\n   at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.ExecuteAsync(CancellationToken cancellationToken)\r\n   at Microsoft.Identity.Client.Internal.Requests.RequestBase.RunAsync(CancellationToken cancellationToken)\r\n   at Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor.ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken)\r\n   at Azure.Identity.AbstractAcquireTokenParameterBuilderExtensions.ExecuteAsync[T](AbstractAcquireTokenParameterBuilder`1 builder, Boolean async, CancellationToken cancellationToken)\r\n   at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientCoreAsync(String[] scopes, String tenantId, Boolean enableCae, Boolean async, CancellationToken cancellationToken)\r\n   at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientAsync(String[] scopes, String tenantId, Boolean enableCae, Boolean async, CancellationToken cancellationToken)\r\n   at Azure.Identity.ManagedIdentityClient.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)\r\n   at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)`,             `RemoteStackTraceString`: null,             `RemoteStackIndex`: 0,             `ExceptionMethod`: null,             `HResult`: -2146233088,             `Source`: `Azure.Identity`,             `WatsonBuckets`: null         },         `HelpURL`: null,         `StackTraceString`: `   at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable)\r\n   at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)\r\n   at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted[T](ValueTask`1 task)\r\n   at Azure.Identity.ManagedIdentityCredential.GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)\r\n   at Azure.Identity.DefaultAzureCredential.GetTokenFromSourcesAsync(TokenCredential[] sources, TokenRequestContext requestContext, Boolean async, CancellationToken cancellationToken)\r\n   at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)\r\n   at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage, Boolean isCredentialUnavailable)\r\n   at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)\r\n   at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted[T](ValueTask`1 task)\r\n   at Azure.Identity.DefaultAzureCredential.GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)`,         `RemoteStackTraceString`: null,         `RemoteStackIndex`: 0,         `ExceptionMethod`: null,         `HResult`: -2146233088,         `Source`: `Azure.Identity`,         `WatsonBuckets`: null     }  Reproduction Steps Create two APIs Grand a role for managed identity service principal to give an access. (In my case I used New-MgServicePrincipalAppRoleAssignment command in PowerShell) Try to use DefaultAzureCredential class from Azure.Identity nuget package to get an access token via its GetToken method. Environment Azure App service running on Windows, .NET 6
Service	OpenAI	Banned from OpenAI after issuing a request with Azure.AI.OpenAI	Library name and version Azure.AI.OpenAI 1.0.0-beta.12 Query/Question Not sure if this related at all but yesterday I added some credits to my OpenAI account, created an API key and sent a single chat requests asking for PR summary for user stories titles. Using your package. During the night it seems my OpenAI account has been banned. Is it possible that my API key was leaked somehow or that the package is abusing the OpenAI platform in some way? Environment Visual Studio 2022
Mgmt	App Services	[BUG] WebSiteResource.Stop method does not work on Staging slot	Library name and version Azure.ResourceManager.AppService v1.1.0-beta4 Describe the bug Consider the following example:             WebSiteResource[] sites = resourceGroup.GetWebSites().GetAll(includeSlots: isStaging).ToArray();              string siteName = isStaging ? functionAppName + `/Staging` : functionAppName;              WebSiteResource site = sites.SingleOrDefault(s => string.Equals(s.Data.Name, siteName, StringComparison.OrdinalIgnoreCase));              if (site is not null)             {                 site.Stop();            }  Stop method fails reporting the following error: {`error`:{`code`:`ResourceNotFound`,`message`:`The Resource 'Microsoft.Web/sites/Staging' under resource group 'statusppecus1' was not found. For more details please go to https://aka.ms/ARMResourceNotFoundFix`}}  Notice that the resource is Microsoft.Web/sites/Staging instead of  Microsoft.Web/sites/{siteName}/slot/Staging Rest API reference: https://learn.microsoft.com/en-us/rest/api/appservice/web-apps/stop-slot?view=rest-appservice-2022-03-01 After some digging, I think I need to do the following:             WebSiteSlotResource webSiteSlot;             try             {                 WebSiteResource site = resourceGroup.GetWebSites().Get(functionAppName);                 webSiteSlot = site.GetWebSiteSlot(stepData.SlotName);             }             catch (RequestFailedException ex) when (ex.Status == (int)HttpStatusCode.NotFound)             {                 return;             }              webSiteSlot.StopSlot();  I am logging this issue to raise awareness that the API is not user friendly. Expected behavior WebSiteResource.Stop method should stop staging slot. Actual behavior RequestFailedException with status 404 is thrown. Reproduction Steps See description Environment .NET Framework 4.8
Client	Event Hubs	[FEATURE REQ] Add TableCheckpointStore	Library name Azure.Messaging.EventHubs.Processor Please describe the feature. Currently, the only built-in CheckpointStore in the Azure SDK, BlobCheckpointStore uses Azure Blob Storage as its backing. As the Durable Functions team shared recently, using Azure Storage Tables is cheaper and easier to debug than using stub blobs, and they are changing their default partition manager accordingly. There's an @azure/eventhubs-checkpoint-table package in beta in the JS SDK that we could port and finalize.
Client	Event Hubs	[QUERY] Possible reasons why Azure IoT Hub built-in endpoint closes the receiver link	Library name and version Azure.Messaging.EventHubs Query/Question I have been working on an unofficial Event Hub SDK for rust, and recently one user found that their Event Hub consumer client kept getting closed by Azure after working fine for a random period of time. They are using the Event Hub consumer client to read events from an IoT Hub built-in endpoint, and they are working with a North Europe instance. What they have been observed in the log is the follows:  The consumer client works fine for some hours The AMQP receiver link gets disconnected by Azure with a closing detach frame with no error message The underlying AMQP connection, however, is kept open, and the AMQP management link on that connection is also kept active During the retrying process, disconnecting and reconnect the management link works, but trying to receive from the receiving link (this is actually indeed my problem, should not have tried resuming a closed link) yields the same error mentioned above in (2)  There are roughly 6 or 7 messages per minute coming from the IoT Hub, so we could rule out connection closure due to inactiveness. I have been trying to reproduce this on a test instance in the Canada Central region, but I have not been able to reproduce this yet. I was just wondering if you have any insights of what could be causing the initial closing Detach from Azure? Environment No response
Client	Event Grid	[BUG] EventGridClient got 401 when acknowledging messages from Event Grid namespace topic	Library name and version Azure.Messaging.EventGrid 4.22.0-beta.1 Describe the bug I created an Azure service principal under my Azure Subscription. For simplicity I am using password as the secret for authentication, not certificate. Then under the same Azure subscription I created an Event Grid Namespace, enabled MQTT for it, and created a namespace topic and a subscription. The following roles are assigned to my service principal at the namespace topic level (not at the EG namespace level): EventGrid Contributor and EventGrid Data Contributor. I then use this service principal's credential to read messages from the namespace topic: var clientSecretCredential = new ClientSecretCredential(     `<a valid tenant id>`,     `<a valid app id>`,     `<app password>`); var egClient = new EventGridClient(new Uri(`<a valid eg endpoint>`), clientSecretCredential); int egListenerCount = 1; var topicName = `<a valid topic name>`; var subscriptionName = `<a valid subscription name>`; var listenerTasks = new List<Task>();  for (int count = 0; count < egListenerCount; count++) {     listenerTasks.Add(         Task.Run(async () =>         {             while (Interlocked.Read(ref flag) == 0)             {                 ReceiveResult result = await egClient.ReceiveCloudEventsAsync(topicName, subscriptionName, 5, TimeSpan.FromSeconds(30));                  if (result?.Value != null)                 {                     var toAcknowledge = new List<string>();                      foreach (ReceiveDetails detail in result.Value)                     {                         CloudEvent cloudEvent = detail.Event;                         BrokerProperties brokerProperties = detail.BrokerProperties;                         Console.WriteLine($`[EGNS Topic Testing]Data: {cloudEvent?.Data?.ToString()}`);                          toAcknowledge.Add(brokerProperties.LockToken);                     }                      if (toAcknowledge.Any())                     {                         AcknowledgeResult acknowledgeResult = await egClient.AcknowledgeCloudEventsAsync(topicName, subscriptionName, new AcknowledgeOptions(toAcknowledge));                          if (acknowledgeResult.FailedLockTokens.Any())                         {                             Console.WriteLine($`[EGNS Topic Testing]Failed count for Acknowledge: {acknowledgeResult.FailedLockTokens.Count}`);                             foreach (FailedLockToken failedLockToken in acknowledgeResult.FailedLockTokens)                             {                                 Console.WriteLine($`Lock Token: {failedLockToken.LockToken}; Error Code: {failedLockToken.Error}; Error Description: {failedLockToken.ToString}`);                             }                         }                          if (acknowledgeResult.SucceededLockTokens.Any())                         {                             Console.WriteLine($`[EGNS Topic Testing]Success count for Acknowledge: {acknowledgeResult.SucceededLockTokens.Count}`);                             foreach (string lockToken in acknowledgeResult.SucceededLockTokens)                             {                                 Console.WriteLine($`Lock Token: {lockToken}`);                             }                         }                     }                 }             }         })); }  The ReceiveCloudEventsAsync() method returned some messages from the namespace topic, but when the code tried to acknowledge them by calling AcknowledgeCloudEventsAsync(), the following error occurred: Provided JWT token is not allowed to perform following operation Status: 401 (Unauthorized) ErrorCode: Unauthenticated Content: {`error`:{`code`:`Unauthenticated`,`message`:`Provided JWT token is not allowed to perform following operation`,`timestamp_utc`:`2023-12-15T19:34:32.914700543+00:00`,`tracking_id`:`319A8767-930D-45DA-9955-F8D1EEBB89F5`}} Headers: broker-errorcode: REDACTED Date: Fri, 15 Dec 2023 19:34:32 GMT Content-Length: 220 Content-Type: application/json; charset=utf-8 Expected behavior Both read and ack should succeed or fail together, using the same service principal. Actual behavior read succeeded but ack failed. Reproduction Steps All repro steps are mentioned in the summary. Environment No response
Client	Extensions	[QUERY] Dependency injection of all azure clients, use stale HttpClient instances?	Library name and version Microsoft.Extensions.Azure 1.8.0-beta.1 Query/Question After inspecting the source code, the underlying HttpClientTransport uses an HttpClient, which as far as my understanding goes, needs to be refreshed from an IHttpClientFactory as keeping a single long-lived instance of it, might cause issues relating to DNS. The AzureClientFactory coupled with ClientRegistration<TClient> cache the whole client that's built from DI, which also includes any dependencies it might have, such as HttpClientTransport. My question is - is this intended? If so, why? Environment No response
Mgmt	ARM	How to update ApplicationGroupReferences for an AVD workspace object? there property is read only and no constructor.	azure-sdk-for-net/sdk/desktopvirtualization/Azure.ResourceManager.DesktopVirtualization/src/Generated/VirtualWorkspaceData.cs                    Line 26       in       0519b41                                                 ApplicationGroupReferences = new ChangeTrackingList<string>();
Client	Search	[Poor Results from the Hybrid Vector/Semantic Search]	Library name and version Azure.SearchDocument 11.5.1 Query/Question I implemented something similar to Vector/Semantic search, as described here: The code of configuring both vector and semantic searches is based on the flags passed to the API, and look like that: `    public SearchIndex? GetOrCreateSearchIndex(int searchTypeInt,                                        SearchIndexClient searchIndexClient,                                        string searchIndexName) {     SearchIndex? searchIndex = null;      SearchType searchType = (SearchType)searchTypeInt;  try {     // Get index if exists     searchIndex = searchIndexClient.GetIndex(searchIndexName); } catch (RequestFailedException ex) when (ex.Status == 404) {     try     {         // The search index schema (local definition of index) does not exist - create one         FieldBuilder builder = new FieldBuilder();         searchIndex = new SearchIndex(searchIndexName, builder.Build(typeof(SegmentObj)));          // VECTOR OPTION         if ((searchType & SearchType.Vector) == SearchType.Vector)         {             //string vectorProfileFilePath = Path.Combine(InstallDir, mVectorProfileFileName);             string jsonStr = File.ReadAllText(`VectorProfile.json`);              searchIndex.VectorSearch = new VectorSearch             {                 Profiles =                 {                     // using 11.5.0-beta5 of Azure.Search.Documents, in 11.5.0 it will be different ???                     //new VectorSearchProfile(`my-default-vector-profile`, `my-hnsw-config-2`)                     new VectorSearchProfile(`my-vector-profile`, `my-hnsw-config`)                     {                          Name = `my-vector-profile`,                          AlgorithmConfigurationName =`my-hnsw-config`                     }                 },                 Algorithms =                 {                     // using 11.5.0-beta5 of Azure.Search.Documents, in 11.5.0 it will be different ???                     //new HnswAlgorithmConfiguration(`my-hnsw-config-2`) // using 11.5.0-beta5 of Azure.Search.Documents                     new HnswAlgorithmConfiguration(`my-hnsw-config`)                     {                          Name = `my-hnsw-config`,                          Parameters = new HnswParameters()                          {                               Metric = `cosine`,                                EfSearch = 800,                                 EfConstruction = 800,                                  M = 8                          }                     },                 }             };          }          // SEMANTIC OPTION         if ((searchType & SearchType.Semantic) == SearchType.Semantic)         {             SemanticSearch semanticSearch = new SemanticSearch             {                 Configurations =                 {                     // Looks line `my-semantic-config` is not a file name by a name I give                     // to new semantic configuration I am creating...Not sure about it...                     // https://learn.microsoft.com/en-us/azure/search/semantic-how-to-query-request?tabs=rest%2Crest-query                     // The above documentation says: Set `semanticConfiguration` to a                     // predefined semantic configuration that's embedded in your index.                     //                     new SemanticConfiguration(`my-semantic-config`, new()                     {                         //TitleField = new SemanticField(`HotelName`),                         ContentFields =                         {                             new SemanticField(`SegmentText`),                             new SemanticField(`NamedEntities`)                         },                         KeywordsFields =                         {                             new SemanticField(`NamedEntities`)                         }                     })                 }             };              searchIndex.SemanticSearch = semanticSearch;         }          // Create SearchIndex in Azure         if (searchIndex != null)             searchIndex = searchIndexClient.CreateIndex(searchIndex);     }     catch (Exception ex2)     {         _logger.LogError(ex2, ex2.Message);         return null;     } }  return searchIndex; }`  and here is the calling function: `public async Task<List<SegmentObj>?> HybridSearch(SearchClient searchClient,                             SearchIndexClient searchIndexClient,                             string searchIndexName,                            int searchTypeInt,                             ReadOnlyMemory<float> embeddings, // Embeddings of prompt                            string searchText = ``,  // Additional Text to search                            string filterNamedEntities = ``,                            int k = 10) {     _logger.LogTrace(`HybridSearch entered`);      SearchIndex? searchIndex = null; SearchOptions? searchOptions = null; List<SegmentObj>? segList = null;      SearchType searchType = (SearchType)searchTypeInt;     _logger.LogTrace($`SearchType: {searchType.ToString()}`);  try {     // Get Index if exists, otherwise create it     searchIndex = GetOrCreateSearchIndex(searchTypeInt,                                          searchIndexClient,                                          searchIndexName);      searchOptions = CreateSearchOptions(searchTypeInt, k, embeddings);      if (!String.IsNullOrWhiteSpace(filterNamedEntities.Trim()))         searchOptions.Filter = filterNamedEntities;       //if (searchIndex != null)     //    searchIndex = await searchIndexClient.CreateIndexAsync(searchIndex);      SearchResults<SegmentObj>? response = null;     if (searchOptions != null)         response = await searchClient.SearchAsync<SegmentObj>(searchOptions);     //response = await searchClient.SearchAsync<SegmentObj>(``, searchOptions);      int count = 0;     _logger.LogTrace($`Single Vector Search Results:`);      segList = new List<SegmentObj>();      //foreach (SearchResult<SegmentObj> result in response.GetResults())     if (response != null)     {         await foreach (SearchResult<SegmentObj> result in response.GetResultsAsync())         {             count++;             SegmentObj seg = result.Document;             segList.Add(seg);             _logger.LogTrace($`ID: {seg.segmentId}: Text:{seg.SegmentText}: NE:{seg.NamedEntities} `);         }     }      _logger.LogTrace($`Total number of search results:{count}`); } catch (Exception ex) {     _logger.LogError(ex, ex.Message);     return null; }  _logger.LogTrace(`HybridSearch exiting`); return segList; }  ` So, everything works - no exceptions. Obviously, you need to take my word that all other entities associated with this configuration were created correctly. Now, previously I ingested a document using the same configuration as far I know (just my resume). Now that I do the search, I ask something like: When did [Person's Name] work at [Company Name]? - and I get back only a single result instead of 10 that I asked, and this result is TOTALLY incorrect - just a last paragraph of the document. (Something to clarify: I segmented this document into segments, which are paragraphs, before I fed them to Azure OpenAI Embeddings API, so each paragraph is represented by a vector). Do you see anything evident in the code that results in my misfortunes? So far, I ran 'Vector' mode and 'Vector | Semantic', but the results are bad for both... Environment Windows 11, Visual Studio 2022 Azure.Search.Documents 11.5.1
Mgmt	Container Instances	How to authenticate to Azure Container Instance use Service Principal and ManagedIdentity using Azure.ResourceManager.ContainerInstance [QUERY]	Library name and version Azure.ResourceManager.ContainerInstance 1.2.0 Query/Question When creating an Azure Container Instance I am having trouble authentication to an ACR use a service principal or managed credential. I can get it to working using the ACR admin user, but that is not as secure. Ideally I would like to authenticate using the same service principal my ArmClient is using? Second best option would be a managed identity. Would it be possible to provide a sample showing how to do this. Environment No response
Client	OpenAI	[FEATURE REQ] Support extra header in OpenAI LLM sdk like Python openai sdk did	Library name Azure.AI.OpenAI Please describe the feature. hi, OpenAI .Net sdk developper, we know that in python sdk openai, there is a way to add extra header directly in chat/completion api, but seems in Azure.AI.OpenAI .net sdk, there is no such feature support, is there any plan to support it? below is the python invocation sample: `import openai openai.api_key = `your-api-key` response = openai.Completion.create( engine=`text-davinci-002`, prompt=`Translate the following English text to French: '{`role`: `system`, `content`: `You are a helpful assistant.`}'`, max_tokens=60, headers={`Extra-Header`: `Extra-Value`} )`
Service	Service Bus	[BUG] Paging through a considerable amount of queues in a namespace results in inconsistent page and total item count results	Library name and version Azure.Messaging.ServiceBus, Version=7.17.1.0 Describe the bug I have a small service bus browser tool https://github.com/sergevm/azure-servicebus-browser that has some search features (contains on queue / topic name). To execute this search, I use ServicebusAdministrationClient.GetQueuesRuntimePropertiesAsync() with AsPages() to run through the the queue runtime informations and find matches. However, I noticed that I don't always get the same number of search results. I added some logging to the method that processes the IAsyncEnumerable<Page>. With the page size set to 100, I see in the logging that all pages except for the last one contain 100 queues, except for the last page. In the logging, I see that the number of pages is not consistent, as are the number of queues on the last page received. Expected behavior Without queues being created or deleted, the number of pages is always the same, as well as the total number of items. Actual behavior There are no exceptions thrown, nor logging statements. Reproduction Steps Use a namespace that contains a considerable amount of queues. In my test context, I have +1900 queues. Use the Azure.ServiceBus.Messaging ServicebusAdministration client to run over the queues in the namespace, using the ServicebusAdministrationClient.GetQueuesRuntimePropertiesAsync() API, and call AsPages() on the result, e.g. ` return client.GetQueuesRuntimePropertiesAsync(cancellationToken).AsPages(continuationToken, pageSize); The implementation I use is as simple as public IAsyncEnumerable<Azure.Page<QueueRuntimeProperties>> GetQueueRuntimeInfo(int pageSize, string? continuationToken, CancellationToken cancellationToken = default) {        return client.GetQueuesRuntimePropertiesAsync(cancellationToken).AsPages(continuationToken, pageSize); }  This method is called from another method (on another class): public async IAsyncEnumerable<IEnumerable<QueueViewModel>> GetQueues(string filter, int maxItems = 100, [EnumeratorCancellation] CancellationToken cancellationToken = default) {     var count = 0;     var pageIndex = 0;     var totalQueueCount = 0;      var info = client.GetQueueRuntimeInfo(maxItems, null, cancellationToken);        await foreach (var page in info)     {         var itemCount = page.Values.Count;         totalQueueCount += page.Values.Count;         var matches = page.Values.Where(v => v.Name.Contains(filter, StringComparison.InvariantCultureIgnoreCase)).ToList();         var matchesCount = matches.Count;         count += matches.Count;          logger.Information(`Page {PageIndex} contains {ItemCount} items, {MatchesCount} matches, continuation token is {ContinuationToken}`, pageIndex++, itemCount, matchesCount, page.ContinuationToken);          yield return matches.Select(runtimeProperties => new QueueViewModel(namespaceContext, new QueueRuntimePropertiesWrapper(runtimeProperties)));          if (count >= maxItems)         {             break;         }     }          logger.Information(`Total queue count that has been evaluated against filter: {TotalQueueCount}`, totalQueueCount); }    Run this multiple times, and see the total item count vary, as well as the page count. Note that all but the last page contain the page size worth of items Environment Installation Source: SDK 8.0.100 Manifest Version:    8.0.0-preview.1.23557.2/8.0.100 Manifest Path:       /usr/local/share/dotnet/sdk-manifests/8.0.100/microsoft.net.sdk.aspire/8.0.0-preview.1.23557.2/WorkloadManifest.json Install Type:        FileBased Host: Version:      8.0.0 Architecture: arm64 Commit:       5535e31a71 .NET SDKs installed: 6.0.400 [/usr/local/share/dotnet/sdk] 6.0.412 [/usr/local/share/dotnet/sdk] 6.0.413 [/usr/local/share/dotnet/sdk] 7.0.304 [/usr/local/share/dotnet/sdk] 7.0.305 [/usr/local/share/dotnet/sdk] 7.0.306 [/usr/local/share/dotnet/sdk] 7.0.307 [/usr/local/share/dotnet/sdk] 8.0.100-rc.1.23463.5 [/usr/local/share/dotnet/sdk] 8.0.100-rc.2.23502.2 [/usr/local/share/dotnet/sdk] 8.0.100 [/usr/local/share/dotnet/sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.8 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.20 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.21 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.7 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.8 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.9 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.10 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.0-rc.2.23480.2 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.8 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.20 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.21 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.7 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.8 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.9 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.10 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.0-rc.2.23479.6 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Other architectures found: x64   [/usr/local/share/dotnet/x64] Environment variables: Not set
Client	Azure.Identity	ManagedIdentityCredential giving back default msi in my service fabric app	Library name and version Azure.Identity Version=`1.10.4` Query/Question I have a service fabric app with an existing user assigned managed identity, and I have added one more. I was able to create those two msi via arm templates without any issues. Now in my code, I am using ManagedIdentityCredential(clientId, options: null) and passing the correct clientId for the new msi but I am getting back the default msi. It looks like it is ignoring clientId altogether. ApplicationManifest.xml - I added this to all the service packages that require it. <Policies>       <IdentityBindingPolicy ServiceIdentityRef=`AssignedIdentity1` ApplicationIdentityRef=`[ManagedIdentityName1]` />       <IdentityBindingPolicy ServiceIdentityRef=`AssignedIdentity2` ApplicationIdentityRef=`[ManagedIdentityName2]` /> </Policies>  In the ApplicationManifext.xml, I also have the Principals section   <Principals>     <ManagedIdentities>       <ManagedIdentity Name=`[ManagedIdentityName1]` />       <ManagedIdentity Name=`[ManagedIdentityName2]` />     </ManagedIdentities>   </Principals>  ServiceManifest.xml for each package     <ManagedIdentities DefaultIdentity=`AssignedIdentity1`>       <ManagedIdentity Name=`AssignedIdentity1` />       <ManagedIdentity Name=`AssignedIdentity2` />     </ManagedIdentities>  It looks like AssignedIdentity1 is always returned by the ManagedIdentityCredential. Any ideas what I might be missing? Environment .NET SDK: Version:   7.0.404
Client	OpenAI	[BUG] OpenAI GPT-4 Vision API should supports string as url	Library name and version Azure.AI.OpenAI 1.0.0-beta.11 Describe the bug Currently Azure.AI.OpenAI 1.0.0-beta.11 supports GPT-4 Vision API, however it's using a Uri as a parameter, this uri supports a internet picture url or data url like this: data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/4Rm4....  If the image data url is too long(> 65535 characters), it will throws a UriFormatException: Invalid URI: The Uri string is too long. Expected behavior We should allow user use a string as a parameter instead of url. Actual behavior If this image data url is too long(> 65535 characters), it will throws a UriFormatException: Invalid URI: The Uri string is too long. Reproduction Steps Find a local image file that > 64KB, create the data url using following code: public class ImageHelper {  private static readonly Dictionary<string, string> MimeTypes = new Dictionary<string, string>  {   { `.bmp`, `image/bmp` },   { `.gif`, `image/gif` },   { `.jpg`, `image/jpeg` },   { `.jpeg`, `image/jpeg` },   { `.png`, `image/png` },   { `.tiff`, `image/tiff` },         // 更多的MIME类型可以在这里添加     };   public static string ReadAsBase64Url(string imagePath)  {   // 检查文件是否存在   if (!File.Exists(imagePath))   {    throw new FileNotFoundException(`Specified image path is not found.`, imagePath);   }    // 获取文件的扩展名，并转换为小写   string extension = Path.GetExtension(imagePath).ToLowerInvariant();    // 根据文件扩展名获取MIME类型   if (!MimeTypes.TryGetValue(extension, out string? mimeType))   {    throw new ArgumentException(`Unsupported image type.`, nameof(imagePath));   }    // 返回数据URI格式的Base64 URL   return $`data:{mimeType};base64,{Convert.ToBase64String(File.ReadAllBytes(imagePath))}`;  } } Then call the Azure OpenAI GPT-4 vision using the data url: OpenAIClient api = new OpenAIClient(new Uri($`https://your-endpoint.openai.azure.com/`), new AzureKeyCredential(`your-api-key`)); var resp = await api.GetChatCompletionsStreamingAsync(new ChatCompletionsOptions(`gpt-4-vision`, new ChatRequestMessage[] {  new ChatRequestSystemMessage(`你是智能AI助理，可以帮用户识别图像，并仔细遵循用户的问题，使用markdown回复。`),  new ChatRequestUserMessage(new ChatMessageContentItem[]  {   new ChatMessageImageContentItem(new Uri(ImageHelper.ReadAsBase64Url(@`C:\Users\ZhouJie\Pictures\car.jpg`))),   new ChatMessageTextContentItem(`这张图里有什么？`),  }) }) {  MaxTokens = 4096 }); await foreach (var delta in resp) {  if (delta.ContentUpdate == null) continue;  Console.Write(delta.ContentUpdate); }  This line of code will causing the issue: new Uri(ImageHelper.ReadAsBase64Url(@`C:\Users\ZhouJie\Pictures\car.jpg`)) Environment .NET 8, LINQPad 8
Client	Schema Registry	[FEATURE REQ] SchemaRegistryClient : Get Schema or SchemaId using GroupName and SchemaName	Library name Microsoft.Azure.Data.SchemaRegistry.ApacheAvro Please describe the feature. Current .Net SDK only supports getting SchemaRegistryClient.GetSchemaPropertiesAsync. Which required the schema definition. Can We expose getting the schema like using the REST API below? https://{EventHubName}.servicebus.windows.net/$schemagroups/{groupName}/schemas/{schemaName}?api-version=2023-07-01  OR how we can extend the features on the SDK user/consumer side rather than changing SDK-related code?
Client	Azure.Core	[QUERY] Is HttpPipeline supported for handwritten/custom requests?	Library name and version Azure.Core 1.35.0 Query/Question I am wondering if HttpPipeline is supported to be used for hand-written scenarios. I want to reuse all of the default policies and flow that SDK clients use for custom requests that the SDK does not support. Because all of the necessary APIs are public and after some brief issue searching, I assume yes, but I also have some worries:  It's currently consumed by all SDK clients and feels like an internal implementation because of that. Will its public API be stable over time?  It's consumed by generated code which could increase the likelihood of breaking changes because altering the output of generated code is easier than migrating manually written code.   There didn't seem to be support for a base URI feature so I added a custom policy to set this on my HttpPipeline, but changes to the implementation regarding the ordering of policies in HttpPipelineBuilder could break this. The generated code explicitly sets a base URI on requests. I didn't see any explicit mention in the places that I looked that this is supported for hand-written scenarios.  Environment No response
Client	Service Bus	Not able to migrate AbandonAsync of Microsoft.Azure.ServiceBus to AbandonMessageAsync of Azure.Messaging.ServiceBus	Library name and version Azure.Messaging.ServiceBus, 7.17.1 Query/Question private async Task AbondonMessagesFromAllQueuesAsync( IMessageReceiver messageReceiver, ConcurrentDictionary<string, T> lockTokenMessageMap) { if (messageReceiver.IsClosedOrClosing) { return; } foreach (KeyValuePair<string, T> lockTokenMessagePair in lockTokenMessageMap) {     try     {         await messageReceiver.AbandonAsync(lockTokenMessagePair.Key);     }     catch (Exception ex)     {         this.logger.LogException(ex, `Lock has expired `);     } }  } I have the above code that I am trying to migrate to Azure.Messaging.ServiceBus, now it has AbandonMessageAsync in place of AbandonAsync that accepts parameter of type ServiceBusReceivedMessage but previously it was being used as a string locktoken, so how can I solve the issue. Environment .Net
Client	Service Bus	[QUERY] disable distributed tracing / Diagnostic-Id in messages	Library name and version Azure.Messaging.ServiceBus latest/7.17.1 Query/Question Hey @JoshLove-msft, I hope it is okay to ask you directly from within this question - but it seems you are the head of knowledge on this topic :) We would like to disable distributed tracing with the Diagnostic-Id in the message properties that causes Activities to have a parent and when it comes to Application Insights to see all those message chains under one operation_id (sorry that I am not able to be more precise in wording - no native speaker) In the code I saw that there is a passage in the summary that says: If tracing is enabled, a diagnostic id will be added to the message properties, which alters the message size. But I can't find any docs describing how to disable the diagnostic id.  We recently switch from custom handling of ServiceBusReceiver to the ServiceBusProcessor and lots f our queries are based on the fact that the operation id is unique upon the processing of a message - which now is not anymore as the operation id might return message chains. I know that it is not ideal on what is supposed to be a logical operation but that application is kind of brownfield. If there is anything else you need, please, let me know. Best, Marcus Environment We are using .NET 8 with Application Insights 2.22 and Azure ServiceBus Messaging 7.17.1
Client	Tables	[BUG] Cannot filter on Timestamp using Azure.Data.Tables	Library name and version Azure.Data.Tables Describe the bug The Azure.Data.Tables package seems to block the ability to filter my queries using the Timestamp property. I am migrating from Microsoft.Azure.Cosmos.Table to Azure.Data.Tables, I need to query my Cosmos DB using the Timestamp in the following way... _tableClient.Query(TableClient.CreateQueryFilter(e => e.Timestamp >= datetimeValue)); However after implementing the Azure.Data.Tables package, I no longer get any results back. I have read this is a known issue and it looks like its been closed for some reason, but its still not resolved https://github.com/Azure/azure-sdk-for-net/issues/32468. Are there any updates on a fix for this? Thanks. Expected behavior My query should be filtered by the Timestamp property and return results from my Cosmos DB which match the condition above. Actual behavior An empty collection is returned. No exception is thrown. There are elements that should satisfy the query and by using the deprecated Cosmos package or Azure Portal I am able to retrieve these expected results back. Reproduction Steps var dateFilter = TableClient.CreateQueryFilter(e => e.Timestamp >= date); Console.WriteLine(_tableClient.Query(dateFilter).Count()); Environment Microsoft.NET.Sdk.Web net8.0 Console App
Mgmt	ARM	[BUG] Change of Api version not being reflected when using SetApiVersion for configurationAssignment in Microsoft.Maintenance	Library name and version Azure.ResourceManager.Maintenance 1.2.0-beta.4 Describe the bug Using SetApiVersion to override version using SDK libraries like so ArmClient Client { get; set; } ArmClientOptions clientOptions = new ArmClientOptions(){Environment = environment }; clientOptions.SetApiVersion(new ResourceType(`Microsoft.Maintenance/configurationAssignments`), `2021-05-01`); Client = new ArmClient(cred, subscriptionId, clientOptions); Using the following code for creating the configuration assignment await resourceGroupResource.CreateOrUpdateConfigurationAssignmentAsync(ProviderName, ResourceType, VMSSResourceName, VMSSConfigurationAssignmentName, data); Getting an exception while making the call which shows that the version was not overridden. The error is expected as the endpoint I'm calling does not support this version.  Further Information Upon debugging I saw that the ApiVersionOverrides property of the ArmClient is being populated correctly The issue is that the ResourceGroupResourceExtensionClient is not initializing the ConfigurationAssignmentsRestClient object with the correct ApiVersion, instead the default constructor is being used default _apiVersion Code: `private ConfigurationAssignmentsRestOperations ConfigurationAssignmentsRestClient => _configurationAssignmentsRestClient ??= new ConfigurationAssignmentsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);`  Reference of the above code ResourceGroupResourceExtensionClient.cs#L49 ConfigurationAssignmentsRestClient is being used to call the CreateOrUpdateAsync of configurationAssignments  Reference of the above code ResourceGroupResourceExtensionClient.cs#L554 The autorest.md file indicates that the code is auto generated so this might not be the right place to look for such errors.  Expected behavior After calling SetApiVersion, The specified version should be sent in the request while making the call to configurationAssignments. Actual behavior The default Api version ('2023-04-01' in this case) is being sent in the request. Reproduction Steps ArmClient Client { get; set; } ArmClientOptions clientOptions = new ArmClientOptions(){Environment = environment }; clientOptions.SetApiVersion(new ResourceType(`Microsoft.Maintenance/configurationAssignments`), `2021-05-01`); Client = new ArmClient(cred, subscriptionId, clientOptions); Using the following code for creating the configuration assignment await resourceGroupResource.CreateOrUpdateConfigurationAssignmentAsync(ProviderName, ResourceType, VMSSResourceName, VMSSConfigurationAssignmentName, data); Environment No response
Client	Search	[BUG] WebApiSkill is still missing the authResourceId property	Library name and version Azure.Search.Documents.Indexes.Models 11.5.1 Describe the bug I have the same problem as i described in #35302 . It actualy never been fixed. The authResourceId Property that is used with a managed identity is not available. I am not able to set the authResourceId when i create a WebApiSkill with the .Net SDK. Expected behavior it should be possible to set the authResourceId Actual behavior cannot set authResourceId Reproduction Steps create a new WebApiSkill() and check for presence of the property Environment No response
Client	Service Bus	Atomicity of sending a message batch to a queue	Hello, It would be helpful to clarify if sending a message batch is atomic or not. If it's possible for only a part of a batch to be sent in case of a failure on the client or server side. Thanks, Aleksey  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: eb6fd36b-5867-fee8-adc4-97034c315899 Version Independent ID: c7bfcaa6-c427-d56f-e154-38d3f3c60d46 Content: ServiceBusSender.SendMessagesAsync Method (Azure.Messaging.ServiceBus) - Azure for .NET Developers Content Source: xml/Azure.Messaging.ServiceBus/ServiceBusSender.xml Service: azure GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Mgmt	ARM	[BUG] TenantResource.GetManagementGroups returns data from other tenant	Library name and version Azure.ResourceManager 1.9.0 Describe the bug When I call GetManagementGroups  to list the management groups of a tenant, it lists management groups from another tenant. Expected behavior It lists management groups from the tenant on which the method is called. Actual behavior Consider the code below var tenantCollection = armClient.GetTenants(); var tenant = await tenantCollection.FirstAsync(t => t.Data.TenantId == Guid.Parse(selectedTenant.Id));  var mgs = tenant.GetManagementGroups(); await foreach (var mg in mgs.GetAllAsync()) {     Console.WriteLine(mg.Data.DisplayName); } were selectedTenant.Id equals `a266655a-245b-4ab8-8d8f-6be387631120` the following happens when I inspect the values in a debug sessions: mg.Data.TenantId 2250FCE3-5BC9-4AE7-A5E9-58C510A422EC _a: 575732963 _b: 23497 _c: 19175 _d: 165 _e: 233 _f: 88 _g: 197 _h: 16 _i: 164 _j: 34 _k: 236 tenant.Data.Id '/tenants/a266655a-245b-4ab8-8d8f-6be387631120' Empty: '' Length: ƒ Length () selectedTenant.Id 'a266655a-245b-4ab8-8d8f-6be387631120' Empty: '' Length: ƒ Length () This clearly indicates that the call to GetManagementGroups of tenant with id a266655a-245b-4ab8-8d8f-6be387631120 lists managementgroups that belong to tenant with id 2250FCE3-5BC9-4AE7-A5E9-58C510A422EC Reproduction Steps var tenantCollection = armClient.GetTenants(); var tenant = await tenantCollection.FirstAsync(t => t.Data.TenantId == Guid.Parse(selectedTenant.Id));  var mgs = tenant.GetManagementGroups(); await foreach (var mg in mgs.GetAllAsync()) {     Console.WriteLine(mg.Data.DisplayName); } Environment  Blazor Webassembly project running on localhost (Windows 11) Visual Studio 2022 17.8.0
Client	OpenAI	[FEATURE REQ] Include OpenAI Assistant api and beta endpoints	Library name Azure.AI.OpenAI 1.0.0-beta.9 Please describe the feature. Hello, Just wondering if you could please include the Beta api endpoints from openAI in this library, if already included can you link me to some documentation or ways of using it. See attached screenshot from openAI documentation This feature is highly used and will be coming out of beta soon hopefully, it would be great to access using this azure sdk for dotnet  Thanks in advance
Mgmt	Compute	Typo `a Azure`→`an Azure`	https://learn.microsoft.com/en-us/dotnet/api/microsoft.azure.management.hybridcompute.models?view=azure-dotnet-legacy&viewFallbackFrom=azure-dotnet-preview  #PingMSFTDocs  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 5b96aa8e-6098-3fa9-4387-abd31bcb44b4 Version Independent ID: 73369e74-c1e0-f2fd-1716-62e313674921 Content: Microsoft.Azure.Management.HybridCompute.Models Namespace - Azure for .NET Developers Content Source: xml/ns-Microsoft.Azure.Management.HybridCompute.Models.xml Service: azure-arc GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Client	Azure.Identity	[BUG] VisualStudioCredential error AADSTS65002 connecting to Azure Monitor	Library name and version Azure.Identity 1.10.4 Describe the bug Using VisualStudioCredential via DefaultAzureCredential to ingest logs into Azure Monitor fails with an error indicating the consent between Visual Studio and Azure Monitor needs to be approved by Microsoft. Other credential types such as Azure CLI or Azure PowerShell work as expected. Expected behavior A user logged in to Visual Studio with an appropriate account should be able to authenticate using VisualStudioCredential Actual behavior The following error is thrown when attempting to obtain a token for Azure Monitor: Process `C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\Asal\TokenService\Microsoft.Asal.TokenService.exe` has failed with unexpected error: TS003: Error, TS004: Unable to get access token.  'WAM Error    Error Code: 3399614466   Error Message: IncorrectConfiguration   WAM Error Message: V2Error: invalid_request AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'e933bd07-d2ee-4f1d-933c-3752b819567b' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API. Trace ID: 5e0a5cc2-ff03-4d7f-8bd5-919f4c239601 Correlation ID: 0d5e9441-0a84-4561-aa66-1fc4d7ded14f Timestamp: 2023-11-28 10:45:43Z   Internal Error Code: 557973643   Possible causes:  - Invalid redirect uri - ensure you have configured the following url in the application registration in Azure Portal: ms-appx-web://microsoft.aad.brokerplugin/04f0c124-f2bc-4f59-8241-bf6df9866bbd  '.  Reproduction Steps Log in to Visual Studio as a user with permissions on an Azure Monitor Data Collection Rule. Log out of Azure CLI, Azure PowerShell and other possible credential sources. Use the following code to attempt to upload a log entry: var client = new LogsIngestionClient(new Uri(Endpoint), new DefautAzureCredential()); var logEntry = new {   Hello = `World` }; await client.UploadAsync(DcrImmutableId, DcrStreamName, RequestContent.Create(BinaryData.FromObjectAsJson(new[] { logEntry }))); Environment Visual Studio 17.8.1 .NET SDK:  Version:           8.0.100  Commit:            57efcf1350  Workload version:  8.0.100-manifests.8d38d0cc  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.100\  .NET workloads installed:  Workload version: 8.0.100-manifests.8d38d0cc There are no installed workloads to display.  Host:   Version:      8.0.0   Architecture: x64   Commit:       5535e31a71  .NET SDKs installed:   8.0.100 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 6.0.25 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Mgmt	Monitor	[FEATURE REQ] It is very difficult to write unit tests, because MonitorLocalizableString, MonitorMetricValue, etc. do not have public constructors	Library name Azure.ResourceManager.Monitor Please describe the feature. Hello, I am trying to upgrade from the Microsoft.Azure.Management.Monitor nuget package to the Azure.ResourceManager.Monitor v1.3. In order to instantiate the following classes, I will need to use reflection, since they only have internal ctors: MonitorLocalizableString, MonitorMetricValue, MonitorTimeSeriesElement, MonitorTimeSeriesElement. Please make ctors public. Thanks!
Client	Monitor - Query	[QUERY] Are KQL injection attacks a possibility via Azure.Monitor.Query?	Library name and version Azure.Monitor.Query Query/Question I'm using Azure.Monitor.Query in a manner where third parties can query our logs against a key (string or GUID) supplied by them via a route value in a web api, and another key from their auth token so they can only query against actions they've done. Now my concern is if they can craft the string key to circumvent those restrictions or the curated projection they get returned? I want to ensure that isn't a possibility. Environment No response
Client	OpenAI	Request for Public Constructors or Factory Methods for DTO Mocking in Azure.AI.OpenAI	Library name Azure.AI.OpenAI Please describe the feature. Issue Description Problem Statement We are currently facing challenges in mocking response DTOs in our testing environment. The primary issue stems from the fact that all DTOs have internal constructors, limiting our ability to instantiate these objects externally for testing purposes. Proposed Solution To address this, I propose two potential solutions:  Make Constructors Public: Altering the access level of the constructors from internal to public would allow external instantiation, facilitating easier mocking of these DTOs. Implement Factory Methods: As an alternative, introducing factory methods for DTO creation could provide a controlled way of instantiating DTOs while preserving encapsulation and internal constructor integrity.  Impact  Testing Efficiency: Implementing either of these changes would significantly streamline our testing process, allowing for more effective and efficient test case creation. Flexibility in Mocking: It would also provide greater flexibility in mocking different scenarios, leading to more robust testing.
Mgmt	ARM	Export an ARM template for a resource	Library name and version Azure.ResourceManager 1.6.0 Query/Question How to export an ARM template for a resource using Azure.ResourceManager.ArmClient. Similar sample example for ARM template deployment provided here seems outdated and uses ResourcesManagementClient which is now not supported[AFAIK]. Please provide sample for Template export using latest lib Environment No response
Client	Azure.Identity	[QUERY] How to make includeInteractiveCredentials faster?	Library name and version Azure.Containers.ContainerRegistry 1.1.0 Query/Question I'm using the 'includeInteractiveCredentials' flag for a commandline app.  However, the first call is incredibly slow.  From what I can discern, it must be timing out looking for credentials elsewhere before finally falling back to interactive.  My question is, how do I skip the first part?  I know it won't find credentials elsewhere......can I set a timeout or something that would speedup the process? var client = new ContainerRegistryClient(     endpoint,      new DefaultAzureCredential(includeInteractiveCredentials: true),      new ContainerRegistryClientOptions     {         Audience = ContainerRegistryAudience.AzureResourceManagerPublicCloud     });  Environment No response
Client	OpenAI	[FEATURE REQ] DALL-E 3 Model ImageGeneration	Library name Azure.AI.OpenAI Please describe the feature. We currently don't have an option to select which model we want to use for ImageGeneration. It seems the default model is still DALL-E 2. The Javascript SDK has implemented the dall-e-3 model ImageGenerations (https://github.com/openai/openai-node/blob/049ce6fa66ebe9a6aa0d64dead1e5fd8c3da1083/tests/api-resources/images.test.ts#L77) but is not available for the Dotnet SDK. Do we have an ETA of when this will be available as many of us would prefer to have images generated on the server side (better validation, access to private data, etc.). Thanks
Client	Event Hubs	[BUG] EventHubBufferedProducerClient EnqueueEventAsync never times out - when the endpoint is invalid.	Library name and version Azure.Messaging.EventHubs 5.9.3 Describe the bug We experience very long hanging processes when we try to enqueue events for EventHub with the Buffered Producer Client It seems to take more than 30 minutes to get a retry for such a simple case as an EventHub endpoint that can't be found. And it seems to be caused by some retry mechanism with exponential  retry mode.     public EventHubBufferedProducerClientOptions()     {         _retryOptions = new EventHubsRetryOptions         {             MaximumRetries = 15,             TryTimeout = TimeSpan.FromMinutes(3),         };     }  Expected behavior Timeout within a minute or something reasonable? Actual behavior Process hangs for more than 30 minutes. Reproduction Steps var connection = MyBadConnectionStringWithInvalidAddress var producerClient = new EventHubBufferedProducerClient(connection); await producerClient.EnqueueEventAsync(new EventData(payload), new EnqueueEventOptions { PartitionKey = `X`});  Environment Dotnet 7
Mgmt	ARM	[QUERY] How to get the cloud information as Azure environment	Library name and version Microsoft.Azure.Management.ResourceManager.Fluent Query/Question Since Microsoft.Azure.Management.ResourceManager.Fluent is deprecated, do we have any alternative method to get the azure cloud information similar as the AzureEnvironment.FromName() ? I know we have auth endpoint defined here. But where could i find the rest? e.g. Name, AuthenticationEndpoint, ResourceManagerEndpoint, ManagementEndpoint, GraphEndpoint,, StorageEndpointSuffix, KeyVaultSuffix Environment No response
Client	KeyVault	[FEATURE REQ] Add support for underscores in Key Vault secret names	Library name Azure.Extensions.AspNetCore.Configuration.Secrets Please describe the feature. I am aware that this will be a limitation with Key Vault itself, and not this package, but I'd appreciate help from the team who manage the package in moving this request to a more appropriate repo - or at the very least telling where I should create it, so that I can link to the final request from this one. Key Vault does not allow underscores in its secret names. This is well documented. However, this limitation makes it much less useful as a storage location for developers, including .NET developers. Often .NET Devs cannot easily migrate from having values stored as configuration items of an Azure App Service to Key Vault because of this limitation. It is common practice for developers to use the underscore character to separate words in the name of a configuration item, and the limitations on Key Vault's secret names means people have to rewrite their code in order to draw configuration from Key Vault instead. Other configuration sources do not suffer from this limitation, so the inconsistency causes some confusion and frustration. That leads to a poor user experience. Sadly, while this limitation is pretty well documented, it will be common for people to find this out only as they try to use KV for the first time - at the point of implementation, not design. This causes rework and lost productivity, or abandoning the use of the service altogether. Is it possible to enhance Key Vault to overcome this limitation?
Client	Search	[QUESTION] NormalizerName property does not exist anymore	Library name and version Azure.Search.Documents v11.5.0 Query/Question In 11.5.0-beta5 we used to have search fields with normalizer names defined as followed [SearchableField(IsFilterable = true, IsSortable = true, NormalizerName = `standard`, AnalyzerName = `custom-text-analyzer`)] After migrating to 11.5.0, it appears the NormalizerName property on SimpleFieldAttribute is simply gone? Yet unless I am missing something, this is not documented as a breaking change Has there been a replacement / change of feature for this? Environment OS: Windows .NET runtime: 7.0.103 Visual Studio 17.4.5 Azure.Search.Documents v11.5.0 vs 11.5.0-beta5
Client	Azure.Identity	[BUG] Sqlconnection created with MSAL access token option is getting object disposed exception with executing connection.OpenAsync	Library name and version Azure.Identity Describe the bug We are currently eliminating the usage of ADAL packages in our cod which resulted in chnaging the access token generation code from ADAL to MSAL to connect to our SQL stores. We have made below changes and used ManagedIdentitiyCredential object to generate the token and assigned it to SqlConection object. Post deployment, we are experience frequent SqlConnection object disposed exception while using Msal token. When code is chnaged back to use Adal token it is working as expected. Note: The issue is very intermittent. We can see some success OpenAsync execution. after 3-4 calls immediately next call goes to error state Code changes:  Error: Exception: System.Data.SqlClient.SqlException (0x80131904): A network-related or instance-specific error occurred while establishing a connection to SQL Server. The server was not found or was not accessible. Verify that the instance name is correct and that SQL Server is configured to allow remote connections. (provider: TCP Provider, error: 35 - An internal exception was caught) ---> System.ObjectDisposedException: Cannot access a disposed object. Object name: 'System.Net.Sockets.Socket'. at System.Net.Sockets.Socket.ThrowObjectDisposedException() at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue) at System.Data.SqlClient.SNI.SNITCPHandle..ctor(String serverName, Int32 port, Int64 timerExpire, Object callbackObject, Boolean parallel) at System.Data.ProviderBase.DbConnectionPool.CheckPoolBlockingPeriod(Exception e) at System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection) at System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection) at System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection) at System.Data.ProviderBase.DbConnectionPool.WaitForPendingOpen() --- End of stack trace from previous location --- at Microsoft.Commerce.Billing.Storage.SqlCommandExecutor`1.Execute(CancellationToken cancellationToken, EventTraceActivity traceId) in C:__w\1\s\private\Billing\shared\Common.Storage.Core\V1\SqlCommandExecutor.cs:line 187 Expected behavior SqlConnection should not error out at connection.OpenAsync() and should work how it works while using Adal access token. Actual behavior SqlConnection object OpenAsync is timeodout failing with exception mentioned in description. Reproduction Steps using (SqlConnection connection = new SqlConnection(this.connectionString)) { connectionStopWatch.Restart(); string aksManagedIdentityClientId = ServiceConfigurations.AKSManagedIdentityClientId; // Get Access token for SQLMI using AKS Managed identity if MSI ClientId(AppId) is not empty if (!string.IsNullOrEmpty(aksManagedIdentityClientId)) { var tokenProvider = new ManagedIdentityCredential(aksManagedIdentityClientId); connection.AccessToken = tokenProvider.GetTokenAsync(new TokenRequestContext(new[]{ azureResourceSQLMI })).Result.Token; } await connection.OpenAsync(cancellationToken); connectionStopWatch.Stop(); Environment .NET, Azure.Identity - 1.10.3, System.Data.SqlClient - 4.6.1.5
Client	Service Bus	[QUERY] Losing messages when receiving messages in ReceiveAndDelete mode	Library name and version Azure.Messaging.ServiceBus 7.16.2 Query/Question Messages are lost when I try receiving a few hundred from a topics subscription whilst using ReceiveAndDelete mode. In my example I add 500 messages to a topic and try to receive up to a maximum of 500 messages. What I observe is that all 500 messages are removed from the subscription but only a few are returned to me, usually 30-100 messages. Below is a simple console app that replicates the issue using Azure.Messaging.ServiceBus; using Azure.Messaging.ServiceBus.Administration;  // settings const string serviceBusConnectionString = `ADD-CONNECTION-STRING`; const string topicName = `example-topic`; const string subscriptionName = `example-subscription`; const int numberOfMessages = 500;  Console.WriteLine(`Beginning...`); var startTime = DateTime.UtcNow;  // Create admin client, topic and subscription var adminClient = new ServiceBusAdministrationClient(serviceBusConnectionString);  try {     Console.WriteLine(`Deleting topic and subscription...`);     await adminClient.DeleteSubscriptionAsync(topicName, subscriptionName);     await adminClient.DeleteTopicAsync(topicName);     Console.WriteLine(`Deleted topic and subscription`); } catch (Exception) {     // ignored }  var topicProperties = await adminClient.CreateTopicAsync(topicName); var subscriptionProperties = await adminClient.CreateSubscriptionAsync(topicName, subscriptionName);  // Create client var serviceBusClient = new ServiceBusClient(serviceBusConnectionString);  // Add messages to topic var sender = serviceBusClient.CreateSender(topicProperties.Value.Name);  using var messageBatch = await sender.CreateMessageBatchAsync();  foreach (var i in Enumerable.Range(0, numberOfMessages)) {     var message = new ServiceBusMessage($`Message {i}`);     messageBatch.TryAddMessage(message); }  Console.WriteLine($`Sending {messageBatch.Count} messages...`); await sender.SendMessagesAsync(messageBatch); Console.WriteLine(`Sent messages`);  // Read messages from subscription await using var receiver = serviceBusClient.CreateReceiver(     topicProperties.Value.Name,     subscriptionProperties.Value.SubscriptionName,     new ServiceBusReceiverOptions { ReceiveMode = ServiceBusReceiveMode.ReceiveAndDelete, PrefetchCount = 0 } );  var messages = await receiver.ReceiveMessagesAsync(numberOfMessages, TimeSpan.FromSeconds(3));  Console.WriteLine($`Received {messages.Count} messages`);  // Work out how many messages are lost var subscriptionRuntimeProperties = await adminClient.GetSubscriptionRuntimePropertiesAsync(topicProperties.Value.Name, subscriptionProperties.Value.SubscriptionName); var remainingMessages = subscriptionRuntimeProperties.Value.ActiveMessageCount; Console.WriteLine($`Messages remaining on the subscription: {remainingMessages}`); var numberOfLostMessages = numberOfMessages - (remainingMessages + messages.Count); Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine($`{numberOfLostMessages} messages lost to the ether`); Console.ResetColor();  var endTime = DateTime.UtcNow; var totalRunInSeconds = (endTime - startTime).TotalSeconds; Console.WriteLine($`Finished in {totalRunInSeconds}`);  A typical output will look like this: Beginning... Deleting topic and subscription... Deleted topic and subscription Sending 500 messages... Sent messages Received 104 messages Messages remaining on the subscription: 0 396 messages lost to the ether Finished in 2.876073  Is what I'm experiencing expected behaviour? For anyone else experiencing this our solution was: Looping await receiver.ReceiveMessagesAsync(..) until either a set time has passed or we receive all 500 messages in peek lock mode instead. We then complete them manually. Environment No response
Client	OpenAI	[FEATURE REQ] Support OpenAI GPT-4 Vision API	Library name Azure.AI.OpenAI Please describe the feature. Saw that 1.0.0-beta.9 just dropped, and was looking for support for GPT-4 Vision. I searched issues, and don't see anything else tracking this. Do you expect to support the new 'content' syntax for providing image URLs to the model? ChatMessage only takes a string for Content right now, it appears. https://platform.openai.com/docs/guides/vision For example: curl https://api.openai.com/v1/chat/completions   -H `Content-Type: application/json`   -H `Authorization: Bearer $OPENAI_API_KEY`   -d '{     `model`: `gpt-4-vision-preview`,     `messages`: [       {         `role`: `user`,         `content`: [           {             `type`: `text`,             `text`: `What’s in this image?`           },           {             `type`: `image_url`,             `image_url`: {               `url`: `https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg`             }           }         ]       }     ],     `max_tokens`: 300   }'
Client	Extensions	[BUG] : Azure.Extensions.AspNetCore.Configuration.Secrets have incorrect dependencies	Library name and version Azure.Extensions.AspNetCore.Configuration.Secrets Describe the bug Azure.Extensions.AspNetCore.Configuration.Secrets (1.2.2) have dependency on Azure.Core >= 1.24.0 and Azure.Security.KeyVault.Secrets >= 4.2.0. Azure.Security.KeyVault.Secrets (4.2.0) have dependency on Azure.Core >= 1.15.0. This is causing issues in using the package. Please upgrade Azure.Security.KeyVault.Secrets package in Azure.Extensions.AspNetCore.Configuration.Secrets to the correct version. Expected behavior Azure.Extensions.AspNetCore.Configuration.Secrets should have latest dependency of Azure.Security.KeyVaults.Secrets which should be compatible with Azure.Identity. Actual behavior Azure.Extensions.AspNetCore.Configuration.Secrets have old dependency of Azure.Security.KeyVaults.Secrets (4.2.0) which is incompatible with other packages. Reproduction Steps Any azure function with Azure.Extensions.AspNetCore.Configuration.Secrets 1.2.2 and Azure.Identity 1.10.2 and calling AddAzureKeyVault from the IConfigurationbuilder will result in (loading the dependency) failure. Environment .Net Framework 4.6.1
Client	Search	[BUG] Semantic Search QueryLanguage Parameter Not Affecting Results for Multilingual Content	Library name and version Azure.Search.Documents v11.5.0-beta.5 Describe the bug Issue Description: When performing semantic search on an Azure Cognitive Search index with content in both English and German, the queryLanguage parameter does not appear to influence the search results. This results in identical results being returned for different queryLanguage settings, despite the content being in distinct languages. Expected behavior The queryLanguage parameter should influence the semantic search results, ensuring that queries in distinct languages return language-appropriate results. In this case, German and English queries should yield different results based on the language of the content. Actual behavior The queryLanguage parameter does not appear to affect the semantic search results, resulting in identical outcomes regardless of the specified queryLanguage. Reproduction Steps   Create an Azure Cognitive Search index that stores data in both English and German.   Populate the index with relevant documents, ensuring that the content is correctly tagged with the language metadata.   Perform two semantic search queries with different queryLanguage settings: Query 1: {   `count`: true,   `search`: `auto`,   `queryType`: `semantic`,   `queryLanguage`: `de-de`,   `semanticConfiguration`: `default` } Query 2: {   `count`: true,   `search`: `auto`,   `queryType`: `semantic`,   `queryLanguage`: `en-us`,   `semanticConfiguration`: `default`,   `select`: `id, chunk_id, content` }   Observe that both queries return identical results, despite specifying different queryLanguage values.   Environment .NET SDK: Version:   7.0.402 Commit:    791db8e2d8 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64
Mgmt	SQL	[QUERY] ArmSqlModelFactory class missing in latest Azure.ResourceManager.Sql 1.2.0 package	Library name and version Azure.ResourceManager.Sql 1.2.0 Query/Question I am trying to mock some of the Azure.ResourceManager.Sql models. I know that the pattern for the azure-sdk-for-net libraries is to use a model factory for mocking. However, the ArmSqlModelFactory that is supposed to allow that functionality is missing in the Azure.ResourceManager.Sql 1.2.0 package. Is there something I'm missing? Is there another way to mock these Sql models? Environment .NET6
Client	Service Bus	Does this also apply to the latest version or there might be some changes like support bacth messages Microsoft.Azure.WebJobs.Extensions.ServiceBus v5.13.3	[Enter feedback here]  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: a0203fd1-e905-1db5-8ec1-4a0a00d0ca4e Version Independent ID: 458d6304-e240-a5e9-d7cb-45573a279062 Content: ServiceBusOptions.MaxConcurrentSessions Property (Microsoft.Azure.WebJobs.ServiceBus) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.WebJobs.ServiceBus/ServiceBusOptions.xml Service: azure-functions GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Client	Search	[BUG] Exception when deserializing Azure.Search.Documents.SearchOptions	Library name and version Azure.Search.Documents 11.1.1 Describe the bug The bug occurs since the 24th of October. It only happens sporadically but consistently since then. Stacktrace: System.InvalidOperationException: The requested operation requires an element of type 'Number', but the target element has type 'Null'.    at System.Text.Json.JsonDocument.TryGetValue(Int32 index, Int32& value)    at System.Text.Json.JsonElement.GetInt32()    at Azure.Search.Documents.SearchOptions.DeserializeSearchOptions(JsonElement element)    at Azure.Search.Documents.Models.SearchResults`1.DeserializeAsync(Stream json, ObjectSerializer serializer, Boolean async, CancellationToken cancellationToken)    at Azure.Search.Documents.SearchClient.SearchInternal[T](SearchOptions options, String operationName, Boolean async, CancellationToken cancellationToken)  As the stacktrace indicates there is a problem deserializing the SearchOptions. I have looked into it and the only properties which are trying to be deserialized as Number (GetInt32) are skip and top. Expected behavior No exceptions should be thrown. Actual behavior See description... Reproduction Steps See description... Environment  Azure hosted App Service using a Docker container based on mcr.microsoft.com/dotnet/aspnet:6.0
Client	Event Hubs	[BUG] StaticPartitionProcessor in the sample is consuming high CPU due to ClaimOwnershipAsync	Library name and version Azure.Messaging.EventHubs 5.9.3 Describe the bug The sample https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/eventhub/Azure.Messaging.EventHubs/samples/Sample08_CustomEventProcessor.md#building-a-custom-processor-with-pluggablecheckpointstoreeventprocessortpartition for StaticPartitionProcessor causes high CPU utilization (e.g. for a pod in AKS, instead of single-digit millicores consumes 100+ millicores). The culprit seems to be protected override Task<IEnumerable<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(         IEnumerable<EventProcessorPartitionOwnership> desiredOwnership,         CancellationToken cancellationToken) =>              Task.FromResult(desiredOwnership.Select(ownership =>             {                 ownership.LastModifiedTime = DateTimeOffset.UtcNow;                 return ownership;             }));  If commented out or defaulted to the base implementation there is no high CPU utilization. Expected behavior No high CPU utilization Actual behavior High CPU utilization Reproduction Steps Use the StaticPartitionProcessor in a client application ... Environment No response
Mgmt	Recovery Services Backup	[BUG] BackupProtectedItemResource.Get throws ArgumentException	Library name and version Azure.ResourceManager.RecoveryServicesBackup 1.1.0 Describe the bug I cannot get a backup protected item. I always get ArgumentException. No matter if I try to use the method: BackupProtectedItemCollection.Get() or if I try to use BackupProtectedItemResource.Get(). I also wonder why I cannot do: BackupProtectedItemCollection.ToList(), other classes that represent a collection of 'Azure.ResourceManager' allows to do so.  Expected behavior Response should be a result of type: Response. Actual behavior Trying to get BackupProtectedItemResource always returns ArgumentException Reproduction Steps using Azure.Identity; using Azure.ResourceManager; using Azure.ResourceManager.RecoveryServicesBackup; using System; // get your azure access token, for more details of how Azure SDK get your access token, please refer to https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication?tabs=command-line TokenCredential cred = new DefaultAzureCredential(); // authenticate your client ArmClient client = new ArmClient(cred); //this example assumes that the backup protected item exists in Azure. string subscriptionId = `00000000-0000-0000-0000-000000000000`; string vaultName = `test-rsvault`; string vaultResourceGroup = `test-infra-rg`; string vmName = `test`; string vmResourceGroup = `test-GROUP`; string containerName = $`IaasVMContainer;iaasvmcontainerv2;{vmResourceGroup};{vmName}`; string protectedItemName = $`VM;iaasvmcontainerv2;{vmResourceGroup};{vmName}`; string fabricName = `Azure`; //=================================================================================== // Try to get the BackupProtectedItem from BackupProtectedItemCollection //=================================================================================== var backupProtectectionContainerResourceId = BackupProtectionContainerResource.CreateResourceIdentifier(subscriptionId, vaultResourceGroup, vaultName, fabricName, containerName); var backupProtectectionContainerResource = client.GetBackupProtectionContainerResource(backupProtectectionContainerResourceId); var backupProtectedItem_fromCollection = backupProtectectionContainerResource.GetBackupProtectedItems().Get(protectedItemName); //This call throws exception //=================================================================================== // Try to get the BackupProtectedItem from BackupProtectedItemResource //=================================================================================== var backupProtectedItemResourceId = BackupProtectedItemResource.CreateResourceIdentifier(subscriptionId, vaultResourceGroup, vaultName, fabricName, containerName, protectedItemName); var backupProtectedItemResource = client.GetBackupProtectedItemResource(backupProtectedItemResourceId); var backupProtectedItem = backupProtectedItemResource.Get(); //This call throws exception Environment Microsoft Visual Studio Enterprise 2019 Version 16.11.19
Client	Tables	How to update the connection string in TableServiceClient	Library name and version Azure.Data.Tables 12.8.1 Query/Question I am using this code TableServiceClient serviceClient = new TableServiceClient(`ConnectionString`); How can I update the connection string after the TableServiceClient creation? Environment No response
Mgmt	Search	[BUG] SearchServiceCollection.CreateOrUpdateAsync throws ObjectDisposedException	Library name and version Azure.ResourceManager.Search_1.2.0-beta.1 Describe the bug SearchServiceCollection.CreateOrUpdateAsync throws ObjectDisposedException. The service gets created regardless of the exception. Problem occurs both for WaitUntil.Started and WaitUntil.Completed. Expected behavior No exception should be thrown when successfully creating or updating a search service. Actual behavior An exception is thrown when attempting to create a search service. The service gets created regardless of the exception. Reproduction Steps var client = new ArmClient(new DefaultAzureCredential()); var subscriptions = client.GetSubscriptions(); var subscription = await subscriptions.GetAsync(_configuration.SubscriptionId); var resourceGroup = await subscription.Value.GetResourceGroupAsync(_configuration.ResourceGroupName); var searchServiceCollection = resourceGroup.Value.GetSearchServices();  // exception is thrown for both WaitUntil.Started and WaitUntil.Completed await searchServiceCollection.CreateOrUpdateAsync(WaitUntil.Started, @params.NewServiceName, new(AzureLocation.UKSouth) {    SkuName = SearchSkuName.Basic,    ReplicaCount = 1,    PartitionCount = 1,    HostingMode = SearchServiceHostingMode.Default,    PublicNetworkAccess = SearchServicePublicNetworkAccess.Enabled }); Environment MacOS, .NET 7.0.100 Rider
Mgmt	ARM	no help at all for filter types	need some explanation about filter types  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 42a20203-9bd1-4c28-0ac1-d2b1214902e9 Version Independent ID: 7e18fdc7-503c-6a13-72e8-fea167f7882a Content: ResourceGroupResource.GetGenericResources Method (Azure.ResourceManager.Resources) - Azure for .NET Developers Content Source: xml/Azure.ResourceManager.Resources/ResourceGroupResource.xml Service: azure GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Mgmt	Event Grid	[QUERY] How can I gather all eventsubscriptions attached to a storage account?	Library name and version Azure.ResourceManager.EventGrid 1.0.1 Query/Question Hi! I am wanting to get all eventsubscriptions that are attached to a storage account, how can i go about doing this? Here is a picture in the UI, which shows what I want to get.  I want the line at the very bottom that I covered in red Environment No response
Client	Azure.Core	[FEATURE REQ] Public ConnectionString Types and Validation	Library name Azure.Core Please describe the feature. Types such Azure.Core.ConnectionString or Azure.Data.Tables.TableConnectionString etc. are internal. To validate application configuration it would be helpful if we could parse connection strings beforehand instead of having to handle runtime failures when using them. If these connection string types would be accepted in the client constructors, it would also make for a more type safe API. Maybe it could be an extensions of the .NET Azure SDK Design Guidelines to always make non-primitive configuration types public if they are available – similar to ClientOptions.
Client	KeyVault	[QUERY]Disable SSL verification in azure keyvault .net sdk	Library name and version Azure.Security.KeyVault.Secrets Query/Question Hey folks I'm new to Azure keyvault and would like some help on some auth issue when testing azure keyvault .NET sdk v4 locally in a unit test. The SecretClient is constructed as below: var secretClient = new SecretClient(vaultUri: new Uri(vaultUri), credential: new DefaultAzureCredential()); And a WebHostBuilder to use as the test host. However, it returns an error as below: Bearer token authentication is not permitted for non TLS protected (https) endpoints. at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.d__11.MoveNext() at Azure.Core.Pipeline.RedirectPolicy.d__7.MoveNext() at Azure.Core.Pipeline.RetryPolicy.d__5.MoveNext() at Azure.Core.Pipeline.RetryPolicy.d__5.MoveNext() at Azure.Core.Pipeline.HttpPipeline.d__18.MoveNext() at System.Threading.Tasks.ValueTask 1.get_Result() at Azure.Security.KeyVault.KeyVaultPipeline.d__29.MoveNext() at Azure.Security.KeyVault.KeyVaultPipeline.d__21.MoveNext() at Azure.Security.KeyVault.Secrets.SecretClient.d__8.MoveNext() at MyProject.KeyVaultDataProvider.d__11.MoveNext() Looks like it's required to use https. I'm wondering if there is any method to bypass this verification? Environment windows .net 7.0
Client	Cognitive - Form Recognizer	[BUG] Table Fields for Neural/Template models are not returned correctly DocumentAnalysisClient.AnalyzeDocument (including other versions of this method)	Library name and version Azure.AI.FormRecognizer 4.1.0 Describe the bug When calling the Document Intelligence SDK DocumentAnalysisClient.AnalyzeDocument or any of it's variants e.g. async or from url, I get a different response than if I call the rest api directly.  The first response with the white background is what I get back from the rest api.  The second response in black is what I get back via the SDK.  In short Table Fields don't appear to be returning correctly via the SDK. Expected behavior TableFields should contain appropriate data not just the Table Field Name e.g.  Actual behavior Table Fields are returned with only the Table Field Names and empty values e.g.  Reproduction Steps   In Azure, Create a custom extraction model based in West Europe   define a model with a table field    train model   Call model as per the below AnalyzeDocumentOperation operation = await azureClient.AnalyzeDocumentAsync(WaitUntil.Completed, `10DocNeural`, fs); AnalyzeResult result = operation.Value;   Inspect `Fields` element.   Environment .NET SDK: Version:   7.0.400 Commit:    73bf45718d Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.400\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4 .NET SDKs installed: 7.0.400 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 7.0.10 C:\Program Files\dotnet\shared[Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.11 C:\Program Files\dotnet\shared[Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.10 C:\Program Files\dotnet\shared[Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.11 C:\Program Files\dotnet\shared[Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.10 C:\Program Files\dotnet\shared[Microsoft.WindowsDesktop.App] IDE = Visual Studio Code Project   Exe net7.0 enable enable
Client	Extensions	[BUG] Internal Error with AsPages Method not found Exception	Library name and version Azure.Security.KeyVault.Secrets 4.5.0.0 Azure.Extensions.AspNetCore.Configuration.Secrets 1.2.2 Describe the bug our team moved from connecting directly to Azure Key Vault to use the nuget package Azure.Extensions.AspNetCore.Configuration.Secrets and use the AddAzureKeyVault(URI, AzureCredential) method. when we did that the app threw the following exception: Method 'AsPages' in type 'FuncAsyncPageable`1' from assembly 'Azure.Security.KeyVault.Secrets, Version=4.5.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8' does not have an implementation. attempts to reduce Azure.Security.KeyVault.Secrets to 4.3 and 4.2 did not help. we also found this error in another open issue without solution: Azure/azure-functions-host#9127 Expected behavior the expected beheviour it that we will manage to connect Actual behavior internal exception is thrown Reproduction Steps remove all non microsoft related nuget packages - yet still the issue reproduces it has not reproduced on other services Environment .net 6 (migration from .net 4.6.2)
Client	KeyVault	[BUG] Key Vault adding escape characters on secret values.	Library name and version Azure.Security.KeyVault.Secrets 4.5.0 Describe the bug Key Vault secret value of Pass\Word comes out as Pass\\Word    Expected behavior Key Vault secret value of Pass\Word should not have escape character when read from configuration. Reproduction Steps Please see attached screenshots. Environment .Net 7 Azure.Security.KeyVault.Secrets 4.5.0
Client	Search	Adding Dimension and Configuration to SearchIndex in Azure.Search.Documents	Library name and version Azure.Search.Documents 11.5.0-bet Query/Question When I try to create SearchIndex I use this:              try             {                 SearchIndex? searchIndex = null;                 try                 {                     searchIndex = await mSearchIndexClient.GetIndexAsync(mIndexName);                 }                 catch (RequestFailedException ex) when (ex.Status == 404)                 {                     Log.Verbose(ex);                     // If the specified index not exist, 404 is thrown.                      string vectorProfileFilePath = Path.Combine(InstallDir, mVectorProfileFileName);                     string jsonStr = File.ReadAllText(vectorProfileFilePath);                           VectorSearch? vectorSearch = new()                         {                             Profiles =                             {                                 new VectorSearchProfile(`my-default-vector-profile`, `my-hnsw-config-2`)                             },                             Algorithms =                             {                                 new HnswVectorSearchAlgorithmConfiguration(`my-hnsw-config-2`)                             }                         };                          **searchIndex = new SearchIndex(mIndexName)**                         {                             Fields = new FieldBuilder().Build(typeof(SegmentObj)),                                                          // Only available starting 2023-10-01 beta version                             VectorSearch = vectorSearch                         };                     }                      searchIndex = await mSearchIndexClient.CreateIndexAsync(searchIndex);                 }                 catch (Exception ex)                 {                     Log.Verbose(ex);                     return;                 } At the line searchIndex = new SearchIndex(mIndexName) the exception is thrown as shown below, however, I cannot find the way to add 'dimentions' and 'vectorSearchConfiguration' to SegmentTextVector field despite I browsed many of your samples and documentation. So how do I do it? This field is defined as:           [SearchableField(IsFilterable = false, IsSortable = true)]           public IReadOnlyList<float>? SegmentTextVector { get; set; } Exception thrown: Azure.RequestFailedException: 'The request is invalid. Details: definition : The vector field 'SegmentTextVector' must have the properties 'dimensions' and 'vectorSearchConfiguration' set. Status: 400 (Bad Request) ErrorCode: InvalidRequestParameter  Content: {`error`:{`code`:`InvalidRequestParameter`,`message`:`The request is invalid. Details: definition : The vector field 'SegmentTextVector' must have the properties 'dimensions' and 'vectorSearchConfiguration' set.`,`details`:[{`code`:`InvalidField`,`message`:`The vector field 'SegmentTextVector' must have the properties 'dimensions' and 'vectorSearchConfiguration' set. Parameters: definition`}]}} Headers: Cache-Control: no-cache Pragma: no-cache client-request-id: 3340b211-e406-4662-afcc-766c94da724a x-ms-client-request-id: 3340b211-e406-4662-afcc-766c94da724a request-id: 3340b211-e406-4662-afcc-766c94da724a elapsed-time: 123 Preference-Applied: REDACTED Strict-Transport-Security: REDACTED Date: Fri, 20 Oct 2023 05:10:16 GMT Content-Type: application/json; charset=utf-8 Content-Language: REDACTED Expires: -1 Content-Length: 397  Environment Win11, .NET 7, VS2022
Mgmt	Cosmos	Azure.ResourceManager.CosmosDB lacking useful examples	There is absolutely no indication how to do anything with this library.  How do I, say, create a container?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: cfe45b72-4171-565a-d259-d15368cb1657 Version Independent ID: eccb7522-fc38-7198-5a2e-c34d44b82ed5 Content: Microsoft Azure Cosmos DB management client library for .NET - Azure for .NET Developers Content Source: api/overview/azure/latest/resourcemanager.cosmosdb-readme.md Service: cosmosdb GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Client	Search	Missing attributes or no NuGet package	Library name and version Azure.Search.Documents Describe the bug I am using 11.4.0 and the attributes VectorSearchDimensions and VectorSearchProfile of the SearchFiled are missing. This is the latest NuGet package! Expected behavior Either provide the appropriate NuGet package or add the attributes. Actual behavior Unable to build Reproduction Steps Unable to build:        /// <summary> /// Embeddings Vector (array of floats) /// </summary> [SearchField(SearchField.VectorSearchDimensions = `1536`, SearchField.VectorSearchProfile = `my-vector-profile`)] public IReadOnlyList<float>? TextVector { get; set; } public IReadOnlyList<float>? SourceVector { get; set; } Environment No response
Client	Extensions	[FEATURE REQ] Add extension method to validate a secret name	Library name Azure.Extensions.AspNetCore.Configuration.Secrets Please describe the feature. As far as I know, there is currently no extension method to check if a secret name is valid. Often, I now create an extension method to check if the secret is valid. Is it an idea to add this to this package to make it easy to verify secret names? public static bool IsValidSecretName(this string secretName) {     const string pattern = @`^[a-zA-Z0-9\-]+$`;      return Regex.IsMatch(secretName, pattern); }
Mgmt	Network	[BUG] NetworkSecurityGroup DesintationPortRange cannot support multiple ports anymore	Library name and version Azure.ResourceManager.Network 1.5.0 Describe the bug It used to be that with Fluent, you could specify multiple ports to allow as the `ToPortRanges()` method in an NSG: nsg.Update()     .DefineRule(TestConstants.RuleName)         .AllowInbound()         .FromAnyAddress()         .FromAnyPort()         .ToAnyAddress()         .ToPortRanges(new string[] { TestConstants.ServiceFabricClientPort.ToString(), TestConstants.ServiceFabricWebPort.ToString(), TestConstants.DNCPort.ToString(), TestConstants.CNSPort.ToString(), EnvironmentVariables[TestConstants.CustomerPortEnvVarName] })         .WithProtocol(SecurityRuleProtocol.Tcp)         .WithDescription(TestConstants.RuleDescription)         .WithPriority(TestConstants.RulePriority)         .Attach()     .Apply();  Now however, this is not possible with ArmClient: SecurityRuleData newRule = new SecurityRuleData(); newRule.Name = TestConstants.RuleName; newRule.Description = TestConstants.RuleDescription; newRule.Access = SecurityRuleAccess.Allow; newRule.Direction = SecurityRuleDirection.Inbound; newRule.SourceAddressPrefix = `*`; newRule.SourcePortRange = `*`; newRule.DestinationAddressPrefix = `*`; newRule.DestinationPortRange = TestConstants.ServiceFabricClientPort.ToString() + `,` + TestConstants.ServiceFabricWebPort.ToString() + `,` + TestConstants.DNCPort.ToString() + `,` + TestConstants.CNSPort.ToString() + `,` + EnvironmentVariables[TestConstants.CustomerPortEnvVarName]; newRule.Protocol = SecurityRuleProtocol.Tcp;  This now throws an error: resourceGroup.GetNetworkSecurityGroups().CreateOrUpdate(WaitUntil.Completed, nsgResourceID.Name, nsg.Data);  Azure.RequestFailedException: 'Security rule has invalid Port range. Value provided: 19000,19080,9001,10090,8081. Value should be an integer OR integer range with '-' delimiter. Valid range 0-65535. Status: 400 (Bad Request) ErrorCode: SecurityRuleInvalidPortRange  Unless I am missing something on how to allow multiple, specified ports, I think this is a regression from Fluent to ArmClient Expected behavior Would like to be able to set multiple specific ports on an NSG rule using ArmClient Actual behavior Error saying: `Azure.RequestFailedException: 'Security rule has invalid Port range. Value provided: 19000,19080,9001,10090,8081. Value should be an integer OR integer range with '-' delimiter. Valid range 0-65535. Status: 400 (Bad Request) ErrorCode: SecurityRuleInvalidPortRange` Reproduction Steps See description Environment No response
Client	Functions	The request is invalid. Details: An unexpected 'StartObject' node was found for property named 'JobID' when reading from the JSON reader. A 'PrimitiveValue' node was expected.	Library name and version Azure.Search 3.0.5 Describe the bug Hi, I am getting `The request is invalid. Details: An unexpected 'StartObject' node was found for property named 'JobID' when reading from the JSON reader. A 'PrimitiveValue' node was expected.` error when trying to call the SearchIndexClient.Documents.Index(...) method. I'm getting this error because my type is not serialized correctly, but this problem only occurs when I run the code in an Azure Function. JobID is an int wrapper, one of the properties of the type that I pass as a parameter to the Index method. I have overridden JsonConverter for this type and everything works fine when I call SearchIndexClient.Documents.Index(...) in any application except the Azure function. Do you happen to know why the same code doesn't work in azure function? P.S. I am not sure if it is the right place for this issue, please let me know if it is not. Expected behavior SearchIndexClient.Documents.Index(...) method sends a batch of upload, merge, and/or delete actions to the Azure Search index. Actual behavior `The request is invalid. Details: An unexpected 'StartObject' node was found for property named 'JobID' when reading from the JSON reader. A 'PrimitiveValue' node was expected.` error occures Reproduction Steps  Create an int/string wrapper with JsonConverter attribute to make it serialize correctly Create a new type with an int/string wrapper property Call the SearchIndexClient.Documents.Index() passing an array of the object with type from previous step.  Environment .NET Framework and Azure Function V1
Client	OpenAI	[FEATURE REQ] Able to change the endpoint of openai	Library name Azure.AI.OpenAI Please describe the feature. microsoft/semantic-kernel#3159 Instead of forcing the use of official endpoints, maybe change the endpoint
Mgmt	Network - CDN	There is not a sample to show how to use CdnEndpointCollection.GetAllAsync	I read the document below, but there are no samples to show how to use these methods.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: bfb9ec09-0a5c-c96f-6fb6-949431f8c738 Version Independent ID: 18e7c844-5e02-aef0-17a1-53d1152f1cda Content: CdnEndpointCollection.GetAllAsync(CancellationToken) Method (Azure.ResourceManager.Cdn) - Azure for .NET Developers Content Source: xml/Azure.ResourceManager.Cdn/CdnEndpointCollection.xml Service: azure GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Client	Event Hubs	[BUG] EventHubTrigger on EventData[] processing same event multiple times	Library name and version Microsoft.Azure.WebJobs.Extensions.EventHubs 5.3.0 Describe the bug Single message being handled many times over, like the Checkpoints aren't being saved after processing a batch of messages. Older image of an instance of this occurring, but continues to be a problem. Sometimes (as seen here) it's the exact same batch being handled over again.  Expected behavior After a batch is handled, checkpoint is written, and that batch is not handled again. Actual behavior Batches being handled multiple times, or a single message making it into many unique batches. Reproduction Steps  Create function with EventHubTrigger for EventData[] for processing batches that logs message id's host.json: `eventHubs`: { `maxEventBatchSize`: 200, `minEventBatchSize`: 50, `maxWaitTime`: `00:02:00` } Send chunk of messages (>1k or so) See logs for messages handled multiple times  Environment Azure Windows Function App version: 4.1.3 Consumer Function App plan Region: West US 2 .NET 6
Service	KeyVault	Recovery of deleted certificates and deleted secrets are too slow in some cases.	Library name and version Azure.Security.KeyVault.Certificates(4.5.1.0) Query/Question Hi, As part of our application code, we are trying to recover soft-deleted certificates before importing certificate with the same name. We observed that the recovery operation is quick for a couple of instances while it takes longer than expected in some cases. What does this recovery operation actually do, does it recover all versions of soft-deleted certificates or only the latest version? Here is the code snippet for certificate recovery. var recoverOperation = await _certClient.StartRecoverDeletedCertificateAsync(certificateName).ConfigureAwait(false); return await recoverOperation.WaitForCompletionAsync().ConfigureAwait(false); The same we have observed while recovering secrets. Here is the code snippet for secret recovery. var recoverOperation = await _secretClient.StartRecoverDeletedSecretAsync(secretName).ConfigureAwait(false);                   return await recoverOperation.WaitForCompletionAsync().ConfigureAwait(false); Environment  Hosting platform: Azure AKS Runtime: .net 7
Client	Azure.Identity	[BUG] VisualStudioCredential fails with AADSTS65002 when accessing Application Insights	Library name and version Azure.Identity 1.10.1 Describe the bug I am trying to get a token for Application Insights using DefaultAzureCredential.  The code setup is like this var credential = new DefaultAzureCredential(new DefaultAzureCredentialOptions {      ExcludeEnvironmentCredential = true,      ExcludeManagedIdentityCredential = true,      ExcludeSharedTokenCacheCredential = true,     ExcludeAzureDeveloperCliCredential = true,     ExcludeAzurePowerShellCredential = true,     ExcludeInteractiveBrowserCredential = true,     ExcludeVisualStudioCodeCredential = true,     ExcludeVisualStudioCredential = false,     ExcludeWorkloadIdentityCredential = true,     ExcludeAzureCliCredential = true }); var token =  credential.GetTokenAsync(new TokenRequestContext(new string[] { `https://api.applicationinsights.io/.default` } ));  Expected behavior The token should be returned. Actual behavior VisualStudioCredential throws an exception: {               `ClassName`: `Azure.Identity.CredentialUnavailableException`,               `Message`: `Process \`C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\IDE\\CommonExtensions\\Microsoft\\Asal\\TokenService\\Microsoft.Asal.TokenService.exe\` has failed with unexpected error: TS003: Error, TS004: Unable to get access token.  'AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'f5c26e74-f226-4ae8-85f0-b4af0080ac9e' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API.\r\nTrace ID: 032456dc-f4a7-4ec5-ae65-33cc6c183d00\r\nCorrelation ID: 6e665b78-4ede-44f4-8fba-da34bf3e4a04\r\nTimestamp: 2023-10-09 09:17:06Z'.`,               `Data`: null,               `InnerException`: {                 `ClassName`: `System.AggregateException`,                 `Message`: `One or more errors occurred.`,                 `Data`: null,                 `InnerException`: {                   `ClassName`: `Azure.Identity.CredentialUnavailableException`,                   `Message`: `Process \`C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\IDE\\CommonExtensions\\Microsoft\\Asal\\TokenService\\Microsoft.Asal.TokenService.exe\` has failed with unexpected error: TS003: Error, TS004: Unable to get access token.  'AADSTS65002: Consent between first party application '04f0c124-f2bc-4f59-8241-bf6df9866bbd' and first party resource 'f5c26e74-f226-4ae8-85f0-b4af0080ac9e' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API.\r\nTrace ID: 032456dc-f4a7-4ec5-ae65-33cc6c183d00\r\nCorrelation ID: 6e665b78-4ede-44f4-8fba-da34bf3e4a04\r\nTimestamp: 2023-10-09 09:17:06Z'.`,  Reproduction Steps So the code above is a minimal reproduction of the issue.  However to see the error it must be part of a website, which is started from the command line with dotnet run:   When I run this code in a unit test in Visual Studio it works fine (I just don't understand this)   When running the website, if I authenticate via the command line using az login, that works fine   If I authenticate in Visual Studio 2019, that works fine   When the website is deployed into Azure, so using ManagedIdentity, that works fine   If I authenticate using Visual Studio 2022, but access Azure Storage, that works fine   The issue looks very similar to this one VisualStudioCredential fails with AADSTS65002 Environment Visual Studio 2022
Client	Service Bus	[QUERY] Register named ServiceBusClient with SAS credential	Library name and version Azure.Messaging.ServiceBus (7.16.1) Query/Question Is it possible to register the AzureClient for ServiceBus with fully qualified namespace and SAS instead of full connectionString or TokenCredential using extensions methods from this lib? I can't find an overload of AddServiceBusClientWithNamespace that accepts AzureSasToken object like this: serviceCollection.AddAzureClients(clientsBuilder => {     clientsBuilder         .AddServiceBusClientWithNamespace(`fullyQualifiedNamespace`, new AzureSasCredential(`sas`)) //error         .WithName(`serviceBus1`); } However, ServiceBusClient has a constructor that accepts fullyQualifiedNamespace and a SasTokenCredential: var serviceBusClient = new ServiceBusClient(`fullyQualifiedNamespace`, new AzureSasCredential(`sas`)); https://learn.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusclient.-ctor?view=azure-dotnet#azure-messaging-servicebus-servicebusclient-ctor(system-string-azure-azuresascredential-azure-messaging-servicebus-servicebusclientoptions) I know I could register the client `manually` but the SDK has very convincing named registrations of clients and injectable factory which can resolve named dependencies. Is there a convenient way to do it? Environment .NET SDK (reflecting any global.json): Version:   6.0.413 Commit:    10710f7d8e Runtime Environment: OS Name:     Windows OS Version:  10.0.19045
Client	Azure.Identity	[BUG] AzurePowerShellCredential authentication failed: String '5.10.2023 ?. 12:52:35 +00:00' was not recognized as a valid DateTime	Library name and version Azure.Identity 1.9.0 Describe the bug Originally reported here: Azure/bicep#12054 We're seeing an exception thrown (details below). We're using Azure.Identity 1.9.0 (lock file here). This appears similar to #22638, but this issue was supposedly fixed in release 1.5.0. Expected behavior Azure.Identity should be able to correctly obtain an auth token from the PowerShell context. Actual behavior An exception is thrown with the following stack trace: Unable to restore the module with reference `<registry reference>`: Unhandled exception: Azure.Identity.AuthenticationFailedException: The ChainedTokenCredential failed due to an unhandled exception: AzurePowerShellCredential authentication failed: String '5.10.2023 ?. 12:52:35 +00:00' was not recognized as a valid DateTime.  ---> Azure.Identity.AuthenticationFailedException: AzurePowerShellCredential authentication failed: String '5.10.2023 ?. 12:52:35 +00:00' was not recognized as a valid DateTime.  ---> System.FormatException: String '5.10.2023 ?. 12:52:35 +00:00' was not recognized as a valid DateTime.    at System.DateTimeParse.Parse(ReadOnlySpan`1 s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset)    at System.DateTimeOffset.Parse(String input, IFormatProvider formatProvider, DateTimeStyles styles)    at Azure.Identity.AzurePowerShellCredential.DeserializeOutput(String output)    at Azure.Identity.AzurePowerShellCredential.RequestAzurePowerShellAccessTokenAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.AzurePowerShellCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage)    at Azure.Identity.AzurePowerShellCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.AzurePowerShellCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.ChainedTokenCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at Azure.Identity.ChainedTokenCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.ChainedTokenCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Containers.ContainerRegistry.ContainerRegistryRefreshTokenCache.GetRefreshTokenFromCredentialAsync(TokenRequestContext context, String service, Boolean async, CancellationToken cancellationToken)    at Azure.Containers.ContainerRegistry.ContainerRegistryRefreshTokenCache.GetAcrRefreshTokenAsync(HttpMessage message, TokenRequestContext context, String service, Boolean async)    at Azure.Containers.ContainerRegistry.ContainerRegistryRefreshTokenCache.GetAcrRefreshTokenAsync(HttpMessage message, TokenRequestContext context, String service, Boolean async)    at Azure.Containers.ContainerRegistry.ContainerRegistryChallengeAuthenticationPolicy.AuthorizeRequestOnChallengeAsyncInternal(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Containers.ContainerRegistry.ContainerRegistryRestClient.GetManifestAsync(String name, String reference, String accept, CancellationToken cancellationToken)    at Azure.Containers.ContainerRegistry.ContainerRegistryContentClient.GetManifestInternalAsync(String reference, Boolean async, CancellationToken cancellationToken)    at Azure.Containers.ContainerRegistry.ContainerRegistryContentClient.GetManifestAsync(String tagOrDigest, CancellationToken cancellationToken)    at Bicep.Core.Registry.AzureContainerRegistryManager.DownloadManifestAndLayersAsync(IOciArtifactReference artifactReference, ContainerRegistryContentClient client) in C:\__w\1\s\bicep\src\Bicep.Core\Registry\AzureContainerRegistryManager.cs:line 183    at Bicep.Core.Registry.AzureContainerRegistryManager.<>c__DisplayClass4_0.<<PullArtifactAsync>g__DownloadManifestInternalAsync|0>d.MoveNext() in C:\__w\1\s\bicep\src\Bicep.Core\Registry\AzureContainerRegistryManager.cs:line 54 --- End of stack trace from previous location ---    at Bicep.Core.Registry.AzureContainerRegistryManager.PullArtifactAsync(RootConfiguration configuration, IOciArtifactReference artifactReference) in C:\__w\1\s\bicep\src\Bicep.Core\Registry\AzureContainerRegistryManager.cs:line 60    at Bicep.Core.Registry.OciModuleRegistry.TryRestoreArtifactAsync(RootConfiguration configuration, OciModuleReference reference) in C:\__w\1\s\bicep\src\Bicep.Core\Registry\OciModuleRegistry.cs:line 442bicep(BCP192)  Reproduction Steps It appears that this occurs when the machine locale is set to something other than en-US. @slavizh would you mind confirming what your machine locale is set to? Environment No response
Client	Azure.Core	How to create an error response for mocking error?	[Enter feedback here]  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 376e2c70-c811-ecc8-2fa4-c5b12fbea1df Version Independent ID: 44106a9f-551c-c279-1f7d-d1d243882ba5 Content: Response Class (Azure) - Azure for .NET Developers Content Source: xml/Azure/Response.xml Service: azure GitHub Login: @azure-sdk Microsoft Alias: azsdkdocs
Client	Service Bus	ActiveMessageCount property missing in TopicRuntimeProperties class for Azure.Messaging.ServiceBus.Administration nuget package	Hi I am using Azure.Messaging.ServiceBus nuget package and below property are missing in TopicRuntimeProperties class  ActiveMessageCount DeadLetterMessageCount TransferMessageCount TransferDeadLetterMessageCount  Please suggest me how can I get above properties of Topic
Client	Search	Upgrade Microsoft.Azure.Search (Version 10.1.0) to Azure.Search.Documents(Verion 11.4.0), The geography points are serialized differently	Library name and version Azure.Search.Documents 11.4.0 Query/Question Microsoft.Azure.Search (Version 10.1.0) Geography Point serialization output: `location`: { `latitude`: 39.2428832397, `longitude`: -75.8474861165, `isEmpty`: false, `z`: null, `m`: null, `coordinateSystem`: { `epsgId`: 4326, `id`: `4326`, `name`: `WGS84` } } Azure.Search.Documents(Verion 11.4.0) Geography point serialization output: `location`: { `type`: `Point`, `coordinates`: [ -75.5646879643, 39.7093928328 ], `crs`: { `type`: `name`, `properties`: { `name`: `EPSG:4326` } } } We are using NewtonsoftJsonMicrosoftSpatialGeoJsonConverter, how can we retain the Microsoft.Azure.Search (Version 10.1.0) serialization format? This would allow our clients to use our current API without making any changes in their end. Environment No response
Client	Extensions	[BUG] Adding AzureKeyVault configuration provider causes 0x80131506	Library name and version Azure.Extensions.AspNetCore.Configuration.Secrets 1.2.2 Describe the bug When I try to load secrets from Azure Key Vault, the application crashes Expected behavior The application is able to load the secrets from AKV Actual behavior C:/Users/RenatoGolia/Development/Tobii/mytd/backend/src/API/bin/Debug/net8.0/MyTobiiDynavox.API.exe  Fatal error. Internal CLR error. (0x80131506)    at System.Runtime.Serialization.SerializationGuard.<ThrowIfDeserializationInProgress>g__ThrowIfDeserializationInProgress|0_0(System.Runtime.Serialization.SerializationInfo, System.String, Int32 ByRef)    at System.Diagnostics.Process.Start()    at Azure.Identity.ProcessService+ProcessWrapper.Start()    at Azure.Identity.ProcessRunner.StartProcess()    at Azure.Identity.ProcessRunner.RunAsync()    at Azure.Identity.VisualStudioCredential+<RunProcessesAsync>d__21.MoveNext()    at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Azure.Identity.VisualStudioCredential+<RunProcessesAsync>d__21, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]](<RunProcessesAsync>d__21 ByRef)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].Start[[Azure.Identity.VisualStudioCredential+<RunProcessesAsync>d__21, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]](<RunProcessesAsync>d__21 ByRef)    at Azure.Identity.VisualStudioCredential.RunProcessesAsync(System.Collections.Generic.List`1<System.Diagnostics.ProcessStartInfo>, Boolean, System.Threading.CancellationToken)    at Azure.Identity.VisualStudioCredential+<GetTokenImplAsync>d__19.MoveNext()    at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Azure.Identity.VisualStudioCredential+<GetTokenImplAsync>d__19, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]](<GetTokenImplAsync>d__19 ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].Start[[Azure.Identity.VisualStudioCredential+<GetTokenImplAsync>d__19, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]](<GetTokenImplAsync>d__19 ByRef)    at Azure.Identity.VisualStudioCredential.GetTokenImplAsync(Azure.Core.TokenRequestContext, Boolean, System.Threading.CancellationToken)    at Azure.Identity.VisualStudioCredential+<GetTokenAsync>d__17.MoveNext()    at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Azure.Identity.VisualStudioCredential+<GetTokenAsync>d__17, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]](<GetTokenAsync>d__17 ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].Start[[Azure.Identity.VisualStudioCredential+<GetTokenAsync>d__17, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]](<GetTokenAsync>d__17 ByRef)    at Azure.Identity.VisualStudioCredential.GetTokenAsync(Azure.Core.TokenRequestContext, System.Threading.CancellationToken)    at Azure.Identity.DefaultAzureCredential+<GetTokenFromSourcesAsync>d__14.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.ValueTuple`2[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[System.__Ca non, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Identity.DefaultAzureCredential+<GetTokenFromSourcesAsync>d__14, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.ValueTuple`2[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[System.__Ca non, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Identity.DefaultAzureCredential+<GetTokenFromSourcesAsync>d__14, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.ValueTuple`2[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[System.__Ca non, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Identity.DefaultAzureCredential+<GetTokenFromSourcesAsync>d__14, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception, System.Threading.Tasks.Task`1<Azure.Core.AccessToken> ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception)    at Azure.Identity.ManagedIdentityCredential+<GetTokenAsync>d__14.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityCredential+<GetTokenAsync>d__14, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityCredential+<GetTokenAsync>d__14, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityCredential+<GetTokenAsync>d__14, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception, System.Threading.Tasks.Task`1<Azure.Core.AccessToken> ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception)    at Azure.Identity.ManagedIdentityCredential+<GetTokenImplAsync>d__16.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityCredential+<GetTokenImplAsync>d__16, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityCredential+<GetTokenImplAsync>d__16, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityCredential+<GetTokenImplAsync>d__16, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception, System.Threading.Tasks.Task`1<Azure.Core.AccessToken> ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception)    at Azure.Identity.ManagedIdentityClient+<AuthenticateAsync>d__15.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityClient+<AuthenticateAsync>d__15, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityClient+<AuthenticateAsync>d__15, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentityClient+<AuthenticateAsync>d__15, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception, System.Threading.Tasks.Task`1<Azure.Core.AccessToken> ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception)    at Azure.Identity.ImdsManagedIdentitySource+<AuthenticateAsync>d__15.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ImdsManagedIdentitySource+<AuthenticateAsync>d__15, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ImdsManagedIdentitySource+<AuthenticateAsync>d__15, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ImdsManagedIdentitySource+<AuthenticateAsync>d__15, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception, System.Threading.Tasks.Task`1<Azure.Core.AccessToken> ByRef)    at System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].SetException(System.Exception)    at Azure.Identity.ManagedIdentitySource+<AuthenticateAsync>d__10.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentitySource+<AuthenticateAsync>d__10, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentitySource+<AuthenticateAsync>d__10, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[Azure.Core.AccessToken, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8],[Azure.Identity.ManagedIdentitySource+<AuthenticateAsync>d__10, Azure.Identity, Version=1.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.Threading.Tasks.VoidTaskResult> ByRef)    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.Threading.Tasks.VoidTaskResult> ByRef)    at Azure.Core.Pipeline.RedirectPolicy+<ProcessAsync>d__7.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.RedirectPolicy+<ProcessAsync>d__7, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.RedirectPolicy+<ProcessAsync>d__7, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.RedirectPolicy+<ProcessAsync>d__7, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.Threading.Tasks.VoidTaskResult> ByRef)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.Threading.Tasks.VoidTaskResult> ByRef)    at Azure.Core.Pipeline.HttpPipelineTransportPolicy+<ProcessAsync>d__4.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.HttpPipelineTransportPolicy+<ProcessAsync>d__4, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.HttpPipelineTransportPolicy+<ProcessAsync>d__4, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.HttpPipelineTransportPolicy+<ProcessAsync>d__4, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.Threading.Tasks.VoidTaskResult> ByRef)    at Azure.Core.Pipeline.HttpClientTransport+<ProcessAsync>d__12.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.HttpClientTransport+<ProcessAsync>d__12, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.HttpClientTransport+<ProcessAsync>d__12, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[Azure.Core.Pipeline.HttpClientTransport+<ProcessAsync>d__12, Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.__Canon> ByRef)    at System.Net.Http.HttpClient+<<SendAsync>g__Core|83_0>d.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Net.Http.HttpClient+<<SendAsync>g__Core|83_0>d, System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Net.Http.HttpClient+<<SendAsync>g__Core|83_0>d, System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Net.Http.HttpClient+<<SendAsync>g__Core|83_0>d, System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.__Canon> ByRef)    at System.Net.Http.HttpConnectionPool+<SendWithVersionDetectionAndRetryAsync>d__89.MoveNext()    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Net.Http.HttpConnectionPool+<SendWithVersionDetectionAndRetryAsync>d__89, System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Net.Http.HttpConnectionPool+<SendWithVersionDetectionAndRetryAsync>d__89, System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Net.Http.HttpConnectionPool+<SendWithVersionDetectionAndRetryAsync>d__89, System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].MoveNext()    at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)    at System.Threading.Tasks.Task.RunContinuations(System.Object)    at System.Threading.Tasks.Task.FinishSlow(Boolean)    at System.Threading.Tasks.Task.TrySetException(System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetException(System.Exception, System.Threading.Tasks.Task`1<System.__Canon> ByRef)    at System.Threading.Tasks.TaskCompletionSourceWithCancellation`1+<WaitWithCancellationAsync>d__1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()         at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.TaskCo mpletionSourceWithCancellation`1+<WaitWithCancellationAsync>d__1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].ExecutionContextCallback(System.Object)    at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread, System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.TaskCo mpletionSourceWithCancellation`1+<WaitWithCancellationAsync>d__1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].MoveNext(System.Threading.Thread)    at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.TaskCo mpletionSourceWithCancellation`1+<WaitWithCancellationAsync>d__1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Net.Http, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a]].ExecuteFromThreadPool(System.Threading.Thread)    at System.Threading.ThreadPoolWorkQueue.Dispatch()    at System.Threading.PortableThreadPool+WorkerThread.WorkerThreadStart()  Reproduction Steps Simple web app var builder = WebApplication.CreateBuilder(args);  if (builder.Configuration.GetConnectionString(`AzureKeyVault`) is { } vaultUrl ) {     builder.Configuration.AddAzureKeyVault     (         new Uri(vaultUrl),         new DefaultAzureCredential()     ); } Environment $ dotnet --info      .NET SDK:  Version:   8.0.100-rc.1.23455.8  Commit:    e14caf947f  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win-x64  Base Path:   C:\Program Files\dotnet\sdk\8.0.100-rc.1.23455.8\  .NET workloads installed: There are no installed workloads to display.  Host:   Version:      8.0.0-rc.1.23419.4   Architecture: x64   Commit:       92959931a3   RID:          win-x64  .NET SDKs installed:   3.1.426 [C:\Program Files\dotnet\sdk]   6.0.317 [C:\Program Files\dotnet\sdk]   6.0.414 [C:\Program Files\dotnet\sdk]   7.0.111 [C:\Program Files\dotnet\sdk]   7.0.203 [C:\Program Files\dotnet\sdk]   7.0.308 [C:\Program Files\dotnet\sdk]   7.0.401 [C:\Program Files\dotnet\sdk]   8.0.100-rc.1.23455.8 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.22 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 8.0.0-rc.1.23421.29 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.22 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 8.0.0-rc.1.23419.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.22 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 8.0.0-rc.1.23420.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   C:\Users\RenatoGolia\Development\Tobii\mytd\global.json  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download I'm experiencing this issue both locally on Rider and in a docker container hosted in ACI both on 8.0 RC1
Client	Search	[BUG] Newing up SearchIndex throws NullReferenceException when assigning VectorSearch	Library name and version Azure.Search.Documents 11.5.0-beta.4 Describe the bug This code throws a NullReferenceException: var definition = new SearchIndex(`myindex`) {     Fields =     {         new SimpleField(`id`, SearchFieldDataType.String) { IsKey = true },         new SearchableField(`content`) { AnalyzerName = `en.microsoft` },         new SearchField(`embedding`, SearchFieldDataType.Collection(SearchFieldDataType.Single))         {             IsHidden = false,             IsSearchable = true,             IsFilterable = false,             IsSortable = false,             IsFacetable = false,             VectorSearchDimensions = 1536,             VectorSearchConfiguration = `default`,         },         new SimpleField(`name_spaces`, SearchFieldDataType.String) { IsFilterable = true, IsFacetable = true },         new SimpleField(`url`, SearchFieldDataType.String) { IsFilterable = true, IsFacetable = true },     },     SemanticSettings = new SemanticSettings     {         Configurations = {             new SemanticConfiguration(`default`, new PrioritizedFields             {                 TitleField = null,                 ContentFields = {                     new SemanticField { FieldName = `content` }                 },             })         }     },     VectorSearch =     {         AlgorithmConfigurations =         {             new HnswVectorSearchAlgorithmConfiguration(`default`)             {                 Parameters = new HnswParameters                 {                     Metric = VectorSearchAlgorithmMetric.Cosine                 }             }         }     } };  If I comment out the VectorSearch section, it does not throw. Incidentally, I am trying to convert this Python code to C#: https://github.com/Azure-Samples/azure-search-openai-demo/blob/3c752304a8faa8d078aed256152225bd24d9060f/scripts/prepdocs.py#L337 EDIT: If I do it like this: var vectorSearch = new VectorSearch(); vectorSearch.AlgorithmConfigurations.Add(new HnswVectorSearchAlgorithmConfiguration(`default`) {     Parameters = new HnswParameters     {         Metric = VectorSearchAlgorithmMetric.Cosine     } });  and set VectorSearch to that, it works. Maybe something related to ChangeTrackingList? Kind regards, Emil
Mgmt	SQL	[FEATURE REQ] Make library Azure.ResourceManager mockable	Library name Azure.ResourceManager.Sql Please describe the feature. This library is generally not very convenient to write unit tests against and though there are many places need attention, here I would like to give as an example several places in particular where I ended up resorting to reflection in order to have unit tests. ElasticPoolData setting State property ElasticPoolData setting Name property inherited from ResourceData Obtaining instance of SqlServerUsage
Mgmt	Compute	[BUG] managedDiskData needs to be able to set the Zones	Library name and version Azure.ResourceManager.Compute 1.1.0 Describe the bug Premium v2/Ultra disk requires to be deployed on a Zone; In ManagedDiskData we have:     /// <summary> The Logical zone list for Disk. </summary>     public IList<string> Zones { get; }  It also needs a set; else you will not be able to assign the disk to a vm/vmss that is on a zone. Expected behavior Zones should have a set Actual behavior Disks created have no zone and they fail to get attached to a vm/vmss that is on a zone. Reproduction Steps create a disk from code; attach it to a vm that is on a availability zone It fails. Environment No response
Client	Purview	[QUERY] Purview models do not support public serialization	Library name and version Azure.Analytics.Purview.Catalog Query/Question I want to use Azure.Analytics.Purview.Catalog sdk for microspft purview. like ex;  first i create client . var entities = client.Entities; using this i can access entities in catalog var classifications = entities.GetClassifications(`10f8870f-86b6-4ca0-bd24-c3a876100f5d`); var value = classifications.Content.ToString(); using value how do i see response if i try to use PurviewEntities entityfromResponse = JsonConvert.DeserializeObject(value); here PurviewEntities is a class of Entities but in this class there is no variables define so how do i get response in entityfromResponse .  Environment No response
Client	Azure.Identity	[FEATURE REQ] Annotate Azure.Identity for Nullable Reference Types	Library name Azure.Identity Please describe the feature. Nullable Reference Types were introduced in C# 8 and have now become a standard part of the framework and many other libraries. Please consider annotating Azure.Identity for NRTs to enable the library to work with this very helpful language feature.
Client	Service Bus	[QUERY] Is it possible to stop ServiceBusProcessor from within ProcessMessageAsync callback?	Library name and version Azure.Messaging.ServiceBus Query/Question I need to be able to stop ServiceBusProcessor from receiving messages from within the ProcessMessageAsync callback. Calling processor.StopProcessingAsync() from within the handler doesn't seem to work. Is this scenario supported? Environment No response
Client	Service Bus	[QUERY]not able use Deadletter and abandon in serviceBusreceived message class	Library name and version serviceBustrigger Query/Question not able use Deadletter and abandon in serviceBusreceived message class in azure function app v4 Environment .net FM v4.8
Mgmt	App Services	[QUERY] How to set 'Deployment slot setting' when updating slot's application settings?	Library name and version Azure.ResourceManager.AppService 1.0.2 Query/Question So I want to set some of my application settings per deployment slot, but I see no respective setting for this option in the AppServiceConfigurationDictionary. Here's the code I tried using to add slot-specific settings: var azureFunction = await resourceGroup.GetWebSiteAsync(`azureFunctionName`); WebSiteSlotResource slot = await azureFunction.GetWebSiteSlotAsync(`slotName`); AppServiceConfigurationDictionary applicationSettings = await slot.GetApplicationSettingsSlotAsync(); applicationSettings.Properties[`test`] = `test`; await slot.UpdateApplicationSettingsSlotAsync(applicationSettings);  But it only Updates the slot's settings, none of which are 'slot-specific'. To be clear, I am trying to achieve the same result as with this command: az functionapp config appsettings set --name <FUNCTION_APP_NAME> \ --resource-group <RESOURCE_GROUP_NAME> --slot <SLOT_NAME> \ --slot-settings AzureWebJobs.QueueTrigger.Disabled=true  Environment  Azure Functions v4, .NET Framework 4.8 Visual Studio 17.6.3
Client	Extensions	[FEATURE REQ] Allow Users to Configure Retry Policy for Credentials through ClientFactory	Library name Microsoft.Extensions.Azure Please describe the feature. While RetryOptions may be configured for Azure service clients through the AzureComponentFactoryImpl.CreateClientOptions, they cannot be similarly configured for any of the TokenCredential objects generated through ClientFactory.CreateCredential. For my team, it is becoming more important to configure our ManagedIdentityCredential object's retry while federated identities are still not available in all Azure regions, and AAD pod identity may take some time to become ready for a given pod. I think the existing API could be easily extended to allow a nested configuration section called retry with all of the value for RetryOptions. Eg. {   `credential`: `managedidentity`,   `retry`: {     `delay`: `00:00:10`,     `maxRetries`: 10   } }
Client	Azure.Identity	Issue connecting to my account when using IAzureClientFactory to retrieve KeyVault data	Library name and version Azure.Security.KeyVault Query/Question Hello all! Context I have an API that connects to a KeyVault using a SecretClient and a CertificateClient to retrieve specific data. I am authorized to access the KeyVault, and I possess the necessary permissions. I have an older Microsoft account that offers both Personal and Work options, with the Work option being utilized for the Azure Portal. Problem Method 1: When I try to access to the KeyVault with the IAzureClientFactory interface configuration: In Program.cs: services.AddAzureClients(async clientBuilder => {     clientBuilder.AddCertificateClient(new Uri(``)).WithName(`Name`); });  Constructor: public Class1(IAzureClientFactory<CertificateClient> certificateClientFactory) {    certificateClient = certificateClientFactory.CreateClient(`Name`); }  I get this error, and there is no way to retrieve data from this KeyVault  BUT Method 2: If I don't use dependency injection and I create a new client I don't get an error, the connection is made and the data is retrieved. Constructor: public Class1() {     certificateClient = new CertificateClient(new Uri(`Uri`), new DefaultAzureCredential()); }   My question is: Is there a distinction between Method 1 and Method 2? Perhaps the credentials utilized in the dependency injection are not the DefaultAzureCredential(), which might explain why it's unable to retrieve the correct user. If this is indeed a bug, kindly inform me, and I will file a report for it. Any response or feedback is greatly appreciated. If you require additional information, please don't hesitate to inform me. Environment Windows 11 Enterprise Insider (Dev channel) .NET SDK:  Version:   8.0.100-rc.1.23455.8 Commit:    e14caf947f  IDE and version:  Microsoft Visual Studio Professional 2022 (64-bit) - Preview Version 17.8.0 Preview 2.0
Mgmt	Cosmos	[BUG] ResourceManager.CosmosDB not using PATCH semantics	Library name and version Azure.ResourceManager.CosmosDB 1.4.0-beta3 Describe the bug See https://developercommunity.visualstudio.com/t/Using-CosmosDBAccountPatch-object-always/10478789 When trying to use the azure Management SDK for Cosmos DB every time we use the CosmosDBAccountPatch object to say set IPRules no matter what we set the Allow Access from Azure Portal flag is set to false/disabled. For Example: var ri = CosmosDBAccountResource.CreateResourceIdentifier(IaCConfiguration.AzureSubscriptionId.ToString()                                                      , resourceConfig.ResourceGroupName                                                      , resourceConfig.ResourceName);  var armResource = ArmClient.GetCosmosDBAccountResource(ri);  if (armResource == null)  {      continue;  }  var armResourceData = await armResource.GetAsync(cancellationToken: cancellationToken). ConfigureAwait(false);  if (armResourceData?. Value?. Data?. IPRules == null)  {      continue;  }  var firewallRuleCollection = armResourceData.Value.Data.IPRules;  if (firewallRuleCollection == null)  {      continue;  }  //Clear all existing rules  firewallRuleCollection.Clear();  firewallRuleCollection.Add(new CosmosDBIPAddressOrRange {  IPAddressOrRange = '<IP Address>'});  var updateParameters = new CosmosDBAccountPatch();  updateParameters.NetworkAclBypass = armResourceData.Value.Data.NetworkAclBypass;  updateParameters.PublicNetworkAccess = armResourceData.Value.Data.PublicNetworkAccess;  foreach (var ipRule in firewallRuleCollection)  {      updateParameters.IPRules.Add(ipRule);  }  var updateOperation = await armResource.UpdateAsync(WaitUntil.Completed, updateParameters, cancellationToken). ConfigureAwait(false);  Expected behavior The Allow Access from Azure Portal flag would not be mutated unless we explicitly set it. Actual behavior The Allow Access from Azure Portal flag is mutated back to its default of disabled it seems.. Reproduction Steps See code above in description Environment Windows 11 (latest patches) desktop Microsoft Visual Studio Enterprise 2022 Version 17.8.0 Preview 2.0 VisualStudio.17.Preview/17.8.0-pre.2.0+34112.27 Microsoft .NET Framework Version 4.8.09032 Installed Version: Enterprise Visual C++ 2022   00476-80000-00000-AA741 Microsoft Visual C++ 2022 ADL Tools Service Provider   1.0 This package contains services used by Data Lake tools ASA Service Provider   1.0 ASP.NET and Web Tools   17.8.226.21692 ASP.NET and Web Tools Azure App Service Tools v3.0.0   17.8.226.21692 Azure App Service Tools v3.0.0 Azure Data Lake Tools for Visual Studio   2.6.5000.0 Microsoft Azure Data Lake Tools for Visual Studio Azure Functions and Web Jobs Tools   17.8.226.21692 Azure Functions and Web Jobs Tools Azure Stream Analytics Tools for Visual Studio   2.6.5000.0 Microsoft Azure Stream Analytics Tools for Visual Studio Bundler & Minifier   2.9.9 Adds support for bundling and minifying JavaScript, CSS and HTML files in any project. C# Tools   4.8.0-2.23429.7+44555193fd1135b5d53a2099f76fec91e0d1ebde C# components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used. Common Azure Tools   1.10 Provides common services for use by Azure Mobile Services and Microsoft Azure Tools. Entity Framework Core Power Tools   2.5 Adds useful design-time EF Core DbContext features to the Visual Studio Solution Explorer context menu. Extensibility Message Bus   1.4.39 (main@e8108eb) Provides common messaging-based MEF services for loosely coupled Visual Studio extension components communication and integration. GitHub Copilot   1.110.0.0 (v1.110.0.0@9f24d0f53) GitHub Copilot is an AI pair programmer that helps you write code faster and with less work. GitHub Copilot Agent   1.110.389 (v1.110.0) Microsoft Azure Hive Query Language Service   2.6.5000.0 Language service for Hive query Microsoft Azure Stream Analytics Language Service   2.6.5000.0 Language service for Azure Stream Analytics Microsoft Azure Tools for Visual Studio   2.9 Support for Azure Cloud Services projects Microsoft JVM Debugger   1.0 Provides support for connecting the Visual Studio debugger to JDWP compatible Java Virtual Machines Mono Debugging for Visual Studio   17.8.14 (0c9914e) Support for debugging Mono processes with Visual Studio. NuGet Package Manager   6.8.0 NuGet Package Manager in Visual Studio. For more information about NuGet, visit https://docs.nuget.org/ Razor (ASP.NET Core)   17.8.2.2345506+ade90399d42c1a7bf92191b1c067816c0ae1c311 Provides languages services for ASP.NET Core Razor. Solution Colors   1.1.44 Allows you to associate a color with a solution and display it in various locations within Visual Studio. Inspired by the Peacock extension for VS Code. SQL Server Data Tools   17.8.64.0 Microsoft SQL Server Data Tools Syntax Visualizer   1.0 An extension for visualizing Roslyn SyntaxTrees. Test Adapter for Boost.Test   1.0 Enables Visual Studio's testing tools with unit tests written for Boost.Test.  The use terms and Third Party Notices are available in the extension installation directory. Test Adapter for Google Test   1.0 Enables Visual Studio's testing tools with unit tests written for Google Test.  The use terms and Third Party Notices are available in the extension installation directory. ToolWindowHostedEditor   1.0 Hosting json editor into a tool window TypeScript Tools   17.0.20830.2001 TypeScript Tools for Microsoft Visual Studio Visual Basic Tools   4.8.0-2.23429.7+44555193fd1135b5d53a2099f76fec91e0d1ebde Visual Basic components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used. Visual F# Tools   17.8.0-beta.23425.10+0d3549fa5b8b6387ade191d76768405cefed8229 Microsoft Visual F# Tools Visual Studio IntelliCode   2.2 AI-assisted development for Visual Studio. VisualStudio.DeviceLog   1.0 Information about my package VisualStudio.Mac   1.0 Mac Extension for Visual Studio VSPackage Extension   1.0 VSPackage Visual Studio Extension Detailed Info Xamarin   17.8.0.118 (main@35c256f) Visual Studio extension to enable development for Xamarin.iOS and Xamarin.Android. Xamarin Designer   17.8.1.11 (remotes/origin/d17-8@13ef934098) Visual Studio extension to enable Xamarin Designer tools in Visual Studio. Xamarin Templates   17.8.16 (830b56a) Templates for building iOS, Android, and Windows apps with Xamarin and Xamarin.Forms. Xamarin.Android SDK   13.2.1.2 (d17-5/a8a26c7) Xamarin.Android Reference Assemblies and MSBuild support. Mono: d9a6e87 Java.Interop: xamarin/java.interop/d17-5@149d70fe SQLite: xamarin/sqlite@68c69d8 Xamarin.Android Tools: xamarin/xamarin-android-tools/d17-5@ca1552d Xamarin.iOS and Xamarin.Mac SDK   16.4.0.16 (b5972410d) Xamarin.iOS and Xamarin.Mac Reference Assemblies and MSBuild support.
Client	Search	[QUERY] How to access the search results from calling SearchClient.SearchAsync	Library name and version Azure.Search.Documents (11.4) Query/Question Original Code (v10.): var client = _serviceClient.Indexes.GetClient(indexName); Task<DocumentSearchResult> results = await client.Documents.SearchAsync(azureQuery.SearchValueParam, searchParams); New Replacement Code (v11): var client = _searchIndexClient.GetSearchClient(indexName); Response<SearchResults<SearchResult>> results = await client.SearchAsync<SearchResult>(azureQuery.SearchValueParam, (SearchOptions)searchParams); I am trying to determine how to get the `SearchResult<Document>` from results. Is there a way to do this? Which object inside Response class and also inside the SearchResults class do I need to reference to get down to this information? I am asking here because of all of the name changes in the API. Environment .Net 6.0 Visual Studio 2022
Mgmt	ARM - Core	[BUG] Cannot attach a User Assigned Managed Identity to Azure Maps Account	Library name and version Azure.ResourceManager.Maps 1.1.0-beta.2 Describe the bug When I create a User Assigned Managed Identity using Azure.ResourceManager.ManagedServiceIdentities I get a UserAssignedIdentityResource object. That object has a Data property that contains PrincipalId and ClientId properties. UserAssignedIdentityResource identity = resourceGroup.GetUserAssignedIdentities().CreateOrUpdate(Azure.WaitUntil.Completed, userAssignedIdentityName, userIdData).Value; After that, I try to create an Azure Maps Account, with that user assigned identity attached: var mapsSku = new MapsSku(MapsSkuName.G2); var mapsAccountData = new MapsAccountData(AzureLocation.WestUS2, mapsSku); mapsAccountData.Identity = new ManagedServiceIdentity(ManagedServiceIdentityType.UserAssigned); mapsAccountData.Identity.UserAssignedIdentities.Add(identity.Id, identity); var mapsAccount = resourceGroup.GetMapsAccounts().CreateOrUpdate(Azure.WaitUntil.Completed, mapsAccountName, mapsAccountData).Value; I can't, because UserAssignedIdentities is a IDictionary<ResourceIdentifiers, UserAssignedIdentity> and identity is a UserAssignedIdentityResource, not a UserAssignedIdentity. I can't work around it by instantiating a new UserAssignedIdentity because it only provides an empty constructor and the properties are read-only. When I try this var uaid = (UserAssignedIdentity)Activator.CreateInstance(typeof(UserAssignedIdentity), BindingFlags.NonPublic | BindingFlags.Instance, null, new object[] { identity.Data.PrincipalId, identity.Data.ClientId }, null); I manage to get a UserAssignedIdentity with the correct attributes. Is that the intended use, or am I missing something? Expected behavior There should be a common type between created identity object and the assignment to Azure Maps Account. Actual behavior No direct way to assign the identity to the resource. A transformation using Reflections is needed. Reproduction Steps var mapsSku = new MapsSku(MapsSkuName.G2); var mapsAccountData = new MapsAccountData(AzureLocation.WestUS2, mapsSku); mapsAccountData.Identity = new ManagedServiceIdentity(ManagedServiceIdentityType.UserAssigned); mapsAccountData.Identity.UserAssignedIdentities.Add(identity.Id, identity); var mapsAccount = resourceGroup.GetMapsAccounts().CreateOrUpdate(Azure.WaitUntil.Completed, mapsAccountName, mapsAccountData).Value; Environment No response
Client	Monitor - Exporter	[FEATURE REQ] AddAzureMonitorLogExporter should support IOptions	Library name Azure.Monitor.OpenTelemetry.Exporter Please describe the feature. Is it possible to configure the Log exporter with traditional IOptions idioms, similar to Trace and Metric exporters? Currently, options are only provided through the configure delegate passed to the extension method. I have a use case where I want to separate AddAzureMonitorLogExporter from its configuration.
Client	Storage	[BUG] ClientDiagnostics.GetResourceProviderNamespace allocations	Library name and version Azure.Storage.Files.DataLake 12.16.0 Describe the bug In a recent memory profiling session to find memory leaks (not related), one of the major  string allocations was the following (this is only a short run, to demonstrate the problem). detail:  total:  An instance of the ClientDiagnostics Type is created for each BlobContainerClient (and probably others too). https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/src/Shared/ClientDiagnostics.cs In the ctor it calls a method, which reads some namespace via assembly attributes                azure-sdk-for-net/sdk/core/Azure.Core/src/Shared/ClientDiagnostics.cs                   Lines 31 to 37       in       9b7a0f4                                                 public ClientDiagnostics(ClientOptions options, bool? suppressNestedClientActivities = null)                                                       : this(options.GetType().Namespace!,                                                       GetResourceProviderNamespace(options.GetType().Assembly),                                                       options.Diagnostics,                                                       suppressNestedClientActivities)                                           {                                           }                     and that method:                azure-sdk-for-net/sdk/core/Azure.Core/src/Shared/ClientDiagnostics.cs                   Lines 63 to 75       in       9b7a0f4                                                 internal static string? GetResourceProviderNamespace(Assembly assembly)                                           {                                               foreach (var customAttribute in assembly.GetCustomAttributes(true))                                               {                                                   // Weak bind internal shared type                                                   var attributeType = customAttribute.GetType();                                                   if (attributeType.Name == `AzureResourceProviderNamespaceAttribute`)                                                   {                                                       return attributeType.GetProperty(`ResourceProviderNamespace`)?.GetValue(customAttribute) as string;                                                   }                                               }                                                                                          return null;                     parses the assembly attributes and reads a value via reflection, which is then responsible for the above stacktrace. Aren't there better ways to do that? Cache it in a concurrentdictionary by Assembly? Expected behavior Less allocations Actual behavior many allocations Reproduction Steps Code Analysis after Memory profiling Environment .NET 7
Client	Functions	How can I use Azure App Configuration for QueueTrigger bindings?	Library name and version Microsoft.Azure.Functions.Worker 1.19.0 Query/Question I've been searching for a way to use Azure 'App Configuration' to store the connection string of an Azure Storage Queue. After hours searching on the Web I'm even more confused--there seems to be conflicting opinions on how to do this. Maybe even using Managed Identity, but that makes debugging locally a nightmare. What I want is something like this: [Function(`foo`) public void foo([QueueTrigger(`bar`, Connection = `FooConnection`)] QueueMessage message) Where `FooConnection` is the name of a 'key' in an Azure App Configuration from which the connection string is specified. adly, it seems that Azure only looks in the 'Configuration' of the function (or local settings if running locally). So, is this even possible? Note: I do 'AddAzureAppConfiguration(..) in my HostBuilder. Thanks in advance, I've tried to surround the name with '%' like `%FooConnection%`, but I get an error saying the expression did not evaluate to a value. I've seen posts that speak so an expression pattern, but there is not much guidance on it. see: https://stackoverflow.com/q/77180419/8307483 Environment No response
Client	Event Hubs	[Feature Request] Compacted Eventhub Events with EntityKey and PartitionKey	Library name Azure.Messaging.EventHubs Please describe the feature. Send events with a partition key to a specific partition (set both PartitionKey and PartitionID) Or be able to specify a PartitionKey and EntityKey Example we want all Account entities to be partitioned by ClientKey, so that all accounts for the same client are on the same partition. At the same time we compaction to happen on the AccountKey so that we only store the latest Account Event
Client	Event Grid	Issues with validation of the `data` property in EventGridEvent class	Hello, I think there might be a problem with the validation of the `data` property in the EventGridEvent class. Since I have changed the library from deprecated Microsoft.Azure.EventGrid to an Azure.Messaging.EventGrid I have stumbled upon an issue trying to adapt the validation of the message that is coming from the Azure message bus. Whenever I try to send a message with an empty data parameter or null:  Validation always passes. If I try to send anything else as null, validation will not pass and argumentNullException will be thrown which is expected. In the picture below you can see the validation inside the constructor.  The `data` property that is coming from the Azure message bus is in the raw JSON data and when parsing, if the value is null, it actually is not represented as null, but {null} instead. Sent data:  Parsed data:  The solution is quite simple with additional check in the logic, but I think that this has to be addressed and dealt with in the library itself since the expected behavior is that an exception will be thrown if no data is provided. If I missed something, please let me know. Thank you in advance!  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: ce873d0e-3608-877c-99c0-a7cd281e8b89 Version Independent ID: c04935be-26dc-8096-5ea6-939e4e12ca1d Content: EventGridEvent.Parse(BinaryData) Method (Azure.Messaging.EventGrid) - Azure for .NET Developers Content Source: xml/Azure.Messaging.EventGrid/EventGridEvent.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Mgmt	App Services	[BUG] AppService List ConnectionString Fails	Library name and version PackageVersion Include=`Azure.ResourceManager.AppService` Version=`1.0.2` Describe the bug The GetConnectionStringsAsync throw exception after http 200 The requested operation requires an element of type 'Object', but the target element has type 'Array'.. Exception: System.InvalidOperationException: The requested operation requires an element of type 'Object', but the target element has type 'Array'.    at Azure.ResourceManager.AppService.Models.ConnectionStringDictionary.DeserializeConnectionStringDictionary(JsonElement element)    at Azure.ResourceManager.AppService.WebAppsRestOperations.ListConnectionStringsAsync(String subscriptionId, String resourceGroupName, String name, CancellationToken cancellationToken)    at Azure.ResourceManager.AppService.WebSiteResource.GetConnectionStringsAsync(CancellationToken cancellationToken)  Expected behavior The function should return connection string successfully Actual behavior See Describe Reproduction Steps Can reproduce as it is from production log. We only have the request message. Maybe need to contact with service team about the response format. {`requestMethod`:`POST`,`requestUri`:`https://management.azure.com/subscriptions/***/resourceGroups/***/providers/Microsoft.Web/sites/***/config/connectionstrings/list?api-version=2021-02-01`,`duration`:444.3982,`correlationId`:`f6de0155-17eb-45b0-9068-86328bc3190f`,`requestContentLength`:0,`responseCode`:200,`contentLength`:807} Environment Docker mcr.microsoft.com/dotnet/runtime:6.0
Mgmt	Monitor	[BUG] OperationalInsightsTableCollection - The requested operation requires an element of type 'String', but the target element has type 'True'.    at System.Text.Json.ThrowHelper.ThrowJsonElementWrongTypeException	Library name and version Azure.ResourceManager 1.7.0, Azure.ResourceManager.OperationalInsights 1.1.0 Describe the bug Based on this example: https://learn.microsoft.com/en-us/rest/api/loganalytics/tables/get?tabs=dotnet#tablesget The code throws a JsonElementWrongTypeException. // get the collection of this OperationalInsightsTableResource OperationalInsightsTableCollection collection = operationalInsightsWorkspace.GetOperationalInsightsTables();  // invoke the operation string tableName = `AppEvents`; bool result = await collection.ExistsAsync(tableName);  Stacktrace: The requested operation requires an element of type 'String', but the target element has type 'True'.    at System.Text.Json.ThrowHelper.ThrowJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType)    at System.Text.Json.JsonDocument.GetString(Int32 index, JsonTokenType expectedType)    at Azure.ResourceManager.OperationalInsights.OperationalInsightsTableData.DeserializeOperationalInsightsTableData(JsonElement element)    at Azure.ResourceManager.OperationalInsights.TablesRestOperations.GetAsync(String subscriptionId, String resourceGroupName, String workspaceName, String tableName, CancellationToken cancellationToken)    at Azure.ResourceManager.OperationalInsights.OperationalInsightsTableCollection.ExistsAsync(String tableName, CancellationToken cancellationToken)    at imec.PartnerMatrix.Cli.PartnerMatrixDeployment.DoEnsureResourcesAsync(IDeploymentContext context) in F:\Projects\IMEC\imec.PartnerPortal\src\imec.PartnerMatrix.Cli\PartnerMatrixDeployment.cs:line 92    at Dlw.Platina.DevOps.Provision.AbstractDevOpsDeployment.EnsureResourcesAsync(IDeploymentContext context)    at Dlw.Platina.DevOps.Provision.Cli.ProvisionCommand'1.EnsureResources(ResourceNaming resourceNamespace, T deployment, IDeploymentContext context)    at Dlw.Platina.DevOps.Provision.Cli.ProvisionCommand'1.DoExecute()    at Dlw.Platina.DevOps.Cli.CliCommand.Execute()  The actual JSON returned: {     `properties`: {         `totalRetentionInDays`: 90,         `archiveRetentionInDays`: 0,         `plan`: `Analytics`,         `retentionInDaysAsDefault`: true,         `totalRetentionInDaysAsDefault`: true,         `schema`: {             `tableSubType`: `Any`,             `name`: `AppEvents`,             `tableType`: `Microsoft`,             `standardColumns`: [                 {                     `name`: `TenantId`,                     `type`: `guid`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `TimeGenerated`,                     `type`: `datetime`,                     `description`: `Date and time when customEvent was recorded.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `Name`,                     `type`: `string`,                     `description`: `Human-readable name of the customEvent.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `Properties`,                     `type`: `dynamic`,                     `description`: `Application-defined properties.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `Measurements`,                     `type`: `dynamic`,                     `description`: `Application-defined measurements.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `OperationName`,                     `type`: `string`,                     `description`: `Application-defined name of the overall operation. The OperationName values typically match the Name values for AppRequests.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `OperationId`,                     `type`: `string`,                     `description`: `Application-defined operation ID.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ParentId`,                     `type`: `string`,                     `description`: `ID of the parent operation.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `SyntheticSource`,                     `type`: `string`,                     `description`: `Synthetic source of the operation.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `SessionId`,                     `type`: `string`,                     `description`: `Application-defined session ID.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `UserId`,                     `type`: `string`,                     `description`: `Anonymous ID of a user accessing the application.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `UserAuthenticatedId`,                     `type`: `string`,                     `description`: `Persistent string that uniquely represents each authenticated user in the application.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `UserAccountId`,                     `type`: `string`,                     `description`: `Application-defined account associated with the user.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `AppVersion`,                     `type`: `string`,                     `description`: `Version of the application.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `AppRoleName`,                     `type`: `string`,                     `description`: `Role name of the application.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `AppRoleInstance`,                     `type`: `string`,                     `description`: `Role instance of the application.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientType`,                     `type`: `string`,                     `description`: `Type of the client device.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientModel`,                     `type`: `string`,                     `description`: `Model of the client device.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientOS`,                     `type`: `string`,                     `description`: `Operating system of the client device.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientIP`,                     `type`: `string`,                     `description`: `IP address of the client device.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientCity`,                     `type`: `string`,                     `description`: `City where the client device is located.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientStateOrProvince`,                     `type`: `string`,                     `description`: `State or province where the client device is located.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientCountryOrRegion`,                     `type`: `string`,                     `description`: `Country or region where the client device is located.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ClientBrowser`,                     `type`: `string`,                     `description`: `Browser running on the client device.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ResourceGUID`,                     `type`: `string`,                     `description`: `Unique, persistent identifier of an Azure resource.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `IKey`,                     `type`: `string`,                     `description`: `Instrumentation key of the Azure resource.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `SDKVersion`,                     `type`: `string`,                     `description`: `Version of the SDK used by the application to generate this telemetry item.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `ItemCount`,                     `type`: `int`,                     `description`: `Number of telemetry items represented by a single sample item.`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 },                 {                     `name`: `SourceSystem`,                     `type`: `string`,                     `isDefaultDisplay`: true,                     `isHidden`: false                 }             ],             `solutions`: [                 `LogManagement`             ],             `isTroubleshootingAllowed`: false         },         `provisioningState`: `Succeeded`,         `retentionInDays`: 90     },     `id`: `/subscriptions/57c1b396-5b86-4aef-9148-d74c91181b02/resourceGroups/REDACTED/providers/Microsoft.OperationalInsights/workspaces/REDACTED/tables/AppEvents`,     `name`: `AppEvents` }  Expected behavior The JSON should be deserialized correctly. Actual behavior A JsonElementWrongTypeException is thrown. Reproduction Steps The example here https://learn.microsoft.com/en-us/rest/api/loganalytics/tables/get?tabs=dotnet#tablesget doesn't work. Environment Console App running on .NET 7
Mgmt	Compute	[BUG] System.UriFormatException is thrown when list galleries	Library name and version Azure.ResourceManager.Compute 1.1.0 Describe the bug The SDK throws exception System.UriFormatException if the `publisherUri` field of a community gallery is not an URI. Please note Azure portal does not check the URI when creating the gallery. Got Azure Exception in: AzureRmClientWrapper.GetGalleriesAsync, try handle it: System.UriFormatException: Invalid URI: The format of the URI could not be determined.    at System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind)    at Azure.ResourceManager.Compute.Models.CommunityGalleryInfo.DeserializeCommunityGalleryInfo(JsonElement element)    at Azure.ResourceManager.Compute.Models.SharingProfile.DeserializeSharingProfile(JsonElement element)    at Azure.ResourceManager.Compute.GalleryData.DeserializeGalleryData(JsonElement element)    at Azure.ResourceManager.Compute.GalleryCollection.<GetAllAsync>b__9_2(JsonElement e)    at Azure.Core.PageableHelpers.PageableImplementation`1.<GetAsyncEnumerator>d__15.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.GetResult(Int16 token)    at System.Linq.AsyncEnumerable.SelectEnumerableAsyncIterator`2.<MoveNextCore>d__7.MoveNext() in /_/Ix.NET/Source/System.Linq.Async/System/Linq/Operators/Select.cs:line 221 --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Linq.AsyncIteratorBase`1.<MoveNextAsync>d__8.MoveNext() in /_/Ix.NET/Source/System.Linq.Async/System/Linq/AsyncIterator.cs:line 70 --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Linq.AsyncIteratorBase`1.<MoveNextAsync>d__8.MoveNext() in /_/Ix.NET/Source/System.Linq.Async/System/Linq/AsyncIterator.cs:line 75 --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Linq.AsyncEnumerableEx.<DoCore>d__56`1.MoveNext() in /_/Ix.NET/Source/System.Interactive.Async/System/Linq/Operators/Do.cs:line 310   Expected behavior No exception Actual behavior System.UriFormatException thrown Reproduction Steps Create a gallery whose `publisherUri` is not a valid URL, e.g. `Not.a.valid.uri` Environment No response
Client	Schema Registry	[QUERY] [Schema Registry] Client credential overloads	Library name and version Azure.Data.SchemaRegistry Query/Question It seems quite common that HTTP based SDK client types provide constructor overloads of the following form SdkClient(Uri endpoint, AzureKeyCredential credential) SdkClient(Uri endpoint, AzureKeyCredential credential, SdkClientOptions options) SdkClient(Uri endpoint, TokenCredential credential, SdkClientOptions options = default) SdkClient(Uri endpoint, AzureSasCredential credential, SdkClientOptions options = default) is there a reason the SchemaRegistryClient does only provide overloads for TokenCredential and SchemaRegistryClientOptions but not for key credential or SAS credential? Environment No response
Client	Azure.Core	[QUERY] Why are some ResponseError fields internal?	Library name and version Azure.Core 1.34.0 Query/Question I'm migrating code that uses Track 1 SDKs to use Track 2 SDKs. The code captures all of the fields listed here in track 1's ErrorResponse: namespace Microsoft.Azure.Management.ResourceManager.Models {   /// <summary>Error Response</summary>   /// <remarks>   /// Common error response for all Azure Resource Manager APIs to return   /// error details for failed operations. (This also follows the OData error   /// response format.)   /// </remarks>   public class ErrorResponse   {     /// <summary>     /// Initializes a new instance of the ErrorResponse class.     /// </summary>     public ErrorResponse()     {     }      /// <summary>     /// Initializes a new instance of the ErrorResponse class.     /// </summary>     /// <param name=`code`>The error code.</param>     /// <param name=`message`>The error message.</param>     /// <param name=`target`>The error target.</param>     /// <param name=`details`>The error details.</param>     /// <param name=`additionalInfo`>The error additional info.</param>     public ErrorResponse(       string code = null,       string message = null,       string target = null,       IList<ErrorResponse> details = null,       IList<ErrorAdditionalInfo> additionalInfo = null)     {       this.Code = code;       this.Message = message;       this.Target = target;       this.Details = details;       this.AdditionalInfo = additionalInfo;     }      /// <summary>Gets the error code.</summary>     [JsonProperty(PropertyName = `code`)]     public string Code { get; private set; }      /// <summary>Gets the error message.</summary>     [JsonProperty(PropertyName = `message`)]     public string Message { get; private set; }      /// <summary>Gets the error target.</summary>     [JsonProperty(PropertyName = `target`)]     public string Target { get; private set; }      /// <summary>Gets the error details.</summary>     [JsonProperty(PropertyName = `details`)]     public IList<ErrorResponse> Details { get; private set; }      /// <summary>Gets the error additional info.</summary>     [JsonProperty(PropertyName = `additionalInfo`)]     public IList<ErrorAdditionalInfo> AdditionalInfo { get; private set; }   } } Track 2's Azure.ResponseError only exposes Code and Message, while other fields like Details, Target, and InnerError are internal. I am wondering what's the reason behind keeping these internal and if there's any way these can be accessed directly? I see ToString() will print all of these fields to a string but there's no control over that output or ability to narrow down the data to distinct fields. The error handling code I'm working with captures all of these fields to distinct fields elsewhere. Environment No response
Client	Event Hubs	PartitionContext.PartitionId Data Type	Library name and version Azure.Messaging.EventHubs v5.9.3 Query/Question Is there a reason why the PartitionContext.PartitionId property is of type string instead of int? My question applies specifically to the message consumer -- Every message must come through a partition, so I imagine the property will always be set to the int number of the partition in which the message was stored. Is that correct? Or is there a scenario where null, empty, or some other string value might come through that field? I suppose the same question might be asked of the producer as well: I know the PartitionId can be specifically set, or left blank. Is there a reason why it's a string instead of a Nullable<int>? Environment N/A
Client	Azure.Core	[QUERY] Dependencies mayhem	Library name and version Azure.Core 1.35.0 Query/Question I think the dependencies for this project can be cleaned up at least for .net core 3 and up. These packages are not needed they are only needed on .netstandard and everything before .net core 3: [Microsoft.Bcl.AsyncInterfaces](https://www.nuget.org/packages/Microsoft.Bcl.AsyncInterfaces/) (>= 1.1.1) [System.Diagnostics.DiagnosticSource](https://www.nuget.org/packages/System.Diagnostics.DiagnosticSource/) (>= 6.0.1) [System.Memory.Data](https://www.nuget.org/packages/System.Memory.Data/) (>= 1.0.2) [System.Numerics.Vectors](https://www.nuget.org/packages/System.Numerics.Vectors/) (>= 4.5.0) [System.Text.Encodings.Web](https://www.nuget.org/packages/System.Text.Encodings.Web/) (>= 4.7.2) [System.Text.Json](https://www.nuget.org/packages/System.Text.Json/) (>= 4.7.2) [System.Threading.Tasks.Extensions](https://www.nuget.org/packages/System.Threading.Tasks.Extensions/) (>= 4.5.4)  Provides the IAsyncEnumerable and IAsyncDisposable interfaces and helper types for .NET Standard 2.0. This package is not required starting with .NET Standard 2.1 and .NET Core 3.0. Microsoft.Bcl.AsyncInterfaces  Some of the packages you're forcing for everybody are like 7 years old. Environment .NET SDK: Version:   7.0.308 Commit:    f6a2f50f2d Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.308\ Host: Version:      7.0.11 Architecture: x64 Commit:       ecb34f85ec .NET SDKs installed: 6.0.414 [C:\Program Files\dotnet\sdk] 7.0.111 [C:\Program Files\dotnet\sdk] 7.0.302 [C:\Program Files\dotnet\sdk] 7.0.308 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.22 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.22 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.22 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Drop support for end-of-life targets And maybe even start considering dropping support for all those versions that are out off support for years, according to your own support policy:  .NET Core 2.1 ended support Augustus 21th 2021 which is over 2 years ago. .NET5 ended support May 10th 2022 which is also over 16 months ago .NET 4.6.1 ended support on April 26th 2022 according to this page which is 17 months ago.  Remove high severity vulnerabilities Packages.Data.props seem to be forcing <PackageReference Update=`Newtonsoft.Json` Version=`10.0.3` /> which according to nuget has at least 1 high severity vulnerability Check PR #38885 for more comments
Client	Cognitive - Form Recognizer	[QUERY] FormRecognizer - How Can I get an Output Like in the Studio? (paragraphs/tables in order per page)	Library name and version Azure.AI.FormRecognizer 4.1.0.0 Query/Question Currently results returns `pages` which has `lines` There is also an output called `paragraphs` There is also an output `tables` The data in `tables` also shows up in `paragraphs`. I want a data structure that is:  page  paragraph table paragraph    As they show up on the page. Which is how the studio represents the data:  What can I do to make the data output appear like it does in studio? Where the paragraphs and tables are in the right order with no overlapping data? This is my current request code:  // NOTE: Ensure the client variable for the Form Recognizer is instantiated elsewhere in the program     AnalyzeDocumentOperation operation = await client.AnalyzeDocumentAsync(WaitUntil.Completed, `prebuilt-layout`, stream);     AnalyzeResult result = operation.Value;  Environment .NET 6.0 running on linux containers, and Visual Studio locally on Windows.
Client	Azure.Core	[BUG] TelemetryDetails.EscapeProductInformation throws FileNotFoundException (System.Net.Http)	Library name and version Azure.Core 1.35.0 Describe the bug I'm trying to use Azure.Storage.Blobs 12.13.0, together with 12.12.0, and Azure.Core 1.35.0. Unfortunately they seem to be blowing up while creating telemery for my HTTP pipeline that they're about to use to send requests to blob storage :-(. Description: The process was terminated due to an unhandled exception. Exception Info: System.IO.FileNotFoundException at Azure.Core.TelemetryDetails.EscapeProductInformation(System.String) at Azure.Core.TelemetryDetails.GenerateUserAgentString(System.Reflection.Assembly, System.String, Azure.Core.RuntimeInformationWrapper) at Azure.Core.TelemetryDetails..ctor(System.Reflection.Assembly, System.String, Azure.Core.RuntimeInformationWrapper) at Azure.Core.Pipeline.HttpPipelineBuilder.CreateTelemetryPolicy(Azure.Core.ClientOptions) at Azure.Core.Pipeline.HttpPipelineBuilder.BuildInternal(Azure.Core.Pipeline.HttpPipelineOptions, Azure.Core.Pipeline.HttpPipelineTransportOptions) at Azure.Core.Pipeline.HttpPipelineBuilder.Build(Azure.Core.ClientOptions, Azure.Core.Pipeline.HttpPipelinePolicy[], Azure.Core.Pipeline.HttpPipelinePolicy[], Azure.Core.ResponseClassifier) at Azure.Storage.StorageClientOptions.Build(Azure.Core.ClientOptions, Azure.Core.Pipeline.HttpPipelinePolicy, System.Uri) at Azure.Storage.Blobs.Specialized.BlobBaseClient..ctor(System.Uri, Azure.Core.Pipeline.HttpPipelinePolicy, Azure.Storage.Blobs.BlobClientOptions, Azure.Storage.StorageSharedKeyCredential) Based on the latest code I see for this, I have no idea how it could get a FileNotFoundException, so I suppose next logical thing to do is update to a newer version of Azure.Core.... except Azure.Core 1.35.0 is the latest one, isn't it? Expected behavior No crash (I wish) Actual behavior Could not load file or assembly 'System.Net.Http, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The system cannot find the file specified. Reproduction Steps Run in production, trying to authenticate with ManagedIdentity to storage, at startup time, to download a blob.                     Uri blobServiceUri = new Uri(new Uri(blobUrl, UriKind.Absolute).GetLeftPart(UriPartial.Authority), UriKind.Absolute);                     var tmpBlob = new BlobClient(new Uri(blobUrl));                     var client = new BlobServiceClient(blobServiceUri, new DefaultAzureCredential());                     var bsc = client.GetBlobContainerClient(tmpBlob.BlobContainerName).GetBlobClient(tmpBlob.Name);                     var ms = new MemoryStream();                     var response = bsc.DownloadTo(ms);                     Logger.LogInfo($`download response is {response.Status}`);  Environment Windows Server 2022's default install of .Net Framework.
Client	Cognitive - Form Recognizer	[QUERY] Is it possible to deserialize stored JSON result into AnalyzeResult?	Library name and version Azure.AI.FormRecognizer 4.1.0.0 Query/Question For unit testing processing of an Azure.AI.FormRecognizer.DocumentAnalysis.AnalyzeResult, I would like to be able to load a static JSON value and create an instance of AnalyzeResult. The use case is unit testing processing of sample responses from document analysis. I have stored the JSON string locally as a file to load for processing.  In my unit test, I load the contents of the JSON file.  However, there does not seem to be a clear path to constructing an AnalyzeResult instance from this JSON. From what I can tell:  There is no public, parameterless constructor that would allow deserialization via System.Text.Json The DeserializeAnalyzeResult(JsonElement element) static method is marked internal AnalyzeResultOperation.DeserializeAnalyzeResultOperation(JsonElement element) static method is marked internal DocumentAnalysisModelFactory.AnalyzeResult() does not allow input of a JSON model The mock tests rely on an unpublished library Azure.Core.TestFramework so the test samples cannot be used without pulling the repo. Several of the dependent classes in the TestFramework like DictionaryHeader are marked as internal in Azure.Core.  The workaround is to manually load the JSON and select the elements to feed into DocumentAnalysisModelFactory.  However, this is quite tedious as it requires building up the model from the ground up.
Client	Azure.Core	[BUG] Azure.Response's HasValue property always returns true, even when the underlying value is null	Library name and version Azure.Storage.Queues 12.14.0 Describe the bug When calling QueueClient.ReceiveMessage() on an empty queue, Response.HasValue returns true even though the inner message is null. This is the case with either Azurite local queue or a live instance of Azure Storage. Is this just my misunderstanding what the Azure.Response object is supposed to be? Sample code: var queueClient = new QueueClient(connectionString, queueName, new QueueClientOptions {     MessageEncoding = QueueMessageEncoding.Base64 });  //set up test queue queueClient.Create();  var response = queueClient.ReceiveMessage(); // no messages in fresh queue Console.WriteLine(response.HasValue) // should be false, but is true  response.Value.Body; // NullReferenceException  Expected behavior Response.HasValue = false Actual behavior Response.HasValue = true Reproduction Steps See sample code above. Environment No response
Client	Monitor	[FEATURE REQ] Require Overload for QueryResourceAsync with QueryTimeRange as optional so that the time range can be included in the query	Library name Azure.Monitor.Query Please describe the feature. As of now, the QueryResourceAsync method of the LogsQueryClient in Azure.Monitor.Query accepts the query and the time range separately. It would be good to have an overload that accepts the time range as part of the query and hence the time range parameter can be ignored. This will simplify automating the queries generation and avoid additional parsing to extract time range just for the need to pass it as a aparam
Mgmt	Cost Management - Query	[BUG] ExportDataset.Columns is read-only and has no setter	Library name and version Azure.ResourceManager.CostManagement 1.0.0 Describe the bug The Columns property in Azure.ResourceManager.CostManagement.Models.ExportDataset has a getter but no setter This prevents a user from being able to define which columns they want when setting up a Cost Export. Expected behavior It should be possible to set a value for Columns Actual behavior Cannot define/set a list of columns for a cost export. Error CS0200 Property or indexer 'ExportDataset.Columns' cannot be assigned to -- it is read only  Reproduction Steps IList<string> listOfColumns; listOfColumns.Add(`BillingAccountId`);  var exportProperties = new CostManagementExportData {     Format = ExportFormatType.Csv,     Definition = new ExportDefinition(ExportType.AmortizedCost, TimeframeType.Custom)     {         DataSet = new ExportDataset()         {             Columns = listOfColumns,  //<<<<<<<<<< fails here             Granularity = GranularityType.Daily,         },         ExportType = ExportType.AmortizedCost,         Timeframe = TimeframeType.Custom,         TimePeriod = new ExportTimePeriod(DateTimeOffset.MinValue, DateTimeOffset.MaxValue),     },     Schedule = new ExportSchedule()     {         Status = ExportScheduleStatusType.Inactive     },     DeliveryInfoDestination = new ExportDeliveryDestination(container)     {         Container = container,         ResourceId = storageId,         RootFolderPath = exportType     } }; Environment Hosting platform PS C:\Users\me> dotnet --info .NET SDK:  Version:   7.0.400  Commit:    73bf45718d  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\7.0.400\  Host:   Version:      7.0.10   Architecture: x64   Commit:       a6dbb800a4  .NET SDKs installed:   7.0.400 [C:\Program Files\dotnet\sdk]   IDE Microsoft Visual Studio Professional 2022 (64-bit) - Current Version 17.7.2
Client	Event Hubs	[QUERY] Reason why ProcessEventArgs is a struct instead of a record/class	Library name and version Azure.Messaging.EventHubs Query/Question Referring to ProcessEventArgs.cs. This is a question of simple curiosity - is there any particular reason why ProcessEventArgs is a struct? What drives a decision to choose one over another in a case scenario like this? Various .NET EventArgs are classes, and my colleague and I have been wondering about this particular choice. If performance is the main concern, and given that an enormous amount of eventargs objects are created every minute, would then heap allocation overhead significantly worsen the performance? On the other hand, aren't we risking blowing up the stack because of this? Or would JIT take care of this (still better than heap overhead?) Perhaps this isn't even that big of a deal, I mean, we only store a boolean, two references, a token and a delegate. Surely that's small enough to warrant the use of a struct. And if event args contained data directly and have an arbitrary size, I assume this would immediately become a reference type. Or would it? Apologies in advance, since I am not that familiar with the EventHub infrastructure, or maybe I have already answered myself, but it still felt like a good educational opportunity:-) Environment No response
Client	Storage	[BUG] Blob copy from StorageAccount (on Azure) and local Azurite	Library name and version Azure.Storage.Blobs 12.17.0 Describe the bug If a try to copy a Blob from a container on Azure to my local Azurite I get the following error:  If I change the target container to a storage account on Azure, everything works. Here is a snippet of my code: var sourceBlob = new BlobContainerClient(`sourceconnectionstring`, `sourcecontainername`)     .GetBlobClient(`sourceblob`); var sourceBlobSasToken = sourceBlob.GenerateSasUri(BlobSasPermissions.All, DateTimeOffset.Now.AddHours(10));  var targetBlob = new BlobContainerClient(`targetconnectionstring`, `targetcontainername`)     .GetBlobClient(`targetblob`);  var copyOperation = await targetBlob.StartCopyFromUriAsync(sourceBlobSasToken,     options: new BlobCopyFromUriOptions() { }, ct); await copyOperation.WaitForCompletionAsync(ct); If I go on my azurite docker container, I see a PUT request that fails with 404. I've also enabled public access level to: `Public read access for container and blobs` on my container in Azurite. Expected behavior Copy a blob from StorageAccount (on Azure) to my local Azurite. Actual behavior I got an exception from the SDK saying that specified resource does not exist. Reproduction Steps Just run the code pasted above using as target blob Azurite and source blob a StorageAccount on Azure. Environment No response
Client	Azure.Identity	[QUERY] Best practices for implementing `TokenCredential` class.	Library name and version Azure.Core 1.34.0 Query/Question Query What are some best practices we need to adhere to while implementing the TokenCredential abstract class. We have our own logic of fetching tokens from AAD by calling a different RP. Do we have to include any sort of caching mechanism? Also, there are two methods GetTokenAsync and GetToken. What is the significance of implementing the non-async method here? Will it be just like calling the async method and waiting for completion? Environment No response
Client	Tables	[BUG] TableClient query does not filter nullable DateTimeOffset properties correctly using LINQ	Library name and version Azure.Data.Tables 12.8.1 Describe the bug I'm using the TableClient to get records of a table and some records are not returned even though they meet the conditions defined on the filter. Behaviour is different for CosmosDB and for Table Storage. It happens with DateTimeOffset? but I noticed a the same behaviour with Guid?. Let's say I have two records, one with a date and another one with no date. var notAnonymizedRecords = await tableClient     .QueryAsync<SomeRecord>(x => x.AnonymizedAt == null)     .ToListAsync();  var anonymizedRecords = await tableClient     .QueryAsync<SomeRecord>(x => x.AnonymizedAt != null)     .ToListAsync();  Console.WriteLine($`NotAnonymized records: {notAnonymizedRecords.Count}`); Console.WriteLine($`Anonymized records: {anonymizedRecords.Count}`);  Expected behavior NotAnonymized records: 1 Anonymized records: 1  Actual behavior In Cosmos: NotAnonymized records: 0 Anonymized records: 1  In Table Storage NotAnonymized records: 1 Anonymized records: 0  Reproduction Steps You can try both Cosmos/Table storage using a console app. Table connection string is the default for the emulator. Cosmos connection string is the default for the emulator if you start it with the table api: https://learn.microsoft.com/en-us/azure/cosmos-db/local-emulator?tabs=ssl-netstd21#api-for-table using Azure; using Azure.Data.Tables;  // Cosmos emulator connectionString //var connectionString = `DefaultEndpointsProtocol=http;AccountName=localhost;AccountKey=C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw==;TableEndpoint=http://localhost:8902/;`;  // Table connectionString var connectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;TableEndpoint=http://localhost:10002/devstoreaccount1;`;  var tableServiceClient = new TableServiceClient(connectionString); await tableServiceClient.DeleteTableAsync(`SomeTable`);  var tableClient = tableServiceClient.GetTableClient(`SomeTable`); await tableClient.CreateIfNotExistsAsync();  var someNotAnonymizedRecord = new SomeRecord {     PartitionKey = Guid.NewGuid().ToString(),     RowKey = Guid.NewGuid().ToString() }; var someAnonymizedRecord = new SomeRecord {     PartitionKey = Guid.NewGuid().ToString(),     RowKey = Guid.NewGuid().ToString(),     AnonymizedAt = DateTimeOffset.Now };  await tableClient.AddEntityAsync(someNotAnonymizedRecord); await tableClient.AddEntityAsync(someAnonymizedRecord);  var records = await tableClient     .QueryAsync<SomeRecord>()     .ToListAsync(); var notAnonymizedRecords = await tableClient     .QueryAsync<SomeRecord>(x => x.AnonymizedAt == null)     .ToListAsync(); var anonymizedRecords = await tableClient     .QueryAsync<SomeRecord>(x => x.AnonymizedAt != null)     .ToListAsync();  Console.WriteLine($`Total records: {records.Count}`); Console.WriteLine($`NotAnonymized records: {notAnonymizedRecords.Count}`); Console.WriteLine($`Anonymized records: {anonymizedRecords.Count}`); Console.ReadKey();  class SomeRecord : ITableEntity {     public string PartitionKey { get; set; }     public string RowKey { get; set; }     public DateTimeOffset? Timestamp { get; set; }     public ETag ETag { get; set; }     public DateTimeOffset? AnonymizedAt { get; set; } };  static class Extensions {     public static async Task<List<SomeRecord>> ToListAsync(this AsyncPageable<SomeRecord> records)     {         var list = new List<SomeRecord>();         await foreach (var record in records)         {             list.Add(record);         }         return list;     } }  Environment .NET SDK (reflecting any global.json): Version:   6.0.413 Commit:    10710f7d8e Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.413\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4 .NET SDKs installed: 6.0.413 [C:\Program Files\dotnet\sdk] 7.0.100-rc.2.22477.23 [C:\Program Files\dotnet\sdk] 7.0.100 [C:\Program Files\dotnet\sdk] 7.0.307 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.0-rc.2.22476.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.0-rc.2.22472.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.0-rc.2.22472.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: C:\Repos\Roomz\dotnet-monorepo\global.json
Client	Event Hubs	[QUERY] What happens if two Eventhub Trigger Functions use one EventHubs consumer group？	Library name and version Microsoft.Azure.WebJobs.Extensions.EventHubs 5.0.0 Query/Question Hi, team, According to this doc, it says:  in certain scenarios, you may use up to five consumers or receivers per partition where all receivers get all the events of the partition.  But in this doc, it says:  Don't share consumer groups between function apps and other consumer applications. Each function app should be a distinct application with its own assigned consumer group to ensure offset integrity for each consumer and to simplify dependencies in an event streaming architecture. Such a configuration, along with providing each event hub-triggered function its own function app and storage account, helps set the foundation for optimal performance and scaling.  It seems if the total Eventhub Trigger Functions are no more than 5, it would be fine to let them use one consumer group. I don't know if I understand correct, please help explain~~ Thanks~ Environment No response
Client	Service Bus	[BUG] High threadcount	Library name and version Azure.Messaging.ServiceBus 7.15.0 Describe the bug We're using this SDK inside of an InRiver ServerExtension. This platform comes with some quirks, one of them being: we're not allowed to spin up threads. We recently got an email from InRiver stating that we've exceeded over 84K threads. After some research, we found that we have one extension using tasks, we paused that and the issue went away. To solve this problem, we rolled our own Synchronization context, that prevents threading. However, that doesn't seem to fix the problem. Even in idle state. It appears the ServiceBusClient or ServiceBusSender has it's own threadpool, or at least it's own logic of accessing the threadpool and scheduling concurrent calls. We can't have that. I can see that in the deprecated Microsoft.Azure.ServiceBus there is a setting for max concurrent calls. However, I can't find this setting in the new library. I also tried using a ServiceBusSessionProcessor and clamping that to 1 session with 1 concurrent call per session, but that doesn't seem to do anything at all. Expected behavior I'd expect the ServiceBus SDK to respect the SynchronizationContext. Alternatively, I'd expect a setting where I can disable threading, or set the max amount of threads. Actual behavior A wild growth of threads. Reproduction Steps Create an IEntityListener on an InRiver server that pushes a basic model to a service bus on product update. Environment net48
Client	Azure.Identity	Value of constant AUTH_RECORD_PATH not explained	How is this value established? In order to check for existence of token at app start I need to know the path, on my dev system it's C:\Users\[Windows User Name]\AppData\Local\.IdentityService\O365_FSMail_TokenCache.nocae So can it always be built from  [C:\Users\[Windows User Name]\AppData\Local\.IdentityService][TokenCachePersistenceOptions.Name].nocae E.g. for user `TestUser` and TokenCachePersistenceOptions.Name=`TestToken` will it always be `C:\Users\TestUser\AppData\Local\.IdentityService\TestToken.nocae`  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 8b7f06c2-e869-c455-4b39-babf320bd343 Version Independent ID: b99cd14e-64ff-7b0c-0538-1da1eca887b9 Content: TokenCachePersistenceOptions Class (Azure.Identity) - Azure for .NET Developers Content Source: xml/Azure.Identity/TokenCachePersistenceOptions.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Mgmt	App Services	[BUG] GetSiteDetectors GetAll - json parsing throws error	Library name and version Azure.ResourceManager.AppService 1.0.2 Describe the bug ResourceIdentifier webSiteResourceId =     WebSiteResource.CreateResourceIdentifier(subscriptionId, resourceGroupName, siteName); WebSiteResource webSite = client.GetWebSiteResource(webSiteResourceId);  var collection = webSite.GetSiteDetectors(); var all = collection.GetAll();  System.InvalidOperationException: The requested operation requires an element of type 'Array', but the target element has type 'String'. this is the debug: in DetectorInfo DeserializeDetectorInfo(JsonElement element): ValueKind = Object : `{`id`:`netcorestartupfailures`,`name`:`.NET Core Startup Failures`,`description`:`Recognize common startup failures, get exception messages and stack traces from startup failure events for ASP.NET core apps.`,`author`:``,`category`:null,`supportTopicList`:[],`analysisType`:`appDownAnalysis`,`typeId`:`3c46bb93-6dff-4048-9904-8fcd535679e9`,`analysisTypes`:[`appDownAnalysis`],`type`:`Detector`,`score`:0}` property.Value = ValueKijnd = string ``analysisType`:`appDownAnalysis``             if (property.NameEquals(`analysisType`u8))             {                 if (property.Value.ValueKind == JsonValueKind.Null)                 {                     continue;                 }                 List<string> array = new List<string>();                 foreach (var item in property.Value.EnumerateArray())  in enumerate array it goes to throw public ArrayEnumerator EnumerateArray() { CheckValidInstance();         JsonTokenType tokenType = TokenType;          if (tokenType != JsonTokenType.StartArray)         {             **throw ThrowHelper.GetJsonElementWrongTypeException(JsonTokenType.StartArray, tokenType);**         }          return new ArrayEnumerator(this);     }  Expected behavior it shouldnt throw an error Actual behavior Exception was thrown System.InvalidOperationException: The requested operation requires an element of type 'Array', but the target element has type 'String'. Reproduction Steps ResourceIdentifier webSiteResourceId =     WebSiteResource.CreateResourceIdentifier(subscriptionId, resourceGroupName, siteName); WebSiteResource webSite = client.GetWebSiteResource(webSiteResourceId);  var collection = webSite.GetSiteDetectors(); var all = collection.GetAll();  Environment NET6.0 using the latest sdk version 1.0.2 also tried the beta version 1.1.0-beta.1 still didn't work
Client	Azure.Identity	[FEATURE REQ] Expose specifying region for authority url with TokenCredentialOptions	Library name Azure.Identity Please describe the feature. Currently to make use of MSAL's WithAzureRegion, one has to set the environmental variable AZURE_REGIONAL_AUTHORITY_NAME . This is not intuitive . Inferring the region specific url for the login endpoint should be exposed via TokenCredentialOptions TokenCredentialOptions already provides option for specifying AuthorityHost, There should be an option for Region. Please consider exposing it in addition to the current environmental variable usage.
Mgmt	App Services	[BUG] Azure.ResourceManager.AppService.Models.SiteConfigProperties serializable issue	Library name and version Azure.ResourceManager.AppService 1.0.2 Describe the bug Serializing SiteConfigProperties seems to cause a side effect that prevents persisting WebSiteData changes. This issue occurs using JSON.Net and System.Text.Json. Expected behavior Serializing SiteConfigProperties shouldn't introduce problems. Actual behavior Azure.RequestFailedException HResult=0x80131500 Message=Service request failed. Status: 500 (Internal Server Error) Content: {`Message`:`An error has occurred.`} Headers: Cache-Control: no-cache Pragma: no-cache Strict-Transport-Security: REDACTED X-AspNet-Version: REDACTED X-Powered-By: REDACTED x-ms-failure-cause: REDACTED x-ms-ratelimit-remaining-subscription-resource-requests: REDACTED x-ms-request-id: 1e954df3-8e52-4954-88ac-f02babe44a7d x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED X-Content-Type-Options: REDACTED X-Cache: REDACTED X-MSEdge-Ref: REDACTED Date: Fri, 01 Sep 2023 19:02:27 GMT Content-Length: 36 Content-Type: application/json; charset=utf-8 Expires: -1 Source=Azure.ResourceManager.AppService StackTrace: at Azure.ResourceManager.AppService.WebAppsRestOperations.d__15.MoveNext() at Azure.ResourceManager.AppService.WebSiteCollection.d__5.MoveNext() at Program.<$>d__0.MoveNext() in C:\Users\TomBrothers\source\repos\AppServiceTest\AppServiceTest\Program.cs:line 43 Reproduction Steps using Azure; using Azure.Core; using Azure.Identity; using Azure.ResourceManager; using Azure.ResourceManager.AppService; using Azure.ResourceManager.AppService.Models; using Azure.ResourceManager.Resources;  var resourceGroupName = `csappplans`; var appServicePlanName = `csappplan0`; var armClient = new ArmClient(new DefaultAzureCredential(new DefaultAzureCredentialOptions { #if DEBUG     ExcludeManagedIdentityCredential = true,     ExcludeEnvironmentCredential = true, #endif })); var resourceGroupResourceIdentifier = ResourceGroupResource.CreateResourceIdentifier(     armClient.GetDefaultSubscription().Id.SubscriptionId,     resourceGroupName ); var appServicePlanResourceIdentifier = AppServicePlanResource.CreateResourceIdentifier(     resourceGroupResourceIdentifier.SubscriptionId,     resourceGroupResourceIdentifier.ResourceGroupName,     appServicePlanName ); var webSiteResourceIdentifier = WebSiteResource.CreateResourceIdentifier(     resourceGroupResourceIdentifier.SubscriptionId,     resourceGroupResourceIdentifier.ResourceGroupName,     $`devtest{DateTime.Now:yyyyMMddHHmmss}` ); var resourceGroupResource = armClient.GetResourceGroupResource(resourceGroupResourceIdentifier); var webSiteCollection = resourceGroupResource.GetWebSites(); var newWebSiteData = new WebSiteData(AzureLocation.EastUS) {     AppServicePlanId = appServicePlanResourceIdentifier,     SiteConfig = new SiteConfigProperties() };  Console.WriteLine(Newtonsoft.Json.JsonConvert.SerializeObject(newWebSiteData)); //Console.WriteLine(System.Text.Json.JsonSerializer.Serialize(newWebSiteData));  var operation = await webSiteCollection.CreateOrUpdateAsync(     WaitUntil.Completed,     webSiteResourceIdentifier.Name,     newWebSiteData ); var webSiteData = operation.Value.Data;   Console.ReadLine();  Environment .NET SDK: Version:   7.0.307 Commit:    7b77e35a2b Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.307\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4 .NET SDKs installed: 7.0.307 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 5.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found
Client	Storage	[BUG]usBatchset Blob access tier to archive will report BlobAccessTierNotSupportedForAccountType 400 error.	Library name and version Azure.Storage.Blobs.Batch      12.14.0 Describe the bug set Blob access tier to archive will report error. https://learn.microsoft.com/en-us/dotnet/api/overview/azure/storage.blobs.batch-readme?view=azure-dotnet#setting-access-tiers // Set the access tier for all three blobs at once BlobBatchClient batch = service.GetBlobBatchClient(); batch.SetBlobsAccessTier(new Uri[] { foo.Uri, bar.Uri, baz.Uri }, AccessTier.Cool); batch.SetBlobsAccessTier(new Uri[] { foo.Uri, bar.Uri, baz.Uri }, AccessTier.Cold); batch.SetBlobsAccessTier(new Uri[] { foo.Uri, bar.Uri, baz.Uri }, AccessTier.Archive); C:\Users\danliu1\MyApp>dotnet list package Project 'MyApp' has the following package references [net7.0]: Top-level Package                Requested   Resolved  Azure.Storage.Blobs            12.17.0     12.17.0 Azure.Storage.Blobs.Batch      12.14.0     12.14.0  C:\Users\danliu1\MyApp>dotnet run Unhandled exception. System.AggregateException: 1 batch operation(s) failed. (Blob access tier is not supported on this storage account type. RequestId:c1fe1549-801e-0023-0fae-dcadba1eeca4 Time:2023-09-01T08:27:07.3660966Z Status: 400 (Blob access tier is not supported on this storage account type.) ErrorCode: BlobAccessTierNotSupportedForAccountType Content: ? BlobAccessTierNotSupportedForAccountTypeBlob access tier is not supported on this storage account type. RequestId:c1fe1549-801e-0023-0fae-dcadba1eeca4 Time:2023-09-01T08:27:07.3660966Z Headers: x-ms-error-code: BlobAccessTierNotSupportedForAccountType x-ms-request-id: c1fe1549-801e-0023-0fae-dcadba1eeca4 x-ms-version: 2023-01-03 x-ms-client-request-id: feb0496a-b162-4a7c-a328-f341a68996fb Content-Length: 273 Content-Type: application/xml Server: Windows-Azure-Blob/1.0 ) ---> Azure.RequestFailedException: Blob access tier is not supported on this storage account type. RequestId:c1fe1549-801e-0023-0fae-dcadba1eeca4 Time:2023-09-01T08:27:07.3660966Z Status: 400 (Blob access tier is not supported on this storage account type.) ErrorCode: BlobAccessTierNotSupportedForAccountType Content: ? BlobAccessTierNotSupportedForAccountTypeBlob access tier is not supported on this storage account type. RequestId:c1fe1549-801e-0023-0fae-dcadba1eeca4 Time:2023-09-01T08:27:07.3660966Z Headers: x-ms-error-code: BlobAccessTierNotSupportedForAccountType x-ms-request-id: c1fe1549-801e-0023-0fae-dcadba1eeca4 x-ms-version: 2023-01-03 x-ms-client-request-id: feb0496a-b162-4a7c-a328-f341a68996fb Content-Length: 273 Content-Type: application/xml Server: Windows-Azure-Blob/1.0 at Azure.Storage.Blobs.Specialized.BlobBatch.<>c.b__26_0(Response response) at Azure.Storage.Blobs.Specialized.DelayedResponse.SetLiveResponse(Response live, Boolean throwOnFailure) at Azure.Storage.Blobs.Specialized.BlobBatchClient.UpdateOperationResponses(IList1 messages, Response rawResponse, Boolean throwOnAnyFailure, Boolean async, CancellationToken cancellationToken) --- End of inner exception stack trace --- at Azure.Storage.Blobs.Specialized.BlobBatchClient.UpdateOperationResponses(IList1 messages, Response rawResponse, Boolean throwOnAnyFailure, Boolean async, CancellationToken cancellationToken) at Azure.Storage.Blobs.Specialized.BlobBatchClient.SubmitBatchInternal(BlobBatch batch, Boolean throwOnAnyFailure, Boolean async, CancellationToken cancellationToken) at Azure.Storage.Blobs.Specialized.BlobBatchClient.SetBlobsAccessTierInteral(IEnumerable1 blobUris, AccessTier accessTier, Nullable1 rehydratePriority, Boolean async, CancellationToken cancellationToken) at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted[T](Task1 task) at Azure.Storage.Blobs.Specialized.BlobBatchClient.SetBlobsAccessTier(IEnumerable1 blobUris, AccessTier accessTier, Nullable`1 rehydratePriority, CancellationToken cancellationToken) at Program.Main(String[] args) in C:\Users\danliu1\MyApp\Program.cs:line 31 Expected behavior set access tier to archive by Azure.Storage.Blobs.Batch will be successful Actual behavior Status: 400 (Blob access tier is not supported on this storage account type.) ErrorCode: BlobAccessTierNotSupportedForAccountType Reproduction Steps // Get a connection string to our Azure Storage account. string connectionString = `<connection_string>`; string containerName = `sample-container`; // Get a reference to a container named `sample-container` and then create it BlobServiceClient service = new BlobServiceClient(connectionString); BlobContainerClient container = service.GetBlobContainerClient(containerName); container.Create(); // Create three blobs named `foo`, `bar`, and `baz` BlobClient foo = container.GetBlobClient(`foo`); BlobClient bar = container.GetBlobClient(`bar`); BlobClient baz = container.GetBlobClient(`baz`); foo.Upload(BinaryData.FromString(`Foo!`)); bar.Upload(BinaryData.FromString(`Bar!`)); baz.Upload(BinaryData.FromString(`Baz!`)); // Set the access tier for all three blobs at once BlobBatchClient batch = service.GetBlobBatchClient(); batch.SetBlobsAccessTier(new Uri[] { foo.Uri, bar.Uri, baz.Uri }, AccessTier.Archive); Environment C:\Users\danliu1\MyApp>dotnet list package Project 'MyApp' has the following package references [net7.0]: Top-level Package                Requested   Resolved  Azure.Storage.Blobs            12.17.0     12.17.0 Azure.Storage.Blobs.Batch      12.14.0     12.14.0  C:\Users\danliu1\MyApp>dotnet --info .NET SDK: Version:   7.0.400 Commit:    73bf45718d Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.400\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4 .NET SDKs installed: 6.0.316 [C:\Program Files\dotnet\sdk] 7.0.400 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: None Environment variables: Not set global.json file: Not found Learn more: https://aka.ms/dotnet/info Download .NET: https://aka.ms/dotnet/download
Client	App Configuration	[FEATURE REQ] Add support for replicas and automatic failover for Azure.Data.AppConfiguration.ConfigurationClient	Library name Azure.Data.AppConfiguration Please describe the feature. The ConfigurationClient doesn't seem to support multiple endpoints/connection strings. I was expecting to be able to use replicas with the ConfigurationClient just like i'm able to do so with the AppConfigurationProvider in ASP.NET Core (ref: https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-geo-replication?tabs=dotnet#use-replicas). Am i missing something or there is no way to failover automatically to another replica when using the ConfigurationClient directly?
Client	Tables	[BUG] An exception is thrown when trying to load long datatype from AzureTableStorage	Library name and version Azure.Data.Tables 12.8.1 Describe the bug Hi, I have the below code await var result = this.tableClient.QueryAsync<RequestEntity>(x => x.PartitionKey == `123`).ToListAsync()  public abstract class RequestEntity: ITableEntity {     public virtual long Id { get; set; }      public virtual string Name { get; set; }      // other properties }  An exception is being thrown, when I change the `Id` from long to int. it works as expected. Expected behavior No exception should be thrown and the data should be retrieved Actual behavior An exception is being thrown, when I change the `Id` from long to int. it works as expected. Reproduction Steps Run my code Environment VS 2022 Windows 11
Mgmt	Network - Application Gateway	[BUG] Assistance using ResourceManager.ApplicationGateway	Library name and version Azure.ResourceManager.Resources 1.6.0, Azure.ResourceManager 1.7.0 Describe the bug When trying to add a new applicationGateway via ApplicationGatewayCollection.CreateOrUpdateAsync(WaitUntil.Completed, `CC-ApplicationGateway`, appdata) It returns an exception regarding the content of ApplicationGatewayFrontendIPConfiguration. The following code snippet is where the failure occurs.  public async static Task<int> AddPublicIpAddressesAsync(ResourceGroupResource resourceGroup, ApplicationGatewayData appdata)  {     PublicIPAddressCollection ipCollection = resourceGroup.GetPublicIPAddresses();     PublicIPAddressData ipConfig = new PublicIPAddressData();     ipConfig.Location = AzureLocation.WestUS;         try         {             var ips = await ipCollection.CreateOrUpdateAsync(WaitUntil.Completed, `cc-ip12344321`, ipConfig);             ApplicationGatewayFrontendIPConfiguration feConfig = new ApplicationGatewayFrontendIPConfiguration();             feConfig.PublicIPAddressId = ips.Value.Id;             feConfig.Name = `cc-ip12344321`;                          appdata.FrontendIPConfigurations.Add(feConfig);              var listen = new ApplicationGatewayHttpListener();             listen.Name = `myFirstListener`;             listen.Protocol = ApplicationGatewayProtocol.Http;             listen.FrontendIPConfigurationId = feConfig.Id;              appdata.HttpListeners.Add(listen);         }         catch (Exception e)         {             Console.WriteLine(e.Message);         }          return 0;     } If I don't call the code snippet then the add of the gateway returns that a FrontendConfiguration is required. Calling the code above the adding to the PublicIPAddressCollection works, and I see it in the portal. If I don't add any HttpListeners it returns that at least one listener is required. When I add the listener then it returns that FrontendIPConfigurationId of the listener is invalid, which it is because it is null. Since this is not a separate collection how do I get a valid FrontendIPConfigurationId? Expected behavior I should be able to add a applicationGateway Actual behavior It fails to add a applicationGateway Reproduction Steps Program.zip The AZURE_CLIENT_ID, AZURE_CLIENT_SECRET and AZURE_TENANT_ID environment variables need to be set. This sample successfully creates the virtual network and public ip address, but fails as above to create the gateway Environment Visual Studio 2022 .Net Core 6 Azure.ResourceManager.Resources 1.6.0 Azure.ResourceManager 1.7.0
Client	Azure.Identity	Update documentation for DefaultAzureCredential using Service principal with certificate	I believe that the documentation form Service principal with certificate is incorrect:    Variable name Value     AZURE_CLIENT_ID ID of an Azure AD application   AZURE_TENANT_ID ID of the application's Azure AD tenant   AZURE_CLIENT_CERTIFICATE_PATH 👉path to a PFX or PEM-encoded certificate file including private key 👈   AZURE_CLIENT_CERTIFICATE_PASSWORD (optional) the password protecting the certificate file (currently only supported for PFX (PKCS12) certificates)   AZURE_CLIENT_SEND_CERTIFICATE_CHAIN (optional) send certificate chain in x5c header to support subject name / issuer based authentication    The parseCertificate() ensures the -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- is included in the certificate file and calculates the thumbprint based on it: certificateParts.thumbprint = createHash(`sha1`)     .update(Buffer.from(publicKeys[0], `base64`))     .digest(`hex`)     .toUpperCase(); But then it also retrieves the private key: if (this.configuration.certificatePassword !== undefined) {         const privateKeyObject = createPrivateKey({           key: parts.certificateContents,           passphrase: this.configuration.certificatePassword,           format: `pem`,         });          privateKey = privateKeyObject           .export({             format: `pem`,             type: `pkcs8`,           })           .toString();       } else {         privateKey = parts.certificateContents;       } and the  parts.certificateContents is the ClientCertificatePEMCertificate or the contents of the ClientCertificatePEMCertificatePath file. This means that the AZURE_CLIENT_CERTIFICATE_PATH certificate must be a PEM file and must contain both, the certificate and the private key. I described my analysis here: AZURE_CLIENT_CERTIFICATE_PATH I also use it in my code, and the only way I made it work is with PEM file containing both. Could you please look into it and if I'm correct, update the documentation?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 91f437c5-363b-f98a-f595-5fcb9bf39d2a Version Independent ID: c6232a65-a004-428e-1ddf-84f6049ce875 Content: Azure Identity client library for .NET - Azure for .NET Developers Content Source: api/overview/azure/latest/identity-readme.md Service: identity GitHub Login: @schaabs Microsoft Alias: sschaab
Client	KeyVault	[BUG]  Azure.Security.KeyVault.Secrets GetSecret tries to spawn a child process even though it's a synchronous function.	Library name and version Azure.Security.KeyVault.Secrets Describe the bug When I call the code below as part of a word VSTO App var client = new SecretClient(new Uri($`https://some_keyvault.azure.net/`), new DefaultAzureCredential()); client.GetSecret(`some connection-connection-string`)' It is blocked by my customers IT policy because it is a word child process.  Expected behavior for the GetSecret function to not spawn a child process. Actual behavior GetSecret spawns a child process on _pipeline.SendRequest Reproduction Steps create a string you want to fetch from a keyvault using a connection string create a skeleton vsto app. your ThisAddIn_Startup should look like this private void ThisAddIn_Startup(object sender, System.EventArgs e) { var client = new SecretClient(new Uri($`https://some_keyvault.azure.net/`), new DefaultAzureCredential()); client.GetSecret(`some connection-connection-string`)' } Run the application. Environment .NET SDK: Version:   7.0.307 Commit:    7b77e35a2b Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.307\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4 .NET SDKs installed: 6.0.316 [C:\Program Files\dotnet\sdk] 7.0.307 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.21 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found
Mgmt	Recovery Services Backup	[QUERY] We are not able to get the method to retrieve files or folders within the backed up recovery point ?	Library name and version Azure.ResourceManager.RecoveryServicesBackup 1.0.0 Query/Question We used below code to get the fileshare recovery point data, now we need to get files or folders  that are backed up within this fileshare recovery point. Could you please help us ? ResourceIdentifier backupProtectedItemResourceId = BackupProtectedItemResource.CreateResourceIdentifier(subscriptionId, resourceGroupName, vaultName, fabricName, containerName, protectedItemName); BackupProtectedItemResource backupProtectedItem = client.GetBackupProtectedItemResource(backupProtectedItemResourceId);             BackupRecoveryPointCollection collection = backupProtectedItem.GetBackupRecoveryPoints();                await foreach (BackupRecoveryPointResource item in collection.GetAllAsync())             {                 FileShareRecoveryPoint resourceData = (FileShareRecoveryPoint)item.Data.Properties;             }   Environment No response
Mgmt	Subscription	[QUERY] Get SubscriptionId from SubscritionCreation before Operation Completes	Library name and version Azure.ResourceManager.Subscription 1.0.1 Query/Question How do you get the suscriptionId from the Create Process? Current Approach: Wait until creation is Completed var subscriptionOp= await tenant       .GetSubscriptionAliases()       .CreateOrUpdateAsync(         WaitUntil.Completed,         ...       );  var subscriptionId = subscriptionOp.Value.Data.Properties.SubscriptionId Desired approach: Early yielding of subscriptionId In specific scenarios it is useful to get the subscriptionId as fast as possible in order to parallelize tasks. A workflow such as the following would be used:     var subscriptionOp= await tenant       .GetSubscriptionAliases()       .CreateOrUpdateAsync(         WaitUntil.Started,         ...       );      var subscriptionId = subscriptionOp.Value.Data.Properties.SubscriptionId ;     // use subscriptionId in parallel tasks     await subscriptionOpFirst.WaitForCompletionAsync(); We know that the Azure Server is returning the subscriptionId when the SDK is calling the endpoint. But the the SDK is not filling the value in the Operation Object. Would it be possible to return the Id in an earlier step and not wait until completion of the operation? Environment .NET SDK: Version:   7.0.110 Commit:    ba920f88ac Laufzeitumgebung: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.110\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4
Client	Service Bus	[QUERY] Why ServiceBusClientOptions doesn't inherit from ClientOption?	Library name and version Microsoft.Extensions.Azure 1.7.0 Query/Question I noticed that most of sdk inherit from the abstract class ClientOption eg: SearchClientOption Is there any particular reason for ServiceBusClientOptions  to not inherit from ClientOption? Environment No response
Client	Functions	[BUG] MessageLockLostException in Microsoft.Azure.ServiceBus	Library name and version Microsoft.Azure.ServiceBus 4.2.1 Describe the bug I am deploying function app with service bus trigger. The function app has multiple functions listening with different subscriptions to same topic. Before deploying the function app to production slot, we disable the subscription using az command as the message needs to be processed only once as it does registration of user. az servicebus topic subscription update --resource-group xxx --namespace-name yyy --topic-name mytopic --name subscription --status `ReceiveDisabled` After the app is deployed we enable the subscription az servicebus topic subscription update --resource-group xxx  --namespace-name yyy  --topic-name mytopic  --name subscription  --status `Active` Expected behavior We expect all the message in the queue to be processed Actual behavior Roughly half the message throw following error message when we are trying to Complete the message Exception while executing function: CartaDispatcherSendRegistration The lock supplied is invalid. Either the lock expired, or the message has already been removed from the queue, or was received by a different receiver The subscription is set to following lockout dution : 1m 15 mins AutoComplete: Off maxAutoRenewDuration 5 mins maxConcurrentCalls: 16 (default) Max delivery count: 1 Now what is interesting is this error only occurs when I disable and enable Subscription. If I stop the function and let the queue build up and then  enable the function, there is no error. If I reduce maxConcurrentCalls down to 1, then it works fine with no errors but this has a significant impact on performance Reproduction Steps  Create a very simple app listening to a topic and subscription `using System; using System.Threading.Tasks; using Microsoft.Azure.ServiceBus.Core; using Microsoft.Azure.WebJobs; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Logging;  namespace ServiceBus { public class Function1 { private readonly ILogger _logger;     public Function1(ILogger<Function1> log)     {         _logger = log;     }      [FunctionName(`Function1`)]     public async Task Run([ServiceBusTrigger(`partition-topic`, `hello-world`, Connection  = `AzureServiceBus`)]string mySbMsg, string lockToken, MessageReceiver messageReceiver,  ILogger logger)     {         messageReceiver.PrefetchCount = 0;         messageReceiver.         _logger.LogInformation($`C# ServiceBus topic trigger function processed message: {mySbMsg}`);         Console.WriteLine(mySbMsg);         try         {             await messageReceiver.CompleteAsync(lockToken);         }         catch (Exception ex)         {             Console.WriteLine($`Error: {ex}`);             await messageReceiver.DeadLetterAsync(lockToken);         }      } }  } ` 2. Start the function app 3. Set the Subscription to ReceiveDisabled with use az or portal 4. Send some 100 test messages 5. Set the Subscription to Enable 6. See the app throw errors I am using .Net 6 Environment .NET SDK: Version:   7.0.306 Commit:    f500069cb7 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.306\ Host: Version:      7.0.9 Architecture: x64 Commit:       8e9a17b221 .NET SDKs installed: 3.1.426 [C:\Program Files\dotnet\sdk] 5.0.408 [C:\Program Files\dotnet\sdk] 5.0.414 [C:\Program Files\dotnet\sdk] 6.0.120 [C:\Program Files\dotnet\sdk] 6.0.315 [C:\Program Files\dotnet\sdk] 7.0.306 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.25 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.25 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.25 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Cognitive - Speech	Documentation question	Is Riff16Khz16BitMonoPcm the default SpeechSynthesisOutputFormat?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 5a995cd2-4e91-ff57-60d2-b45a9ae11c35 Version Independent ID: 0d7f53df-acbf-bd8f-a615-43665ea7e89b Content: SpeechConfig.SetSpeechSynthesisOutputFormat Method (Microsoft.CognitiveServices.Speech) - Azure for .NET Developers Content Source: xml/Microsoft.CognitiveServices.Speech/SpeechConfig.xml Service: cognitive-services GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Storage	[QUERY] Migration path for blob encryption from Microsoft.Azure.Storage.Blob to Azure.Storage.Blobs	Library name and version Azure.Storage.Blobs v12 Query/Question We're looking to migrate from Microsoft.Azure.Storage.Blob to Azure.Storage.Blobs but are using blob encryption. I was looking at the migration guide to see if there are any changes and/or if the encryption will be broken but this does not seem to be mentioned. Does that mean there is full parity and there is no impact? Environment No response
Client	Event Hubs	[BUG] EventReceiveError: 'At least one receiver for the endpoint is created with epoch of '0''	Library name and version Azure.Messaging.EventHubs 5.9.2 Describe the bug In the last couple of months, this error has started showing up in the logs: 'At least one receiver for the endpoint is created with epoch of '0', and so non-epoch receiver is not allowed. Either reconnect with a higher epoch, or make sure all epoch receivers are closed or disconnected.' It first started on May 31 which exactly coincides with an update of the azurefunctions SDK from version 4.19.0.20414 to version 4.21.2.20699. We get around 5000 of these error messages every day in the log. As a reference, we have around 100 million outgoing messages per day from the event hub. We have a function app with several functions that use EventHubTrigger to consume events. In addition, we are explicitly using EventProcessorClient in one function. For that latter case, we create and reuse one EventProcessorClient throughout the app's lifetime. We have 18 consumer groups in the event hub, not counting the default one which we don't use. Each consumer group is only used in one place in the code. The event hub has 6 partitions, but I noticed that the message is only reported on partition ID 0. The error indicates we are trying to register a non-epoch receiver, but I have scanned the code and haven't found anything like that. The function app is allowed to scale out to 10 instances. Expected behavior No exceptions of this type in the log Actual behavior Around 5000 of these errors in the log every day. Reproduction Steps Haven't been able to reproduce this locally. Environment Azure functions v4 in-process .NET 6
Client	OpenAI	[QUERY] how do I provide a azure cognitive hybrid response to the Azure.OpenIA client?	Library name and version Azure.AI.OpenAi Query/Question Hi I use the Azure.Search.Documents framework to do a hybrid search (Vector, text with semantic ) with Azure Search service on my one data for a chat question. What is the best way to provide this response to Azure.Ai.OpenAi to answer(summerice) the chat question? I have looked everywhere and there are no samples/video on this only on the search but not on how you provide the answer to the OpenAi. //Joacim Environment No response
Client	Service Bus	Grammar issue for CorrelationId description	Hello Azure team, Thanks for the wonderful and up to date documentation. However, there is a grammar issue which is a bit misleading as seen below.  It should be Gets or sets the correlation identifier.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 1f6230cb-970e-7765-59a4-d0db58d0e8e2 Version Independent ID: ecd4a582-cd6d-0976-0481-0a221065b095 Content: ServiceBusMessage Class (Azure.Messaging.ServiceBus) - Azure for .NET Developers Content Source: xml/Azure.Messaging.ServiceBus/ServiceBusMessage.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Event Hubs	[FEATURE REQ] EventHubs: Amqp properties have different attributes than the REST API	Library name Azure.Messaging.EventHubs Please describe the feature. The object EventHubProperties returned by EventHubProducerClient.GetEventHubPropertiesAsync() cannot be used to have insight on the status of the EventHub. This feature provided by the Rest API. The property can be retrieved via the EventHub management library (Azure.ResourceManager.EventHubs), but this requires the client to be aware of the resource group where the EventHub is hosted - that is not desirable for a producer client, who only needs to know about the EventHub namespace and EventHub name.
Client	Azure.Identity	[BUG] Azure.Identity 1.8.0+ throws Exception Attempting Managed Identity in Local Dev Env	Library name and version Azure.Identity 1.8.2 Describe the bug When updating Azure.Identity from 1.7.0 to 1.8.0 or higher I am now  getting exceptions on ManagedIdentity.    I am use Azure CLI in my local environment.  This is happening in my .NET V4 Azure Function running on core-tools. Azure Functions Core Tools Core Tools Version:       4.0.5198 Commit hash: N/A  (64-bit) Function Runtime Version: 4.21.1.20667 I suspect it is trying various authentication methods using DefaultAzureCredential and logging the failure from trying Managed Identity.  If that is the case, seems like that should be hidden from me.  Or maybe there should (or already is) way to stop it from trying ManagedIdentity on my local environment. [2023-08-10T16:03:13.035Z] False MSAL 4.54.1.0 MSAL.NetCore .NET 6.0.16 Microsoft Windows 10.0.19045 [2023-08-10 16:03:13Z - b2881984-ccc1-4415-9854-6782137aee04] Exception type: Azure.Identity.CredentialUnavailableException [2023-08-10T16:03:13.036Z] ---> Inner Exception Details [2023-08-10T16:03:13.037Z] Exception type: System.AggregateException [2023-08-10T16:03:13.037Z] ---> Inner Exception Details [2023-08-10T16:03:13.038Z] Exception type: Azure.RequestFailedException [2023-08-10T16:03:13.039Z] ---> Inner Exception Details [2023-08-10T16:03:13.039Z] Exception type: System.Net.Http.HttpRequestException [2023-08-10T16:03:13.040Z] ---> Inner Exception Details [2023-08-10T16:03:13.041Z] Exception type: System.Net.Sockets.SocketException [2023-08-10T16:03:13.042Z] [2023-08-10T16:03:13.043Z]    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken) [2023-08-10T16:03:13.044Z]    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource.GetResult(Int16 token) [2023-08-10T16:03:13.045Z]    at System.Net.Sockets.Socket.g__WaitForConnectWithCancellation|277_0(AwaitableSocketAsyncEventArgs saea, ValueTask connectTask, CancellationToken cancellationToken) [2023-08-10T16:03:13.045Z]    at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken) [2023-08-10T16:03:13.046Z] === End of inner exception stack trace === [2023-08-10T16:03:13.047Z] [2023-08-10T16:03:13.047Z]    at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken) [2023-08-10T16:03:13.048Z]    at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) [2023-08-10T16:03:13.049Z]    at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) [2023-08-10T16:03:13.049Z]    at System.Net.Http.HttpConnectionPool.AddHttp11ConnectionAsync(HttpRequestMessage request)[2023-08-10T16:03:13.050Z]    at System.Threading.Tasks.TaskCompletionSourceWithCancellation1.WaitWithCancellationAsync(CancellationToken cancellationToken) [2023-08-10T16:03:13.051Z]    at System.Net.Http.HttpConnectionPool.GetHttp11ConnectionAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) [2023-08-10T16:03:13.051Z]    at System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken) [2023-08-10T16:03:13.052Z]    at System.Net.Http.DiagnosticsHandler.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) [2023-08-10T16:03:13.053Z]    at System.Net.Http.HttpClient.<SendAsync>g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) [2023-08-10T16:03:13.054Z]    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async) [2023-08-10T16:03:13.054Z] === End of inner exception stack trace === [2023-08-10T16:03:13.055Z] [2023-08-10T16:03:13.058Z]    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async) [2023-08-10T16:03:13.059Z]    at Azure.Core.Pipeline.HttpPipelineTransportPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline) [2023-08-10T16:03:13.060Z]    at Azure.Core.Pipeline.RequestActivityPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) [2023-08-10T16:03:13.061Z]    at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) [2023-08-10T16:03:13.062Z]    at Azure.Core.Pipeline.LoggingPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) [2023-08-10T16:03:13.063Z]    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) [2023-08-10T16:03:13.064Z]    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) [2023-08-10T16:03:13.064Z] === End of inner exception stack trace === [2023-08-10T16:03:13.065Z] [2023-08-10T16:03:13.065Z]    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) [2023-08-10T16:03:13.066Z]    at Azure.Identity.ManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken) [2023-08-10T16:03:13.067Z]    at Azure.Identity.ImdsManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken) [2023-08-10T16:03:13.068Z] === End of inner exception stack trace === [2023-08-10T16:03:13.069Z] [2023-08-10T16:03:13.069Z]    at Azure.Identity.ImdsManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken) [2023-08-10T16:03:13.072Z]    at Azure.Identity.ManagedIdentityClient.AuthenticateCoreAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken) [2023-08-10T16:03:13.073Z]    at Azure.Identity.ManagedIdentityClient.AppTokenProviderImpl(AppTokenProviderParameters parameters) [2023-08-10T16:03:13.073Z]    at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.SendTokenRequestToProviderAsync(CancellationToken cancellationToken) [2023-08-10T16:03:13.074Z]    at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.FetchNewAccessTokenAsync(CancellationToken cancellationToken) [2023-08-10T16:03:13.075Z]    at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.ExecuteAsync(CancellationToken cancellationToken) [2023-08-10T16:03:13.076Z]    at Microsoft.Identity.Client.Internal.Requests.RequestBase.RunAsync(CancellationToken cancellationToken) Expected behavior Now Exceptions throw Actual behavior Throwing Exception Reproduction Steps have not tried to create minimal Environment .NET SDK: Version:   7.0.400 Commit:    73bf45718d Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.400\ Host: Version:      7.0.10 Architecture: x64 Commit:       a6dbb800a4
Client	Azure.Core	[BUG] AzureLocation not supporting NULL check	Library name and version Azure.Core 1.32.0 Describe the bug ThanksI'm migrating Microsoft.Azure.Management.ResourceManager.Fluent.Core to Azure.Core which main changes are changing Region to AzureLocation. We had the following code: using Microsoft.Azure.Management.ResourceManager.Fluent.Core; private Region _region;  if (_region == null)  {    _region = Region.Create(displayName); }  When I tried to migrate it to now use AzureLocation: using Microsoft.Azure.Management.ResourceManager.Fluent.Core; private AzureLocation _location;  if (_location == null)  {    _location = new AzureLocation(displayName); }  it didn't work, I got the following error, pointing to the line where I'm comparing _location == null, not where I'm setting _location = new AzureLocation . Error Message:    System.ArgumentNullException : Value cannot be null. (Parameter 'location')   Stack Trace:      at Azure.Core.AzureLocation..ctor(String location)    at Azure.Core.AzureLocation.op_Implicit(String location)  I ended finding a workaround so I don't have to compare _location == null, but I saw something similar was reported before #34818 and you didn't find a way to reproduce it. Should we be able to compare _location == null? Expected behavior  Give a better error message  Actual behavior The following error is thrown Error Message:    System.ArgumentNullException : Value cannot be null. (Parameter 'location')   Stack Trace:      at Azure.Core.AzureLocation..ctor(String location)    at Azure.Core.AzureLocation.op_Implicit(String location)  Reproduction Steps Added in description Environment No response
Client	EngSys	GDPR Privacy issues with Moq, starting from version 4.20 for any contributor to the SDK	You might want to consider locking Moq to < 4.20 (and prevent any dependency updates) or replacing it https://github.com/Azure/azure-sdk-for-net/blob/main/eng/Packages.Data.props#L269 as long as https://github.com/moq/moq/pull/1373 is not merged More context  in https://github.com/moq/moq/issues/1372
Client	App Configuration	[BUG] AppConfig: Cannot set ETag when constructing FeatureFlagConfigurationSetting	Library name and version Azure.Data.AppConfiguration 1.1.0-beta.2 Describe the bug There is a property called 'eTag' that is inherited from ConfigurationSetting  in FeatuerFlagConfigurationSetting but there does not appear to be a way to set the property. When you try to update the featureFlag it does no evaluation with eTag. Expected behavior The eTag should be allowed to set in the FeatureFlagConfigurationSetting object. The expected behaviour should be to enable eTags for Feature Flags, just as in ConfigurationSetting object. Actual behavior Currently, FeatureFlagConfigurationSetting does not have eTag as a parameter, but the inherited class `ConfigurationSetting` has the eTag. But I am working with FeatureFlagConfigurationSetting object and I want to be able to update the flag and create the flag, which is difficult to do as there is no eTag in FeatureFlagConfigurationSetting. Reproduction Steps Here are the links that have the documentation: https://azuresdkdocs.blob.core.windows.net/$web/dotnet/Azure.Data.AppConfiguration/1.1.0-beta.2/api/Azure.Data.AppConfiguration/Azure.Data.AppConfiguration.ConfigurationSetting.html https://azuresdkdocs.blob.core.windows.net/$web/dotnet/Azure.Data.AppConfiguration/1.1.0-beta.2/api/Azure.Data.AppConfiguration/Azure.Data.AppConfiguration.FeatureFlagConfigurationSetting.html Environment .NET SDK: Version:   7.0.304 Commit:    7e794e2806 Runtime Environment: OS Name:     Mac OS X OS Version:  13.5 OS Platform: Darwin RID:         osx.13-arm64 Base Path:   /usr/local/share/dotnet/sdk/7.0.304/ Host: Version:      7.0.7 Architecture: arm64  IDE is Rider 2022 version
Client	Cognitive - Form Recognizer	[QUERY] How to get barcodes with prebuit-invoice model	Library name and version Azure.AI.FormRecognizer 4.1.0-beta.1 Query/Question I'm following the javascript example to get invoice data using the prebuilt-invoice model. When I tried on Form Recognizer Studio there is an option to enable the detection of barcodes. With the given example I could not find a way to enable this. My code: const client = new DocumentAnalysisClient(endpoint, new AzureKeyCredential(key)); const poller = await client.beginAnalyzeDocumentFromUrl(`prebuilt-invoice`, document); const {         documents: [result]     } = await poller.pollUntilDone();  //poller.getResult().pages[0].barcodes = undefined  I believe I need to pass a parameter to enable the barcode read, any thoughts? Environment .NET SDK: Version:   7.0.202 Commit:    6c74320bc3 OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.202\ Host: Version:      7.0.4 Architecture: x64 Commit:       0a396acafe .NET SDKs installed: 6.0.401 [C:\Program Files\dotnet\sdk] 7.0.202 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Cognitive - Language	[FEATURE REQ] Need to format the result from ConversationAnalysisClient response	Library name Azure AI services Please describe the feature. We are using Orchestrator workflow of Custom question answering service for connecting to multiple Question answering service. We are fetching the predictions using ConversationAnalysisClient. The response contains all data but to access the values we need to use json. Question answering is returning the data in KnowledgeBaseAnswer format which is easy to access. Is there any possibility to develop a similar structure for fetching the response from Orchester for Question answering, Luis and Conversational analysis
Client	KeyVault	[QUERY]Initial request from function app to retrieve key vault secret results in 401	Library name and version Azure.Security.KeyVault.Secrets 4.5.0 Query/Question We have an Azure Function App recently upgraded from v1 to v4.  The function app is throwing 401's on the initial request to retrieve a key vault secret.  We cannot confirm if this has always been happening or if this is a result from the upgrade to v4. The function app is now v4 in C# .NET 6 using the Azure.Security.KeyVault.Secrets nuget package.  This is the full list of all nuget packages for the function app. <Project Sdk=`Microsoft.NET.Sdk`>     <PropertyGroup>         <TargetFramework>net6.0</TargetFramework>         <AzureFunctionsVersion>v4</AzureFunctionsVersion>     </PropertyGroup>     <ItemGroup>         <PackageReference Include=`Azure.Identity` Version=`1.9.0` />         <PackageReference Include=`Azure.Messaging.ServiceBus` Version=`7.15.0` />         <PackageReference Include=`Azure.Security.KeyVault.Secrets` Version=`4.5.0` />         <PackageReference Include=`Microsoft.Azure.Functions.Extensions` Version=`1.1.0` />         <PackageReference Include=`Microsoft.Azure.WebJobs.Extensions.DurableTask` Version=`2.10.0` />         <PackageReference Include=`Microsoft.Azure.WebJobs.Extensions.ServiceBus` Version=`5.11.0` />         <PackageReference Include=`Microsoft.Extensions.Azure` Version=`1.6.3` />         <PackageReference Include=`Microsoft.NET.Sdk.Functions` Version=`4.2.0` />     </ItemGroup>     <ItemGroup>         <None Update=`host.json` CopyToPublishDirectory=`Always`>             <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>         </None>         <None Update=`local.settings.json`>             <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>             <CopyToPublishDirectory>Never</CopyToPublishDirectory>         </None>     </ItemGroup> </Project> Here is the simplified code used to fetch the key vault secret, DefaultAzureCredentialOptions credentialOptions = new DefaultAzureCredentialOptions(); DefaultAzureCredential azureCredentials = new DefaultAzureCredential(credentialOptions);  SecretClient client = new SecretClient(new Uri(keyVaultUrl), azureCredentials); KeyVaultSecret secret = await client.GetSecretAsync(new Uri(secretUrl));  return secret.Value; All methods in this function app are static. The code clearly works, eventually, after the first request throws a 401 because there is no authentication token provided.  The request is then re-authenticated auto-magically and retried.  With the valid token in place, the request is then successful and the key vault secret is returned. I found this GitHub issue and tried to implement a startup class to configure the default Azure credentials, #29471 But when using the startup class, the function app threw this startup error, https://learn.microsoft.com/en-us/azure/azure-functions/errors-diagnostics/diagnostic-events/azfd0005 I changed tactics and was able to prevent the 401's from happening by using a key vault reference in our function app configuration. https://learn.microsoft.com/en-us/azure/app-service/app-service-key-vault-references?tabs=azure-cli My question is if this is the intended behaviour when fetching secrets from our key vault using DefaultAzureCredential?  If not, is the only method to prevent the 401 exceptions is to use key vault references in our configuration?  My concern is that we are receiving these 401 exceptions on many of our Azure app services, not just this function app and they are all using similar implementations to use SecretClient and KeyVaultSecret using DefaultAzureCredential. Environment C# .NET 6 Azure Function App v4 Key Vault
Client	Event Hubs	[QUERY] Is it expected that WithCredential work when calling AddEventHubProducerClient?	Library name and version Azure.Messaging.EventHubs 5.9.2 Query/Question I'm attempting to use Azure Event Hubs like so:     builder.Services.AddAzureClients(         b =>         {             b.AddEventHubProducerClient(builder.Configuration.GetConnectionString(`EventHub`))                 .WithCredential(new DefaultAzureCredential());         }     ); However, I'm getting an exception thrown from EventHubsConnectionStringProperties.Parse which is called from the EventHubProducerClient constructor that doesn't get a credential. It seems that the EventHubsConnectionStringProperties.Parse method isn't called if a credential is passed to the EventHubProducerClient constructor, though, but I'm not finding another way to specify a credential when using the AddEventHubProducerClient method. I just want to verify that I'm using it as expected. It seems that I'll have to register the EventHubProducerClient manually if I want to use identity instead of a shared access key or signature. Environment  Version:   7.0.302  Commit:    990cf98a27  Runtime Environment:  OS Name:     Mac OS X  OS Version:  13.5  OS Platform: Darwin  RID:         osx.13-x64  Base Path:   /usr/local/share/dotnet/sdk/7.0.302/  Host:   Version:      7.0.5   Architecture: x64   Commit:       8042d61b17  .NET SDKs installed:   5.0.408 [/usr/local/share/dotnet/sdk]   6.0.408 [/usr/local/share/dotnet/sdk]   7.0.302 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 5.0.17 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.16 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.5 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 5.0.17 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.16 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.5 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]  Other architectures found:   None  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Mgmt	Container Registry	[QUERY] Creating ContainerApp with link to Azure ContainerRegistry	Library name and version Azure.ResourceManager.AppContainers 1.0.3 & Azure.ResourceManager.ContainerRegistry 1.1.0 Query/Question There seems to be a little confusion here on how Azure.ResourceManager.AppContainers and Azure.ResourceManager.ContainerRegistry work together. Heres some proto code to show what I'm talking about. //so we load our container registry var registries = await arm.GetContainerRegistriesAsync(); //then we select the first registry var registry = registries.First(); //then create a new container app configuration var appConfig = new ContainerAppConfiguration() {     Ingress =         {             AllowInsecure = false,             TargetPort = service.dockerProfile.InternalPort,             ExposedPort = service.dockerProfile.ExternalPort,             Transport = Azure.ResourceManager.AppContainers.Models.ContainerAppIngressTransportMethod.Http,             External = service.dockerProfile.ExternalPort is not null         },     Registries =     {         //It is unclear how to use the above registry here     } };  var container = await arm.CreateContainerApp(service.containerAppName, new(Azure.Core.AzureLocation.SouthCentralUS) {     EnvironmentId = environment.Id,     Configuration = appConfig }); If someone can answer this I'd be happy to throw up some documentation so its not asked again. I couldnt find any documentation on this. Environment No response
Client	Search	[QUERY] Azure Cognitive Search Alias	Library name and version Azure.Search.Documents Query/Question Recently I came across this article which mentioned that we can create an Index Alias and use it to query documents. Alias is very helpful to avoid downtime when we have to change Index definition and to do that we need to drop and recreate index. https://learn.microsoft.com/en-us/azure/search/search-how-to-alias?tabs=rest However, this Index Alias feature is only available in Public Preview. I just wanted to know if there was any movement on this and any plans to make this a full fledged feature. It would be great to have this available in regular non-beta SDK versions to use and avoid downtimes which switching indexes. Environment No response
Client	Monitor - Exporter	[QUERY] How do you set Adaptive Sampling Off in Azure Monitor Trace Exporter	Library name and version Azure.Monitor.OpenTelemetry.Exporter 1.0.0-beta.13 Query/Question I'm trying to figure out how to turn off adaptive sampling in a .net core console application when using Azure.Monitor.OpenTelemetry.Exporter 1.0.0-beta.13. I just don't see any kind of configuration option in the Diagnostics, or anywhere else in the trace exporter.    .WithTracing(builder => builder .AddConsoleExporter() .AddAzureMonitorTraceExporter(o => { o.ConnectionString = appInsightsConnection; o.Diagnostics.IsDistributedTracingEnabled = true; })) I tried setting it directly in the ApplicationInsights section of my config file, but that didn't work either `Logging`: { `LogLevel`: { `Default`: `Information` }, `ApplicationInsights`: { `LogLevel`: { `Default`: `Information` }, `EnableAdaptiveSampling`: false, } }, Any ideas? Environment Visual Studio 2022.17.6.5 running on Windows 11
Client	Monitor	[FEATURE REQ] LogsQueryClient is not behind an interface and not easy to mock in unit tests	Library name Azure.Monitor.Query Please describe the feature. We used Microsoft.Azure.OperationalInsights before and could mock the returns of the queries. Now with the LogsQueryClient this is not possible anymore. It is not behind an interface and not easy to mock in unit tests. Please improve here so that we can start using this
Client	Extensions	[QUERY] Creating custom client with AddClient() in AddAzureClients() using ClientSecretCredential and ClientOptions	Library name and version Azure.Identity 1.9.0 Query/Question What is the correct approach when calling a daemon when using a custom client. I would like to use the Azure.Identity package and use it's client builder. Because this will manage the lifetime of the token. The thing is that the AddClient method needs a class that inherits ClientOptions, but what purpose does it have? In this use case. Or is there an alternative? A few observations:  If I provide a custom class it must inherit ClientOptions and must be registered in the DI, The AddClient TOptions does not enforce it to be inherited by ClientOptions It will fail when not inherited with ClientOptions .  (Constructor on type 'MyCustomOptions' not found.) I could also use SecretClientOptions, which works, but it does not feel ok, because it could have side effects.  I use MyTokenKeeper in the DelegatingHandler of a HttpClient to fill the Authorization header. That's the only thing I need in this use case.             services.AddAzureClients(clientBuilder =>             {                 clientBuilder.UseCredential(serviceProvider =>                 {                     var myOptions = serviceProvider.GetRequiredService<myOptions>();                     return new ClientSecretCredential(myOptions.TenantId, myOptions.ClientId, myOptions.Secret);                 });                 clientBuilder.AddClient<MyTokenKeeper, MyTokenKeeperClientOptions>((options, tokenCredential, serviceProvider) =>                 {                     var myOptions = serviceProvider.GetRequiredService<MyOptions>();                     var token = tokenCredential.GetToken(new TokenRequestContext(new[] { myOptions.Scope }), CancellationToken.None);                     return new MyTokenKeeper(token.Token);                 });             });
Client	Cognitive - Form Recognizer	[FEATURE REQ]  Form recognizer: Copy classifier models?	Library name FormRecognizer.DocumentAnalysis Please describe the feature. I'd would like to see a method to be able to copy custom classification models. There is a model to copy models (CopyDocumentModelTo) but not to copy classification models.  You will get an error when you try to pass in the ID of a classifier model into he copydocumentmodel method.
Client	Cosmos	[FEATURE REQ] Support for CosmosClient in AddAzureClients	Library name Microsoft.Extensions.Azure Please describe the feature. Coming from Azure/azure-cosmos-dotnet-v3#4002, I have been sent here. The following extension is useful and neat, it would work like this for Blob Storage builder.Services.AddAzureClients(options =>         {             //Add storage accounts                 options.AddBlobServiceClient(i`blabla`).;             // Use DefaultAzureCredential by default             options.UseCredential(new DefaultAzureCredential());         });  I wonder if we can add something like AddCosmosServiceClient? I did not find it in the docs.
Client	Azure.Identity	horrible use description.	nothing but jargon, no examples of usage. no explaination on how to use it in conjunction to the DefaultAzureCredential class.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 8279aa91-58d0-7319-86fa-b67c07e3f3bd Version Independent ID: 3324e0cc-7a80-d42a-0ac5-1dc70fbea481 Content: DefaultAzureCredentialOptions.AdditionallyAllowedTenants Property (Azure.Identity) - Azure for .NET Developers Content Source: xml/Azure.Identity/DefaultAzureCredentialOptions.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	KeyVault	[BUG] Dependency conflict with Azure.Security.KeyVault.Secrets	Library name and version Azure.Identity 1.9.0 Describe the bug Azure.Identity 1.9.0 requires Azure.Core >=1.32, but Azure.Security.KeyVault.Secrets 4.5.0 throws the following exception if Azure.Core 1.30 is not installed: Could not load file or assembly 'Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8' How can we resolve this? Expected behavior No exceptions Actual behavior Exception is thrown Reproduction Steps Install Azure.Identity 1.9.0 with Azure.Security.KeyVault.Secrets 4.5.0 Environment No response
Client	KeyVault	[QUERY] Azure.Security.KeyVault.Secrets : NameResolutionFailure	Library name and version Azure.Security.KeyVault.Secrets 4.2.0 Query/Question Our team is using Azure.Security.KeyVault.Secrets Lib v4.2.0 since 2021, to fetch KeyVaultSecret. It was working smoothly since then without any issues. We are suddenly getting NameResolutionFailure errors. This is an intermittent issue now.  var client = new SecretClient(new Uri(` xyz.net `), new ClientSecretCredential(`xyz`, ClientID, ClientSecret)); var Password = client.GetSecretAsync(`CertificatePassword`).GetAwaiter().GetResult();  I've been getting the NameResolutionFailure error frequently lately when running the above code snippet. Can anyone please help me in pointing the root cause and a possible solution Environment Windows 10 .NET Framework 4.8
Mgmt	Network - DNS	[BUG] Cannot create private DNS TXT records, Values property is not accessible.	Library name and version Azure.ResourceManager.PrivateDns 1.0.1 Describe the bug It is not possible to create new Private DNS TXT records because the 'Values' property on class PrivateDnsTxtRecordInfo does not have a setter. This is different from other private DNS record types. Expected behavior Should be able to set 'Values' property in order to be able to create new private dns txt records. Actual behavior Cannot set 'Values' property. Reproduction Steps if (!recordExists) { privateDnsZoneTxtRecordData.PrivateDnsTxtRecords.Add(new PrivateDnsTxtRecordInfo() { Values = txtValues.ToArray() }); } Environment Visual Studio Profession 2022
Service	KeyVault	[BUG] Requests to Key Vaults are timing out after considerable time	Library name and version Azure.Security.KeyVault.Keys 4.5.0 Describe the bug When interacting with Azure KeyVault we occasionally notice request which seem to time out with the following exception: System.Threading.Tasks.TaskCanceledException: The operation was canceled.  ---> System.IO.IOException: Unable to read data from the transport connection: Operation canceled.  ---> System.Net.Sockets.SocketException (125): Operation canceled    --- End of inner exception stack trace ---    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource<System.Int32>.GetResult(Int16 token)    at System.Net.Security.SslStream.EnsureFullTlsFrameAsync[TIOAdapter](CancellationToken cancellationToken)    at System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1.StateMachineBox`1.System.Threading.Tasks.Sources.IValueTaskSource<TResult>.GetResult(Int16 token)    at System.Net.Security.SslStream.ReadAsyncInternal[TIOAdapter](Memory`1 buffer, CancellationToken cancellationToken)    at System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1.StateMachineBox`1.System.Threading.Tasks.Sources.IValueTaskSource<TResult>.GetResult(Int16 token)    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at System.Net.Http.HttpClient.HandleFailure(Exception e, Boolean telemetryStarted, HttpResponseMessage response, CancellationTokenSource cts, CancellationToken cancellationToken, CancellationTokenSource pendingRequestsCts)    at System.Net.Http.HttpClient.<SendAsync>g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken)    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.HttpPipelineTransportPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.RequestActivityPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)   In Application Insights we can see the following telemetry. The issue only occurs when multiple requests are processed at the same time: Request 1  Request 2  To summarize the above:  initially the request to KeyVault fails for both requests with a 401 a new token is obtained in the context of the first request the request to KeyVault is retried for both requests a deadlock seem to occur and both requests time out (can also be more than two requests)  However, looking at the Insights of KeyVault it does at no point indicate that requests fail or have a significant latency so it seems the problem is in the KeyVault client and not caused by KeyVault itself. The issue related to some extent to the behavior described in #4016. However, as there is not much information provided in that issue it's hard to verify. Expected behavior Deadlocks should not occur Actual behavior Deadlocks occur from time to time Reproduction Steps The original issue is occuring in a more complex setup. However, we could reproduce it occasionally in this very minimal PoC. However:  it was only reproducible on Kubernetes and not in a local setup (or we haven't observed it there yet at least) the issue only occured when multiple simultaneous requests are processed      public class KeyVaultService : IKeyVaultService     {         private readonly KeyClient _client;          public KeyVaultService(IConfiguration configuration)         {                          _configuration = configuration;                           var tenantId = 'tenant-id';             var clientId = 'client-id';             var clientSecret = 'client-secret';              var servicePrincipal = new ClientSecretCredential(tenantId, clientId, clientSecret);                          _client = new KeyClient(new Uri(`https://your-keyvault.vault.azure.net`), servicePrincipal);         }                   public async Task<bool> CheckKey(string name)         {             try             {                 var key = await _client.GetKeyAsync(name) ?? null;                 return key != null;             }             catch             {                 return false;             }         }              } It's worth noting that the KeyVaultService is injected via dependency injection so a single instance is shared among requests: public static class ServiceCollectionExtensions {     public static IServiceCollection InjectEncryptionServices(this IServiceCollection services)     {         services.AddSingleton<IKeyVaultService, KeyVaultService>();          return services;     } } The issue could be triggered by calling repeatedly/simultaneously the follwing API endpoint. The issue could be observed independently of a specific KeyVault operation (e.g. also on wrap/unwrap key)     [HttpGet(`check`)]     public async Task<ActionResult<bool>> CheckKeyVaultStatus(Guid id)     {         return await _keyVaultService.CheckKey(id.ToString());     } Environment Container Image: mcr.microsoft.com/dotnet/aspnet:7.0
Mgmt	API Management	[BUG] ApiManagement.ApiManagementServiceResource.CreateOrUpdateContentTypeAsync(..) does not allow to define body	Library name and version Azure.ResourceManager.ApiManagement 1.0.1 Describe the bug The documentation of PUT Content Type defines body with item properties. SDK method only allows ContentTypeId to be defined: https://learn.microsoft.com/en-us/rest/api/apimanagement/current-ga/content-type/create-or-update?tabs=HTTP#request-body Expected behavior ContentType can be created with all properties (schema, name, version, description). Actual behavior ContentType can be created with only Id property Reproduction Steps Construct an ApiManagementServiceResource using Azure resource values for subscription, resourcegroup and servicename, then perform the call: await apiManagementClient.CreateOrUpdateContentTypeAsync(contentTypeId, Azure.ETag.All); The method does not allow to provide properties described by REST API Environment Windows 10 .NET 6.0 project Visual Studio 2022 17.4.2
Mgmt	Compute - VM	What is the recommended way to size a VM in C#	Library name and version Azure.ResourceManager.Compute v1.1.0 Query/Question When creating a VM in C#, historically the way to set the VM Size was using the VirtualMachineHardwareProfile property of the VM and using the VMSize enum to specify a value. With this enum being deprecated, what is the current recommended guidance for how to set a VM Size in C#? I note that this enum does not contain all available sizes (and given its status is unlikely to). Is there any documentation that suggests a (somewhat) future proof mechanism for specifying size? Environment .NET SDK: Version:   7.0.304 Commit:    7e794e2806 Runtime Environment: OS Name:     Mac OS X OS Version:  13.4 OS Platform: Darwin RID:         osx.13-arm64 Base Path:   /usr/local/share/dotnet/sdk/7.0.304/ Host: Version:      7.0.7 Architecture: arm64 Commit:       5b20af47d9 .NET SDKs installed: 6.0.406 [/usr/local/share/dotnet/sdk] 6.0.407 [/usr/local/share/dotnet/sdk] 6.0.408 [/usr/local/share/dotnet/sdk] 6.0.410 [/usr/local/share/dotnet/sdk] 7.0.200 [/usr/local/share/dotnet/sdk] 7.0.201 [/usr/local/share/dotnet/sdk] 7.0.202 [/usr/local/share/dotnet/sdk] 7.0.203 [/usr/local/share/dotnet/sdk] 7.0.302 [/usr/local/share/dotnet/sdk] 7.0.304 [/usr/local/share/dotnet/sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.10 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.11 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.12 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.13 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.14 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.15 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.16 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.18 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.2 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.4 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.5 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.7 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.10 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.11 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.12 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.13 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.14 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.15 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.16 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.18 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.2 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.3 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.4 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.5 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.7 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App] Other architectures found: None Environment variables: Not set global.json file: Not found Azure Functions Visual Studio Code/VS for Mac
Client	Service Bus	[Service Bus]  `The link with identifier Receiver|LinkName|ContainerId has been closed due to link stealing.` exceptions in Azure Service Bus triggered function	Library name and version Azure.Messaging.ServiceBus 7.5.1 Describe the bug  Expected behavior If we can not prevent it, it should not be logged as an exception. Actual behavior Thousands of exceptions getting logged in a few hours. Reproduction Steps  Set up an Azure Service Bus triggered function. Configure the function to receive messages from a Service Bus entity. Trigger the function by sending messages to the Service Bus entity. Monitor the function's execution and observe if any `The link with identifier Receiver|LinkName|ContainerId has been closed due to link stealing.` exceptions occur.  Environment Target Framework - net6.0 AzureFunctionVeriosn - v4
Mgmt	Container Service	[BUG] The param AdminGroupObjectIds defined in Azure.ResourceManager.ContainerService.ManagedClusterAadProfile is readonly.	Library name and version Azure.ResourceManager.ContainerService Describe the bug The param AdminGroupObjectIds defined in ManagedClusterAadProfile is readonly. How do we set this value via sdk? Actually this param could be set via rest api. Expected behavior We could set it. Actual behavior It's readonly. Reproduction Steps None Environment No response
Client	OpenAI	What is the URI/URL for Embeddings with AzureOpenAI	Library name and version Azure.AI.OpenAI 1.0.0-beta.5 Query/Question In the examples 1 through 5: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/openai/Azure.AI.OpenAI/tests/Samples/Sample01_Chatbot.cs URL is a placeholder: `https://myaccount.openai.azure.com/` What is `myaccount`? Azure Resource Name? Subscription Name? This Url is used for completions and chat. What would be URL for Embeddings? Is the following correct? https://{resourceName}.openai.azure.com/openai/deployments/{deploymentId}/embeddings?api-version={apiVersion} (It took it from somewhere on MS sites, and it might be for Semantic Kernel case, or HttpClient) So what is Embeddings URL for AzureOpenAI? Is there any example for Embeddings? Environment Win11 .NET 7 VS2022 17.5.4 Azure.AI.OpenAI 1.0.0-beta.5
Client	Service Bus	[Question] Large additional financial cost due to useless logs	Library name and version Azure.Messaging.ServiceBus 7.15.0 Query/Question Could you please explain why in the class ServiceBusRetryOptions the property TryTimeout has a check that does not allow us to specify the value TimeSpan.MaxValue? Are there any reasons that do not allow us to turn off this timer for Azure.Messaging.ServiceBus? I would be very grateful if you give an example of when disabling the timer can lead to unpleasant consequences, this example will help a lot in understanding and we can use your package more correctly. The fact is that Azure.Messaging.ServiceBus uses Microsoft.Azure.Amqp in which there are two options for initializing the message processing pipeline: by timer and by signal. Every time the timer expires, a message processing pipeline is started for each consumer, even if there are no messages in the queue, which as a result leads to a lot of meaningless logs inside ApplicationInsights. In Microsoft.Azure.Amqp it is possible to disable the timer, for this, you just need to specify the TimeSpan.MaxValue value. By default, the timer is set to 1 minute, so one log is created every minute for each consumer. If the project has 100 consumers, then every minute there will be 100 extra logs, 6 000 in one hour, 144 000 in one day, 4 320 000 in a month... This is an insane amount that requires additional financial costs. Changing the timer to 1 hour doesn't solve the problem, only slightly lessens it. Since we have a very large project on SOA architecture, we have tens and hundreds of consumers, so this is a serious problem for us. I made a small test project that you can use to reproduce the problem. You just need to run it, wait 5-10 minutes and you will see such a bunch of logs.  Environment Windows 11 (10.0.22621) dotnet SDK 6.0.410 Microsoft.ApplicationInsights.AspNetCore 2.22.0-beta3 (reproduced in all versions)
Client	Service Bus	[BUG] ServiceBus trigger has null body	Library name and version Microsoft.NET.Sdk.Functions 4.2.0 Describe the bug Getting null body in Azure Fuction app receiver when Publisher Code private static async Task PublishToAgreements()         {             queueClient = new QueueClient(connectionStringAgreements, queueNameAgreements);              var msgId = `30`;             var msgCount = 1;              await SendMessageAgreementsAsync(@`{                                                 ``name``: ``John Doe``,                                                 ``age``: ``55``                                               }`, msgId, 11);              Console.WriteLine($`{msgCount} messages sent!`);             await queueClient.CloseAsync();         }  Receiver Code  [FunctionName(`ProcessErrors`)]         public async Task ProcessErrorsAsync(         [ServiceBusTrigger(`%ErrorsProcessingQueueName%`, Connection = `ServiceBusConnection`             , IsSessionsEnabled = true)] Message message)         {             var messageBody = message.GetBody<string>(); // messageBody is null, message object is there.                      }  Packages in Function App  <PackageReference Include=`Microsoft.NET.Sdk.Functions` Version=`4.2.0` />     <PackageReference Include=`Microsoft.Azure.WebJobs.Extensions.ServiceBus` Version=`5.11.0` />     <PackageReference Include=`Microsoft.ApplicationInsights.AspNetCore` Version=`2.21.0` />     <PackageReference Include=`Microsoft.Extensions.Configuration.AzureAppConfiguration` Version=`6.0.1` />    <PackageReference Include=`Microsoft.Azure.Functions.Extensions` Version=`1.1.0` />    <PackageReference Include=`Microsoft.Azure.ServiceBus` Version=`5.2.0` />     <PackageReference Include=`Microsoft.Extensions.DependencyInjection` Version=`7.0.0` />     <PackageReference Include=`Microsoft.Extensions.Logging.Abstractions` Version=`6.0.3` />  Expected behavior I should get the full message body along with all properties and session id Actual behavior Getting null in message body Reproduction Steps Create publisher and send message with json formatter. private static async Task PublishToAgreements()       {           queueClient = new QueueClient(connectionStringAgreements, queueNameAgreements);            var msgId = `30`;           var msgCount = 1;            await SendMessageAgreementsAsync(@`{                                               ``name``: ``John Doe``,                                               ``age``: ``55``                                             }`, msgId, 11);            Console.WriteLine($`{msgCount} messages sent!`);           await queueClient.CloseAsync();       }  Create Function app with Service Bus Trigger and below is the code. [FunctionName(`ProcessErrors`)]        public async Task ProcessErrorsAsync(        [ServiceBusTrigger(`%ErrorsProcessingQueueName%`, Connection = `ServiceBusConnection`            , IsSessionsEnabled = true)] Message message)        {            var messageBody = message.GetBody<string>(); }  Environment dotnet core 6 Visual studio 2022 Local OS : Windows 11
Client	Search	Azure Search - Managed Identity	All requests to a search service need an api-key that was generated specifically for your service. The api-key is the sole mechanism for authenticating access to your search service endpoint.  This doesn't seem right - Managed Identity should even be the preferred method imo - or am I missing something here? https://learn.microsoft.com/en-us/dotnet/api/overview/azure/search.documents-readme?view=azure-dotnet#authenticate-the-client  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: f60660a9-9a80-3259-8eeb-79d18bcf5d50 Version Independent ID: 6f76c320-0f86-7013-a389-8aba5421706e Content: Azure Cognitive Search client library for .NET - Azure for .NET Developers Content Source: api/overview/azure/latest/search.documents-readme.md Service: search GitHub Login: @ShivangiReja Microsoft Alias: shreja
Client	OpenAI	[BUG] Azure.AI.OpenAI - Chat Completion - ChatCompletionsOptions.Messages is read only but shouldn't be	Library name and version Azure.AI.OpenAI 1.0.0-beta.5 Describe the bug When creating a new ChatCompletionsOptions() object, cannot set the Messages property except with an object initializer. This makes it impossible to create an ongoing dynamic conversation which is feeding in the system and user responses to the service dynamically. The comment in the code even says `Gets or sets` (see below)     ///     Gets or sets the set of chat messages associated with a chat completions request.     ///     This is the full set of chat messages for the history of a conversation between an assistant and user.     ///     Typical usage begins with a chat message for the System role that provides instructions for the     ///     behavior of the assistant followed by alternating messages between the User role and Assistant role.      public IList<ChatMessage> Messages { get; }  Expected behavior The Messages property should not be read only, it should allow `set`. Actual behavior The Messages property is read only Reproduction Steps List chatMessageList = new List();         chatMessageList.Add(new ChatMessage(ChatRole.System, `blah1`));         chatMessageList.Add(new ChatMessage(ChatRole.User, `blah2`));          Response<ChatCompletions> responseWithoutStream = await client.GetChatCompletionsAsync(             `gpt-4`,             new ChatCompletionsOptions()             {                 Messages = chatMessageList,                 Temperature = (float)0.7,                 MaxTokens = 800,                 NucleusSamplingFactor = (float)0.95,                 FrequencyPenalty = 0,                 PresencePenalty = 0,             });  //CS0200 Property or indexer 'ChatCompletionsOptions.Messages' cannot be assigned to -- it is read only Environment No response
Client	Service Bus	Add links to mode descriptions on page: ReceiveMode Enum	Please add links to what modes the ReceiveMode Enums refer to. So that others can then read about what each of the modes will do. e.g. have links to https://learn.microsoft.com/en-us/azure/service-bus-messaging/message-transfers-locks-settlement#receiveanddelete  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: f76fe8a7-501f-acbd-76cc-0201764173a4 Version Independent ID: 35d05909-a780-d644-2838-10c77992f9d3 Content: ReceiveMode Enum (Microsoft.ServiceBus.Messaging) - Azure for .NET Developers Content Source: xml/Microsoft.ServiceBus.Messaging/ReceiveMode.xml Service: service-bus-messaging GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Identity	[QUERY] Using DefaultAzureCredential to get PBI access token	Library name and version using Azure.Identity 1.9.0 Query/Question Currently I pick up a acces token in the following way: AuthenticationResult authenticationResult = null; var authenticationContext = new AuthenticationContext(authorityUrl + $`{TenantId.Trim()}`); var credential = new ClientCredential($`{SPId}`, $`{SPSecret}`); authenticationResult = authenticationContext.AcquireTokenAsync(resourceUrl, credential).Result; return authenticationResult; with authorityUrl = https://login.microsoftonline.com/common/ TenantId = xxxxxx-xxxx-xxxx-xxxxx-xxxxxxxx (in form of) SPId = xxxxxx-xxxx-xxxx-xxxxx-xxxxxxxx (in form of) SPSecret = xxxxxxxxxxxxxxxxxxx= (in form of) resourceUrl= https://analysis.windows.net/powerbi/api Within the new company regulations I cant no longer connect via this way and need to connect via ManagedIdentites. In order to do this I wanted to make use of DefaultAzureCredential() With the following code: var tokenCredential = new DefaultAzureCredential(); var tokenContext = new TokenRequestContext( scopes: new string[] { resourceUrl }); var accessToken = await tokenCredential.GetTokenAsync(tokenContext); I do get a token back but if I try to connect to the PBI reports, I get a 401 not authorised error and I dont understand why. Do I need to add the authorityUrl and TenentId somewhere? If so, where or why not? I cant find an example where this connection to PBI is made so I am really stuck here.. Environment ASP.NET WEBAPP
Client	KeyVault	[KeyVauly] Cannot mock `SignResult` in `Azure.Security.KeyVault.Keys` at UT	Information The method CryptographyClient.SignAsync() return the SignResult object directly, which is only have an internal constructor that I cannot mock it in UT. Is it possible to consider adding a public constructor to this object, or return an interface type in the SignAsync method? And I was wondering if there is someway to mock the return value of SignAsync in UT? var cryptographyClient = Substitute.For<CryptographyClient>(); await cryptographyClient.SignAsync(Arg.Any<SignatureAlgorithm>(), Arg.Any<byte[]>(), Arg.Any<CancellationToken>()).ReturnsForAnyArgs(???);
Client	KeyVault	[BUG] : KeyClient class Getting certificates when asking for keys	Library name and version Azure.Security.KeyVault.Keys (version 4.5.0) Describe the bug I am trying to use the KeyClient class present under this library to access the Keys present in my Key Vault. Here I have a key vault under my Visual Studio Enterprise Subscription with vault uri as given in the code. The problem is that I am not only getting the key names but also the certificate names where cert1 and cert2 are certificates and key1 and key2 are the required keys Expected behavior The output should be Key1 Key2  Actual behavior Getting the output cert1 cert2 Key1 Key2  Reproduction Steps using Azure.Security.KeyVault.Keys; using Azure.Core; using Azure.Identity; using System.Threading;  internal class Program {     private static void Main(string[] args)     {         TokenCredential credential = new DefaultAzureCredential();         KeyClient key = new KeyClient(new Uri(`https://XX.vault.azure.net/`), credential);         Azure.Pageable<KeyProperties> allkeys = key.GetPropertiesOfKeys();         foreach(KeyProperties Key in allkeys)         {             Console.WriteLine(Key.Name);         }         //Console.WriteLine(key.ToString());     } } Environment Os: Windows 11 .NET Framework: 6.0(Long term Support IDE: Visual Studio Community version 17.6.1
Client	KeyVault	[FEATURE REQ] - Expose JsonWebKeyComparer found in Azure.Security.KeyVault.Keys/tests/JsonWebKeyTests.cs	Library name Azure.Security.KeyVault.Keys Please describe the feature. Good morning, I am working on trying to store a key from Azure KeyVault for a limited amount of time (less than 5 minutes) using an implementation of IDistributedCache (Redis, SQL Server, etc.). In order to verify the key that is stored is the same key that was originally pulled down from Azure KeyVault, I first serialize the JsonWebKey as described in #24282 storing the serialized result to the IDistributedCache. When another call is made for the key, the IDistributedCache is checked and if there is a key found it is deserialized into a JsonWebKey. To test this within my unit testing, I need something that can compare the two JsonWebKeys properly. As part of the tests in the Azure SDK, there is a class called JsonWebKeyComparer that implements IEqualityComparer. As a workaround, I currently have a portion of the code to use in the unit test, but having an officially supported IEqualityComparer would be preferred to using this workaround. Thank you for your time and assistance, Adam Brousseau
Client	Azure.Identity	[BUG] AzureKeyCredential could not be found  ,I have already imported and install using azure.Core in my project	Library name and version Azure.Core Describe the bug AzureKeyCredential could not be found  ,I have already imported and install  azure.Core in my project### Expected behavior should be able to use AzureKeyCredential credential = new AzureKeyCredential(`{api-key}`); Actual behavior The type or namespace name 'AzureKeyCredential' could not be found (are you missing a using directive or an assembly reference?) [C:\Users\bserajelahi\Desktop\TD Engagement\MyConversationAnalysisApp\ MyConversationAnalysisApp.csproj] Reproduction Steps using Azure.Core; using Azure.AI.Language.Conversations; Uri endpoint = new Uri(`https://myaccount.cognitiveservices.azure.com`); AzureKeyCredential credential = new AzureKeyCredential(`{api-key}`); ConversationAnalysisClient client = new ConversationAnalysisClient(endpoint, credential); Environment No response
Mgmt	ARM	[QUERY] C# how to add existing VM into host pool	Library name and version https://github.com/Azure/azure-sdk-for-net/tree/a9e03d83467941a7596aff060a5b3109d94d694a/sdk/desktopvirtualization/Azure.ResourceManager.DesktopVirtualization Query/Question Please share class for HostPoolData.VmTemplate and also share how add/Create session host into host pool using C# Environment C#  and Dot net
Mgmt	Media Services	[BUG] This call throws an error when a resource isn't found; it should simply allow the caller to check the status for a 404	Library name and version Azure.ResourceManager.Media 1.2.0 Describe the bug When retrieving a resource, the code assumes that a 404 should throw an error. This isn't in the spirit of REST - as the consumer of a GET, I should be allowed to determine for myself if the resource was found or not. In the event of a streaming locator, my workflow is to retrieve an existing locator by name and, if not found, create it. If I try to create one, the only call available is CreateOrUpdate. The `Update` portion of this has been acknowledged in a separate ticket to be in error - that call in fact throws if, while creating, it notices that the locator already exists. Because of this, and because GetStreamingLocator throws an exception if one isn't found, I'll have to wrap just this call in its own try/catch block just to determine that I received a 404 - which is in the response object for me to check anyway. Bad SDK architecture, please modify. Expected behavior Return the response object, let me evaluate the status and access the Value property if the response is 200 (or if Value isn't null :) ). Actual behavior Throw an exception Reproduction Steps As stated. Environment Not relevant, it's in the source.
Client	Search	[QUERY] How to convert the Json object to SearchDocument correctly?	Library name and version Azure.Search.Documents Query/Question In our current code which using Microsoft.Azure.Search library, we build the Document from pre-build fields dictionary: IDictionary<string, object> fields. The object in dictionary could be any Json object, like string, string array, complex type array. e.g.: fields[`CatIds`] = { [`1`, `2`] } fields[`Images`] = { [ {`Url`:`https://aaa`, `IsDefault`: false}, {`Url`:`https://bbb`, `IsDefault`: true} ] } When build the azure search document, we just simply assign the field value to Document object. var document = new Document(); foreach (var field in fields) { document[field.Key] = document[field.Value] } And then send documents to index, that worked perfectly. But now we cannot simply assign the value from fields to SearchDocument anymore using SDK v11 (Azure.Search.Documents), if the field value is a JArray value, otherwise we will get exception when sending documents to ACS: Details: An unexpected 'StartArray' node was found when reading from the JSON reader. A 'PrimitiveValue' node was expecte Seems have to manually convert the JArray to List before assign value to SearchDocument. Do you have sample code to handle this conversion? Or guidance document? Environment No response
Client	Service Bus	[QUERY] Is it possible to round-robin messages to Azure ServiceBus Topic's subscriptions?	Library name and version Azure.Messaging.Servicebus 7.14.0 Query/Question I have a requirement where a topic contains 10 subscriptions. Is it possible to group them into two groups, let's say, Grp1 and Grp2 with each containing 5 subscriptions? When the message arrives at the topic, I want the messages to be round-robin between the subscriptions of a particular group. I understand that I can add multiple consumers to a single subscription and get this load balancing. However, this is pertaining to some legacy code and cannot change certain things. I went through the Subscription filter rules but don't think this is possible. However, as a last resort, I thought I can ask the community. Environment No response
Mgmt	Websites	[BUG] Microsoft.Azure.Management.Websites 3.1.2 the resource group validation is not correct	Library name and version Microsoft.Azure.Management.Websites 3.1.2 Describe the bug Microsoft.Rest.ValidationException: 'resourceGroupName' does not match expected pattern '^[-\w._()]+[^\.]$'. The resource group such as s can be created on Azure but can't pass the validation and it throws error Expected behavior The exception shouldn't be thrown for a valid resource group Actual behavior Exception: Microsoft.Rest.ValidationException: 'resourceGroupName' does not match expected pattern '^[-\w._()]+[^\.]$'. at Microsoft.Azure.Management.WebSites.WebAppsOperations.***(String resourceGroupName, String name, Dictionary`2 customHeaders, CancellationToken cancellationToken) at Microsoft.Azure.Management.WebSites.WebAppsOperationsExtensions.ListApplicationSettingsAsync(IWebAppsOperations operations, String resourceGroupName, String name, CancellationToken cancellationToken) Reproduction Steps create a resource group named s and a webapp in it, then call await this._appClient.WebApps.ListApplicationSettingsAsync(resourceGroup, webAppName).ConfigureAwait(false); the error would be thrown Environment .NET SDK: Version:   7.0.203 Commit:    5b005c19f5 Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.203 global.json file: Not found
Client	KeyVault	[BUG] Failure to backup a key/secret returns only bad request instead of proper error message	Library name and version Microsoft.Azure.KeyVault 3.0.4 Describe the bug Failure of Creating a Backup of keys/secret causing the SDK to fail with bad request error where as service returns proper error. Expected behavior To get proper error message in case of failure Actual behavior Getting below error as part of failure System.AggregateException: One or more errors occurred. ---> Microsoft.Azure.KeyVault.Models.KeyVaultErrorException: Operation returned an invalid status code 'BadRequest' at Microsoft.Azure.KeyVault.KeyVaultClient.d__73.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable1.ConfiguredTaskAwaiter.GetResult() at Microsoft.Azure.KeyVault.KeyVaultClientExtensions.<BackupSecretAsync>d__56.MoveNext() --- End of inner exception stack trace --- at System.Threading.Tasks.Task1.GetResultCore(Boolean waitCompletionNotification) at Microsoft.Internal.CloudBackup.Service.Common.CsmV2SdkHelperV2019.CsmV2Helper.BackupKeyVaultSecretData(String secretUrl) in C:__w\1\s\src\Service\CsmV2SdkHelperV2019\KeyVaultHelper.cs:line 93 at Microsoft.Internal.CloudBackup.Service.Common.CsmV2SdkHelperV2019.CsmV2Helper.<>c__DisplayClass128_0.b__0() in C:__w\1\s\src\Service\CsmV2SdkHelperV2019\KeyVaultHelper.cs:line 148 at Microsoft.Internal.CloudBackup.Service.Common.CsmV2SdkHelperV2019.CsmV2Helper.<>c__DisplayClass111_0.b__0() in C:__w\1\s\src\Service\CsmV2SdkHelperV2019\CsmV2SdkHelper.cs:line 295 ---> (Inner Exception #0) Microsoft.Azure.KeyVault.Models.KeyVaultErrorException: Operation returned an invalid status code 'BadRequest' at Microsoft.Azure.KeyVault.KeyVaultClient.d__73.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult() at Microsoft.Azure.KeyVault.KeyVaultClientExtensions.d__56.MoveNext()<--- }the Reproduction Steps If a secret has more than 500 version then the backup of such secret will cause this error Environment Global
Client	Service Bus	[QUERY] How do we test for AMQP over TLS?	Library name and version Azure.Messaging.Servicebus 7.14.0 Query/Question I have an application that uses Azure.Messaging.ServiceBus library to send/receive messages to/from service bus. This application is deployed to various clients. I was using the previous Microsoft.Azure.ServiceBus nuget and this code is kind of used as a `connectivity check` to inform the users whether their network/firewall configurations are in place. var serviceBusConnectionStringBuilder = new ServiceBusConnectionStringBuilder(endPoint, queueName, sasToken, Microsoft.Azure.ServiceBus.TransportType.Amqp); ManagementClient client = new ManagementClient(serviceBusConnectionStringBuilder); isExists = client.QueueExistsAsync(queueName).GetAwaiter().GetResult(); The mainstream code to send/receive was upgraded to use Azure.Messaging.ServiceBus and post-upgrade users complained that the connection is not happening. I realized that the AMQP over TLS was denied by the PaloAlto firewall. Will the `healthcheck` code check for the AMQP over TLS or just the AMQP? If I upgrade the `healthcheck` code also to use the latest sdk, will that try to use AMQP over TLS and can I determine whether AMQPS is enabled in their firewall? The health-check code just checks for the presence of a queue. Should I make it to `sending a dummy message` to acheive the AMQPS attempt? Any thoughts? Environment No response
Service	Cognitive - Form Recognizer	Analyze multiple documents with one request in Azure Form Recognizer using prebuilt-invoice model	The DocumentAnalysisClient.StartAnalyzeDocumentFromUriAsync function accepts a document URI, but we need to analyze multiple documents with a single call. How can we do that?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: d0550e40-a31e-f2fb-71b6-6be3bbe1dbfe Version Independent ID: 7b85784c-8a8a-b4ec-b291-622cc49787ab Content: DocumentAnalysisClient.AnalyzeDocumentFromUriAsync Method (Azure.AI.FormRecognizer.DocumentAnalysis) - Azure for .NET Developers Content Source: xml/Azure.AI.FormRecognizer.DocumentAnalysis/DocumentAnalysisClient.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Mgmt	Quota	[QUERY] Unable to access usages api via the Azure.ResourceManager.Quota SDK	Library name and version Azure.ResourceManager.Quota 1.0.0-beta.3 Query/Question Hello, when I try to access the usages api as described here: Usages- Get I get errors like this: Message:  Azure.RequestFailedException : The resource type 'usages' could not be found in the namespace 'Microsoft.Quota' for api version '2023-02-01'. The supported api-versions are '2021-03-15-preview'. Status: 404 (Not Found) ErrorCode: InvalidResourceType  Content: {`error`:{`code`:`InvalidResourceType`,`message`:`The resource type 'usages' could not be found in the namespace 'Microsoft.Quota' for api version '2023-02-01'. The supported api-versions are '2021-03-15-preview'.`}}  How can I set an api version since it is automatically defaulting to a newer one? Is the usages api deprecrated? I am not able to find this information anywhere. I am using the code snippet thats provided in the sample: string scope = $`/subscriptions/{SubscriptionId}/providers/Microsoft.Compute/locations/{Region}`;             ResourceIdentifier currentUsagesBaseResourceId = CurrentUsagesBaseResource.CreateResourceIdentifier(scope, resourceName);             CurrentUsagesBaseResource currentUsagesBase = ArmClient.GetCurrentUsagesBaseResource(currentUsagesBaseResourceId);              // invoke the operation             CurrentUsagesBaseResource result = await currentUsagesBase.GetAsync();  Environment .NET SDK: Version:   7.0.203 Commit:    5b005c19f5 Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.203\ Host: Version:      7.0.5 Architecture: x64 Commit:       8042d61b17 .NET SDKs installed: 3.0.103 [C:\Program Files\dotnet\sdk] 6.0.408 [C:\Program Files\dotnet\sdk] 7.0.203 [C:\Program Files\dotnet\sdk] 7.0.300-preview.23122.5 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set
Client	Cognitive - Speech	Misleading documentation, parameter says deviceName however it requires a text id such as `{0.0.1.00000000}.{5f23ab69-6181-4f4a-81a4-45414013aac8}`	I went to the c# example and it showed printing a device's friendly name and a device's id, I tried the friendlyname, and it didn't work however the id did work. It would be helpful if the parameter was named better  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 51ea0365-48aa-3375-53be-10cc52feb8ba Version Independent ID: 7c9abf92-cb7c-5e11-2604-9b9b2cd4d464 Content: AudioConfig.FromSpeakerOutput(String) Method (Microsoft.CognitiveServices.Speech.Audio) - Azure for .NET Developers Content Source: xml/Microsoft.CognitiveServices.Speech.Audio/AudioConfig.xml Service: cognitive-services GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Identity	[QUERY] Is there a way to access underlying TokenCache?	Library name and version Azure.Identity 1.9.0 Query/Question ClientSecretCredential internally creates MsalConfidentialClient which in turn creates and uses TokenCache. Is there a way to access and manipulate cache entries, including persistent cache? For example, I want to remove specific entries from cache completely. Any options? The use-case is that my app may receive tokens which miss roles (no admin consent) and in that case I need to force refresh them. Apparently it's not possible to do so? Environment .NET
Client	Tables	[BUG] Getting odata.error `InvalidInput` when using Azurite and oData syntax with 'and' filter expression	Library name and version Azure.Data.Tables Describe the bug I use Azurite for local development. I run this query. The two variables userName and userPW came from a query string (e.g. http://192.168.1.54:7015/api/Command?Login&userName=Peter&userPW=abc). I'm using Azure functions. The following code runs via `await Task.Run(() => [class-instance].[methodname]`) The weird is, when I hardcode the String `User eq 'Peter' and Password eq 'abc` it works fine and I got 1 result. But if I insert the variables, I'm getting the odata.error. Pageable<TableEntity> oDataQueryEntities = tableClient.Query<TableEntity> (filter: TableClient.CreateQueryFilter($`User eq '{userName}' and Password eq '{userPW}'`)); If I omit the second parameter, I'm also getting a result:                     (filter: TableClient.CreateQueryFilter($`User eq '{userName}'`)); The table is there if I check it with the Storage Explorer. Expected behavior See above Actual behavior See above Reproduction Steps See above Environment Win10 Visual Studio Community 2022 17.6.2 Azure.Data.Tables 12.8.0 Azurite 3.22.0
Client	Functions	[BUG] Failing authentication when using EventGrid triggered Azure Function with Blob input	Library name and version Azure.Storage.Blobs 12.13.1 Azure.Identity 1.8.2 Microsoft.Azure.EventGrid 1.3.0 Microsoft.NET.Sdk.Functions 4.1.1 Describe the bug Hi, Recently been having an issue when trying to trigger an EventGrid triggered Azure Function with a Blob input. I'm triggering a function (.NET 6 / v4) running locally in Visual Studio using a payload from Postman, using a similar URL to http://localhost:7071/runtime/webhooks/EventGrid?functionName=FooBar. DefaultAzureCredential is invoked, which tries each authentication method. For reference, I'm running this on an Azure Virtual Desktop, and I'm signed into an account where the default tenant is NOT the tenant we want to use, as we are doing work for another client that's on another tenant. From checking the logs, EnvironmentCredential fails, then it moves onto ManagedIdentityCredential, which calls http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=REDACTED to get a token. It apparently succeeds, the issue being that it's using the wrong tenant ID, and as far as we know there's no way to force it to use a different tenant ID. This step would normally fail, as it does for my coworker as he's not using a Virtual Desktop. but because I'm on an Azure Virtual Desktop it apparently has Managed Identity set up on it, so calls to that endpoint will succeed, but again it's using the wrong tenant ID so the token we get is invalid. So after a lot of messing around we eventually blocked access to that IP address in Windows Defender to force it to move onto the next authentication method, that being VisualStudioCredential. This fails again because the default tenant being used on Visual Studio is not the one we want to use, and we don't seem to be able to change that, so it uses the wrong tenant ID again. So then I just signed out of Visual Studio to force that authentication method to fail, and it moves onto AzureCliCredential, which does work because I can force the correct tenant there through the command line. We think this is an issue with the Azure.Identity library, as with AppAuthentication you were able to override the authentication method using `AzureServicesAuthConnectionString`: `RunAs=Developer; DeveloperTool=AzureCli`, in local.settings.json. But in this case we're using Azure.Identity and this doesn't seem configurable anymore. I will note that this token issue probably isn't specific to functions with a Blob input, we were having a similar issue with a regular endpoint that just takes in an EventGrid event. But in that case it was more an issue of being unable to raise another EventGrid event after triggering an endpoint, because of the token being invalid for the same reasons. This was a lot of work just to be able to run a function locally, and I guess we do have a special set of circumstances here, being on an Azure Virtual Desktop and trying to use a different tenant. But it would be nice to be able to force a specific authentication mechanism, or to find some other resolution that doesn't involve having to block an IP address etc. Expected behavior Be able to configure the authentication mechanism used. Actual behavior (See description) Reproduction Steps Call an EventGrid triggered Azure Function locally, with a Blob input, through Visual Studio, on an Azure Virtual Desktop while signed into an account with multiple tenants, where the relevant tenant is not the default one. Environment Visual Studio Enterprise 2022 17.5.5 Azure Function app (v4, .NET 6) Windows 11 Enterprise Version 10.0.22000 Build 22000 (dotnet --info output) .NET SDK: Version:   7.0.203 Commit:    5b005c19f5 Runtime Environment: OS Name:     Windows OS Version:  10.0.22000 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.203\ Host: Version:      7.0.5 Architecture: x64 Commit:       8042d61b17 .NET SDKs installed: 3.1.426 [C:\Program Files\dotnet\sdk] 6.0.311 [C:\Program Files\dotnet\sdk] 7.0.203 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Mgmt	Automation	[BUG] Cannot remove all tags from a runbook resource	Library name and version Azure.ResourceManager.Automation 1.01, Azure.ResourceManager 1.5 Describe the bug Clearing the Tags property of the AutomationRunbookPatch class, does remove any tags when invoking the AutomationRunbookResource.UpdateAsync method. Note that it is possible to remove and replace one or more existing tags, so long as the tags property is not empty when calling the Patch method. Expected behavior You should be able to remove all  tags from a runbook resource. Actual behavior You cannot clear the tags from a runbook resource. Reproduction Steps   Create a runbook resource in Azure Automation and give it one or more tags (you could do this using either the Azure portal, or using the IAutomationRunboolCollectionClient.CreateOrUpdateAsync method.   Update the resource created in step 1 using the PatchAsync  method. The tags property of the AutomationRunbookPatch class instance should be empty.   Expected: the runbook should be updated and no longer have any tags. Actual: no tags were removed   Environment Windows 10 Visual Studio 2022 (17.4.4)
Client	Tables	[FEATURE REQ] Support for Cosmos Table API OrderBy Queries	Library name Azure.Data.Tables Please describe the feature. In reference to #30423, I believe that OrderBy support should be added to the TableClient in Azure.Data.Tables. The Cosmos DB Nuget package has not been updated in over 4 years, and there are migration paths from Azure Storage to Azure Cosmos Tables to support customers who want more SLA/replication/performance. I don't believe this feature should be omitted just because Azure Storage doesn't support it. Doing so means not taking care of your higher-value customers (the ones who use Cosmos DB vs Storage). This is especially important since results returned by queries to Azure Cosmos Tables are NOT sorted by RowKey ascending, unlike Azure Storage. (ref) So without OrderBy support, there is no way for a Cosmos Table consumer to order their results from a query. I suggest two possible avenues to add this functionality:  Add support for OrderBy as an overload directly to the QueryAsync method.  If this parameter is used against Azure Storage, it should throw an exception, or the API should return a friendly error message stating that ordering is only possible with Cosmos DB.   Create a derived class from TableClient called CosmosTableClient which exposes additional methods specific to Cosmos DB to avoid customer confusion, if that is a concern.  Since it will likely take a while for this functionality to be added, are there any workarounds to using the OrderBy feature in Cosmos Tables with Azure.Data.Tables? It is not an option for our team to use the legacy Cosmos DB Nuget package since it has not been updated.
Client	DevOps	Package for Azure DevOps repository management	Hi there, I could not find out if there is an Azure SDK package that provides functionality like in Azure REST API's devops/git/pull-requests or Azure CLI's az repos. Is there? Best regards.
Mgmt	ARM	Create or Update a Certificate	Library name and version Azure.ResourceManager.* Query/Question What is the SDK equivalent of this REST API? Unfortunately, the SDK is so poorly documented that—after two full days of digging—I finally have to ask. Environment Win11 .NET 7 VS 17.5.1
Client	OpenAI	[BUG] Unable to create CompletionsOptions in F#	Library name and version Azure.AI.OpenAI, 1.0.0-beta.5 Describe the bug The constructor for CompletionsOptions is not visible in F#. let prompts = ResizeArray [ `Write a catchy and....` ] let compOpts =                new CompletionsOptions(                     Prompts = prompts,                     Temperature = float 1,                     MaxTokens = 600,                     NucleusSamplingFactor = float 1,                     FrequencyPenalty = float 0,                     PresencePenalty =  float 0,                     GenerationSampleCount = 1                 )  The above code does not compile in F# script. Please ensure API works for F# as well. Thanks, Faisal Expected behavior Should be able to construct CompletionsOptions in F# Actual behavior Does not compile Reproduction Steps See code above Environment windows 11. .Net 7.0 SDK, Visual Sudio 2019 (latest bits)
Mgmt	Batch	Configuration of Pools with Managed Identities using Azure.ResourceManager.Batch client library	Library name and version Azure.ResourceManager.Batch 1.1.1 Query/Question Can someone help me by providing me with any documentation about how to configure Pools with Managed Identities in Azure batch resources using  Azure.ResourceManager.Batch client library? The actual documentation refers to Microsoft.Azure.Management.Batch sdk, but that package has been deprecated.   Environment No response
Client	Azure.Core	Response was not set, make sure SendAsync was called	Library name and version Azure.Core.HttpMessage.get_response() Describe the bug The bug I am running into is similar to the issue reported here: #33294. When using Rider, and running the application locally in Debug mode, I keep getting this error when making a call to the Azure Blob Storage. I've verified that I have access, that the storage exists, basically, everything is in place. Call Stack `InnerExceptionMessages`: `Response was not set, make sure SendAsync was called`,         `StackTrace`: [             `at Azure.Core.HttpMessage.get_Response()`,             `at System.Diagnostics.DiagnosticSourceEventSource.TransformSpec.PropertySpec.PropertyFetch.RefTypedFetchProperty`2.Fetch(Object obj)`,             `at System.Diagnostics.DiagnosticSourceEventSource.TransformSpec.PropertySpec.Fetch(Object obj)`,             `at System.Diagnostics.DiagnosticSourceEventSource.TransformSpec.Morph(Object obj)`,             `at System.Diagnostics.DiagnosticSourceEventSource.FilterAndTransform.Morph(Object args)`,             `at System.Diagnostics.DiagnosticSourceEventSource.FilterAndTransform.<>c__DisplayClass2_1.<.ctor>b__2(KeyValuePair`2 evnt)`,             `at System.Diagnostics.DiagnosticSourceEventSource.CallbackObserver`1.OnNext(T value)`,             `at System.Diagnostics.DiagnosticListener.Write(String name, Object value)`,             `at Azure.Core.Pipeline.DiagnosticScope.ActivityAdapter.Dispose()`,             `at Azure.Core.Pipeline.DiagnosticScope.Dispose()`,             `at Azure.Core.Pipeline.RequestActivityPolicy.ProcessAsync(HttpMessage message  I can also confirm that this is only happening in Rider. When I am using Visual Studio Community 2022 for example, I do not run into these problems. Unfortunately, I cannot upgrade System.Diagnostics.DiagnosticSourceEventSource to 6.0.0 due legacy code at the moment. (We run the 4.6.0 and 4.7.0) versions Expected Behavior This should just work regardless of IDE/Environment. It clearly works in Visual Studio, but not with Rider. Actual Behavior When calling the .ExistsAsync or .Exists method to verify a container exists on the Azure Blob Storage, the error is thrown. Environment Windows 11 Rider IDE 2023.1.1 .NET Core App 2.2 System.Diagnostics.DiagnosticSourceEventSource < 6.0 I'm not expecting a fix, but a workaround would at least be awesome.
Client	Service Bus	[BUG] ScheduledEnqueueTime is not respected	Library name and version Azure.Messaging.ServiceBus v7.14.0 Describe the bug ScheduledEnqueueTime is not respected, at least for small (10s of seconds) time periods. Expected behavior Scheduled enqueue time is respected: Setting ScheduledEnqueueTime to         17/05/2023 1:01:23 PM Sending message at                      17/05/2023 1:01:03 PM Recieved message at                     17/05/2023 1:01:03 PM Expected delay                          00:00:20 Actual delay                            00:00:20 ---------------------------------------------- Setting ScheduledEnqueueTime to         17/05/2023 1:01:23 PM Sending message at                      17/05/2023 1:01:03 PM Recieved message at                     17/05/2023 1:01:03 PM Expected delay                          00:00:20 Actual delay                            00:00:20 ---------------------------------------------- Setting ScheduledEnqueueTime to         17/05/2023 1:01:23 PM Sending message at                      17/05/2023 1:01:03 PM Recieved message at                     17/05/2023 1:01:03 PM Expected delay                          00:00:20 Actual delay                            00:00:20 ----------------------------------------------  Actual delay should be ~20 seconds, += a few hundred milliseconds each way Actual behavior Setting ScheduledEnqueueTime to         17/05/2023 1:01:23 PM Sending message at                      17/05/2023 1:01:03 PM Recieved message at                     17/05/2023 1:01:03 PM Expected delay                          00:00:20 Actual delay                            00:00:00.5169477 ---------------------------------------------- Setting ScheduledEnqueueTime to         17/05/2023 1:01:23 PM Sending message at                      17/05/2023 1:01:03 PM Recieved message at                     17/05/2023 1:01:03 PM Expected delay                          00:00:20 Actual delay                            00:00:00.1924140 ---------------------------------------------- Setting ScheduledEnqueueTime to         17/05/2023 1:01:23 PM Sending message at                      17/05/2023 1:01:03 PM Recieved message at                     17/05/2023 1:01:03 PM Expected delay                          00:00:20 Actual delay                            00:00:00.1067586 ----------------------------------------------  Reproduction Steps using Azure.Messaging.ServiceBus;  const int PadSize = -40; const int EnqueueDelaySeconds = 20; var connectionString = `<service bus connection string>` var queue = `<queue name>`; var client = new ServiceBusClient(connectionString); var sender = client.CreateSender(queue); var processor = client.CreateProcessor(queue);  processor.ProcessMessageAsync += Processor_ProcessMessageAsync; processor.ProcessErrorAsync += Processor_ProcessErrorAsync;  await processor.StartProcessingAsync(); await SendMessageAsync();  Console.ReadLine();  async Task Processor_ProcessMessageAsync(ProcessMessageEventArgs arg) {     try     {         Console.WriteLine($`{`Recieved message at`,PadSize}{DateTime.UtcNow}`);         Console.WriteLine($`{`Expected delay`,PadSize}{TimeSpan.FromSeconds(EnqueueDelaySeconds)}`);         Console.WriteLine($`{`Actual delay`,PadSize}{DateTime.UtcNow.Subtract(SendTime)}`);         Console.WriteLine($`----------------------------------------------`);         await SendMessageAsync();     }     catch (Exception ex)     {         Console.WriteLine(ex.ToString());     } }  async Task SendMessageAsync() {     var message = new ServiceBusMessage();     var scheduledEnqueueTime = DateTime.UtcNow.AddSeconds(EnqueueDelaySeconds);     Console.WriteLine($`{`Setting ScheduledEnqueueTime to`,PadSize}{scheduledEnqueueTime}`);     message.ScheduledEnqueueTime = scheduledEnqueueTime;     SendTime = DateTime.UtcNow;     Console.WriteLine($`{`Sending message at`,PadSize}{DateTime.UtcNow}`);     await sender.SendMessageAsync(message); }  Task Processor_ProcessErrorAsync(ProcessErrorEventArgs arg) {     throw new NotImplementedException(); }  public partial class Program {     public static DateTime SendTime; } Environment  .NET Version: .NET 6, but can repro on .NET 7.0 as well. OS: Windows   dotnet --info .NET SDK:  Version:   7.0.400-preview.23225.8  Commit:    c63317749e  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\7.0.400-preview.23225.8\  Host:   Version:      7.0.5   Architecture: x64   Commit:       8042d61b17  .NET SDKs installed:   6.0.202 [C:\Program Files\dotnet\sdk]   6.0.203 [C:\Program Files\dotnet\sdk]   6.0.311 [C:\Program Files\dotnet\sdk]   7.0.100 [C:\Program Files\dotnet\sdk]   7.0.400-preview.23225.8 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Mgmt	Automation	JsonReaderException when invoking AutomationCertificateCollection.CreateOrUpdateAsync to create a new certificate	Library name and version Azure.ResourceManager.Automation 1.0.1 Describe the bug We are consistently observing as JsonReaderException when invoking AutomationCertificateCollection.CreateOrUpdateAsync to create a new certificate in Azure Automation. The error message is `'A' is an invalid end of a number. Expected a delimiter. LineNumber: 0 | BytePositionInLine: 8.`. Stack Trace: at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan1 bytes) at System.Text.Json.Utf8JsonReader.TryGetNumber(ReadOnlySpan1 data, Int32& consumed) at System.Text.Json.Utf8JsonReader.ReadFirstToken(Byte first) at System.Text.Json.Utf8JsonReader.ReadSingleSegment() at System.Text.Json.Utf8JsonReader.Read() at System.Text.Json.JsonDocument.Parse(ReadOnlySpan1 utf8JsonSpan, Utf8JsonReader reader, MetadataDb& database, StackRowStack& stack) at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory1 utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedBytes) at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory1 json, JsonDocumentOptions options) at System.Text.Json.JsonDocument.Parse(String json, JsonDocumentOptions options) at Azure.ResourceManager.Automation.Models.AutomationCertificateCreateOrUpdateContent.Azure.Core.IUtf8JsonSerializable.Write(Utf8JsonWriter writer) at Azure.Core.Utf8JsonWriterExtensions.WriteObjectValue(Utf8JsonWriter writer, Object value) at Azure.ResourceManager.Automation.CertificateRestOperations.CreateCreateOrUpdateRequest(String subscriptionId, String resourceGroupName, String automationAccountName, String certificateName, AutomationCertificateCreateOrUpdateContent content) at Azure.ResourceManager.Automation.CertificateRestOperations.<CreateOrUpdateAsync>d__12.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.ResourceManager.Automation.AutomationCertificateCollection.<CreateOrUpdateAsync>d__5.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable1.ConfiguredTaskAwaiter.GetResult() at Kelverion.RunbookStudio.Cloud.Core.AutomationCertificateCollectionClient.d__2.MoveNext() in C:\Users\DavidCader\source\repos\app-automation-console\Src\Kelverion.RunbookStudio.Cloud\Core\AutomationCertificateCollectionClient.cs:line 36 at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable1.ConfiguredTaskAwaiter.GetResult() at Kelverion.RunbookStudio.Cloud.Core.AutomationCollectionClientBase1.d__9.MoveNext() in C:\Users\DavidCader\source\repos\app-automation-console\Src\Kelverion.RunbookStudio.Cloud\Core\AutomationCollectionClientBase.cs:line 58 Expected behavior The certificate should be create successfully Actual behavior A JsonReaderException is invariably observered. Reproduction Steps public async Task CreateOrUpdate_CreateOrUpdateACertificate() { // Generated from example definition: specification/automation/resource-manager/Microsoft.Automation/preview/2020-01-13-preview/examples/createOrUpdateCertificate.json // this example is just showing the usage of `Certificate_CreateOrUpdate` operation, for the dependent resources, they will have to be created separately.         // get your azure access token, for more details of how Azure SDK get your access token, please refer to https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication?tabs=command-line         TokenCredential cred = new DefaultAzureCredential();         // authenticate your client         ArmClient client = new ArmClient(cred);          // this example assumes you already have this AutomationAccountResource created on azure         // for more information of creating AutomationAccountResource, please refer to the document of AutomationAccountResource         string subscriptionId = `subid`;         string resourceGroupName = `rg`;         string automationAccountName = `myAutomationAccount18`;         ResourceIdentifier automationAccountResourceId = AutomationAccountResource.CreateResourceIdentifier(subscriptionId, resourceGroupName, automationAccountName);         AutomationAccountResource automationAccount = client.GetAutomationAccountResource(automationAccountResourceId);          // get the collection of this AutomationCertificateResource         AutomationCertificateCollection collection = automationAccount.GetAutomationCertificates();          // invoke the operation         string certificateName = `testCert`;         AutomationCertificateCreateOrUpdateContent content = new AutomationCertificateCreateOrUpdateContent(`testCert`, `base 64 value of cert`)         {             Description = `Sample Cert`,             Thumbprint = BinaryData.FromString(`thumbprint of cert`),             IsExportable = false,         };         ArmOperation<AutomationCertificateResource> lro = await collection.CreateOrUpdateAsync(WaitUntil.Completed, certificateName, content);         AutomationCertificateResource result = lro.Value;          // the variable result is a resource, you could call other operations on this instance as well         // but just for demo, we get its data from this resource instance         AutomationCertificateData resourceData = result.Data;         // for demo we just print out the id         Console.WriteLine($`Succeeded on id: {resourceData.Id}`);     }  Environment Windows 10 .NET Framework 4.8.1 Visual Studio 17.4.4
Client	KeyVault	[BUG] Client Encryption Feature - If the key uri specified without version id, the decryption will fail to retrieve KEK.	Library name and version Azure.Storage.Blobs 12.16.0 Describe the bug We setup the encryptionOption as below - specify the KEK URI without key version.             // Resolve the KEK using key identifier without key version (basic identifier)             key = await keyResolver.ResolveAsync(`https://jrkeyvault.vault.azure.net/keys/storage-kek`);             Console.WriteLine(`KEK key ID without key version: {0}`, key.KeyId);                   // Create encryption options for uploading and downloading             ClientSideEncryptionOptions encryptionOption = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V2_0)             {                 KeyResolver = keyResolver,                 KeyEncryptionKey = key,         // the code may trigger a bad parameter error when downloading/decryption CEK after key rotation                 KeyWrapAlgorithm = `RSA-OAEP`             };  When we rotate the key in KeyVault (the old key still enabled), the download\decryption will be failed with 400 BadParameter. RequestFailedException: Error occurred while decoding OAEP padding. Status: 400 (Bad Request) ErrorCode: BadParameter  Content: {`error`:{`code`:`BadParameter`,`message`:`Error occurred while decoding OAEP padding.`}}  Headers: Cache-Control: no-cache Pragma: no-cache x-ms-keyvault-region: eastasia x-ms-client-request-id: 8b5074cc-45da-406b-842e-b4f38a9bfb17 x-ms-request-id: 25b98b11-643c-41c3-90ae-d7ada677b567 x-ms-keyvault-service-version: 1.9.787.1 x-ms-keyvault-network-info: conn_type=Ipv4;addr=167.220.255.18;act_addr_fam=InterNetwork; X-Content-Type-Options: REDACTED Strict-Transport-Security: REDACTED Date: Mon, 15 May 2023 09:31:49 GMT Content-Length: 89 Content-Type: application/json; charset=utf-8 Expires: -1   Expected behavior The decryptor should fetch the correct key from keyvault to finish the decryption. This process should not rely on the encryptionOption. Actual behavior 400 Error - seems from KeyVault. If we use a keyURI with key version, e.g. https://jrkeyvault.vault.azure.net/keys/storage-kek/xxxxxxxx This issue will not happened. Reproduction Steps  Setup the blob client and encryptionOption with URI described above Using the blobclient to upload a blob with client encryption. Rotate the key in the key vault manually Continue download the blob using the same blob client.  CODE using Azure.Storage.Blobs; using Azure.Storage.Blobs.Specialized; using Azure.Storage.Blobs.Models; using Azure.Storage; using Azure.Identity; using Azure.Core.Cryptography; using Azure.Security.KeyVault.Keys.Cryptography; using Azure.Security.KeyVault.Keys; using System;  namespace StorageClientEncrptoin {     class Program     {         static async Task Main(String[] args)         {             Console.WriteLine(`Hello Azure Blob Storage with client side encryption!`);              // Get token             DefaultAzureCredential cred = new DefaultAzureCredential();             Uri storageUri = new Uri(`https://jr3.blob.core.windows.net`);              //var kvclient = new KeyClient(keyvaultUri, cred);               // Create local test file             string localPath = `data`;             Directory.CreateDirectory(localPath);             string fileName = `quickstart` + Guid.NewGuid().ToString() + `.txt`;             string localFilePath = Path.Combine(localPath, fileName);             await File.WriteAllTextAsync(localFilePath, `Hello World!`);              IKeyEncryptionKey key;             IKeyEncryptionKeyResolver keyResolver;              // Create key resolver to resolve key             keyResolver = new KeyResolver(cred);              // Resolve the KEK using key identifier without key version (basic identifier)             key = await keyResolver.ResolveAsync(`https://jrkeyvault.vault.azure.net/keys/storage-kek`);             Console.WriteLine(`KEK key ID without key version: {0}`, key.KeyId);                   // Create encryption options for uploading and downloading             ClientSideEncryptionOptions encryptionOption = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V2_0)             {                 KeyResolver = keyResolver,                 KeyEncryptionKey = key,         // the code may trigger a bad parameter error when downloading/decryption CEK after key rotation                 KeyWrapAlgorithm = `RSA-OAEP`             };              BlobClientOptions blobClientOption = new SpecializedBlobClientOptions()             {                 ClientSideEncryption = encryptionOption             };              // Get blob service client and container client and blob client             string containerName = `quickstartblobs` + Guid.NewGuid().ToString();             BlobServiceClient blobServiceClient = new BlobServiceClient(storageUri, cred, blobClientOption);             BlobContainerClient blobContainerClient = await blobServiceClient.CreateBlobContainerAsync(containerName);             BlobClient blobClient = blobContainerClient.GetBlobClient(fileName);              // Upload the test file to blob container             Console.WriteLine(`Uploading to Blob storage as blob:\n\t {0}\n`, blobClient.Uri);             await blobClient.UploadAsync(localFilePath, true);              // List blobs in the container             Console.WriteLine(`Listening blobs...`);             await foreach (BlobItem blobItem in blobContainerClient.GetBlobsAsync())             {                 Console.WriteLine(`\t` + blobItem.Name);             }             Console.WriteLine(`\n`);              // kvclient.RotateKey(key.KeyId);             // Console.WriteLine(`Rotating keys...`);                // Download a blob             Console.WriteLine(`Press any key to download blob...`);             Console.ReadLine();              IKeyEncryptionKey newkey = await keyResolver.ResolveAsync(keyUri);             Console.WriteLine(`New KEK key ID: {0}`, newkey.KeyId);              string downloadFilePath = localFilePath.Replace(`.txt`, `DOWNLOADED.txt`);             Console.WriteLine(`\nDownloading blob to\n\t{0}\n`, downloadFilePath);             try             {                 await blobClient.DownloadToAsync(downloadFilePath);             }             catch (Azure.RequestFailedException e)             {                 // RequestFailedException will be captured after key rotation                 Console.WriteLine(`{0}: {1}`, e.GetType().Name, e.Message);             }              // Delete a container             Console.Write(`Press any key to begin clean up...`);             Console.ReadLine();                          Console.WriteLine(`Deleting blob container...`);             await blobContainerClient.DeleteAsync();              // Clean up local file             Console.WriteLine(`Deleting the local source and downloaded files...`);             File.Delete(localFilePath);             File.Delete(downloadFilePath);             Console.WriteLine(`Done.`);         }     }  }  Environment Tested on both Azure AppServiace and local machine. Local .NET SDK: Version:   7.0.203 Commit:    5b005c19f5 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.203\ Host: Version:      7.0.5 Architecture: x64 Commit:       8042d61b17 .NET SDKs installed: 7.0.203 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found
Central-EngSys	EngSys	[QUERY] Scheduled Event Processor Action creates noise on forks	Library name and version All Query/Question The Scheduled Event Processor github action is triggered also on forks according to the schedule and creates lots of failed actions noise on those. Would it be possible to conditionally skip those when the github token is not available? (which is only known on the upstream repo here) Environment No response
Mgmt	Container Instances	[QUERY] Azure.RequestFailedException: The image in container group is not accessible. Please check the image and registry credential.	Library name and version Azure.ResourceManager.ContainerInstance 1.1.0 Query/Question I have a few questions. The code will be pasted below.  Does this code both create a Container Group and the Container Instance? Does the Container Group specified need to already exist? I want to use an image from Azure Container Registry using the credentials in my DefaultAzureCredential. When I try to run the code below, I get the following error:  Azure.RequestFailedException: 'The image 'http://*****.azurecr.io/*****:*****' in container group '*****' is not accessible. Please check the image and registry credential. Status: 400 (Bad Request) ErrorCode: InaccessibleImage  I tried to look at setting ImageRegistryCredentials but there is no way to set them as the DefaultAzureCredential. Is this setup wrong? What is the correct way to create an Azure Container Instance using an image from ACR? I saw this answer but I'd like to transparently use the identity of where the code is running (e.g. - Local development or an Azure Function) without having to specifically input the identity. Thanks! 😸             var azureCredential = new DefaultAzureCredential(new DefaultAzureCredentialOptions             {                 ExcludeEnvironmentCredential = true,                 ExcludeInteractiveBrowserCredential = true,                 ExcludeAzurePowerShellCredential = true,                 ExcludeSharedTokenCacheCredential = true,                 ExcludeVisualStudioCodeCredential = true,                 ExcludeVisualStudioCredential = true,                 // ExcludeAzureCliCredential = true,                 // ExcludeManagedIdentityCredential = true,             });             var client = new ArmClient(azureCredential);              String subscriptionId = `*****************`;             String resourceGroupName = `*********************`;              String containerName = `mycontainer-1`;             String image = `http://*****.azurecr.io/*****:*****`;             String containerGroupName = `container-1`;              var subscription = await client.GetSubscriptions().GetAsync(subscriptionId);             var resourceGroup = subscription.Value.GetResourceGroup(resourceGroupName);             var containerGroupCollection = resourceGroup.Value.GetContainerGroups();              //Int32 count = containerGroupCollection.Count();             //foreach (var g in containerGroupCollection)             //{             //    // g.Id             //}              // Create Container Instance             var reqs = new ContainerResourceRequirements(new ContainerResourceRequestsContent(memoryInGB: 1, cpu: 1));             var container = new ContainerInstanceContainer(containerName, image, reqs);             var containers = new List<ContainerInstanceContainer> { container };             var data = new ContainerGroupData(AzureLocation.EastUS, containers, ContainerInstanceOperatingSystemType.Windows);             data.ImageRegistryCredentials.Add(new ContainerGroupImageRegistryCredential(``) { Identity = `` });             ArmOperation<ContainerGroupResource> result = await containerGroupCollection.CreateOrUpdateAsync(WaitUntil.Completed, containerGroupName, data);  Environment Windows 11 Enterprise Visual Studio 2022
Client	Azure.Identity	ManagedIdentityCredential token cache not working?	I recently upgraded Azure.Identity to version 1.8.2, hoping I can get rid of my token caching implementation and rely on the internal caching. however, from looking at Application Insights logs, it looks like there is no caching going on, and a token is acquired before every access to the database. Here is a screenshot for example. I highlighted requests for a token and the corresponding database calls.  I am using a ChainedTokenCredential like this:         private static TokenCredential GetCredential()         {             return new ChainedTokenCredential(                 new ManagedIdentityCredential(),                 new VisualStudioCredential(),                 new EnvironmentCredential()             );         } and then get a token like this:         public SqlConnection GetConnection()         {             SqlConnection conn = new SqlConnection(Config.ConnectionString);             if (!Config.IsDevEnvironment)  //in dev we use an on-prem db             {                 TokenCredential credential = GetCredential();                                  AccessToken token = credential.GetToken(new TokenRequestContext(new[] { `https://database.windows.net/.default` }), CancellationToken.None);                                  conn.AccessToken = token.Token;             }             return conn;         } Am I doing something wrong?
Client	Event Grid	[QUERY] Getting started with the Event Grid Extensions	Library name and version Microsoft.Azure.WebJobs.Extensions.EventGrid --version 3.2.1 Query/Question Hello, I am currently working on a project which requires me to connect two seperate twins on Azure digital twins in order to send live telemetry from on to the other. I have seen a github repo with the code to do so and have hence tried to execute this myself in order to understand it better. On trying to upload the code from VS Code to Azure Functions I am encountering a couple of errors which I will share in this query. The solutions I have found online were to either install this package or to reference it in my .csproj file. I have tried out both these solutions but am unfortunately still stuck with the same error. What would be my best course of action in order to tackle this issue?  Environment .NET SDK (reflecting any global.json): Version:   6.0.407 Commit:    d8659ea151 Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.407\ global.json file: Not found Host: Version:      6.0.15 Architecture: x64 Commit:       5edef4b20b .NET SDKs installed: 6.0.407 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Download .NET: https://aka.ms/dotnet-download Learn about .NET Runtimes and SDKs: https://aka.ms/dotnet/runtimes-sdk-info The IDE I am using is VS Code
Mgmt	API Management	Problem creating a new API in an existing APIM instance	Library name and version Azure.ResourceManager.ApiManagement 1.0.1 Query/Question hi, I'm trying to add a new API to an existing APIM instance and I'm getting this error: Azure.RequestFailedException: 'One or more fields contain incorrect values: Status: 400 (Bad Request) ErrorCode: ValidationError Content: {`error`:{`code`:`ValidationError`,`message`:`One or more fields contain incorrect values:`,`details`:[{`code`:`ValidationError`,`target`:`protocols`,`message`:`API must define at least one supported protocol`}]}} Headers: Cache-Control: no-cache Pragma: no-cache Strict-Transport-Security: REDACTED X-Content-Type-Options: REDACTED x-ms-request-id: 31390054-6e8a-4b81-b551-1f4ca19f9fa5 Server: Microsoft-HTTPAPI/2.0 x-ms-ratelimit-remaining-subscription-writes: REDACTED x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED Date: Wed, 10 May 2023 19:56:20 GMT Content-Length: 213 Content-Type: application/json; charset=utf-8 Expires: -1 Here is my code: public class AzureApimService : IAzureApimService {     private readonly ArmClient _client;     public AzureApimService(string tenantId, string clientId, string clientSecret)     {         //_client = new ArmClient(new DefaultAzureCredential());         _client = new ArmClient(new Azure.Identity.ClientSecretCredential(tenantId, clientId, clientSecret));     }      public async Task CreateApi(string apiName, string apimName, string resourceGroupName, string revision, string apiPath, string backendUrl)     {         try         {             SubscriptionResource subscription = await _client.GetDefaultSubscriptionAsync();             ResourceGroupCollection resourceGroups = subscription.GetResourceGroups();             ResourceGroupResource resourceGroup = await resourceGroups.GetAsync(resourceGroupName);             ApiManagementServiceResource apimResource = await resourceGroup.GetApiManagementServiceAsync(apimName);             ApiCollection apiCollection = apimResource.GetApis();             var protocols = new List<string>();             protocols.Add(`http`);             protocols.Add(`https`);             var api = new ApiCreateOrUpdateContent             {                 ApiRevision = revision,                 ApiType = ApiType.Http,                 DisplayName = apiName,                 Path = apiPath,                 ServiceUri = new Uri(backendUrl),                 IsSubscriptionRequired = false,                 IsCurrent = true             };              await apiCollection.CreateOrUpdateAsync(Azure.WaitUntil.Completed, apiName.Trim().Replace(` `,``), api); ;         }         catch (Exception ex)         {              throw ex;         }     } }  Protocol property of the ApiCreateOrUpdateContent class is read only and I can't figure out how to populate the list. Environment Visual Studio 2022 Windows 11 Enterprise .Net 6
Mgmt	ARM	[BUG] ValidateRestore (and TriggerRestore) does not work as expected	Library name and version Azure.ResourceManager.DataProtectionBackup 1.1.2 Describe the bug This may not seem to be a valid issue but I believe it is an issue with the sdk since a direct REST api call for the same operation works without any issues. I created a related issue to these libs and that was addressed - #35526 Here is a code snippet that throws Azure.RequestFailedException `             var dataSourceResourceId = DataProtectionBackupInstanceResource.CreateResourceIdentifier(                            _subscriptionId,                            _resourceGroupName,                            _vaultName,                            _backupInstanceName);             var backupInstanceResource =                 _armClient.GetDataProtectionBackupInstanceResource(dataSourceResourceId                     );             DataSourceInfo dataSourceInfo = new DataSourceInfo(dataSourceResourceId);             RecoverySetting recoverySetting = new RecoverySetting(`FailIfExists`);             IEnumerable<ItemLevelRestoreCriteria> restoreCriteria = new List<ItemLevelRestoreCriteria>             {                 new RangeBasedItemLevelRestoreCriteria                 {                     MinMatchingValue = `test3`,                     MaxMatchingValue = `test3-0`                 }             }              RestoreTargetInfoBase restoreTarget = new ItemLevelRestoreTargetInfo(recoverySetting, restoreCriteria, dataSourceInfo);             SourceDataStoreType sourceDataStoreType = SourceDataStoreType.OperationalStore;             var recoverOn = new DateTimeOffset(new DateTime(2023, 5, 2, 5, 21, 30, DateTimeKind.Utc));             BackupRestoreContent backupRestoreContent = new BackupRecoveryTimeBasedRestoreContent(restoreTarget, sourceDataStoreType, recoverOn);             BackupValidateRestoreContent backupValidateRestoreContent = new BackupValidateRestoreContent(backupRestoreContent);              var backupInstance = await backupInstanceResource.GetAsync();             var backupInstancetData = backupInstance.Value.Data;                        // this is Line#295 in the Stack trace added below that throws the exception.             var operation = await backupInstance.Value.ValidateRestoreAsync(WaitUntil.Completed, backupValidateRestoreContent);             var operationStatus = await operation.WaitForCompletionAsync();  ` More details on the exception - Azure.RequestFailedException : User input provided for the call is invalid Status: 400 (Bad Request) ErrorCode: BMSUserErrorInvalidInput Content: {`error`:{`additionalInfo`:[{`type`:`UserFacingError`,`info`:{`message`:`User input provided for the call is invalid`,`recommendedAction`:[`Please check the required inputs`],`details`:null,`code`:`BMSUserErrorInvalidInput`,`target`:``,`innerError`:null,`isRetryable`:false,`isUserError`:false,`properties`:{`ActivityId`:`635cf2d3-afd5-4624-b127-39c85fcf61c5`}}}],`code`:`BMSUserErrorInvalidInput`,`message`:`User input provided for the call is invalid`,`target`:null,`details`:null}} Headers: Cache-Control: no-cache Pragma: no-cache Server: Kestrel x-ms-ratelimit-remaining-subscription-writes: REDACTED X-Content-Type-Options: REDACTED x-ms-request-id: a43ba84e-8228-459e-9f14-c238be64e870 x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED Strict-Transport-Security: REDACTED Date: Wed, 10 May 2023 15:00:06 GMT Content-Length: 484 Content-Type: application/json; charset=utf-8 Expires: -1 Stack Trace:  BackupInstancesRestOperations.ValidateForRestoreAsync(String subscriptionId, String resourceGroupName, String vaultName, String backupInstanceName, BackupValidateRestoreContent content, CancellationToken cancellationToken) DataProtectionBackupInstanceResource.ValidateRestoreAsync(WaitUntil waitUntil, BackupValidateRestoreContent content, CancellationToken cancellationToken) AzureBlobStorageDemoTests.ValidateRestore() line 295 <>c.b__128_0(Object state) Expected behavior The method ValidateRestoreAsync should not throw an exception. Actual behavior The method ValidateRestoreAsync throws an exception - Azure.RequestFailedException : User input provided for the call is invalid Status: 400 (Bad Request) ErrorCode: BMSUserErrorInvalidInput Reproduction Steps Run the code snippet attached in the description. Environment
Mgmt	Data Factory	Unable to create ADF Azure Storage Linked Services	Library name and version Azure.ResourceManager.DataFactory 1.0.0-beta.2 Query/Question While trying to create an ADF resource with linked services, pipelines, etc, the creation of the Linked Service happens `successfully` however, the resource is not in a usable state. Snippet: private async Task<FactoryDatasetResource> CreateBlobDataset(         DataFactoryResource adf,         StorageBackupConfigEntry entry)     {         var prodResourceGroup = await this._azure.Production.GetResourceGroupAsync(entry.ResourceGroup);         var storage = await prodResourceGroup.Value.GetStorageAccounts().GetAsync(entry.AccountName);          StorageAccountKey key = default!;         await foreach (var k in storage.Value.GetKeysAsync()) // Yeah this is ugly, but is what we have in the API...         {             key = k;             break;         }          var blobLinkedService = new AzureBlobStorageLinkedService()         {             ConnectionString = BinaryData.FromObjectAsJson($`DefaultEndpointsProtocol=https;AccountName={entry.AccountName};AccountKey={key};EndpointSuffix=core.windows.net;`),         };          var data = new FactoryLinkedServiceData(blobLinkedService);          var linkedService = await adf.GetFactoryLinkedServices().CreateOrUpdateAsync(WaitUntil.Completed, entry.AccountName, data);          var linkedServiceReference = new FactoryLinkedServiceReference(FactoryLinkedServiceReferenceType.LinkedServiceReference, linkedService.Value.Data.Name);          var blobDataSet = new BinaryDataset(linkedServiceReference);          blobDataSet.Parameters.Add(`container`, new EntityParameterSpecification(EntityParameterType.String));          blobDataSet.Parameters.Add(`directory`, new EntityParameterSpecification(EntityParameterType.String));          blobDataSet.DataLocation = new AzureBlobStorageLocation()         {              // Couldn't find the proper class to represent the expression so, using anonymous type             Container = BinaryData.FromObjectAsJson(new { value = `@dataset().container`, type = `Expression` }),             FolderPath = BinaryData.FromObjectAsJson(new { value = `@dataset().directory`, type = `Expression` })         };          var ds = new FactoryDatasetData(blobDataSet);          var blobDs = await adf.GetFactoryDatasets().CreateOrUpdateAsync(WaitUntil.Completed, entry.AccountName, ds);          return blobDs.Value;     } When opening the Linked Service resource in the ADF designer, I see the resource there without any errors. But when I click on it and try to Test the connection (or if I try to run a pipeline that uses it) I get the following error: Invalid storage connection string provided to 'UnknownLocation'. Check the storage connection string in configuration.  No valid combination of account information found.  Activity ID: e49844bf-4d63-4d76-a9fb-65a69127aa53.  I would appreciate any light on what may be missing here. Thanks! Environment .NET SDK:  Version:   7.0.102  Commit:    4bbdd14480  Runtime Environment:  OS Name:     Mac OS X  OS Version:  13.3  OS Platform: Darwin  RID:         osx.13-arm64  Base Path:   /usr/local/share/dotnet/sdk/7.0.102/  Host:   Version:      7.0.2   Architecture: arm64   Commit:       d037e070eb  .NET SDKs installed:   6.0.405 [/usr/local/share/dotnet/sdk]   7.0.102 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.13 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.2 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.13 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.2 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]  Other architectures found:   x64   [/usr/local/share/dotnet/x64]     registered at [/etc/dotnet/install_location_x64]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Client	Azure.Identity	[BUG] ClientOptions.Retry.NetworkTimeout is ignored	Library name and version Azure.Identity 1.8.2 Describe the bug I am getting the next error: info: Azure.Core[1]       Request [1aba6828-8759-4d40-958d-3346d567b6e2] GET http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=REDACTED       Metadata:REDACTED       x-ms-client-request-id:1aba6828-8759-4d40-958d-3346d567b6e2       x-ms-return-client-request-id:true       User-Agent:azsdk-net-Identity/1.8.2 (.NET 7.0.3; Darwin 22.4.0 Darwin Kernel Version 22.4.0: Mon Mar  6 21:00:17 PST 2023; root:xnu-8796.101.5~3/RELEASE_X86_64)       client assembly: Azure.Identity info: Azure.Core[18]       Request [1aba6828-8759-4d40-958d-3346d567b6e2] exception System.Threading.Tasks.TaskCanceledException: The operation was cancelled because it exceeded the configured timeout of 0:00:01. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.   However, I explicitly specify the timeouts: builder.Services.AddAzureClients(clientBuilder => {     clientBuilder.ConfigureDefaults(options =>     {         //options.Retry.NetworkTimeout = TimeSpan.FromSeconds(10);     });          // Add a Storage account client     clientBuilder.AddBlobServiceClient(builder.Configuration.GetSection(`AzureBlobStorage`)).ConfigureOptions(         options =>         {             options.Retry.NetworkTimeout = TimeSpan.FromSeconds(15);         }     );      // Use DefaultAzureCredential by default     clientBuilder.UseCredential(new DefaultAzureCredential(new DefaultAzureCredentialOptions()     {         Retry = { NetworkTimeout = TimeSpan.FromSeconds(10) }     })); });  A brief investigation showed that the timeout is overridden in ResponseBodyPolicy  Expected behavior The timeout should be the same as specified in the config Actual behavior The timeout is overridden for some reason. Reproduction Steps Configure the project as follows builder.Services.AddAzureClients(clientBuilder => {     clientBuilder.ConfigureDefaults(options =>     {         //options.Retry.NetworkTimeout = TimeSpan.FromSeconds(10);     });          // Add a Storage account client     clientBuilder.AddBlobServiceClient(builder.Configuration.GetSection(`AzureBlobStorage`)).ConfigureOptions(         options =>         {             options.Retry.NetworkTimeout = TimeSpan.FromSeconds(15);         }     );      // Use DefaultAzureCredential by default     clientBuilder.UseCredential(new DefaultAzureCredential(new DefaultAzureCredentialOptions()     {         Retry = { NetworkTimeout = TimeSpan.FromSeconds(10) }     })); });  Call var blobContainerClient = _blobServiceClient.GetBlobContainerClient(containerName); var blobClient = blobContainerClient.GetBlobClient(blobName); var response = await blobClient.DownloadAsync(cancellationToken: cancellationToken);  Environment .NET SDK: Version:   7.0.201 Commit:    68f2d7e7a3 Runtime Environment: OS Name:     Mac OS X OS Version:  13.3 OS Platform: Darwin RID:         osx.13-x64 Base Path:   /usr/local/share/dotnet/sdk/7.0.201/ Host: Version:      7.0.3 Architecture: x64 Commit:       0a2bda10e8
Mgmt	Network - Front Door	[BUG] GetFrontDoorsAsync does not list Azure Front Door Premium resources	Library name and version Azure.ResourceManager.FrontDoor Describe the bug None of the methods within Azure.ResourceManager.FrontDoor that are used to Get Front Door Resources do not seem to work with Azure Front Door Premium. Expected behavior Should be able to call any of the methods for getting FrontDoor and any Front Door Premium resource should be listed. Actual behavior Methods fail to find any Front Doors. Reproduction Steps Create an Azure Front Door Premium resource within a subscription. Attempt to use the following code to retrieve it:             string subscriptionId = `subid`;             ResourceIdentifier subscriptionResourceId = SubscriptionResource.CreateResourceIdentifier(subscriptionId);             SubscriptionResource subscriptionResource = client.GetSubscriptionResource(subscriptionResourceId);              // invoke the operation and iterate over the result             await foreach (FrontDoorResource item in subscriptionResource.GetFrontDoorsAsync())             {                 // the variable item is a resource, you could call other operations on this instance as well                 // but just for demo, we get its data from this resource instance                 FrontDoorData resourceData = item.Data;                 // for demo we just print out the id                 Console.WriteLine($`Succeeded on id: {resourceData.Id}`);             } Environment Windows 11, .NET 6 (6.0.16), Visual Studio 17.5.1
Client	Azure.Identity	[BUG] MissingMethodException Method not found: 'System.String System.Diagnostics.Activity.get_TraceStateString()'	Library name and version Azure.Identity 1.8.2 Describe the bug It seems that #32314 (From 6 months ago) hasn't made it's way to a released version of Azure.Identity yet, where is `compiled in` so updating the Azure.Core package in the consuming application doesn't help. Tag Azure.Identity_1.8.2 (from 3 months ago):                azure-sdk-for-net/sdk/core/Azure.Core/src/Shared/DiagnosticScope.cs                    Line 247       in       9623f9a                                                 var link = ActivityExtensions.CreateActivityLink(activity.ParentId!, activity.TraceStateString, linkTagsCollection);                     So it crashes on Azure Functions v1 :( Expected behavior No crash :) Actual behavior System.MissingMethodException: Method not found: 'System.String System.Diagnostics.Activity.get_TraceStateString()' at Azure.Core.Pipeline.DiagnosticScope+ActivityAdapter.GetActivitySourceLinkCollection (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Azure.Core.Pipeline.DiagnosticScope+ActivityAdapter.Start (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Azure.Core.Pipeline.DiagnosticScope.Start (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Azure.Identity.CredentialPipeline+ScopeHandler.Azure.Identity.IScopeHandler.Start (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Azure.Identity.CredentialDiagnosticScope.Start (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Azure.Identity.CredentialPipeline.StartGetTokenScope (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at Azure.Identity.ClientSecretCredential+d__19.MoveNext (Azure.Identity, Version=1.8.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Reproduction Steps Call ClientSecretCredential.GetTokenAsync(). Environment Azure Functions v1  Could a new version of Azure.Identity with the updated Azure.Core code please be released? It may also be wise to check any other packages that may be including this code.
Mgmt	API Management	Can not update Product Policy using the Azure.ResourceManager.ApiManagement SDK	Hi, I have a problem with the Azure.ResourceManager.ApiManagement SDK. If I create a product in Azure APIM and then try to update the product policy, the policy is always null. My code looks similar to this: ResourceIdentifier id = ApiManagementServiceResource.CreateResourceIdentifier(_subscriptionId, _resourceGroupName, _serviceName); ClientSecretCredential credentials = new(_tenantId, _clientId, _clientSecret);  ArmClient client = new(credentials); ApiManagementServiceResource apimService = await client.GetApiManagementServiceResource(id).GetAsync();   ApiManagementServiceResource apimService = await GetApiManagementServiceAsync(); Response<ApiManagementProductResource> productResponse = await apimService.GetApiManagementProductAsync(subscription.ResourceId); ApiManagementProductPolicyResource? apimPolicy = productResponse.Value.GetApiManagementProductPolicies().FirstOrDefault();  Next I'd call the apimPolicy.UpdateAsync method, but apimPolicy is always null. I'm not sure how to handle it because it doesn't seem to be a way to actually create a policy if it doesn't exist. AND, it works if I go into the Azure Portal and click the default policy for the product and save it without any changes. Then the apimPolicy object can be used to update the policy.
Client	Event Grid	Event Grid Topic subscribed by azure function app c#	Library name and version Latest version Query/Question Here we want to understand behavior of Event grid topic >> when we subscribe Event grid topic with azure function app and while processing azure function app side unhandled exception thrown whether that message will be retired internally ? if not what will happen to that message. Environment No response
Mgmt	ARM	Not able to use ResourceGroupResource.ExportTemplateAsync to export templates	Need to use Azure SDK for dotnet to export templates programmatically. ExportTemplateAsync() takes ExportTemplate object as an argument to describe what and how to export. ExportTemplate class's Resources propertes is read-only. This prevents callers from specifying `*` for all resources or specific resources that need to be exported. Basically this make the API method ExpotrtTemplateAsync() unusable. If there are another other classes and methods that can do deployed resource templates export, please let me know as well.
Client	Event Hubs	[BUG] Getting FunctionInputConverterException when parsing EventData from IoT hub	Library name and version Azure.Messaging.EventHubs 5.9.0 Describe the bug For my current project I am trying to get the lifecycle events from the IoT Hub via the Event Hub to my Function app. See also this stackoverflow question. Even tough I use a .net 6.0 non-isolated environment I still keep running into the issue that once a message arrives at the Function app it throws an FunctionInputConverterException once it is called by the event hub. Expected behavior No exceptions and a log with all the event data as well as the life cycle data from my IoT device. Actual behavior See here and here for the exceptions I got. Reproduction Steps I grabbed my full test project and uploaded it to github. https://github.com/the-programmer/AzureFunctionIssue See the original stackoverflow question for the full set-up details. Environment The set-up for the Function app was as follows.  IDE is Visual studio 17.5.4
Client	Service Bus	[QUERY] AddServiceBusClient with managed identity	Library name and version Azure.Messaging.ServiceBus 7.13.1 Query/Question I want to use ASP.NET Core dependency injection with a Managed Identity. In the documentation there are two relevant examples:  Then register the client in the Startup.ConfigureServices method: public void ConfigureServices(IServiceCollection services) {     services.AddAzureClients(builder =>     {         builder.AddServiceBusClient(Configuration.GetConnectionString(`ServiceBus`));     });        services.AddControllers(); }  And  Authenticating with Azure.Identity The Azure Identity library provides easy Azure Active Directory support for authentication. // Create a ServiceBusClient that will authenticate through Active Directory string fullyQualifiedNamespace = `yournamespace.servicebus.windows.net`; await using var client = new ServiceBusClient(fullyQualifiedNamespace, new DefaultAzureCredential());  However, builder.AddServiceBusClient does not take a fullyQualifiedNamespace, using one there gives  System.FormatException: The connection string could not be parsed; either it was malformed or contains no well-known tokens.  This is how my code currently looks like:       .AddAzureClients(builder => builder         .AddServiceBusClient(fullyQualifiedNamespace)         .WithCredential(new DefaultAzureCredential())       ); Environment ASP.NET Core 6.0.15 Visual studio 17.5.3
Client	Azure.Identity	[BUG] Trying to send email via Azure Communication Service and get a AADSTS65002 when using DefaultTokenCredentials.	Library name and version Azure.Communication.Email 1.0.0 Describe the bug p.s. everything works if i use the connection string with key. When trying to authenticate use DefaultTokenCredentials (which resolves to AZ CLI Auth), i get AuthenticationFailedException: Azure CLI authentication failed due to an unknown error. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/azclicredential/troubleshoot ERROR: AADSTS65002: Consent between first party application '04b07795-8ddb-461a-bbee-02f9e1bf7b46' and first party resource '632ec9eb-fad7-4cbd-993a-e72973ba2acc' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API.  Trace ID: 04bbb4fb-50c8-4444-aac8-1c0068440500  Correlation ID: b9689670-8f28-4b3e-a96a-28781a3b6d03  Timestamp: 2023-04-25 19:59:32Z To re-authenticate, please run: az login --scope https://communication.azure.com//.default  My code is csharp: builder.Services.AddAzureClients(azureBuilder => {   azureBuilder.UseCredential(new DefaultAzureCredential());   azureBuilder.AddEmailClient(new Uri(`https://resourceName.communication.azure.com/`));  }); I can prove that my account has access to the service as i get valid information (and can even get the keys if i try) az communication show --resource-group `LocalDEV` --name `resourceName` What am i doing wrong ? 1 - I would like myself and devs to be able to work on their local development machines 2 - I want to ensure that i can deploy and that the ManagedIdentity will work correctly once hosed on Azure App Service. 3 - DefaultTokenCredential work correctly to integrate KeyVault and Azure App Conifugration using Managed Identities AND local development. Expected behavior p.s. everything works if i use the connection string with key. When trying to authenticate use DefaultTokenCredentials (which resolves to AZ CLI Auth), i get AuthenticationFailedException: Azure CLI authentication failed due to an unknown error. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/azclicredential/troubleshoot ERROR: AADSTS65002: Consent between first party application '04b07795-8ddb-461a-bbee-02f9e1bf7b46' and first party resource '632ec9eb-fad7-4cbd-993a-e72973ba2acc' must be configured via preauthorization - applications owned and operated by Microsoft must get approval from the API owner before requesting tokens for that API.  Trace ID: 04bbb4fb-50c8-4444-aac8-1c0068440500  Correlation ID: b9689670-8f28-4b3e-a96a-28781a3b6d03  Timestamp: 2023-04-25 19:59:32Z To re-authenticate, please run: az login --scope https://communication.azure.com//.default  My code is csharp: builder.Services.AddAzureClients(azureBuilder => {   azureBuilder.UseCredential(new DefaultAzureCredential());   azureBuilder.AddEmailClient(new Uri(`https://resourceName.communication.azure.com/`));  });  I can prove that my account has access to the service as i get valid information (and can even get the keys if i try) az communication show --resource-group `LocalDEV` --name `resourceName` What am i doing wrong ? 1 - I would like myself and devs to be able to work on their local development machines 2 - I want to ensure that i can deploy and that the ManagedIdentity will work correctly once hosed on Azure App Service. 3 - DefaultTokenCredential work correctly to integrate KeyVault and Azure App Conifugration using Managed Identities AND local development. Actual behavior DefaultTokenCredential works correctly on a local dev machine and hosted using Managed Identities. Reproduction Steps builder.Services.AddAzureClients(azureBuilder => {   azureBuilder.UseCredential(new DefaultAzureCredential());   azureBuilder.AddEmailClient(new Uri(`https://modeloncommservices.communication.azure.com/`)); });  public class EmailSender : IEmailSender {   private readonly EmailClient EmailClient;   private readonly ILogger Logger;    public EmailSender(EmailClient emailClient, ILogger<EmailSender> logger)   {     this.EmailClient = emailClient;     this.Logger = logger;   }    public async Task SendEmailAsync(string email, string subject, string htmlMessage)   {     EmailContent emailContent = new(subject)     {       Html = htmlMessage     };      EmailRecipients emailRecipients = new(       new List<EmailAddress>()       {           new EmailAddress(email)       });      EmailMessage emailMessage = new(`DoNotReply@ffffffffe.azurecomm.net`, emailRecipients, emailContent);      EmailSendOperation result = await EmailClient.SendAsync(Azure.WaitUntil.Completed, emailMessage);      if (result.Value.Status != EmailSendStatus.Succeeded)     {       Logger.ErrorSendingEmail(email);     }   } } Environment Windows 11, dotnet 7 <PackageReference Include=`Azure.Communication.Email` Version=`1.0.0` /> <PackageReference Include=`Microsoft.Extensions.Azure` Version=`1.6.3` />
Mgmt	ARM	Unable to create API Operation with parameters	When trying to create an operation with any parameters using the .net sdk a 400 is returned. Example code: ResourceIdentifier apiResourceId = ApiResource.CreateResourceIdentifier(configs.subscriptionId, configs.resourceGroupName, configs.serviceName, apiName); ApiResource api = client.GetApiResource(apiResourceId); ApiOperationCollection collection = api.GetApiOperations(); ApiOperationData data = new ApiOperationData() { Description = operation.Description, DisplayName = operation.Name, Method = operation.HTTPType.ToString(), UriTemplate = operation.FrontendURITemplate,                 }; ArmOperation<ApiOperationResource> lro = await collection.CreateOrUpdateAsync(WaitUntil.Completed, operation.OperationId, data); Even if I use the Example URL `/customers/{cid}/orders/{oid}/?date={date}` I receive the following error {`error`:{`code`:`ValidationError`,`message`:`One or more fields contain incorrect values:`,`details`:[{`code`:`ValidationError`,`target`:``,`message`:`All template parameters used in the UriTemplate must be defined in the Operation 'OperationName', and vice-versa.`}]}} This suggests I should be defining the parameters but as you can see  public IList<ParameterContract> TemplateParameters { get; } doesn't contain a setter
Client	Service Bus	ServiceBusAdministrationClient proxy	ommunication from the machine is only allowed through proxy. When I create client I can set proxy by specifying WebProxy in ServiceBusClientOptions for ServiceBusClient The thing is I cannot find any proxy configs for a ServiceBusAdministrationClient in ServiceBusAdministrationOptions or anywhere else. That's probably the reason I cannot connect to ASB. Feels like I am missing something here. Could you please tell what is the correct way to run it behind proxy?
Client	Service Bus	[QUERY] ServiceBusAdministrationClient proxy	Library name and version Azure.Messaging.ServiceBus 7.12.0 Query/Question Communication from the machine is only allowed through proxy. When I create client I can set proxy by specifying WebProxy in ServiceBusClientOptions for ServiceBusClient The thing is I cannot find any proxy configs for a ServiceBusAdministrationClient in ServiceBusAdministrationOptions or anywhere else. That's probably the reason I cannot connect to ASB. Feels like I am missing something here. Could you please tell what is the correct way to run it behind proxy? Environment .NET 6
Client	KeyVault	[QUERY] Updating an AKV Key in place	Library name and version Azure.Security.KeyVault.Keys Query/Question Hi! I'm writing an application that requires an akv key to have its value updated. The current method that I've been using is to delete the key with TryDeleteKeyFromKeyVaultAsync and then creating a new key with the same name as the deleted one. Is there a way to update the value of the key in place? I see that KeyClient has an UpdateKeyPropertiesAsync method, but I'm not sure if that creates a new value for the key while keeping the same name, which is what I need. Please let me know if this makes sense; I'm happy to clarify as needed. Happy Monday! Environment VS 2022, .NET 7
Mgmt	IoT	[FEATURE REQ] Align capacity data types in SKU types	Library name Azure.ResourceManager.IotHub Please describe the feature. To avoid casting and to align data types Capacity should be aligned either towards long? or int?.                azure-sdk-for-net/sdk/iothub/Azure.ResourceManager.IotHub/src/Generated/Models/IotHubSkuInfo.cs                    Line 36       in       d72d72a                                                 public long? Capacity { get; set; }                     vs.                azure-sdk-for-net/sdk/resourcemanager/Azure.ResourceManager/src/Resources/Generated/Models/ResourcesSku.cs                    Line 46       in       d72d72a                                                 public int? Capacity { get; set; }
Client	Extensions	CVE in System.Drawing.Common 4.7.0 dependency still there	@jsquire Hi! Thank you for your effort and quick responses! Unfortunately the problem is still there :(   Originally posted by @SymbioticKilla in #32781 (comment)
Client	Service Bus	[QUERY] How to mock raising events from ServiceBusSessionProcessor in a unit test	Library name and version Azure.Messaging.ServiceBus 7.13.1 Query/Question Hi, TL;DR: It looks like ServiceBusSessionProcessor cannot be mocked such that event handling just works, even though event handlers are the way to interact with it from consumer code. Is that by design? If so, how would you write a unit test that validates the correctness of the event handlers that are actually registered to ServiceBusSessionProcessor? I'm having difficulty mocking a ServiceBusSessionProcessor in a unit test. That is, I can mock its methods, but I can't raise events or intercept handler registration, as events are not virtual. Most observations below also apply to ServiceBusProcessor. I hope I'm missing something trivial, and that there is a simple way to validate what I would want my test to validate. I'll try to work out the problem and my own attempts thus far at resolving them. The code to test is a IHostedService implementation that gets a ServiceBusClient injected, which it uses to create a ServiceBusSessionProcessor. It wires up handlers to the ProcessMessageAsync and ProcessErrorAsync events, and starts the processor. Upon receiving of a message, it extracts the message payload from the body, and passes that to a an external handler, which is also injected. The event handlers are private members. The code looks like this: public class MessageProcessor : IHostedService {     private readonly MessageProcessorOptions _options;     private readonly ServiceBusClient _serviceBusClient;     private readonly IMessageHandler _messageHandler;     private ServiceBusSessionProcessor? _processor;      public MessageProcessor(IOptions<MessageProcessorOptions> options, ServiceBusClient serviceBusClient, IMessageHandler messageHandler)     {         _options = options.Value;         _serviceBusClient = serviceBusClient;         _messageHandler = messageHandler;     }      public async Task StartAsync(CancellationToken cancellationToken)     {         if ((_processor?.IsProcessing).GetValueOrDefault()) return;          var processorOptions = new ServiceBusSessionProcessorOptions         {             AutoCompleteMessages = false         };         _processor = _serviceBusClient.CreateSessionProcessor(_options.Queue, processorOptions);         _processor.ProcessMessageAsync += ProcessMessageAsync;         _processor.ProcessErrorAsync += ProcessErrorAsync;         await _processor.StartProcessingAsync(cancellationToken);     }      public async Task StopAsync(CancellationToken cancellationToken)     {         if (_processor != null && !_processor.IsClosed)         {             await _processor.StopProcessingAsync(cancellationToken);             await _processor.CloseAsync(cancellationToken);         }     }      private Task ProcessErrorAsync(ProcessErrorEventArgs arg)     {         // Log stuff         return Task.CompletedTask;     }      private async Task ProcessMessageAsync(ProcessSessionMessageEventArgs arg)     {         var payload = JsonSerializer.Deserialize<MessagePayload>(arg.Message.Body);         await _messageHandler.Handle(payload);         await arg.CompleteMessageAsync(arg.Message);     } }  I made several attempts to make this work. Naive mock The first attempt is a simple mock of all the dependencies:     [Fact]     public async Task GivenMockProcessor_WhenMessageReceived_ShouldCallMessageHandler()     {         // Arrange         var message = ServiceBusModelFactory.ServiceBusReceivedMessage(BinaryData.FromObjectAsJson(new MessagePayload()));         var mockProcessor = new Mock<ServiceBusSessionProcessor>();         var mockClient = new Mock<ServiceBusClient>();         mockClient             .Setup(client => client.CreateSessionProcessor(It.IsAny<string>(), It.IsAny<ServiceBusSessionProcessorOptions>()))             .Returns(mockProcessor.Object);         Mock<ServiceBusSessionReceiver> mockSessionReceiver = new();          TimerCallback dispatchMessage = async _ =>         {             ProcessSessionMessageEventArgs processArgs = new(                 message: message,                 receiver: mockSessionReceiver.Object,                 cancellationToken: CancellationToken.None);              mockProcessor.Raise(processor => processor.ProcessMessageAsync += (args) => { return Task.CompletedTask; }, processArgs);         };          Timer messageDispatchTimer = new(             dispatchMessage,             null,             Timeout.Infinite,             Timeout.Infinite);           mockProcessor.Setup(processor => processor.StartProcessingAsync(It.IsAny<CancellationToken>())).Returns(Task.CompletedTask).Callback(() => messageDispatchTimer.Change(0, 1000));         mockProcessor.Setup(processor => processor.StopProcessingAsync(It.IsAny<CancellationToken>())).Returns(Task.CompletedTask).Callback(() => messageDispatchTimer.Change(Timeout.Infinite, Timeout.Infinite));          var handlerMock = new Mock<IMessageHandler>();         handlerMock.Setup(h => h.Handle(It.IsAny<MessagePayload>())).Verifiable();          var options = Options.Create(new MessageProcessorOptions { Queue = `theQueue` });          var sut = new MessageProcessor(options, mockClient.Object, handlerMock.Object);          // Act         await sut.StartAsync(CancellationToken.None); // This throws a null pointer when an attempt is made to register an event handler, as is done in the SUT         await Task.Delay(2000);         await sut.StopAsync(CancellationToken.None);          // Assert         handlerMock.Verify(h => h.Handle(It.IsAny<MessagePayload>()), Times.AtLeastOnce());     }  This breaks in the IHostedService implementation, because the registration of a handler of ProcessMessageAsync is greeted with a NullReferenceException. So that's the first question: Is registering an event handler on a mocked ServiceBusSessionProcessor supposed to yield a NullReferenceException? Mocking the InnerProcessor In an attempt to fix this, I went into the source code and found the protected InnerProcessor property. So I tried to mock that as well:     [Fact]     public async Task GivenMockProcessorWithInnerProcessor_WhenMessageReceived_ShouldCallMessageHandler()     {         // Arrange         var message = ServiceBusModelFactory.ServiceBusReceivedMessage(BinaryData.FromObjectAsJson(new MessagePayload()));         var mockProcessor = new Mock<ServiceBusSessionProcessor>();         var mockClient = new Mock<ServiceBusClient>();         mockClient             .Setup(client => client.CreateSessionProcessor(It.IsAny<string>(), It.IsAny<ServiceBusSessionProcessorOptions>()))             .Returns(mockProcessor.Object);         Mock<ServiceBusSessionReceiver> mockSessionReceiver = new();          TimerCallback dispatchMessage = async _ =>         {             ProcessSessionMessageEventArgs processArgs = new(                 message: message,                 receiver: mockSessionReceiver.Object,                 cancellationToken: CancellationToken.None);              mockProcessor.Raise(processor => processor.ProcessMessageAsync += (args) => { return Task.CompletedTask; }, processArgs); // Throws (kills the test host process); complains about non-virtual members         };          Timer messageDispatchTimer = new(             dispatchMessage,             null,             Timeout.Infinite,             Timeout.Infinite);           mockProcessor.Setup(processor => processor.StartProcessingAsync(It.IsAny<CancellationToken>())).Returns(Task.CompletedTask).Callback(() => messageDispatchTimer.Change(0, 1000));         mockProcessor.Setup(processor => processor.StopProcessingAsync(It.IsAny<CancellationToken>())).Returns(Task.CompletedTask).Callback(() => messageDispatchTimer.Change(Timeout.Infinite, Timeout.Infinite));          var handlerMock = new Mock<IMessageHandler>();         handlerMock.Setup(h => h.Handle(It.IsAny<MessagePayload>())).Verifiable();          var options = Options.Create(new MessageProcessorOptions { Queue = `theQueue` });          var sut = new MessageProcessor(options, mockClient.Object, handlerMock.Object);          // Act         await sut.StartAsync(CancellationToken.None);         await Task.Delay(2000);         await sut.StopAsync(CancellationToken.None);          // Assert         handlerMock.Verify(h => h.Handle(It.IsAny<MessagePayload>()), Times.AtLeastOnce());     }  This breaks upon raising the event using Moq Raise(). Using Moq to setup the event handler An alternate approach to at least get to the registered handle and then invoke that manually, instead of invoking it through raising the event from the ServiceBusSessionProcessor also broke down:     [Fact]     public async Task GivenMockProcessorWithEventSetup_WhenMessageReceived_ShouldCallMessageHandler()     {         // Arrange         var message = ServiceBusModelFactory.ServiceBusReceivedMessage(BinaryData.FromObjectAsJson(new MessagePayload()));         Func<ProcessSessionMessageEventArgs, Task> handler = null;          var mockProcessor = new Mock<ServiceBusSessionProcessor>();         mockProcessor             .SetupAdd(processor => processor.ProcessMessageAsync += (args) => { return Task.CompletedTask; }) // Throws; complains about non-virtual members             .Callback<Func<ProcessSessionMessageEventArgs, Task>>(h => handler = h);         var mockClient = new Mock<ServiceBusClient>();         mockClient             .Setup(client => client.CreateSessionProcessor(It.IsAny<string>(), It.IsAny<ServiceBusSessionProcessorOptions>()))             .Returns(mockProcessor.Object);         Mock<ServiceBusSessionReceiver> mockSessionReceiver = new();          TimerCallback dispatchMessage = async _ =>         {             ProcessSessionMessageEventArgs processArgs = new(                 message: message,                 receiver: mockSessionReceiver.Object,                 cancellationToken: CancellationToken.None);              mockProcessor.Raise(processor => processor.ProcessMessageAsync += (args) => { return Task.CompletedTask; }, processArgs); // Throws (kills the test host process); complains about non-virtual members         };          Timer messageDispatchTimer = new(             dispatchMessage,             null,             Timeout.Infinite,             Timeout.Infinite);           mockProcessor.Setup(processor => processor.StartProcessingAsync(It.IsAny<CancellationToken>())).Returns(Task.CompletedTask).Callback(() => messageDispatchTimer.Change(0, 1000));         mockProcessor.Setup(processor => processor.StopProcessingAsync(It.IsAny<CancellationToken>())).Returns(Task.CompletedTask).Callback(() => messageDispatchTimer.Change(Timeout.Infinite, Timeout.Infinite));          var handlerMock = new Mock<IMessageHandler>();         handlerMock.Setup(h => h.Handle(It.IsAny<MessagePayload>())).Verifiable();          var options = Options.Create(new MessageProcessorOptions { Queue = `theQueue` });          var sut = new MessageProcessor(options, mockClient.Object, handlerMock.Object);          // Act         await sut.StartAsync(CancellationToken.None);         await Task.Delay(2000);         await sut.StopAsync(CancellationToken.None);          // Assert         handlerMock.Verify(h => h.Handle(It.IsAny<MessagePayload>()), Times.AtLeastOnce());     }  This breaks upon setting up the events on the mock using Moq SetupAdd(). So both Moq approaches (Raise() and SetupAdd()) for doing interesting stuff with events broke down. As it turns out, the ProcessMessageAsync and ProcessErrorAsync events are not virtual(!). From what I understood, virtual public members are the way to go in all Azure SDK's for reasons of testability, since SDK types no longer have interfaces for reasons of evolvability. So, the second question is: Why are events on the ServiceBusProcessor and ServiceBusSessionProcessor not marked as virtual? What alternative are you offering for testability? I've seen the sample code at https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Azure.Messaging.ServiceBus/tests/Samples/Sample15_MockingClientTypes.cs (more specifically the MockRunningTheSessionProcessor() test), but that sample assumes outside access to the event handlers and it invokes them manually. I have two objections to this approach:  I don't like my event handler methods to be publicly accessible. The code under test is consuming a dependency from which it obtains a message which it passes to another downstream dependency. From the perspective of the test code, I shouldn't have to know or care about how that works internally. I don't like the idea of invoking the handlers manually, even apart from their visibility. Invoking the handlers manually means invoking the handlers that I assume to be attached to the events, not the handlers I know to be attached. A refactoring where the handler method is replaced and now contains a bug, will now be missed. I'm testing the old handler, whereas at runtime another faulty handler is actually wired to the event.  So the third question is: Is there anything that can be done to mock ServiceBusSessionProcessor (or ServiceBusProcessor for that matter) such that a unit test can be written to validate the correctness of the event handlers that will actually be called at runtime? Environment Using .NET 6.0; Visual Studio 2022 17.5.3; Moq 4.18.4; xUnit 2.4.2
Client	Service Bus	[QUERY] How does the MaxConcurrentCallsPerSession setting in ServiceBusSessionProcessor actually works?	Library name and version Azure.Messaging.ServiceBus 7.13.1 Query/Question So currently we have a web app application that is creating a non-session subscription to a topic setting the MaxConcurrentCalls setting to 1. AFAIK that means that if we have 4 instances then we will have at most 4 message locks being acquired for the subscription (one for each instance). So far so good. Now we have a business requirement that will imply that we need to process the messages in order depending on some value. Fortunately we found that ASB has the perfect feature for that and that is sessions: https://learn.microsoft.com/en-us/azure/service-bus-messaging/message-sessions Now reading the docs it seems that it is perfect for our use case: if we have the same 4 instances then it means that each one of them will acquire a session lock. That will guarantee that messages with the same session ID will be processed in order. `Long live sessions` we thought. We wanted to start writing the code to setup our ServiceBusSessionProcessor but that's when we started to have some doubts: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Azure.Messaging.ServiceBus/samples/Sample05_SessionProcessor.md More specifically I saw the MaxConcurrentCallsPerSession setting and that's when everything I read in the docs stopped making sense in my head. I thought you could only process one message per session given that the processor was gonna acquire a session lock but it seems that's not true. I guess that setting MaxConcurrentCallsPerSession greater than 1 means that the processor will acquire a session lock, read multiple messages from that session and then it will start processing concurrently (and that would mean that messages from the same session could be processed in an out-of-order way)? If that's the case I believe the message sessions documentation should be updated to mention that is something that can be done if you want to because all that page is talking about ordered handling. But more importantly let's say that we still have the same 4 web app instances, would setting MaxConcurrentCallsPerSession equal to 1 guarantee to us that we will never see multiple messages from the same session being processed at the same time if we use the ServiceBusSessionProcessor? Environment  Hosting platform: .NET 7 Visual Studio 2022
Client	Event Hubs	[QUERY] Inquiry on EventHubsProducerClient SendIdempotentAsync	Library name and version Azure.Messaging.EventHubs Query/Question It seems to me that Service Bus and Event Hubs take different approaches towards duplication mitigation. SB performs this on the service side with uuid generated on the client side, while EH tries to achieve this with SendIdempotentAsync. I vaguely remember somewhere it says the EH was built on top of SB (I am very likely wrong on this). But I was just wondering why these two services take two different approaches? In addition, I am a bit confused by SendIdempotentAsync, because this seems like something that should be already taken care of by the AMQP 1.0 protocol (the section where it discusses link recovery). Part of my confusion comes from how I am trying to mimic the dotnet sdk in rust. Because of rust's ownership model, the underlying AMQP sender takes the ownership of the message and also takes care of resolving duplication upon recovery. And thus I feel like implementing something similar to SendIdempotent is not necessary. Environment No response
Client	Azure.Core	Method not found: void Azure.Core.RequestUriBuilder.AppendPath(System.ReadOnlySpan`1<char>,bool)	I'm running a brand new Xamarin.Forms app with Azure.Storage.Blobs 12.15 nuget.  Everything runs fine on an Android device, but fails on an ios device(tried several).  The code that is failing is in the PCL. byte[] blobBytes = null;  StorageSharedKeyCredential cred = new StorageSharedKeyCredential(`<username>`, `<password>`); BlobServiceClient blobServiceClient = new BlobServiceClient(new Uri($`https://<StorageAccountName>.blob.core.windows.net`), cred, null); BlobContainerClient containerClient = blobServiceClient.GetBlobContainerClient(`<ContainerName>`);             BlobClient blob = containerClient.GetBlobClient(`<PathToBlob>`);  using (MemoryStream ms = new MemoryStream()) {  Response response = blob.DownloadTo(ms); <-- Failing Here(Error in the subject of this ticket)  blobBytes = ms.ToArray(); } Please help.  I'm trying to upgrade from the old deprecated WindowsAzure.Storage to the new Azure.Storage.Blobs in our app and ran into this problem.  I'm using a brand new Xamarin.Forms app to remove all other factors.  It works in MAUI on both types of devices, just not Xamarin.
Client	Extensions	Migration from IConfigurationBuilder.AddAzureKeyVault	Please provide information, samples, or a link to assist with migration from IConfigurationBuilder.AddAzureKeyVault to this new model.
Mgmt	Kusto	[BUG] KustoDatabaseCollection CreateOrUpdateAsync returning ResourceNotFound - false failure	Library name and version Azure.ResourceManager.Kusto 1.3.0 Describe the bug when calling the KustoDatabaseCollection.CreateOrUpdateAsync  with WaitUntil.Completed we are getting this exception: The resource with identifier '/subscriptions/**/resourceGroups/**/providers/Microsoft.Kusto/Clusters/**/Databases/**' is not found. Status: 404 (Not Found) ErrorCode: ResourceNotFound at Azure.Core.OperationInternal1.GetResponseFromState(OperationState1 state) at Azure.Core.OperationInternal1.<UpdateStatusAsync>d__20.MoveNext() at System.Threading.Tasks.ValueTask1.get_Result() at Azure.Core.OperationInternalBase.d__13.MoveNext() at System.Threading.Tasks.ValueTask1.get_Result() at Azure.Core.OperationPoller.<WaitForCompletionAsync>d__11.MoveNext() at System.Threading.Tasks.ValueTask1.get_Result() at Azure.Core.OperationInternalBase.d__19.MoveNext() at System.Threading.Tasks.ValueTask1.get_Result() at Azure.Core.OperationInternal1.d__19.MoveNext() at System.Threading.Tasks.ValueTask1.get_Result() at Azure.Core.OperationInternal1.d__15.MoveNext() at System.Threading.Tasks.ValueTask`1.get_Result() at Azure.ResourceManager.Kusto.KustoDatabaseCollection.d__7.MoveNext() but after waiting 1 minute, the database was actually successfully created! Expected behavior when WaitUntil.Completed is provided, the operation is expected to be awaited until the long-running operation has completed without unexpected errors. Actual behavior exception is thrown, but the operation is actually succeeded after waiting up to one additional minute. Reproduction Steps initialize ArmClient with token credentials and define the cluster resource identifier then : var kustoClusterResource = new ArmClient(tokenCredentials).GetKustoClusterResource(clusterResourceIdentifier);   await kustoClusterResource.GetKustoDatabases().CreateOrUpdateAsync(WaitUntil.Completed,databaseName,databaseData); Environment No response
Mgmt	Recovery Services Backup	[BUG] Azure.ResourceManager.RecoveryServicesBackup	Library name and version Azure.ResourceManager.RecoveryServicesBackup Describe the bug Hi I have an azure SQL VM. I have an azure recovery vault. Takes backup every day of the SQL DB's. Takes backup once a week of the VM. All is working, and from inside Jobs in the vault it shows all success. But now i want to use the SDK  (Nuget: Azure.ResourceManager.RecoveryServicesBackup) For an daily report, that i need. All works perfectly, except when there are a VM backup i the timespan: From my code (Working perfectly, filter include SQL backup ie 'AzureWorkload'): //Actually `startTime eq ...` does a `startTime gt...` String filter = `startTime eq '2023-03-29 00:00:00 AM' and backupManagementType eq 'AzureWorkload'`; Pageable backupJobResources = resourceGroup.GetBackupJobs(`/MyRecoveryServicesvault`).GetAll(filter); From my code (NOT Working throws exception, at the time a VM backup is hit, in a following foreach): //Actually `startTime eq ...` does a `startTime gt...` String filter = `startTime eq '2023-03-29 00:00:00 AM'` System.InvalidOperationException HResult=0x80131509 Message=The requested operation requires an element of type 'String', but the target element has type 'Number'. Source=System.Text.Json StackTrace: at System.Text.Json.JsonDocument.GetString(Int32 index, JsonTokenType expectedType) at Azure.ResourceManager.RecoveryServicesBackup.Models.IaasVmBackupJob.DeserializeIaasVmBackupJob(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.Models.BackupGenericJob.DeserializeBackupGenericJob(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.BackupJobData.DeserializeBackupJobData(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.BackupJobCollection.<>c__DisplayClass11_0.b__2(JsonElement e) at Azure.Core.PageableHelpers.PageableImplementation1.<GetEnumerator>d__17.MoveNext() at BackupNotify.Function1.Run(TimerInfo myTimer, ILogger log) in D:\Visual Studio 2022\Projects\BackupNotify\Function1.cs:line 153 at Microsoft.Azure.WebJobs.Host.Executors.VoidMethodInvoker2.InvokeAsync(TReflected instance, Object[] arguments) at Microsoft.Azure.WebJobs.Host.Executors.FunctionInvoker`2.d__10.MoveNext() Expected behavior That i do not get an exception if the the timespan includes a VM backup. Actual behavior Hi I have an azure SQL VM. I have an azure recovery vault. Takes backup every day of the SQL DB's. Takes backup once a week of the VM. All is working, and from inside Jobs in the vault it shows all success. But now i want to use the SDK  (Nuget: Azure.ResourceManager.RecoveryServicesBackup) For an daily report, that i need. All works perfectly, except when there are a VM backup i the timespan: From my code (Working perfectly, filter include SQL backup ie 'AzureWorkload'): //Actually `startTime eq ...` does a `startTime gt...` String filter = `startTime eq '2023-03-29 00:00:00 AM' and backupManagementType eq 'AzureWorkload'`; Pageable backupJobResources = resourceGroup.GetBackupJobs(`/MyRecoveryServicesvault`).GetAll(filter); From my code (NOT Working throws exception, at the time the VM backup is hit, in a following foreach): //Actually `startTime eq ...` does a `startTime gt...` String filter = `startTime eq '2023-03-29 00:00:00 AM'` System.InvalidOperationException HResult=0x80131509 Message=The requested operation requires an element of type 'String', but the target element has type 'Number'. Source=System.Text.Json StackTrace: at System.Text.Json.JsonDocument.GetString(Int32 index, JsonTokenType expectedType) at Azure.ResourceManager.RecoveryServicesBackup.Models.IaasVmBackupJob.DeserializeIaasVmBackupJob(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.Models.BackupGenericJob.DeserializeBackupGenericJob(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.BackupJobData.DeserializeBackupJobData(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.BackupJobCollection.<>c__DisplayClass11_0.b__2(JsonElement e) at Azure.Core.PageableHelpers.PageableImplementation1.<GetEnumerator>d__17.MoveNext() at BackupNotify.Function1.Run(TimerInfo myTimer, ILogger log) in D:\Visual Studio 2022\Projects\BackupNotify\Function1.cs:line 153 at Microsoft.Azure.WebJobs.Host.Executors.VoidMethodInvoker2.InvokeAsync(TReflected instance, Object[] arguments) at Microsoft.Azure.WebJobs.Host.Executors.FunctionInvoker`2.d__10.MoveNext() Reproduction Steps Hi I have an azure SQL VM. I have an azure recovery vault. Takes backup every day of the SQL DB's. Takes backup once a week of the VM. All is working, and from inside Jobs in the vault it shows all success. But now i want to use the SDK  (Nuget: Azure.ResourceManager.RecoveryServicesBackup) For an daily report, that i need. All works perfectly, except when there are a VM backup i the timespan: From my code (Working perfectly, filter include SQL backup ie 'AzureWorkload'): //Actually `startTime eq ...` does a `startTime gt...` String filter = `startTime eq '2023-03-29 00:00:00 AM' and backupManagementType eq 'AzureWorkload'`; Pageable backupJobResources = resourceGroup.GetBackupJobs(`/MyRecoveryServicesvault`).GetAll(filter); From my code (NOT Working throws exception, at the time the VM backup is hit, in a following foreach): //Actually `startTime eq ...` does a `startTime gt...` String filter = `startTime eq '2023-03-29 00:00:00 AM'` System.InvalidOperationException HResult=0x80131509 Message=The requested operation requires an element of type 'String', but the target element has type 'Number'. Source=System.Text.Json StackTrace: at System.Text.Json.JsonDocument.GetString(Int32 index, JsonTokenType expectedType) at Azure.ResourceManager.RecoveryServicesBackup.Models.IaasVmBackupJob.DeserializeIaasVmBackupJob(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.Models.BackupGenericJob.DeserializeBackupGenericJob(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.BackupJobData.DeserializeBackupJobData(JsonElement element) at Azure.ResourceManager.RecoveryServicesBackup.BackupJobCollection.<>c__DisplayClass11_0.b__2(JsonElement e) at Azure.Core.PageableHelpers.PageableImplementation1.<GetEnumerator>d__17.MoveNext() at BackupNotify.Function1.Run(TimerInfo myTimer, ILogger log) in D:\Visual Studio 2022\Projects\BackupNotify\Function1.cs:line 153 at Microsoft.Azure.WebJobs.Host.Executors.VoidMethodInvoker2.InvokeAsync(TReflected instance, Object[] arguments) at Microsoft.Azure.WebJobs.Host.Executors.FunctionInvoker`2.d__10.MoveNext() Environment Visual studio 2022 latest update, and latest update of nuget packets.
Client	Event Hubs	[QUERY] outgoing messages higher than incoming	Library name and version Azure.Messaging.EventHubs.Processor 5.9.0 Query/Question I have an xunit application test that publishes 5 values to event hub when executed and received those 5 events. The event hub has 1 partition with the $Default consumer group. In the metric I see the nr of outgoing messages is higher than incoming. I expect 5 incoming and 5 outgoing in each test run. But the nr of outgoing message seems to increment by 5 every time.  I called the UpdateCheckpointAsync method in event processing and saw that the checkpoint properties are updated in the storage. Below is the code. I've put a breakpoint in the EventHubProcessor_ProcessEventAsync and it's only hit 5 times. Where do the rest of outgoing messages go to? Is there a way to get the number the same. var processor = new EventProcessorClient(storageClient, EventHubConsumerClient.DefaultConsumerGroupName, eventHubConnectionString, new EventProcessorClientOptions { Identifier = `myapplicationtest`  }); processor.ProcessEventAsync += this.EventHubProcessor_ProcessEventAsync; processor.ProcessErrorAsync += this.EventHubProcessor_ProcessErrorAsync; await processor.StartProcessingAsync(); await Task.Delay(TimeSpan.FromSeconds(15)); // wait for the events to be processed try {     await processor.StopProcessingAsync(); } finally {     // To prevent leaks, the handlers should be removed when processing is complete.     processor.ProcessEventAsync -= EventHubProcessor_ProcessEventAsync;     processor.ProcessErrorAsync -= EventHubProcessor_ProcessErrorAsync; }  private async Task EventHubProcessor_ProcessEventAsync(ProcessEventArgs arg) {     var body = Encoding.UTF8.GetString(arg.Data.EventBody);     try     {          var receivedEvents = JsonSerializer.Deserialize<List<ChangeOfValue>>(body);          allReceivedEvents.AddRange(receivedEvents);     }     catch (JsonException)     {     }     finally     {         await arg.UpdateCheckpointAsync(arg.CancellationToken);     } }  Environment XUnit 2.4.2 Visual Studio 17.5.2
Client	Event Hubs	[FEATURE REQ] Configurable Connection timeout for eventhub	Library name Azure.Messaging.EventHubs 5.8.1 Please describe the feature. Due to satellite connection and a congested network channel, we're constantly hitting an eventhub connection timeout limit. Switching to a better connection is not a viable option. With current version of EventHub library, there's no way to configure a custom timeout for AMQP connection setup. The default timeout is set to 30 seconds, but it's hardwired in property AmqpConnectionScope.SessionTimeout Manually changing just the parameter to 1 minute and recompiling the Eventhub assembly solved our problem. Can you please make this parameter user configurable ? Best regards, Stefano
Mgmt	Cosmos	[BUG] Null timestamp value in the Azure CosmosDB - MongoDB database and collection resource	Library name and version Azure.ResourceManager.CosmosDB 1.3.0 Describe the bug Timestamp in the ExtendedMongoDBCollectionResourceInfo and ExtendedMongoDBDatabaseResourceInfo are returned as null when accessing the data of created MongoDBCollectionResource or MongoDBDatabaseResource Found while trying to add a test where I got a null ref when trying to access the timestamp https://dev.azure.com/azure-sdk/public/_build/results?buildId=2696245&view=ms.vss-test-web.build-test-results-tab&runId=40366958&resultId=101299&paneView=debug Expected behavior Timestamp should be returned when accessing the data of ExtendedMongoDBCollectionResourceInfo or ExtendedMongoDBDatabaseResourceInfo Actual behavior getting null as timestamp value for MongoDB database and collection resource Reproduction Steps Create a MongoDB database or collection resource in Azure CosmosDB Try getting the value of Timestamp from the data of the created resources Environment No response
Client	Service Bus	In the text is written: **CompleteAsync** but in code **CompleteMessageAsync**	Probably there is no updated documentation. In the text is written: CompleteAsync but in code CompleteMessageAsync. In order to remove a message from a queue or subscription, we can call the CompleteAsync method. string connectionString = `<connection_string>`; string queueName = `<queue_name>`; // since ServiceBusClient implements IAsyncDisposable we create it with `await using` await using var client = new ServiceBusClient(connectionString);  // create the sender ServiceBusSender sender = client.CreateSender(queueName);  // create a message that we can send ServiceBusMessage message = new ServiceBusMessage(`Hello world!`);  // send the message await sender.SendMessageAsync(message);  // create a receiver that we can use to receive and settle the message ServiceBusReceiver receiver = client.CreateReceiver(queueName);  // the received message is a different type as it contains some service set properties ServiceBusReceivedMessage receivedMessage = await receiver.ReceiveMessageAsync();  // complete the message, thereby deleting it from the service await receiver.CompleteMessageAsync(receivedMessage);   Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 1b27ca9e-5e7f-c542-ad6f-2abcf1df7989 Version Independent ID: 06b71858-0097-c7d7-4613-6b9d4678633c Content: Azure Service Bus client library for .NET - Azure for .NET Developers Content Source: api/overview/azure/latest/messaging.servicebus-readme.md Service: servicebus GitHub Login: @JoshLove-msft Microsoft Alias: jolov
Client	Azure.Core	[BUG] RetriableStreamImpl NotSupportedException() when attempting to Seek it	Library name and version Azure.Storage.Blobs 12.15.0 Describe the bug NotSupportedException `Specified method is not supported.` is thrown when trying to Seek at Azure.Core.Pipeline.RetriableStream.RetriableStreamImpl.Seek(Int64 offset, SeekOrigin origin)  Expected behavior No Exception is thrown. Actual behavior NotSupportedException `Specified method is not supported.` is thrown when trying to Seek. Reproduction Steps  Create RetriableStreamImpl instance. Call Seek method.  Environment No response
Mgmt	Monitor	enableLogAccessUsingOnlyResourcePermissions is a boolean, but docs give 3 options	The type of this flag is a bool, but the documentation says: `Flag that indicate which permission to use - resource or workspace or both.` I think the correct two options that are being referred to are:  workspace permissions only workspace & resource permissions   Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 974b72d0-2f8c-5aed-0b8f-d0bc3002162b Version Independent ID: 37578e8a-0010-0c99-2607-c9de1c4cf8db Content: WorkspaceFeatures.EnableLogAccessUsingOnlyResourcePermissions Property (Azure.ResourceManager.OperationalInsights.Models) - Azure for .NET Developers Content Source: xml/Azure.ResourceManager.OperationalInsights.Models/WorkspaceFeatures.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Service Bus	[QUERY] Unable to complete Service Bus message	Library name and version Azure.Messaging.ServiceBus 7.13.1 Query/Question We are migrating to Azure.Messaging.ServiceBus from Microsoft.Azure.ServiceBus using the guide [here] (https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Azure.Messaging.ServiceBus/MigrationGuide.md) Nuget Package - Azure.Messaging.ServiceBus 7.13.1 dotnet version on the project - 6.0 However, we are seeing the below error happening all the time, when we are trying to _serviceBusReceiver.CompleteMessageAsync(serviceBusReceivedMessage);. We want to complete the message in all the scenarios whether it fails or it doesn't fail, that is why we have the CompleteMessageAsync in the finally block. Things already tried.  Set the ServiceBusSessionReceiverOptions  explicitly. Tried using await receiver.ReceiveMessageAsync(); instead of await processor.StartProcessingAsync(); to start message processing. However, the later one didn't work / receive message at all. Tried changing MaxAutoLockRenewalDuration to different values, but the message gets processed within few minutes, so it should complete the lock  Please suggest Sample Code: private async Task Subscribe() {   try   {       var serviceBusConnectionString = $`some-valid-connection-string`;       var _serviceBusClient = new ServiceBusClient(serviceBusConnectionString);        var receiverOptions = new ServiceBusReceiverOptions       {           ReceiveMode = ServiceBusReceiveMode.PeekLock,                  };       _serviceBusReceiver = _serviceBusClient.CreateReceiver(`some-valid-queue-name`, receiverOptions);       var options = new ServiceBusProcessorOptions       {           MaxAutoLockRenewalDuration = TimeSpan.FromMinutes(60),           AutoCompleteMessages = false,           MaxConcurrentCalls = 10,             ReceiveMode = ServiceBusReceiveMode.PeekLock       };        // create a processor that we can use to process the messages       _serviceBusProcessor = _serviceBusClient.CreateProcessor(`some-valid-queue-name`, options);       _serviceBusProcessor.ProcessErrorAsync += Processor_ProcessErrorAsync;       _serviceBusProcessor.ProcessMessageAsync += Processor_ProcessMessageAsync;        await _serviceBusProcessor.StartProcessingAsync();   }   catch (Exception ex)   {       _logger.Error(ex, `Subscribe to service bus Failed.`);       throw;   } } private async Task Processor_ProcessMessageAsync(ProcessMessageEventArgs arg) {     try     {        // Some business logic to process the message                 }     catch (Exception e)     {         _logger.Error(e);     }     finally     {         await CompleteLock(arg.Message);     } }   private async Task Processor_ProcessErrorAsync(ProcessErrorEventArgs arg)  {          _logger.Error(arg.Exception, `Service Bus Messaging Exception`);  }  private async Task CompleteLock(ServiceBusReceivedMessage serviceBusReceivedMessage) {     try     {         if (!_serviceBusReceiver.IsClosed)         {             await _serviceBusReceiver.CompleteMessageAsync(serviceBusReceivedMessage);             _logger.Info(`Completed lock`);         }         else         {             _logger.Info(`Could not complete the lock because the MessageReceiver is closing`);         }     }     catch (Exception e)     {         _logger.Error(e, `Failed to complete lock`);         throw;     } } ERROR ERROR Failed to complete lock with Exception Azure.Messaging.ServiceBus.ServiceBusException: The lock supplied is invalid. Either the lock expired, or the message has already been removed from the queue, or was received by a different receiver instance. (MessageLockLost). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot. at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ThrowLockLostException() at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.DisposeMessageAsync(Guid lockToken, Outcome outcome, TimeSpan timeout) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.CompleteInternalAsync(Guid lockToken, TimeSpan timeout) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<CompleteAsync>b__47_0>d.MoveNext() --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<>c__221.<b__22_0>d.MoveNext() --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken, Boolean logTimeoutRetriesAsVerbose) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken, Boolean logTimeoutRetriesAsVerbose) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.CompleteAsync(Guid lockToken, CancellationToken cancellationToken) Environment Hosting Platform .NET SDK (reflecting any global.json):  Version:   6.0.201  Commit:    ef40e6aa06  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.19045  OS Platform: Windows  RID:         win10-x64  IDE - Visual Studio 17.1.3
Client	Service Bus	[QUERY] When processing a message, how can I `just do nothing` with it - causing it to run into the lock timeout later?	Library name and version Azure.Messaging.ServiceBus 7.12.0 Query/Question In former times (older SDKs), when we wanted a Service Bus message to be just rescheduled later (but not immediately), we just did not perform any action on the message, but just stopped handling it. The effect was that the message was not rescheduled until the lock timeout expired. This avoided an overload of our infrastructure because of messages that would immediately be rescheduled as soon as we abandon them. Is there still a way to do something like that? Environment .NET Core 6
Client	Extensions	[BUG] AddAzureClients Caused infinite loop with host logging	Library name and version Microsoft.Extensions.Azure 1.6.3 Describe the bug Using AddAzureClients to add clients like TableServiceClient and using Serilog to log to a TableServiceClient causes a circular dependency that is not present if TableServiceClient is added directly to DI services. Expected behavior Same as adding the TableServiceClient to DI without using AddAzureClients as follows  builder.Services.AddSingleton(new TableServiceClient(`UseDevelopmentStorage=true`)); Actual behavior Stack Overflow or hung app. //this causes a stack overflow / infinite loop in di when accessing the client builder.Services.AddAzureClients(clients => {     _ = clients.AddTableServiceClient(`UseDevelopmentStorage=true`); }); Reproduction Steps https://github.com/lawrencek76/AzureClientsSO using Azure.Data.Tables; using Microsoft.Extensions.Azure; using Serilog;  // Ensure Azurite is running to run demo // npm install -g azurite // azurite --silent  WebApplicationBuilder builder = WebApplication.CreateBuilder(args);  builder.Host.UseSerilog((context, services, configuration) => configuration     .WriteTo.Console()     .WriteTo.AzureTableStorage(services.GetRequiredService<TableServiceClient>(), storageTableName: `test`));  builder.Services.AddAzureClients(clients => {     _ = clients.AddTableServiceClient(`UseDevelopmentStorage=true`); });  WebApplication app = builder.Build();  app.Map(`/`, (TableServiceClient serviceClient) => {     TableClient client = serviceClient.GetTableClient(`test`);    //stack overflow here     _ = serviceClient.CreateTableIfNotExists(`test`);     return `Hello World`; });  app.Run(); Environment .NET SDK:  Version:   7.0.202  Commit:    6c74320bc3  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.19045  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\7.0.202\  Host:   Version:      7.0.4   Architecture: x64   Commit:       0a396acafe  .NET SDKs installed:   3.1.426 [C:\Program Files\dotnet\sdk]   5.0.214 [C:\Program Files\dotnet\sdk]   5.0.301 [C:\Program Files\dotnet\sdk]   6.0.310 [C:\Program Files\dotnet\sdk]   7.0.202 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.26 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   arm64 [C:\Program Files\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\arm64\InstallLocation]   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download
Client	Service Bus	[QUERY] ClientOptions - how to use it?	Library name and version Azure.Messaging.ServiceBus Query/Question There is a good article that describes how to activate logging of internal trace messages https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/Diagnostics.md I used it to activate internal information for the service bus. But there is a part about SecretClientOptions. I guess in the context of the service bus it will be ServiceBusAdministrationClientOptions. And it is not clear how to use/where to pass/where to setup that ClientOptions. No examples. Documentation also doesn't give an answer. Could you please provide a good example and update that Diagnostic.md file? Environment Core
Client	Storage	[BUG] The API version 2021-12-02 is not supported by Azurite	Library name and version Azure.Storage.Blobs 12.15.1 Describe the bug I have update the my visual studio to the latest version yesterday and suddenly the method var azResponse = await blobClient.DownloadToAsync(targetStream); stopped working. i found  the below message in the exception Azure.RequestFailedException   HResult=0x80131500   Message=The API version 2021-12-02 is not supported by Azurite. Please upgrade Azurite to latest version and retry. If you are using Azurite in Visual Studio, please check you have installed latest Visual Studio patch. Azurite command line parameter `--skipApiVersionCheck` or Visual Studio Code configuration `Skip Api Version Check` can skip this error.  RequestId:464b97a7-707a-4af6-8c25-8cce0e6b42f0 Time:2023-04-06T06:58:42.559Z Status: 400 (The API version 2021-12-02 is not supported by Azurite. Please upgrade Azurite to latest version and retry. If you are using Azurite in Visual Studio, please check you have installed latest Visual Studio patch. Azurite command line parameter `--skipApiVersionCheck` or Visual Studio Code configuration `Skip Api Version Check` can skip this error. ) ErrorCode: InvalidHeaderValue  Headers: Server: Azurite-Blob/3.20.1 x-ms-error-code: InvalidHeaderValue x-ms-request-id: 464b97a7-707a-4af6-8c25-8cce0e6b42f0 Date: Thu, 06 Apr 2023 06:58:42 GMT Connection: keep-alive Keep-Alive: REDACTED Transfer-Encoding: chunked Content-Type: application/xml    Source=Azure.Storage.Blobs   StackTrace:    at Azure.Storage.Blobs.BlobRestClient.<DownloadAsync>d__8.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBaseClient.<StartDownloadAsync>d__66.MoveNext()    at System.Threading.Tasks.ValueTask`1.get_Result()    at Azure.Storage.Blobs.Specialized.BlobBaseClient.<DownloadStreamingInternal>d__65.MoveNext()    at Azure.Storage.Blobs.PartitionedDownloader.<DownloadToAsync>d__9.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBaseClient.<StagedDownloadAsync>d__94.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBaseClient.<DownloadToAsync>d__92.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBaseClient.<DownloadToAsync>d__84.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBaseClient.<DownloadToAsync>d__80.MoveNext()    at VPMS.FuncApp.Services.DocumentRespository.<DownloadDocument>d__3.MoveNext() in C:\Projects\vpms\vpms-legacy\VPMS.AzFunctionApps\VPMS.FuncApp\Services\DocumentRespository.cs:line 27    This exception was originally thrown at this call stack:     Azure.Storage.Blobs.BlobRestClient.DownloadAsync(string, string, int?, string, string, bool?, bool?, string, string, Azure.Storage.Blobs.Models.EncryptionAlgorithmTypeInternal?, System.DateTimeOffset?, System.DateTimeOffset?, string, string, string, System.Threading.CancellationToken)     Azure.Storage.Blobs.Specialized.BlobBaseClient.StartDownloadAsync(Azure.HttpRange, Azure.Storage.Blobs.Models.BlobRequestConditions, Azure.Storage.DownloadTransferValidationOptions, long, bool, System.Threading.CancellationToken)     System.Threading.Tasks.ValueTask<TResult>.Result.get()     Azure.Storage.Blobs.Specialized.BlobBaseClient.DownloadStreamingInternal(Azure.HttpRange, Azure.Storage.Blobs.Models.BlobRequestConditions, Azure.Storage.DownloadTransferValidationOptions, System.IProgress<long>, string, bool, System.Threading.CancellationToken)     Azure.Storage.Blobs.PartitionedDownloader.DownloadToAsync(System.IO.Stream, Azure.Storage.Blobs.Models.BlobRequestConditions, System.Threading.CancellationToken)     Azure.Storage.Blobs.Specialized.BlobBaseClient.StagedDownloadAsync(System.IO.Stream, Azure.Storage.Blobs.Models.BlobRequestConditions, System.IProgress<long>, Azure.Storage.StorageTransferOptions, Azure.Storage.DownloadTransferValidationOptions, bool, System.Threading.CancellationToken)     Azure.Storage.Blobs.Specialized.BlobBaseClient.DownloadToAsync(System.IO.Stream, Azure.Storage.Blobs.Models.BlobRequestConditions, Azure.Storage.StorageTransferOptions, System.Threading.CancellationToken)     Azure.Storage.Blobs.Specialized.BlobBaseClient.DownloadToAsync(System.IO.Stream, System.Threading.CancellationToken)     Azure.Storage.Blobs.Specialized.BlobBaseClient.DownloadToAsync(System.IO.Stream)     VPMS.FuncApp.Services.DocumentRespository.DownloadDocument(string, string, System.IO.Stream) in DocumentRespository.cs  Expected behavior The stram must be downloaded Actual behavior Throws error HResult=0x80131500 Message=The API version 2021-12-02 is not supported by Azurite. Please upgrade Azurite to latest version and retry. If you are using Azurite in Visual Studio, please check you have installed latest Visual Studio patch. Azurite command line parameter `--skipApiVersionCheck` or Visual Studio Code configuration `Skip Api Version Check` can skip this error. Reproduction Steps public async Task<ResponseResult<Stream>> DownloadDocument(string containerName, string blobName, Stream targetStream)     {         try         {             var blobContainerClient = GetContainerAsync(containerName);              var blobClient = blobContainerClient.GetBlobClient(blobName);              var azResponse = await blobClient.DownloadToAsync(targetStream);              if (azResponse.IsError) return new(new OperationFailedException(`blob`, JsonConvert.SerializeObject(azResponse)));              return new(targetStream);         }           catch (Exception ex)         {             return new(new OperationFailedException(`Blob`, JsonConvert.SerializeObject(ex)));         }     }  Environment visual studio enterprise: 17.5.3 azurite version: 3.20.1
Client	Service Bus	[QUERY] Distributed tracing Activity scope for batched Service Bus Functions	Library name and version Azure.Messaging.ServiceBus 7.13.1 Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.9.0 Query/Question There currently exists discrepancies when processing Service Bus messages in either a batched versus singular fashion regarding Activity scoping and how the Functions consider incoming message Diagnostic-Id properties. In my scenario, one (or many) message producers are sending Service Bus messages to a given queue/topic and each of these messages may contain different Diagnostic-Ids. The expectation here, is that this producer-provided trace ID is appropriately utilised within the Function when processing the message, and in turn is appropriately sent to any downstream components. Now, when using a singular message Function (as below), this works perfectly. public ProcessIncomingMessage([ServiceBusTrigger(...)] ServiceBusReceivedMessage message) {     // Activity `ServiceBusProcessor.ProcessMessage`     // uses incoming `Diagnostic-Id` ✅      DoWork(message); } When using a batched message Function, however, incoming Diagnostic-Ids are being somewhat `squashed` at this level; the Activity uses a new ID (which is being sent downstream), and the individual message trace IDs are added to Activity.Links. As below: public ProcessIncomingMessages([ServiceBusTrigger(...)] ServiceBusReceivedMessage[] messages) {     // Activity `ServiceBusListener.ProcessMessages`     // uses new Id; incoming `Diagnostic-Id`s added to `Activity.Links` 🤔      foreach (var message in messages)     {         DoWork(message);     } } This seems backwards, I would expect that the incoming Diagnostic-Ids be used as the `primary` Activity ID and the `batch` Activity is added as a Link (or equivalent). Whether or not the message consumer processes messages in batch or singularly could be considered an implementation detail (at least in this scenario) and the message producer shouldn't care; it would expect that the Diagnostic-Id it provided in a given message is the trace ID used for any downstream actions performed in its processing. Now, by this point it may seem obvious that such scoping is just not really feasible within a method written like this (with a ServiceBusReceivedMessage[] argument), and the workaround/solution is to simply perform this context flip manually within the batch processor: foreach (var message in messages) {     using var activity = new Activity(`ServiceBusProcessor.ProcessMessage`);      // preserve reference to the batch Activity (optional)     activity.AddBaggage(`BatchActivityId`, Activity.Current.Id);      // use incoming `Diagnostic-Id` (if present)     if (message.ApplicationProperties.TryGetValue(`Diagnostic-Id`, out var value)         && value is string diagnosticId         && ActivityContext.TryParse(diagnosticId, null, out var parentContext))     {         activity.SetParentId(parentContext.TraceId, parentContext.SpanId, parentContext.TraceFlags);     }      activity.Start();      DoWork(message); } I guess my main question at this point is whether or not this would be the suggested approach; or whether there's another way of implementing a batch-triggered Function such that the trace IDs are registered as I would expect them to be (per-message). The documentation I could find on this subject is rather limited. cc @JoshLove-msft #30279 Environment .Net SDK 6.0.407
Client	Service Bus	[QUERY] Authenticate ServiceBus via Managed Identity when using DI	Library name and version Azure.Messaging.ServiceBus 7.13.1 Query/Question I would like to authenticate my App's Service Bus using Azure Managed Identity. It should be possible to do something like the example below. // Create a ServiceBusClient that will authenticate through Active Directory string fullyQualifiedNamespace = `yournamespace.servicebus.windows.net`; await using var client = new ServiceBusClient(fullyQualifiedNamespace, new DefaultAzureCredential()); The thing is that since I am using ASP.NET Core, I want to register it with the DI, using AddServiceBusClient [documentation]. This method requires a ConnectionString, but it looks like it's not possible to use Managed Identity Authentication with a Connection String, because it requires SAS. public void ConfigureServices(IServiceCollection services) {     services.AddAzureClients(builder =>     {         builder.AddServiceBusClient(Configuration.GetConnectionString(`ServiceBus`));     });        services.AddControllers(); } Is it possible to register a Service Bus using the AddAzureClients helper and use Managed Identity? A lack of this possibility would be forcing people to revert to a less secure approach. Error Message The error message below happens if I remove the SAS token from the Connection String. But since I have disabled local authentication (as advised!), it also won't work if I add the SAS token.  The connection string used for an Service Bus client must specify the Service Bus namespace host and either a Shared Access Key (both the name and value) OR a Shared Access Signature to be valid.  Environment No response
Mgmt	ARM	[QUERY] Equivalent of `az rest` in SDK?	Library name and version Azure.ResourceManager.Resources 1.4.0 Query/Question I am wondering if there is something similar to az rest in Azure SDK? What I want to accomplish is to be able to make Azure REST API calls using the SDK without installing a bunch of Nuget packages. For example, I would like to get complete details about a storage account without installing Azure Storage Resource Manager Nuget. Environment No response
Client	Azure.Core	[BUG] warning MSB3277: There was a conflict between `Azure.Core, Version=1.27.0.0... nd `Azure.Core, Version=1.30.0.0	Library name and version Azure.Core 1.30.0.0  and 1.27.0.0 Describe the bug Couldn't build my project. Thanks for your help. Got this error - Microsoft.Common.CurrentVersion.targets(2352,5): warning MSB3277: There was a conflict between `Azure.Core, Version=1.27.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8` and `Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`. Microsoft.Common.CurrentVersion.targets(2352,5): warning MSB3277:     `Azure.Core, Version=1.27.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8` was chosen because it was primary and `Azure.Core, Version=1.30.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8` was not. Expected behavior I could use 1.30.0.0 and project should build successfully. Actual behavior Project couldn't build. Reproduction Steps Project A has transitive package reference to Azure.Core 1.27.0.0. Class library project B has transitive package reference to Azure.Core 1.30.0.0. Project A references project B.dll. Error occurs when project A is building. Environment No response
Mgmt	ARM	[QUERY]: How can we use AzureEnvironment class going forward as Microsoft.Azure.Management.ResourceManager.Fluent package is deprecated ?	Library name and version Microsoft.Azure.Management.ResourceManager.Fluent Query/Question we are using Microsoft.Azure.Management.ResourceManager.Fluent to work with AzureEnvironment class, since this package is deprecated what is the alternative to continue using AzureEnvironment class (as I don't see proper replacement in the new Azure.ResourceManager package for AzureEnvironment) ? Environment No response
Client	Service Bus	[QUERY] concurrency in batching	Library name and version Azure.Messaging.ServiceBus 7.13.1 Query/Question The following methods seem to be extremely slow:  (await sender.CreateMessageBatchAsync(cancellationToken)).TryAddMessage(...) SendMessagesAsync  In a scenario like below - using a recursion to build a list of safe batches to send in parallel.         public async Task SendBatchesAsync(             string topicOrQueueName,             List<MessageBatch> messages,             CancellationToken cancellationToken = default)         {            ...            // illustrative purpose only - client and sender are DI'ed from container             var clientOptions = new ServiceBusClientOptions             {                 TransportType = ServiceBusTransportType.AmqpWebSockets             };             var client = new ServiceBusClient(                 `xxxxxx.servicebus.windows.net`,                 new DefaultAzureCredential(),                 clientOptions);             var sender = client.CreateSender(topicOrQueueName);              var result = await CreateBatchesSender(                 sender,                 messages,                 new List<ServiceBusMessageBatchWrapper>(),                 new ServiceBusBatchResult() { Failure = new ServiceBusSendBatchException(`batch insert failures`) },                 indexPointer: 0,                 cancellationToken);              // Calling DisposeAsync on client types is required to ensure that network             // resources and other unmanaged objects are properly cleaned up.             await sender.DisposeAsync();             await client.DisposeAsync();              if (!result.AllSucceeded)             {                 throw result.Failure;             }         }          private async Task<ServiceBusBatchResult> CreateBatchesSender(             ServiceBusSender sender,             List<MessageBatch> messages,             List<ServiceBusMessageBatchWrapper> batches,             ServiceBusBatchResult result,             int indexPointer,             CancellationToken cancellationToken)         {             var currentList = messages.Skip(indexPointer).ToList();              if (currentList.Count == 0)             {                 return result;             }              // Start sending the previous batch whilst the new one is building             Task execSend = batches?.Count > 0 ? sender.SendMessagesAsync(batches?.Last().Batch, cancellationToken) : Task.FromResult(true);              int index = indexPointer;              _logger.LogDebug(`creating batcher...`);              var customBatch = new ServiceBusMessageBatchWrapper             {                 Batch = await sender.CreateMessageBatchAsync(cancellationToken),             };              _logger.LogDebug(`finished creating batch sender, starting to process...`);              for (int b = 0; b < currentList.Count; b++)             {                 if (!customBatch.Batch.TryAddMessage(BuildServiceBusMessage(currentList[b].Payload, currentList[b].Context)))                 {                     // do not increment index                     _logger.BatchSizeExceeded(index);                     break;                 }                 customBatch.AddIndex(index);                 index++;             }              batches.Add(customBatch);              return await CreateBatchesSender(                 sender,                 messages,                 batches,                 await CaptureException(execSend, batches?.Last()?.Indexes, result),                 index,                 cancellationToken);         }          internal static ServiceBusMessage BuildServiceBusMessage(             string payload,             IMessageContext? messageContext)         {             var serviceBusMessage = new ServiceBusMessage(new BinaryData(payload))             {                 ContentType = ApplicationJson,                 CorrelationId = messageContext?.CorrelationId ?? ``,                 Subject = messageContext?.Label,                 ScheduledEnqueueTime = messageContext?.ScheduledEnqueueTimeUtc ?? DateTimeOffset.UtcNow             };             serviceBusMessage.AddApplicationProperties(messageContext?.CustomProperties);              return serviceBusMessage;         }          /// <summary>         ///     Executes and captures any exception from the background operation         /// </summary>         /// <param name=`task`></param>         /// <param name=`indexes`></param>         /// <param name=`result`></param>         /// <returns></returns>         internal static async Task<ServiceBusBatchResult> CaptureException(Task task, List<int> indexes, ServiceBusBatchResult result)         {             try             {                 await task;             }             catch (Exception ex)             {                 result.Failure.Exceptions.Add((indexes, ex));                 result.AllSucceeded = false;             }             return result;         } From looking at the app insights dependency analysis it seems TryAddMessage is not extremely fast, and more importantly the await sender.CreateMessageBatchAsync(cancellationToken) takes anywhere between 1 - 3 seconds. If you are looping through 18k items that are split into 62 batches this is obviously run 62 times which would on its own contribute to ~2mins run time. the sender is created above which is scoped to a specific queue, and it is my understanding that at this point the AMQP connection is established and just re-used - in. this case inside the recursive call. For reference the creation of a List of 18k with serialization  of the `payload` into a string takes sub 1s as expected.  The same series of operations in the Go SDK  takes about ~5s for a 50k file  which also includes a download from Blob of that file.  Any thoughts/pointers would be welcomed. PS: some implementations included returning a list of safe batches and then Task.WhenAll(sender.SendMEssagesAsync(...) but this was timing out after a minute... PS2: AWS/GCP both include an errorList in their response for batched operations - maybe something like this could be added here. Environment .NET SDK:  Version:   7.0.201  Commit:    68f2d7e7a3  Runtime Environment:  OS Name:     Mac OS X  OS Version:  12.6  OS Platform: Darwin  RID:         osx.12-x64  Base Path:   /usr/local/share/dotnet/sdk/7.0.201/  Host:   Version:      7.0.3   Architecture: x64   Commit:       0a2bda10e8  VSforMac 17.5.1 (build 23)
Client	Service Bus	[BUG] Azure functions Service Bus trigger: SessionLockLost after previous run timeouts	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.9.0 Describe the bug When Session Service bus trigger timeouts, second re-run gets SessionLockLost. MessageLock is set to 30s in service bus queue Expected behavior The session lock is not lost. Actual behavior Every run ends in timeout (which is correct), but the second run contains also this error:  Azure.Messaging.ServiceBus: The session lock has expired on the MessageSession. Accept a new MessageSession. TrackingId:973f37c90000eca30000da4264269580_G16_B17, SystemTracker:G16:240034969:amqps://jm73010.servicebus.windows.net/-6cc1e03f;0:5:6:source(address:/myqueue,filter:[com.microsoft:session-filter:]), Timestamp:2023-03-31T08:14:09 (SessionLockLost). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.  Happening in local debug environment as well as in azure with this simple function. This is annoying because session messages should not run concurrently but they are (in azure) in this case due to loosing session lock. All logs from run:  [2023-03-31T08:10:40.909Z] Executing 'Function1' (Reason='(null)', Id=06e22585-f628-4670-96d7-c7b4ebf78f30) [2023-03-31T08:10:40.912Z] Trigger Details: MessageId: ba8e7ae5fb2845059279546b5ae313c0, SequenceNumber: 2, DeliveryCount: 5, EnqueuedTimeUtc: 2023-03-30T10:32:09.2810000+00:00, LockedUntilUtc: 9999-12-31T23:59:59.9999999+00:00, SessionId: ses2 [2023-03-31T08:10:40.929Z] C# ServiceBus queue trigger function processing message: mes2 [2023-03-31T08:10:44.532Z] Host lock lease acquired by instance ID '00000000000000000000000011C92764'. [2023-03-31T08:12:40.937Z] Timeout value of 00:02:00 exceeded by function 'Function1' (Id: '06e22585-f628-4670-96d7-c7b4ebf78f30'). Initiating cancellation. [2023-03-31T08:12:40.987Z] Executed 'Function1' (Failed, Id=06e22585-f628-4670-96d7-c7b4ebf78f30, Duration=120113ms) [2023-03-31T08:12:40.988Z] Microsoft.Azure.WebJobs.Host: Timeout value of 00:02:00 was exceeded by function: Function1. [2023-03-31T08:12:41.021Z] Message processing error (Action=ProcessMessageCallback, EntityPath=myqueue, Endpoint=jm73010.servicebus.windows.net) [2023-03-31T08:12:41.022Z] Microsoft.Azure.WebJobs.Host: Timeout value of 00:02:00 was exceeded by function: Function1. [2023-03-31T08:12:41.156Z] Executing 'Function1' (Reason='(null)', Id=a79a835f-95b0-408b-b031-38ea56d09302) [2023-03-31T08:12:41.157Z] Trigger Details: MessageId: ba8e7ae5fb2845059279546b5ae313c0, SequenceNumber: 2, DeliveryCount: 6, EnqueuedTimeUtc: 2023-03-30T10:32:09.2810000+00:00, LockedUntilUtc: 9999-12-31T23:59:59.9999999+00:00, SessionId: ses2 [2023-03-31T08:12:41.158Z] C# ServiceBus queue trigger function processing message: mes2 [2023-03-31T08:14:41.172Z] Timeout value of 00:02:00 exceeded by function 'Function1' (Id: 'a79a835f-95b0-408b-b031-38ea56d09302'). Initiating cancellation. [2023-03-31T08:14:41.193Z] Executed 'Function1' (Failed, Id=a79a835f-95b0-408b-b031-38ea56d09302, Duration=120037ms) [2023-03-31T08:14:41.194Z] Microsoft.Azure.WebJobs.Host: Timeout value of 00:02:00 was exceeded by function: Function1. [2023-03-31T08:14:41.197Z] Message processing error (Action=ProcessMessageCallback, EntityPath=myqueue, Endpoint=jm73010.servicebus.windows.net) [2023-03-31T08:14:41.197Z] Microsoft.Azure.WebJobs.Host: Timeout value of 00:02:00 was exceeded by function: Function1. [2023-03-31T08:14:41.206Z] Message processing error (Action=Abandon, EntityPath=myqueue, Endpoint=jm73010.servicebus.windows.net) [2023-03-31T08:14:41.207Z] Azure.Messaging.ServiceBus: The session lock has expired on the MessageSession. Accept a new MessageSession. TrackingId:973f37c90000eca30000da4264269580_G16_B17, SystemTracker:G16:240034969:amqps://jm73010.servicebus.windows.net/-6cc1e03f;0:5:6:source(address:/myqueue,filter:[com.microsoft:session-filter:]), Timestamp:2023-03-31T08:14:09 (SessionLockLost). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.  Reproduction Steps Function: using System; using System.Threading; using System.Threading.Tasks; using Microsoft.Azure.WebJobs; using Microsoft.Extensions.Logging;  namespace FunctionApp5 {     public class Function1     {         [FunctionName(`Function1`)]         public async Task Run([ServiceBusTrigger(`myqueue`, Connection = `myservicebus`, IsSessionsEnabled = true)] string myQueueItem,             ILogger log, CancellationToken cancellationToken)         {             log.LogInformation($`C# ServiceBus queue trigger function processing message: {myQueueItem}`);              await Task.Delay(TimeSpan.FromMinutes(3), cancellationToken);              log.LogInformation($`C# ServiceBus queue trigger function processed message: {myQueueItem}`);         }     } }  host.json {   `version`: `2.0`,   `logging`: {     `applicationInsights`: {       `samplingSettings`: {         `isEnabled`: true,         `excludedTypes`: `Request`       }     }   },   `functionTimeout`: `00:02:00`,   `extensions`: {     `serviceBus`: {       `maxAutoLockRenewalDuration`: `00:03:00`,       `maxConcurrentCalls`: 1,       `maxConcurrentSessions`: 1     }   } }  Environment OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.202\
Mgmt	App Services	Creating a Diagnostic Setting to a FunctionApp to log to a Log Analytics Workspace	Library name and version Azure.ResourceManager.AppService 1.0.01, Azure.ResourceManager 1.4.0 Query/Question I want to configure the FunctionApp to log to a Log Analytics Workspace using the Diagnostic Setting. However I can't see how to do this with the Azure.ResourceManager api. I have created a function using the following code: var webSiteData = new WebSiteData(location); webSiteData.Kind = `functionapp`; var funcResponse = await resourceGroup.GetWebSites().CreateOrUpdateAsync(WaitUntil.Completed, functionName, webSiteData); var funcResource = funcResponse.Value;  There's a GetSiteDiagnostics() but no equivalent Update method. There's very limited samples for this API and even looking through the source code is hard as the comments are all autogenerated seem to restate class/method names - is there some other resource that would help? Any help would be appreciated! Environment .Net runtime Visual Studio for Mac.
Client	Azure.Identity	[QUERY] How to List releases for a specific package	Library name and version Azure.Identity Query/Question We are looking to do some updates to things and are a few versions behind current. I was wondering if there is a way to query/list releases by package. The releases page doesn't allow us to see all release notes for one package and due to the number of different packages in this repo it's really tough to find say all releases for Azure.identity since 1.7.0. I was kind of hoping it's possible somehow, does anyone know how to do this? Environment No response
Client	OpenAI	[QUERY] how to initialize Messages of ChatCompletionsOptions using a List<Message> variable?	Library name and version Azure.AI.OpenAI 1.0.0-beta.5 Query/Question Messages of ChatCompletionsOptions is readonly. So i can't assign a variable to it using this way: var messages = new List(); messages+=... var chatCompletionsOptions = new ChatCompletionsOptions() { Messages  = messages }; Environment No response
Client	Service Bus	Sometimes ServiceBus consumers get stuck	Library name and version Azure.Messaging.ServiceBus, 7.12.0 Query/Question Hi! Sometimes some consumers of the topic get stuck. Right now my clock shows 6:10 PM. If I look into some consumer in some topic, first message I see there was enqueued at 5:45:03 PM. Processing of message is just reading data from database, easy data manipulation and making some database stored procedures call. Roughly speaking, this is 5-10 calls to the database. I have timeout set on database query execution which is 30 seconds. So if imagine that each query to database takes ~30 seconds, processing time of message can't be greater than 30 seconds * 10 queries = 300 seconds = 5 minutes. Let's triple this value, because Max delivery count for the consumer is set to 3. But we see that first message for specific consumer isn't processed 25 minutes already. If you go Azure portal and open the topic, you'll see the next standard graph for 1 hour:  What I don't like on the graph is that there is 2 User errors and 525 User requests. If you look at this graph for last 6 hours, you'll see Throttled requests is 1.18K. During last hour number of throttled requests are similar to the same metric for previous 5 hours. Obviously, something weird has been happening during last hour. While I'm writing this message, the consumer I started looking at is empty now, but the same situation I see with another consumer: it's 18:43 PM now and first message there was enqueued at 06:15:30 PM. The same situation I observed on another consumer of another topic yesterday. I have turned on logger I created as a result of this issue. If you look at what it wrote, you can discover few common warnings:     RunOperation encountered an exception and will retry. Exception: Azure.Messaging.ServiceBus.ServiceBusException: The request was terminated because the namespace my-prod is being throttled. Error code : 50009. Please wait 2 seconds and try again. To know more visit https://aka.ms/sbResourceMgrExceptions TrackingId:5380c323000000290050fe1c641990cf_G29_B27, SystemTracker:my-prod:Topic:files, Timestamp:2023-03-22T15:58:47 (ServiceBusy). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.      Error response [51299da3-973b-4a3d-9169-9f5a50aea9ba] 503 Service Unavailable (00.2s) Transfer-Encoding:chunked ETag:637965011529870000 Server:Microsoft-HTTPAPI/2.0 Strict-Transport-Security:REDACTED Date:Wed, 22 Mar 2023 15:58:48 GMT Content-Type:application/xml; charset=utf-8      Response [598313c2-9b08-4e2f-8f92-3f287c11801b] took 04.1s  If you look at how the warnings were logged by minute for last hour, you'll see following:  If to look warnings by minute and kind of `error type` you'll see following:  On screenshots above you see time 16 PM, not 18 as I said above, because the time on the screenshots is in UTC. Please notice that not every minute there were such warnings. The question is: what's going on? Why do consumers get stuck sometimes? Is it because of ServiceBus throttling? Any other reasons? What should I do in order to get rid of this issue. Environment No response
Client	Azure.Identity	[QUERY] Avoiding Azure.Identity.CredentialUnavailableException on the fresh startup	Library name and version Azure.Messaging.ServiceBus 7.11.1 Query/Question Short summary When I deploy my application which uses Managed Identity to connect to the Service Bus instance, for a first couple of minutes I see a lot of Azure.Identity.CredentialUnavailableException exceptions in the logs. Then it all starts working fine and the connection is established. Longer explanation My setup is as follows:  Web app hosted in Azure (using Kubernetes) Azure Service Bus which the app connects with Managed Identity assigned to an app used to connect to the Service Bus  In my application I use Azure.Messaging.ServiceBus. In my Startup file I register the Service Bus Client as follows:         services.AddAzureClients(clientBuilder =>             clientBuilder.AddServiceBusClient(Configuration.GetSection(`ServiceBus`))                 .WithCredential(new DefaultAzureCredential())); Just as a side note, I use DefaultAzureCredential instead of ManagedIdentityCredential because I want my application to work locally as well (so VisualStudioCredential or AzureDeveloperCliCredentail can be used). Later, I register my IHostedService implementation where I handle Service Bus messages (I can provide a simplified but full code for this but I don't think it's that important). In this class, I create ServiceBusProcessor instance using ServiceBusClient instance and calling CreateProcessor() method. Then I invoke StartProcessingAsync() method from the created ServiceBusProcessor. As far as I understand, this is the point where the connection to the Service Bus is actually being initialized. When I deployed my app for the first time I saw a lot of Azure.Identity.CredentialUnavailableException exceptions: DefaultAzureCredential failed to retrieve a token from the included credentials. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/defaultazurecredential/troubleshoot - EnvironmentCredential authentication unavailable. Environment variables are not fully configured. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/environmentcredential/troubleshoot - ManagedIdentityCredential authentication unavailable. Multiple attempts failed to obtain a token from the managed identity endpoint. - Operating system Linux 5.4.0-1103-azure #109~18.04.1-Ubuntu SMP Wed Jan 25 20:53:00 UTC 2023 isn't supported. - Stored credentials not found. Need to authenticate user in VSCode Azure Account. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/vscodecredential/troubleshoot - Azure CLI not installed - PowerShell is not installed.  However, after 2 or 3 minutes the connection has been established and it all started working fine. As I understand there is a process under the hood which calls Azure to create some additional resources to 'link' the Managed Identity with a freshly created virtual machine. When this succeeds, the connection is established and the app starts processing Service Bus messages. But in the meantime some code in the package (I assume) is still retrying to connect to the Service Bus and that's why I see a lot of Azure.Identity.CredentialUnavailableException exceptions (the numbers were as high as 70000 exceptions for some deployments). Question Is there any way to check if the connection has been established before continuing to run the application? Or is there any way to have a control over how the connection is established, eg. over the retry policy? My ultimate goal is to avoid those exceptions in the logs. Environment No response
Client	Search	[QUERY]Filtering data on sub complex objects	Library name and version Azure.saerch.Document 11.4.0 Query/Question HI all I am working with SDK and  have a complex object to filter data with, can you please guide me how to operate on this data this is my complex object customer{ name: `asdadads`, ParentLevel: new lookupreference(){ `Id` : `8dbb5abe-dc23-45f2-aa10-8b4383708bbe`,ExternalId` :23 } } i was able to filter the data in the index through this query $filter=ParentLevel/Id eq '8dbb5abe-dc23-45f2-aa10-8b4383708bbe' but i tried with SDK i see exception like this [02:28 am] Manoj Mathe HI all I am working with SDK and  have a complex object to filter data with, can you please guide me how to operate on this data this is my complex object customer{​​​​​​ name: `asdadads`, ParentLevel: new lookupreference(){​​​​​​ `Id` : `8dbb5abe-dc23-45f2-aa10-8b4383708bbe`,ExternalId` :23 }​​​​​​ }​​​​​​ i was able to filter the data in the index through this query $filter=ParentLevel/Id eq '8dbb5abe-dc23-45f2-aa10-8b4383708bbe' but i tried with SDK i see exception like this options.Filter =`$filter=ParentLevel/Id eq '8dbb5abe-dc23-45f2-aa10-8b4383708bbe'` 'options.Filter =`$filter=ParentLevel/Id eq '8dbb5abe-dc23-45f2-aa10-8b4383708bbe'`' threw an exception of type 'System.NullReferenceException' Data: {​​​​​​​System.Collections.ListDictionaryInternal}​​​​​​​ HResult: -2147467261 HelpLink: null InnerException: null Message: `Object reference not set to an instance of an object.` Source: `f065a912e2564afd8ba03586c9d3e1af` StackTrace: `   at <>x.<>m0(d__8 <>4__this)` TargetSite: {​​​​​​​System.String <>m0(d__8)}​​​​​​​ Thanks in adavnce Environment Windows 11
Mgmt	Container Service	[BUG] Azure Container App SDK - Patch (Update) operation erroneously sends empty secret values, makes update via SDK impossible	Library name and version Azure.ResourceManager.AppContainers 1.0.2 Describe the bug When an Azure Container App contains secrets (in our case: the container registry password), when using the SDK to update the container image tag in the template the SDK tries to send a PATCH request containing empty secrets in the configuration property, which will trigger an error like: Invalid Request: Container app secret(s) with name(s) 'secret1, secret2' are invalid: value or keyVaultUrl and identity should be provided. secret1 and secret2 are secrets defined on the app Using the REST api manually works as expected: PATCH https://management.azure.com/subscriptions/x/resourceGroups/y/providers/Microsoft.App/containerApps/yadayada?api-version=2022-03-01 {   `properties`: {     `template`: {       `containers`: [         {           `image`: `yadayada.io/bla:1.2.0`,           `name`: `my-container`         }       ]     }   } } The SDK should not send back the properties.configuration.secrets array in a PATCH, unless the secrets have been changed (because the secrets array after a GET does not contain all information). Ideally the SDK would not touch properties.configuration at all, if only the template or image tags in it are touched. Expected behavior The SDK does not send the properties.configuration.secrets array, and the request is accepted with HTTP 202 (like when doing it manually via REST) Actual behavior The SDK sends an invalid (half-filled) secrets array, leading to Invalid Request: Container app secret(s) with name(s) 'secret1, secret2' are invalid: value or keyVaultUrl and identity should be provided. Reproduction Steps Use Azure.ResourceManager.AppContainers  v1.0.2 Use this code: var containerApp = await resourceGroup.GetContainerAppAsync(request.ResourceName); var containerAppData = containerApp.Value.Data; var container = containerAppData.Template.Containers.Single();  var originalContainerImage = container.Image; container.Image = `yadayada.io/bla:1.2.0`;  //containerAppData.Configuration.Secrets contains secrets, but without the value  var updateResult = await containerApp.Value.UpdateAsync(WaitUntil.Completed, containerAppData); Environment Azure Container Apps Azure.ResourceManager.AppContainers 1.0.2
Mgmt	ARM	[QUERY] How to mock 'SubscriptionData' and 'ManagedByTenant' classes?	Library name and version Azure.ResourceManager 1.4.0 Query/Question Hi, I am creating a simple .NET Console app (.NET 6 / VS2022) to automate access validation to resources in Azure. To ensure that the code is working as intended I am writing unit test (XUnit + Moq), but found some tests impossible (at first glance) to write. I have tried to mock 'ManagedByTenant' and provide my own objects and values to return, but I could not mock the object. Moq throws 'NotSupportedException' because properties are not virtual and it is not possible to create mock objects by inheritance, since constructor is 'internal'. I assume the same goes for 'SubscriptionData' mock object, but I see only partial class implementation of 'SubscriptionData' in Visual Studio. I have found an issue similar to this opened by another user, which seem to be resolved? #26417 so maybe I am simply missing something. My question: how it is intended to mock the above classes? Are there Factories i have missed? Or interfaces/abstract classes to inherit properties from? From what I have quickly checked it does not seem to be a problem for 'ResourceGroupData' and 'GenericResourceData' classes. Thanks in advance, Tomasz Mankin Environment .NET SDK: Version:   7.0.201 Commit:    68f2d7e7a3 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.201\ Host: Version:      7.0.3 Architecture: x64 Commit:       0a2bda10e8 .NET SDKs installed: 2.2.207 [C:\Program Files\dotnet\sdk] 3.1.426 [C:\Program Files\dotnet\sdk] 5.0.303 [C:\Program Files\dotnet\sdk] 5.0.408 [C:\Program Files\dotnet\sdk] 5.0.416 [C:\Program Files\dotnet\sdk] 6.0.203 [C:\Program Files\dotnet\sdk] 7.0.201 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.9 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: arm64 [C:\Program Files\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\arm64\InstallLocation] x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found Learn more: https://aka.ms/dotnet/info Download .NET: https://aka.ms/dotnet/download
Mgmt	Container Registry	[QUERY] How can I configure timeout while using ContainerRegistryManagementClient	Library name and version Microsoft.Azure.Management.ContainerRegistry 6.0.0 Query/Question We migrated our services from Net4.7.2 to dotnet core 6.0. We see the error `The request was cancelled due to the configured HttpClient.Timeout of 100 seconds elapsing.` The Kubernetes pod running this service has enough memory and CPU. The network does not seem to be an issue as the Kubernetes cluster in running on Azure and this client is trying to reach ARM.  Also, during the same time, the service can reach storage accounts. Also this is happening in multiple regions. I want to add a retry logic in our code. For this I want to decrease the timeout from 100sec to 15sec, but I could not find timeout setting exposed. Do I have to create my own HttpClient? My code is really simple var containerRegistryManagementClient = ContainerRegistryManagementClient(resourceManagerUri, tokenCredentials) { SubscriptionId = subscriptionId }; var registry = await containerRegistryManagementClient.GetRegistryPropertiesAsync(                 subscriptionId: resource.SubscriptionId,                 resourceGroupName: resource.ResourceGroupName,                 registryName: resource.ResourceName,                 correlationId: correlationId); Environment No response
Client	Storage	[QUERY] Fine tune copying large blobs (5gb+)	Library name and version Azure.Storage.Blobs 12.15.0 and WindowsStorage.Blobs 9.3.3 Query/Question Hello Am using Azure.Storage.Blobs 12.15.0 to expose an API to copy blobs from our storage to partner storage. I was able to fine tune the options to copy successfully 3gb+ file, but when we copy 5gb+ file, nothing gets copied until 15m and then we hit out client timeout and get a TaskCanceledException. Below is the implementation using Azure.Storage.Blobs 12.15.0. // Instantiate destination using SasUri and set BlockBlobOpenWriteOptions. BlockBlobClient destinationBlockBlobClient = new BlockBlobClient(new Uri(destinationSasUri)); BlockBlobOpenWriteOptions blockBlobWriteOptions = new BlockBlobOpenWriteOptions(); blockBlobWriteOptions.BufferSize = 4194304000; var destinationStream = await destinationBlockBlobClient.OpenWriteAsync(true, blockBlobWriteOptions, cancellationTokenSource.Token).ConfigureAwait(false)) // Set BlobDownloadToOptions from source blockBlob to destination blockBlob. BlobDownloadToOptions blobDownloadToOptions = new BlobDownloadToOptions() { TransferOptions = new StorageTransferOptions() { MaximumConcurrency = 64, InitialTransferSize = DCATBlockBlobMaxStageBlockLongBytes, MaximumTransferSize = 4194304000 }, }; // Download from source blockBlob to destination blockBlob. await sourceBlockBlobClient.DownloadToAsync(destinationStream, blobDownloadToOptions, cancellationTokenSource.Token).ConfigureAwait(false); Question: Is this the recommended way to copy large blobs from one account to another? Old SDK implementation: Initially we used the old WindowsStorage.Blobs 9.3.3 to do the same, and here the 5gb+ file copy completes in ~5m. But, we are hitting other issues and end up waiting 15m even if the copy completed in 5m. This most likely is an issue our code about async/await deadlock. So, we are in parallel trying to solve that as well. Below is the implementation using WindowsStorage.Blobs 9.3.3. // Instantiate destination using SasUri CloudBlockBlob destinationBlob = new CloudBlockBlob(new Uri(destinationSasUri)); destinationBlob.StreamWriteSizeInBytes = 104857600; // Set to 100MB max. var destinationStream = await destinationBlob.OpenWriteAsync(null, new BlobRequestOptions() { ParallelOperationThreadCount = 64 }, null, cancellationTokenSource.Token).ConfigureAwait(false)) // Download from source blockBlob to destination blockBlob. await sourceBlob.DownloadToStreamAsync(destinationStream, null, new BlobRequestOptions() { ParallelOperationThreadCount = 64, }, null, cancellationTokenSource.Token).ConfigureAwait(false); Environment Our service is running in Autopilot.
Client	Cognitive - Form Recognizer	[QUERY] I Can't find valueSignature	Library name and version Azure.AI.FormRecognizer 4.0.0 Query/Question I have a template-trained model to extract information from a document. One of the data points we're interested in extracting is the signature within the document. Therefore, we use the signature field that FormRecognizer Studio allows you to create. When testing the model, it tells me whether or not the document is signed through the valueSignature field.  However, when trying to obtain it through code using AnalyzeDocumentAsync(), I am unable to access that property. The closest property to that value is one called InternalValue.  Is there any way to access the valueSignature field? Environment Windows 10 .NET 6.0 Visual Studio 2022 17.5.2
Client	Service Bus	[BUG] NullReferenceException when updating concurrency in ServiceBusProcessor	Library name and version Azure.Messaging.ServiceBus 7.12.0.0 Describe the bug Under load we're getting periodic NullRefenceExceptions thrown from the Receiver Manager in response to a call to UpdateConcurrency: Looking at the code for UpdatePrefetchCount, it is referencing the property for Receiver multiple times but this property can be updated while the method is running, meaning it can be set to null after the null check but prior to referencing the PrefetchCount property.                azure-sdk-for-net/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ReceiverManager.cs                   Lines 126 to 132       in       7b03cd1                                                 public virtual void UpdatePrefetchCount(int prefetchCount)                                           {                                               if (Receiver != null && Receiver.PrefetchCount != prefetchCount)                                               {                                                   Receiver.PrefetchCount = prefetchCount;                                               }                                           }                     When this happens, the ServiceBusSessionProcessor stops receiving messages. Expected behavior Updating the concurrency should not cause the session processor to fail internally. Actual behavior A null reference exception is thrown with the following stack trace: Azure.Messaging.ServiceBus.ReceiverManager.UpdatePrefetchCount(int prefetchCount) Azure.Messaging.ServiceBus.ServiceBusProcessor.ReconcileReceiverManagers(int maxConcurrentSessions, int prefetchCount) Azure.Messaging.ServiceBus.ServiceBusProcessor.ReconcileConcurrencyAsync() Azure.Messaging.ServiceBus.ServiceBusProcessor.RunReceiveTaskAsync(System.Threading.CancellationToken cancellationToken) Azure.Messaging.ServiceBus.ServiceBusProcessor.RunReceiveTaskAsync(System.Threading.CancellationToken cancellationToken)  Once the exception occurs, the processor fails to retrieve any more messages from service bus Reproduction Steps We are calling: ServiceBusSessionProcessor.UpdateConcurrency(newTaskCount, 1); While under high load.  It happens about once every 8 hours. Environment Windows Service in .NET Framework 4.7.2
Client	Event Hubs	[QUERY] Use of AMQP session in EventHub	Library name and version Azure.Messaging.EventHubs Query/Question I noticed that each AMQP sender/receiver link is created with a separate AMQP session. Is there any special reason behind this design decision? I am asking because I am currently working on a rust sdk for event hubs Environment No response
Client	Azure.Identity	[BUG] Unable to request token with custom scope	Library name and version Azure.Identity 1.8.2, Microsoft.NET.Sdk.Functions 3.1.2 Describe the bug I'm using the Azure.Identity from a Function App (runtime 3) calling the DefaultAzureCredential() class. I've already activated the Managed Identity for the Function App. I'm calling the GetTokenAsync to gather a token for another app which exposes an API using this code. The scope is in the format `api://someguid/.default` var scope = `api://<guid>/.default`    var tokenCredential = new DefaultAzureCredential();    var tokenResponse = await tokenCredential.GetTokenAsync(      new TokenRequestContext(new[] { scope }),      cancellationToken    );    The API I'm trying to get access to, is authenticated using the Easy Auth Authentication from the portal. This auth results in a new app registration created in the Azure Active Directory. I've also created App Roles for the API and assigned an app role to my Managed Identity using the powershell command New-AzureADServiceAppRoleAssignment Expected behavior I would expect to retrieve a token, or at least have a more specific error than the 500. Actual behavior The code throws an exception when calling the GetTokenAsync with a 500 Internal Server error. Azure.Identity.AuthenticationFailedException : ManagedIdentityCredential authentication failed: Service request failed.Status: 500 (Internal Server Error). As a side note, if I change the scope to e.g. `https://.vault.azure.net/` it gets the token properly. Reproduction Steps Create an app service with Easy Auth activated - name: MyAPIApp Get the App Registration linked to the Easy Auth of the MyAPIApp Create a new Azure Function with HttpTrigger in Visual Studio. Import the Assembly Azure.Identity Retrieve the token for the ManagedIdentity using the code above and the scope from the App Registration of the MyAPIApp Publish the Function App to Azure - Name : MyFunctionApp Run the Trigger Http to execute the Function The error 500 appears Environment Microsoft Visual Studio Enterprise 2019 v. 16.10.3 Azure Function runtime 3.x
Client	Event Hubs	[QUERY] Can you invoke UpdateCheckpointAsync after EventProcessorClient.StopProcessingAsync has completed?	Library name and version Azure.Messaging.EventHubs.Processor 5.8.1 Query/Question Apologies in advance if this is a duplicate question or is already explained in the documentation. I couldn't find an explicit answer. I have a scenario where the EventProcessorClient.ProcessEventsAsync event callback will save off incoming batches per partition to a background queue and, once the queue threshold is hit, it will flush it and push it to an upstream location. After the push is completed, the background worker will invoke ProcessEventArgs.UpdateCheckpointAsync for the last per-partition instance, moving the checkpoint forward for all batched messages. To ensure that the background per-partition queue is flushed regularly, a System.Threading.Timer instance is scheduled so that if the queue is not full and a sufficient interval passes, the queue is flushed and the checkpoint is advanced. As a result, there could be race conditions between when EventProcessorClient.StopProcessingAsync is called and when ProcessEventArgs.UpdateCheckpointAsync is invoked during shutdown. Is it safe to call ProcessEventArgs.UpdateCheckpointAsync if the client has already called StopProcessingAsync and StopProcessingAsync is complete? Environment .netcoreapp3.1, .net6, .net7
Client	KeyVault	Can we cache unwrapkeyasync?	We are making massive number of calls to decrypt the secret. Is there a way we can cache the unwraped key, so that we dont have to make calls to KV multiple times. Any C# example will do.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 73896413-fe0d-047d-5f3b-bfc8d3ff7260 Version Independent ID: 638fc43e-1c40-05c3-1363-6ddd8c66641e Content: KeyVaultClientExtensions.UnwrapKeyAsync Method (Microsoft.Azure.KeyVault) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.KeyVault/KeyVaultClientExtensions.xml Service: key-vault GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Core	[BUG] HttpMessage.Properties not accessible anymore after dispose.	Library name and version Azure.Core 1.30.0 Describe the bug Hello, This commit 437d4ad broke our usage of HttpPipeline  in our tests: We use a fake transport to catch all message sent through the HttpPipeline, then in the asserts we check if the received message are what we are expecting. With this changes the _propertyBag is disposed and then it's impossible to access the properties anymore. Expected behavior Property should be accessible or we should have a way to copy all of them in the transport layer, maybe with a way to list all keys so we can make a copy of it. Actual behavior Property are note available anymore Reproduction Steps Capture message with an HttpPipelineTransport and try to access the properties after the Dispose public class FakeTransport : HttpPipelineTransport {  private readonly List<FakeRequest> _requests = new List<FakeRequest>();  private readonly List<HttpMessage> _receivedMessages = new List<HttpMessage>();  public IReadOnlyList<HttpMessage> ReceivedMessages => _receivedMessages;  public IReadOnlyList<FakeRequest> CreatedRequests => _requests;  public Action<HttpMessage>? OnProcess { get; set; }   public FakeTransport()  {   OnProcess = httpMessage =>    httpMessage.Response = new FakeResponse(418, `OnProcess must be override in tests that directly need to control the response `);  }   public override void Process(HttpMessage message)  {   OnProcess?.Invoke(message);   _receivedMessages.Add(message);  }   public override ValueTask ProcessAsync(HttpMessage message)  {   OnProcess?.Invoke(message);   _receivedMessages.Add(message);   return new ValueTask();  }   public override Request CreateRequest()  {   var request = new FakeRequest();   _requests.Add(request);   return request;  } } Environment No response
Client	Extensions	Make DefaultAzureCredential configurable in Azure Functions	When working on my company laptop, we have an annoying problem when using DefaultAzureCredentials, and in turn any functions that connect to Azure resources using DefaultAzureCredentials My understanding of how DefaultAzureCredentials works is this:  Attempt to use EnvironmentCredentials.  If no environment variables are found move on   Attempt to use ManagedIdentityCredentials  Try to connect to a specific IP address. If that fails move on   Attempt to try other credential methods (VisualStudio, AzureCli, etc) until one succeeds  Unfortunately, because of reasons outside of my control, DefaultAzureCredentials works like this on my company laptop:  Attempt to use EnvironmentCredentials.  If no environment variables are found move on   Attempt to use ManagedIdentityCredentials  Try to connect to a specific IP address. Company imposed firewall (firewall? network settings?) thinks you're connecting to a malicious IP address Firewall spits back HTML page ManagedIdentityCredentials gets confused an throws an exception.   Attempt to try other credential methods (VisualStudio, AzureCli, etc) until one succeeds  When using Azure Functions, it does succeed with other authentication methods, but not before spewing errors to the console. In ASP.NET Core apps, we work around this by configuring the DefaultAzureCredentials when running on a devs laptop. Something akin to: if (env.IsLocal()) {     services.Configure<DefaultAzureCredentialOptions>(opt => opt.ExcludeManagedIdentity = true); }  services.AddSingleton(sp => {     var opts = sp.GetService<IOptions<DefaultAzureCredentialOptions>>().Value;      return new DefaultAzureCredentials(opts); } However, when using Azure Functions (i.e. the Service Bus Azure Functions extension) there isn't an obvious extension point which allows the DefaultAzureCredentials to be configured. After much digging around in this repo, I've managed to come up with this workaround: class CustomAzureComponentFactory : AzureComponentFactory {     private readonly DefaultAzureCredentialOptions options;     public CustomAzureComponentFactory(IOptions<DefaultAzureCredentialOptions> options) => this.options = options.Value;     public override object CreateClient(Type clientType, IConfiguration configuration, TokenCredential credential, object clientOptions) => throw new NotImplementedException();     public override object CreateClientOptions(Type optionsType, object serviceVersion, IConfiguration configuration) => throw new NotImplementedException();      public override TokenCredential CreateTokenCredential(IConfiguration configuration) => new DefaultAzureCredential(options); }  if (env.IsLocal()) {     services.Replace(ServiceDescriptor.Singleton<AzureComponentFactory, CustomAzureComponentFactory>()); } Which does work, but feels very hacky. Can have a way of configuring the DefaultAzureCredentials in Azure Function Extensions? Perhaps using the Options model I've described above? Alternatively, having AzureComponentFactory as an implementation with virtual methods, instead of being an abstract class would also work.
Client	Service Bus	How to get some Service Bus message's data inside ProcessErrorAsync method using ServiceBusProcessor?	Library name and version Azure.Messaging.ServiceBus, version 7.12.0 Query/Question I have such code: var processor = client.CreateProcessor();  processor.ProcessMessageAsync += async (ProcessMessageEventArgs args) => {  object tenantId = null;  args.Message.ApplicationProperties.TryGetValue(`tenantId`, out var tenantId);   // ... };  processor.ProcessErrorAsync += async (ProcessErrorEventArgs args) => {  // ...    _logger.LogError(...); };  I write log if something goes wrong. I want to add into the log item tenantId from the message's application properties. But I've not found a way how to get a message inside ProcessErrorAsync handler or how to set some data inside ProcessMessageAsync to make it available inside ProcessErrorAsync. Environment No response
Client	Search	Tokenization Issue	Library name and version Azure.Search.Documents.SearchClient Query/Question Why does the asterisk (*) cause the query to skip analysis and go straight to search for Japanese/Chinese/Thai? I still want the capability of partial term search so I want * on the end of the query, however I still want the query to be tokenized. This is a big problem for these three languages as they do not use spaces, so the terms are not delimited into tokens that way. So, we cannot do partial term search in these 3 languages because otherwise the search treats the entire string of characters as one token, rather than searching by word. Environment .NET SDK 7.0.200
Client	Azure.Core	[BUG] Unexpected type for header	Library name and version Azure.Core 1.29.0 Describe the bug After upgrading to Azure.Core 1.29.0 (required by Microsoft.Extensions.Azure 1.6.2) we repeatedly receive this error: System.InvalidOperationException: Unexpected type for header :   at Azure.Core.Pipeline.HttpClientTransport.PipelineRequest.GetHttpHeaderValue(String headerName, Object value)  at Azure.Core.Pipeline.HttpClientTransport.PipelineRequest.EnumerateHeaders()+MoveNext()  at Azure.Core.Diagnostics.AzureCoreEventSource.FormatHeaders(IEnumerable`1 headers, HttpMessageSanitizer sanitizer)  at Azure.Core.Diagnostics.AzureCoreEventSource.Request(Request request, String assemblyName, HttpMessageSanitizer sanitizer)\n at Azure.Core.Pipeline.LoggingPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)  at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)  at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)\n at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)  at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)  at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken)  at Azure.Messaging.ServiceBus.Administration.HttpRequestAndResponse.SendHttpRequestAsync(Request request, CancellationToken cancellationToken)\n at Azure.Messaging.ServiceBus.Administration.HttpRequestAndResponse.GetEntityAsync(String entityPath, String query, Boolean enrich, CancellationToken cancellationToken)  at Azure.Messaging.ServiceBus.Administration.ServiceBusAdministrationClient.GetQueueAsync(String name, CancellationToken cancellationToken)  This does not happen locally. It only occurs when running in a container in AKS using managed identity credentials. Downgrading to Azure.Core 1.28.0 and Microsoft.Extensions.Azure 1.6.0 solves the issue. If it helps we're using Azure.Messaging.ServiceBus 7.12.0. Expected behavior No errors. Actual behavior See bug description. Reproduction Steps See bug description. Environment No response
Mgmt	Network	Complement to WithDnsServer() ?	I see that there is a `WithDnsServer()` and the effect is additive, but it would be nice if this page explained how to REMOVE a Dns server from the list.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: d68bdbc7-4212-8f18-1199-e8f92ec238b5 Version Independent ID: f74a5671-8d63-c537-10d0-52c0de6d068d Content: IUpdate Interface (Microsoft.Azure.Management.Network.Fluent.Network.Update) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Management.Network.Fluent.Network.Update/IUpdate.xml Service: virtual-network GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Service Bus	[QUERY] Cannot create Receiver from ServiceBusClient once the client has participated in a TransactionScope	Library name and version Azure.Messaging.ServiceBus 7.12.0 Query/Question It seems that once a ServiceBusSender has participated in a TransactionScope, the ServiceBusClient used to create that ServiceBusSender can no longer receive messages from other entities. For context: I have a web app that sends messages to various queues and topics. Some of my endpoints need to send messages to more than one queue/topic, and in those cases I want all of the messages to be sent or none of them, so I wrap the sending in a TransactionScope. Here's a short example that demonstrates the issue. I can even reproduce it with a single sender, to make it as simple as possible: var serviceBusClient = new ServiceBusClient(`...`, new ServiceBusClientOptions     {         EnableCrossEntityTransactions = true,     });  var sender = serviceBusClient.CreateSender(`some_queue`);  using (var ts = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled)) {     await sender.SendMessageAsync(new ServiceBusMessage());     ts.Complete(); }  var receiver = serviceBusClient.CreateReceiver(`some_other_queue`); var receivedMessage = await receiver.ReceiveMessageAsync(); // throws System.InvalidOperationException: 'Local transactions cannot span multiple top-level entities such as queue or topic If I didn't reuse serviceBusClient but instead created the receiver from a brand new instance of ServiceBusClient then I don't get the exception. But I thought the recommendation was to register ServiceBusClient as singleton? So the sending part and the receiving part of my example above might as well occur in two separate parts of the application, triggered by two different users, and the result would be the same. In the old Microsoft.Azure.ServiceBus lib where you had to be more involved with specifying which transfer entity to send via, I never ran into this exception. And I've tried to read everything I can find related to doing this using the new library, but there isn't much info out there. I would be very grateful if someone could help me out. Environment .NET SDK: Version:   7.0.201 Commit:    68f2d7e7a3 Runtime Environment: OS Name:     Windows OS Version:  10.0.22000 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.201\ Host: Version:      7.0.3 Architecture: x64 Commit:       0a2bda10e8 .NET SDKs installed: 7.0.201 [C:\Program Files\dotnet\sdk]
Client	Azure.Identity	[BUG] Updating to Visual Studio 2022 17.5.1 breaks the VisualStudioCredential for EventGrid	Library name and version Microsoft.Extensions.Azure 1.6.0 Describe the bug This sample project runs correctly with Visual Studio 17.4.4 but with version 17.5.1 the VisualStudioCredential for EventGrid breaks the program. However, the project also includes ServiceBus, which takes the credentials from Visual Studio correctly with both versions. The error says `Azure.Identity.CredentialUnavailableException: VisualStudioCredential.GetToken was unable to retrieve an access token. The JSON-RPC connection with the remote party was lost before the request could complete.` Expected behavior Work with Visual Studio 2022 17.5.1 by sending an Azure Eventgrid event Actual behavior Breaks with Visual Studio 2022 17.5.1 with the following errors. Reproduction Steps  Create an Azure Event Grid topic Grant the permission to your user: EventGrid Data Sender Download the repo Update Program.cs with the EventGrid endpoint Login in Visual Studio (not Azure CLI) Run Should see `Event sent` in the logs, but that never happens  Optionally  Create Azure Service Bus queue Grant the permission to your user: Azure Service Bus Data Owner Uncomment the Service Bus related lines in Program.cs and Function1.cs Update Program.cs with the ServiceBus endpoint Run Will see `Message sent` in the logs but still no `Event sent`  Environment Visual Studio 2022 17.5.1 Windows 10
Mgmt	Container Registry	[QUERY] How to create a new container registry from C#?	Library name and version Azure.ResourceManager.ContainerRegistry 1.1.0 Query/Question I today create a new container registry from C# using the Microsoft.Azure.Management.ContainerInstance.Fluent library and that works great. But that package is depreca ted,so I try to use Azure.ResourceManager.ContainerRegistry, but I can't figure out how to properly create a new container registry from C# using this library. Or what other library should I use to achieve this? And I can't find any suitable documentation either. Please help. Environment .NET 7
Mgmt	Event Hubs	[BUG] Get 404 while waiting delete eventhub namespace complete	Library name and version Azure.ResourceManager.EventHubs 1.0.0 Describe the bug As title, getting 404 while waiting delete eventhub namespace to complete. See stacktrace below, let me know if any further information is needed. Status: 404 (Not Found) ErrorCode: ResourceNotFound Content: {`error`:{`code`:`ResourceNotFound`,`message`:`The Resource 'Microsoft.EventHub/namespaces/pvtli-iothub-ns-hub0301-08-10-49992b256d' under resource group 'Default-EventHub-SouthCentralUS' was not found. For more details please go to https://aka.ms/ARMResourceNotFoundFix`}} Headers: Pragma: no-cache x-ms-failure-cause: REDACTED x-ms-request-id: 102ebea4-3d16-4865-be79-0feb85fcf13c x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED Strict-Transport-Security: REDACTED X-Content-Type-Options: REDACTED Content-Length: 273 Cache-Control: no-cache Content-Type: application/json; charset=utf-8 Date: Thu, 02 Mar 2023 05:45:28 GMT Expires: -1    at Azure.Core.OperationInternal`1.GetResponseFromState(OperationState`1 state)    at Azure.Core.OperationInternal`1.<UpdateStatusAsync>d__20.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.OperationInternalBase.<UpdateStatusAsync>d__13.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.OperationInternal.<UpdateStatusAsync>d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.OperationInternalBase.<UpdateStatusAsync>d__13.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.OperationPoller.<WaitForCompletionAsync>d__11.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.OperationInternalBase.<WaitForCompletionResponseAsync>d__19.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.OperationInternalBase.<WaitForCompletionResponseAsync>d__15.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.ResourceManager.EventHubs.EventHubsNamespaceResource.<DeleteAsync>d__36.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Microsoft.Internal.Azure.Devices.Common.AzureServiceManagement.Clients.AzureResourceManagerEventHubClient.<DeleteNamespaceIfExistsAsync>d__8.MoveNext() in C:\__w\1\s\common\Microsoft.Internal.Azure.Devices.Common.AzureServiceManagement\Clients\AzureResourceManagerEventHubClient.cs:line 143 --- End of stack trace from previous location where exception was thrown ---```  ### Expected behavior  No error in eventhub namespace deletion and while waiting delete completion.  ### Actual behavior  Get 404 while waiting delete eventhub namespace complete.  ### Reproduction Steps  Delete eventhub namespace with WaitUntil.Completed option.  ### Environment  _No response_
Client	Azure.Identity	[FEATURE REQ] Make the password parameter on UsernamePasswordCredential a SecureString	Library name Azure.Identity Please describe the feature. The UsernamePasswordCredential constructor could perhaps accept the password as a SecureString instead of just string. Perhaps there is a reason behind the decision to only support string, but I think it would be nice to have the other type as well if possible.
Mgmt	SQL	[QUERY] How can instances be created with ResourceManager.Sql?	Library name and version Azure.ResourceManager.Sql 1.2.0 Query/Question I have run into some issues when trying to create a new SQL database in another region as a secondary geo-replica of our primary databases where I haven't been able to spawn the instances. Essentially, what I want in the end is to automatically set up a replicated instance of each database that is available in our production system but in another region. I wasn't able to find any samples on how to create the SQL instances and would appreciate any tips on how to approach it via the SDK. Thus far I have successfully run the following test code: string fromResourceGroupName = ``; string fromSubscriptionId = ``; string fromSqlServerName = ``;  string targetResourceGroupName = ``; string targetSubscriptionId = ``; string targetSqlServerName = ``;  DefaultAzureCredential credentials = new(includeInteractiveCredentials: true);  ArmClient client = new(credentials); SubscriptionCollection subs = client.GetSubscriptions();  // We want to create a secondary copy from these databases SubscriptionResource fromSubscription = subs.Get(fromSubscriptionId); ResourceGroupCollection fromResourceGroups = fromSubscription.GetResourceGroups(); ResourceGroupResource fromResourceGroup = await fromResourceGroups.GetAsync(fromResourceGroupName); SqlServerResource fromSqlServer = fromResourceGroup.GetSqlServer(fromSqlServerName).Value; SqlDatabaseCollection fromDatabaseCollection = fromSqlServer.GetSqlDatabases();  // To this SQL server instance SubscriptionResource targetSubscription = subs.Get(targetSubscriptionId); ResourceGroupCollection targetResourceGroups = targetSubscription.GetResourceGroups(); ResourceGroupResource targetResourceGroup = await targetResourceGroups.GetAsync(targetResourceGroupName); SqlServerResource targetSqlServer = targetResourceGroup.GetSqlServer(targetSqlServerName).Value;  foreach (SqlDatabaseResource? sourceIter in fromDatabaseCollection) {     // What to put here? }  Thank you for your time Environment No response
Mgmt	SQL	[BUG] Cannot remove last SQL database from Failover Group using FailoverGroupPatch	Library name and version Azure.ResourceManager.Sql 1.2.0 Describe the bug When updating a Failover Group to remove the one and only database of the Failover Group, the operation seems to succeed, but the database is not removed. Basically applying FailoverGroupPatch with an empty IList<string> Databases does not remove the database. Expected behavior Database is removed from Failover Group. Actual behavior Database is not removed from Failover Group. Reproduction Steps var patch = new FailoverGroupPatch(); foreach(var dbId in failoverGroup.Value.Data.Databases) {     if (dbId != databaseToRemoveResourceId)     {         patch.Databases.Add(dbId); //not executed since no other databases in the failover group                    } } await failoverGroup.Value.UpdateAsync(WaitUntil.Completed, patch);  Environment net6.0
Client	Maps	[BUG] GetMapStaticImageAsync	Library name and version Azure.Maps.Search -1.0.0-beta.3 Describe the bug An exception is thrown when providing the latitude and longitude as input to the GetMapStaticImageAsync function. However, the values passed to the ReverseSearchCrossStreetAddressAsync function are functioning properly. Further information is provided below. GetMapStaticImageAsync  exception Service request failed. Status: 400 (Bad Request) Content: {`Center`:[`params are out of range <-180,180> and <-85,85>`]} Headers: x-ms-azuremaps-region: REDACTED X-Content-Type-Options: REDACTED Strict-Transport-Security: REDACTED X-Cache: REDACTED X-MSEdge-Ref: REDACTED Date: Sat, 25 Feb 2023 14:42:40 GMT Content-Length: 62 Content-Type: application/json; charset=utf-8 Expected behavior It should create an image Actual behavior Throw an exception Service request failed. Status: 400 (Bad Request) Content: {`Center`:[`params are out of range <-180,180> and <-85,85>`]} Headers: x-ms-azuremaps-region: REDACTED X-Content-Type-Options: REDACTED Strict-Transport-Security: REDACTED X-Cache: REDACTED X-MSEdge-Ref: REDACTED Date: Sat, 25 Feb 2023 14:42:40 GMT Content-Length: 62 Content-Type: application/json; charset=utf-8 Reproduction Steps GeoPosition geoPosition = new GeoPosition(37.7749, -122.4194); Pass GeoPosition to GetMapStaticImageAsync function it throw an exception Environment .NET SDK: Version:   7.0.200 Commit:    534117727b Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows
Mgmt	Network	[BUG] sourceAddressPrefixes	Library name and version Azure.ResourceManager.Network Describe the bug unable to set sourceAddressPrefixes in SecurityRuleData , it is read only Expected behavior sourceAddressPrefixes able to be set Actual behavior error sourceAddressPrefixes is read only Reproduction Steps create an instance of SecurityRuleData and try to fill the field:   SourceAddressPrefixes Environment Windows
Client	Service Bus	[QUERY] Late ThrowIfCancellationRequested check in SendMessagesAsync	Library name and version Azure Service Bus 7.12.0 Query/Question I was browsing the code and noticed that this cancellation check (link below) is performed after the operation is complete.  Wouldn't this result in a successful queue of the message and a cancellation as the result?  Then may be cause someone to queue the message twice on a retry? https://github.com/Azure/azure-sdk-for-net/blob/Azure.Messaging.ServiceBus_7.12.0/sdk/servicebus/Azure.Messaging.ServiceBus/src/Sender/ServiceBusSender.cs#L255 Environment N/A
Client	Service Bus	[QUERY] How to migrate to .NET 6 given I ran across an AMQP limitation?	Library name and version Azure.Messaging.ServiceBus 7.12.0 Query/Question We have a WebAPI application that targets .NET 4.8 and uses WindowsAzure.ServiceBus. One of the app's core functionalities is to PeekLock a message within the first API call and then complete it within another (Complete) API call. You can think of the app as the gateway for a subset of Azure ServiceBus. We do not want our customers to have direct access to Azure Service Bus, hence we created an API that adds extra authorization, logging, throttling, business validation etc. The app is hosted in Azure and is configured to scale out dynamically, so inherently there is more than one instance of the API running. Even if there was only single instance running, during deployment, it might happen that PeekLock call is made against the `old` instance and Complete against the newly deployed one. We currently rely on Service Bus Messaging Protocol (SBMP) which supports our PeekLock/Complete scenario just fine. However, our Product Owner asked us to migrate to .NET 6. I have tried migrating our code to use the latest Azure.Messaging.ServiceBus as WindowsAzure.ServiceBus does not target .NET Core/NET 5+.  It seems that I have run across a showstopper described in the issue. Since Microsoft decided to drop support for SBMP in the latest SDK, what are our options? Environment .NET 4.8 & WindowsAzure.ServiceBus 3.3.2 willing to migrate to .NET 6
Client	Service Bus	[BUG] unable to peek message or receive message / program just stops	Library name and version Azure.Messaging.ServiceBus 7.12.0 Describe the bug When using var peekedMessage = await _receiver.PeekMessageAsync(79369903); nothing will happen: No exceptions, no returned value - Excecution just stops. I can properly CreateProcessor and CreateSender but the _receiver just returns and stops executing instantiated as  _client.CreateReceiver(_queue, new ServiceBusReceiverOptions() { ReceiveMode = ServiceBusReceiveMode.PeekLock }); I tried 3 authentication variants, same result. Expected behavior some form of information returned Actual behavior Nothing is returned and console execution just stops Reproduction Steps         _client = new ServiceBusClient(`<Cs>`);         _receiver = _client.CreateReceiver(`<Q>`, new ServiceBusReceiverOptions() { ReceiveMode = ServiceBusReceiveMode.PeekLock });  // here: var peekedMessage = await _receiver.PeekMessageAsync(1); Environment Windows 11, Console Application Microsoft Visual Studio Community 2022 (64-bit) - Current Version 17.4.4 .NET 6.0
Client	Functions	[BUG] Unable to filter SDK logs in Azure Function instances	Library name and version Azure.Messaging.ServiceBus and Azure.Storage.Blobs Describe the bug We are seeing few issues with the latest (5.x) version SDKs:   Below lock renew happens constantly with 5.x sdk which we didn't see with the previous 4.x sdk. Request [a0294b3b-3aa4-4b65-9b35-20c2e0493ed3] PUT https://<>.blob.core.windows.net/azure-webjobs-hosts/locks/<>/host?comp=metadata    We are seeing 409 Conflict (Container already exists) Request [b4948ae8-cc71-4239-828f-bc7657391d0b] PUT https://dataqualityfnstorage.blob.core.windows.net/azure-webjobs-hosts?restype=container   This event is flooding our logs every 10 seconds for ServiceBus trigger function. Receiver: ReceiveBatchAsync start. MessageCount = 1.   We tried setting the loglevel in both host.json and appsettings.json Host.json: {   `version`: `2.0`,   `functionTimeout`: `00:55:00`,   `logging`: {     `logLevel`: {       `Default`: `Warning`,       `System`: `Warning`,       `Microsoft`: `Warning`,       `Azure.Messaging.ServiceBus`: `Error`,       `Azure.Storage.Blobs`: `Error`,       `Azure.Core`: `Error`,       `Microsoft.Azure.WebJobs.Extensions.Storage`: `Error`,       `Microsoft.Azure.WebJobs.Extensions.ServiceBus`: `Error`,       `Microsoft.Azure.WebJobs.Script.WebHost.Diagnostics.SystemLoggerProvider`: `Error`,       `Azure.Functions.Cli.Diagnostics.ColoredConsoleLoggerProvider`: `Error`,       `Microsoft.Azure.WebJobs.Logging.ApplicationInsights.ApplicationInsightsLoggerProvider`: `Error`     }   } }  local.appsettings.json {   `IsEncrypted`: false,   `Values`: {     `AzureFunctionsJobHost_logging_LogLevel_Default`: `Error`,     `APP_INSIGHTS_NAMESPACE`: `functions`,  `AzureWebJobsStorage`: ``,     `FUNCTIONS_EXTENSION_VERSION`: `~4`,     `FUNCTIONS_WORKER_RUNTIME`: `dotnet`,     `WEBSITE_FIRST_PARTY_ID`: `AntMDS`,     `WEBSITE_NODE_DEFAULT_VERSION`: `~10`,     `Logging:LogLevel:Azure.Messaging.ServiceBus`: `Error`,     `Logging:LogLevel:Azure.Core`: `Error`,     `Logging:LogLevel:Azure.Storage.Blobs`: `Error`,     `Logging:LogLevel:Microsoft.Azure.WebJobs.Extensions.Storage`: `Error`,     `Logging:LogLevel:Microsoft.Azure.WebJobs.Extensions.ServiceBus`: `Error`,     `applicationInsights:logLevel:default`: `Error`,     `Logging:LogLevel:Serilog.Extensions.Logging.SerilogLoggerProvider`: `Error`,     `Logging:LogLevel:Microsoft.Azure.WebJobs.Script.WebHost.Diagnostics.SystemLoggerProvider`: `Error`,     `Logging:LogLevel:Azure.Functions.Cli.Diagnostics.ColoredConsoleLoggerProvider`: `Error`,     `Logging:LogLevel:Microsoft.Azure.WebJobs.Logging.ApplicationInsights.ApplicationInsightsLoggerProvider`: `Error`,     `Serilog.Extensions.Logging.SerilogLoggerProvider`: `Error`,     `Microsoft.Azure.WebJobs.Script.WebHost.Diagnostics.SystemLoggerProvider`: `Error`,     `Azure.Functions.Cli.Diagnostics.ColoredConsoleLoggerProvider`: `Error`,     `Microsoft.Azure.WebJobs.Logging.ApplicationInsights.ApplicationInsightsLoggerProvider`: `Error`   },   `Logging`: {     `LogLevel`: {       `Default`: `Debug`,       `System`: `Warning`,       `Microsoft`: `Warning`,       `Azure.Messaging.ServiceBus`: `Error`,       `Azure.Storage.Blobs`: `Error`,       `Azure.Core`: `Error`,       `Microsoft.Azure.WebJobs.Extensions.Storage`: `Error`,       `Microsoft.Azure.WebJobs.Extensions.ServiceBus`: `Error`,       `Microsoft.Azure.WebJobs.Script.WebHost.Diagnostics.SystemLoggerProvider`: `Error`,       `Azure.Functions.Cli.Diagnostics.ColoredConsoleLoggerProvider`: `Error`,       `Microsoft.Azure.WebJobs.Logging.ApplicationInsights.ApplicationInsightsLoggerProvider`: `Error`     }   } }   Expected behavior These logs doens't happen with 4.x. So, we don't expect this to happen in 5.x as well Actual behavior As mentioned in the issue section, we are seeing unwanted logs Reproduction Steps Upgrade 4.x to 5.x Environment PROD
Client	Service Bus	[BUG] ReceiveAndDelete interrupts PeekLock	Library name and version Azure.Messaging.ServiceBus 7.12.0 Describe the bug Consider the following sample. It starts by receiving and deleting all messages from a given topic & subscription. Then it sends a message to the topic. Then it attempts to peek lock the message. Finally it receives and deletes all messages (clean up). static void Log(string message) => Console.WriteLine($`[{DateTime.Now:T}] {message}`);  var administrationClient = new ServiceBusAdministrationClient(administrationConnectionString);  if (!await administrationClient.TopicExistsAsync(topicName)) {     await administrationClient.CreateTopicAsync(new CreateTopicOptions(topicName)     {         AutoDeleteOnIdle = TimeSpan.FromMinutes(10)     });     Log($`Topic {topicName} created`);     await administrationClient.CreateSubscriptionAsync(topicName, subscriptionName);     Log($`Subscription {topicName}/{subscriptionName} created`); }  var serviceBusClient = new ServiceBusClient(sendReceiveConnectionString);  await using ServiceBusSender sender = serviceBusClient.CreateSender(topicName); await using ServiceBusReceiver receiver = serviceBusClient.CreateReceiver(topicName, subscriptionName, new ServiceBusReceiverOptions {     ReceiveMode = ServiceBusReceiveMode.ReceiveAndDelete }); await using ServiceBusReceiver peekLocker = serviceBusClient.CreateReceiver(topicName, subscriptionName, new ServiceBusReceiverOptions {     ReceiveMode = ServiceBusReceiveMode.PeekLock });  async Task ReceiveAll() {     IReadOnlyList<ServiceBusReceivedMessage> messages;     do     {         messages = await receiver.ReceiveMessagesAsync(maxMessages: 10, maxWaitTime: TimeSpan.FromSeconds(3));         foreach (var serviceBusReceivedMessage in messages)         {             Log($`Received: {serviceBusReceivedMessage.Body}`);         }     } while (messages.Count > 0);     Log(`Receiving completed.`); }  await ReceiveAll(); //comment me out for the PeekLock to succeed  var messageBody = $`Message {DateTime.Now:T}`; await sender.SendMessageAsync(new ServiceBusMessage(messageBody)); Log($`{messageBody} sent`); var message = await peekLocker.ReceiveMessageAsync(TimeSpan.FromSeconds(15)); if (message != null) {     Log($`{message.Body} received. MessageId = {message.MessageId}, LockToken = {message.LockToken}, LockedUntil = {message.LockedUntil}`); } else {     Log(`No message received using PeekLock`); }  await ReceiveAll(); Expected behavior [16:32:05] Receiving completed. [16:32:06] Message 16:32:05 sent [16:32:06] Message 16:25:34 received. MessageId = 60217e3b779d400ca7a6aa8199b5615b, LockToken = ea02213a-d761-410b-83c8-78cbfec4b8a5, LockedUntil = 10.02.2023 15:33:07 +00:00 [16:32:07] Received: Message 16:32:05 [16:32:10] Receiving completed. It can be achieved by commenting out the first call to ReceiveAll. It appears that the fact that receiver has been called, makes it claim the next message sent, even though that I'm done with it for now and I expect the peekLocker to be the one receiving it. Actual behavior [16:33:30] Receiving completed. [16:33:30] Message 16:33:30 sent [16:33:46] No message received using PeekLock [16:33:46] Received: Message 16:33:30 [16:33:49] Receiving completed. Reproduction Steps Run the sample. Environment Sample running against .NET 6, Windows 10 x64. Also observed in Azure App Service hosting a .NET 4.8 app.
Client	Azure.Identity	[BUG] ManagedServiceIdentity does not use local MSI endpoint when retrieving access token scoped to app registration	Library name and version Azure.Identity 1.8.1 Describe the bug We have multiple function apps deployed to an Elastic Premium plan using vnet integration with vnet route all enabled and a default route to an Azure Firewall that blocks all network traffic to public IPs. All function apps connect to other PaaS services like Cosmos DB and Azure Service Bus using private endpoints deployed inside the same vnet as our Functions. We are trying to make an HTTP request from Function App A to Function App B where Function App B has App Service Authentication enabled and the `User Assignment Required` option set to true on the app registration used for App Service Authentication. The MSI of Function App A has been assigned the appropriate role on the app registration of Function App B so that it has permission to request access tokens scoped to the app registration. We are using ManagedIdentityCredential.GetTokenAsync(new TokenRequestContext(scopes: new string[] { <App ID of Function App B's App Registration> + `/.default` }) in Function App A to request an access token with the correct scope, but the request is being blocked by our Firewall as the request is trying to access `login.windows.net`. The documentation for this method states that GetTokenAsync `Obtains an AccessToken from the Managed Identity service` which lead us to believe that the request should use the function app's local managed identity endpoint and not hit any of the public AAD endpoints. We are able to use the same ManagedIdentityCredential to retrieve an access token for Cosmos DB and Service Bus using the appropriate SDKs without being affected by our firewall rules. Is this expected behaviour, or should the ManagedIdentityCredential use the local MSI endpoint without making any requests to public endpoints? If it is expected behaviour, how does this scenario differ to retrieving an access token scoped to a Cosmos account or a Service Bus namespace? Expected behavior ManagedIdentityCredential should use the local MSI endpoint to retrieve an access token without making requests to public AAD endpoints. Actual behavior A request is made to login.windows.net which is rejected by Azure firewall. Reproduction Steps  Deploy 2 x Function Apps to Elastic Premium plan with vnet integration and the vnet route all option enabled. Create default route to an Azure Firewall with no rules configured Setup App Service Authentication on one Function App Use ManagedIdentityCredential.GetTokenAsync() to retrieve an access token scoped to the app registration used for App Service Auth of the second Function App  Environment Azure Functions running in an Elastic Premium EP1 plan with vnet integration enabled.
Mgmt	Compute	[BUG] Failed to create VirtualMachineScalesetextensionResource with exception Value cannot be null. (Parameter 'id')	Library name and version Azure.ResourceManager.Compute 1.0.1 Describe the bug Try to add extension to the scale set with sdk but failed. Expected behavior The extension should be created successfully. Actual behavior Got exception above. However, the extension is shown in the extension tab of the scale set. Reproduction Steps Execute the following code and got exception. VirtualMachineScaleSetExtensionData vmssExtensionData = new VirtualMachineScaleSetExtensionData(`ExtensionName`) { xxxx }; await scaleset.GetVirtualMachineScaleSetExtensions()                               .CreateOrUpdateAsync(Azure.WaitUntil.Completed, vmssExtensionData.Name, vmssExtensionData);  Exception: Value cannot be null. (Parameter 'id') at Azure.ResourceManager.ArmResource..ctor(ArmClient client, ResourceIdentifier id) at Azure.ResourceManager.Compute.VirtualMachineScaleSetExtensionResource..ctor(ArmClient client, ResourceIdentifier id) at Azure.ResourceManager.Compute.VirtualMachineScaleSetExtensionOperationSource.Azure.Core.IOperationSource<Azure.ResourceManager.Compute.VirtualMachineScaleSetExtensionResource>.CreateResult(Response response, CancellationToken cancellationToken) at Azure.Core.NextLinkOperationImplementation.OperationToOperationOfT1.d__3.MoveNext() at System.Threading.Tasks.ValueTask1.get_Result() at Azure.Core.OperationInternal1.d__20.MoveNext() at Azure.Core.OperationPoller.d__11.MoveNext() at Azure.Core.OperationInternalBase.d__19.MoveNext() at Azure.Core.OperationInternal1.d__19.MoveNext() at Azure.ResourceManager.Compute.VirtualMachineScaleSetExtensionCollection.CreateOrUpdate(WaitUntil waitUntil, String vmssExtensionName, VirtualMachineScaleSetExtensionData data, CancellationToken cancellationToken) Environment .NET SDK: Version: 7.0.102 Commit: 4bbdd14480 Runtime Environment: OS Name: Windows OS Version: 10.0.19044 OS Platform: Windows RID: win10-x64 Base Path: C:\Program Files\dotnet\sdk\7.0.102\ Host: Version: 7.0.2 Architecture: x64 Commit: d037e070eb .NET SDKs installed: 6.0.308 [C:\Program Files\dotnet\sdk] 7.0.102 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86 [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found Learn more: https://aka.ms/dotnet/info Download .NET: https://aka.ms/dotnet/download IDE: Visual Studio 2022
Mgmt	App Services	[BUG] Exists always returns false or throws exception	Library name and version Azure.ResourceManager.AppService 1.0.0 Describe the bug When asking if an AppServicePlan exists, then it return always false. After I created a AppServicePlanResource, I ask if this specific resource exists via resourceGroup.GetAppServicePlans().Exists(rid)  which always return false. Getting the resource via name or by rid works. Also this ways does not work and throws an exception, that the provider is not known. armClient.GetGenericResources().Exists(rid)  Expected behavior Both ways allows to check if an AppServicePlan exists. Actual behavior Returns always false, when going via ResourceGroup.GetAppServicePlans().Exists(rid) Throws exception when going via ArmClient.GetGenericResources().Exists(rid) Reproduction Steps  Create ResourceGroup Create an AppServicePlan Ask if the AppServicePlan exists  Environment No response
Client	Event Hubs	[QUERY] EventHubConsumerClient - exceeded the maximum number of allowed receivers per partition in a consumer group which is 5	Library name and version Azure.Messaging.EventHubs.Consumer Query/Question I keep running into this exception: `Azure.Messaging.EventHubs.EventHubsException(QuotaExceeded): Exceeded the maximum number of allowed receivers per partition in a consumer group which is 5.` To give a bit more context: I have an event hub configured with only a single partition. I'm currently caching and reusing an EventHubConsumerClient in my application. Multiple threads use this same client by calling ReadEventsFromPartitionAsync on it (to read from the one and only partition)— oftentimes concurrently. I can confirm that I'm not creating more than one client and am caching and reusing the same client. Does this mean that each call to ReadEventsFromPartitionAsync is considered a `receiver` in this case? If so, what is a good way to work around this limitation (besides using the maximum number of consumer groups allowed)? I just want multiple threads to be able to read from the same partition concurrently. If there isn’t a work around for this limitation, then what would be a good strategy for retry here whenever this exception occurs? Just simply retry immediately or with a backoff of some sort? Thanks! Environment No response
Client	Azure.Identity	[BUG] SearchIndexClient: After some successful response throwing Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: Service request failed. Status: 429	Library name and version Azure.Search.Documents 11.4.0 Describe the bug Hello Team, We recently had migrated Azure Cognitive Search auth from AzureKeyCredential to DefaultAzureCredential. We do have lots of requests to Azure Search and some of the requests getting failed with below error. Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: Service request failed. Status: 429 ( ) On investigation, we found that we have been throttled by MSI, and noticed current version of SearchIndexClient doesn’t support caching the credentials, can you please take a look? var searchIndexClient = new SearchIndexClient(new Uri($`https://*******.search.windows.net`), new DefaultAzureCredential()); Expected behavior Not expecting an Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed response when large number of request to  SearchIndexClient Actual behavior It's throwing a very large error: Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: Service request failed. Status: 429 ( ) Content: Headers: Content-Length: 90 Content-Type: application/json; charset=utf-8 Date: Thu, 26 Jan 2023 07:34:55 GMT Server: IMDS/150.870.65.798 See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot ---> Azure.RequestFailedException: Service request failed. Status: 429 ( ) Content: Headers: Content-Length: 90 Content-Type: application/json; charset=utf-8 Date: Thu, 26 Jan 2023 07:34:55 GMT Server: IMDS/150.870.65.798 at Azure.Identity.ManagedIdentitySource.d__10.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.ImdsManagedIdentitySource.d__15.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.ManagedIdentitySource.d__9.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.ImdsManagedIdentitySource.d__14.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.ManagedIdentityClient.d__11.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.ManagedIdentityCredential.d__10.MoveNext() --- End of inner exception stack trace --- at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage) at Azure.Identity.ManagedIdentityCredential.d__10.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.ManagedIdentityCredential.d__8.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Azure.Identity.DefaultAzureCredential.d__15.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.DefaultAzureCredential.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage) at Azure.Identity.DefaultAzureCredential.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.DefaultAzureCredential.d__12.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.d__9.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.d__6.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.d__6.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.d__12.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.d__11.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Search.Documents.SearchClient.d__391.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Search.Documents.SearchClient.<SearchInternal>d__381.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Search.Documents.SearchClient.d__37`1.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) ...... Reproduction Steps  Trigger a large number of requests (at some point we will have 50000+ requests in 15 minutes) to GetSearchClient After some successful response, we can start seeing Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication error.  Environment No response
Client	Azure.Identity	[Question] How to refresh token when i use DefaultAzureCredential to get token to connect Azure MySQL	Library name and version Azure.Identity 1.8 Query/Question Here is my code in program.cs file     var credential = new DefaultAzureCredential();     var token = credential.GetToken(new Azure.Core.TokenRequestContext(new[] { `https://ossrdbms-aad.database.windows.net` }));     var connectionString = $`Server={builder.Configuration[`DatabaseConfiguration:Server`]};` +                            `Port=3306;` +                            `SslMode=Required;` +                            $`Database={builder.Configuration[`DatabaseConfiguration:Database`]};` +                            $`Uid={builder.Configuration[`DatabaseConfiguration:UserId`]};` +                            `Password=` + token.Token;     var connection = new MySqlConnection(connectionString);  When i try to connect mysql by this way, (I'm a newer on c#, actually i also try DI, but it doesn't refresh token, so i try this simple way from offcial document, hope it can work), so how to refresh token when i use DefaultAzureCredential to get token to connect Azure MySQL, anyone can give some example to me ? Environment dotnet version is 6
Client	Azure.Identity	adding new node pool to AKS cluster caused default azure credentials to failed	Library name and version aad pod identity Query/Question my pod\managed identity worked perfect until added new node pool. when my hosted service tried to authenticate against the key vault I'm getting below exception: DefaultAzureCredentials failed to retrieve a token from  the included credentials . EnvironmentCredentials authentication unavailable . environment variables are not fully configured. ManagaedIdentityCredentials authentication unavailable. the requested identity has not been assigned to this resource. when observing the cluster it seems like we dont have NMI on the node pool, I'm not sure I fully understand how it supposed to work but i guess this is part of the problem. Environment AKS cluster hosted service in .net 6.0
Client	Service Bus	[QUERY] ServiceBusSender Substitute is not working in test cases	Library name and version Azure.Messaging.ServiceBus Query/Question I have recently migrated azure functions to .NET 6 and also replaced servicebus package to azure.messaging.servicebus by removing deprecated ones. After using new package of service bus Functionapp works just like before but my testcases are failing. We are using Nsubstitute for testing .I have substituted ServiceBusSender and tried to receive calls that reached sendmessagesasync. Code used to send messages is : public async Task Run([TimerTrigger(`%Schedule%` #if DEBUG ,RunOnStartup = true #endif )] TimerInfo timer, ILogger logger) { // some code to retrieve messages from httpclient sender = _serviceBusClient.CreateSender(topicName); await sender.SendMessagesAsync(messages); } Here i want to check received messages in my test cases expected: it should return number of calls made to method actual : No call matching Error: NSubstitute.Exceptions.ReceivedCallsException : Expected to receive a call matching: SendMessagesAsync() Actually received no matching calls. Is mocking/faking is allowed on servicebussender ? Environment No response
Client	App Configuration	App Config SDK Cannot Set Tags on ConfigurationSetting	azure-sdk-for-net/sdk/appconfiguration/Azure.Data.AppConfiguration/src/ConfigurationSetting.cs                    Line 116       in       25b8cd1                                                 internal set => _tags = value;                     In the REST api it is possible to set tags, but seems to be read only in the SDK. Can we fix this?
Client	Event Hubs	[QUERY] EventHubConsumerClient thread safety	Library name and version Azure.Messaging.EventHubs.Consumer Query/Question Is EventHubConsumerClient thread-safe? Does each thread need its own client? Currently we use a single consumer which is being called by multiple threads. The documentation here https://learn.microsoft.com/en-us/dotnet/api/azure.messaging.eventhubs.consumer.eventhubconsumerclient?view=azure-dotnet does not really mention anything about this so I’d like to confirm. Environment No response
Client	Azure.Identity	[BUG]DefaultAzureCredential cache fetch performance	Library name and version Azure.Identity Describe the bug I'm using Azure.Identity to replace all calls in my application to Microsoft.Azure.Services.AppAuthentication which is marked deprecated. But there is one interesting behavior that I observed. It seems that the time spent on calling DefaultAzureCredential.GetToken is more or less constant. i.e. if I have a slow connection and my initial call to DefaultAzureCredential.GetToken took me 1000ms, that means my following calls will all take 1000ms even if the initial result is cached. I can confirm that the caching is functional(I can still get the token if I disconnect the internet which definitely gives me the cached result.) This is very different from the behavior of AzureServiceTokenProvider.GetAccessToken from Microsoft.Azure.Services.AppAuthentication library which returns the token immediately once it's cached. I'm not sure whether this changed behavior is intentional or not. I understand, under certain circumstances, making this process fix-timed may increase the level of security(when some cryptographies are involved), but when the initial call is slow, the time cost to get the cached token is simply too high. Expected behavior Described above Actual behavior Described above Reproduction Steps         // ...  var azCred = new DefaultAzureCredential();  var tknCxt = new TokenRequestContext(new[] { @`https://database.windows.net/.default` });    //  verified the token is cached (once it's fetched, I can still get it even if I'm offline, but it's quite slow, why?)  var tt = 0d;  var ite = 100;  for(var i = 0; i < ite; i++)  {   var strt = DateTime.Now;   azCred.GetToken(tknCxt );   var end = DateTime.Now;      if(i == 0)   {    continue;   }      var ms = (end - strt).TotalMilliseconds;    Console.WriteLine($`{ms}ms`);   tt += ms;  }   Console.WriteLine($`Avg: {tt / (ite - 1)}ms`);   // 1121.2321ms  // 1235.1955ms  // 1145.8936ms  // 1162.2329ms  // 1160.6176ms  // 1185.211ms  // 1116.9651ms  // 1189.3674ms  // 1197.7054ms  // 1143.5696ms  // 1151.9702ms  // 1080.1868ms  // 1080.4418ms  // 1137.3239ms  // 1105.2013ms  // 1123.577ms  // 1080.0606ms  // 1147.6113ms         // ...  // Avg: 1153.7038383838387ms Environment .NET SDK: Version:   7.0.102 Commit:    4bbdd14480 Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.102\ Host: Version:      7.0.2 Architecture: x64 Commit:       d037e070eb
Client	Storage	[BUG] TableClient.CreateIfNotExistsAsync creates entry for failed request in Application Insights if table already exists	Library name and version Azure.Data.Tables 12.6.1 Describe the bug If I call TableClient.CreateIfNotExistsAsync() for an existing table, a request is sent to create it and the resulting exception is caught and dismissed. Expected behavior The call to the table storage to create the table is not logged by Application Insights as a failed request. Actual behavior The failed call to the table storage should not be logged by Application Insights, because it is expected and dealt with. At least, there should be an option to turn on this behavior. Reproduction Steps var tableServiceClient = new TableServiceClient(connectionString); var tableClient = tableServiceClient.GetTableClient(tableName); await tableClient.CreateIfNotExistsAsync(); Environment Azure App Service, Linux x64, .NET 6
Client	Service Bus	How to enrich Azure Service Bus messages with OpenTelemetry trace data?	Library name and version Azure.Monitor.OpenTelemetry.Exporter 1.0.0-beta.6 Query/Question I am trying to use Azure.Monitor.OpenTelemetry.Exporter to enrich Azure ServiceBus message with OpenTelemetry traces. I assumed that similar to HttpClient and AspNet instrumentation, it silently adds OpenTelemetry trace info to service bus messages and if the message consumer enables OpenTelemetry and installs and configures Azure.Monitor.OpenTelemetry.Exporter, then OpenTelemetry propagation context will be automatically created from the message bus service headers. But I don't see anything like this to be done. I also found an example where correlationId is manually set and parsed by publisher and consumer (https://devkimchi.com/2021/05/19/tracing-end-to-end-data-from-power-apps-to-azure-cosmos-db/). So is there a way to configure Azure ServiceBus message publisher and consumer to a publisher will enrich messages with OpenTelemetry trace metadata and consumer will parse them, or this needs to be implemented using custom code? Environment No response
Client	Storage	[QUERY] Storage: usage assistance	Library name and version Azure.Storage.Blobs 12.14.1 Query/Question I want to get the sum of blobs size between two date range. I want to apply filter on Lastmodified date. Can you please help me on this Environment .Net 6 Visual studio 22
Client	Storage	[QUERY] Potential CVE in Storage Blobs	Library name and version Azure.Storage.Blobs 12.14.1 Query/Question This requires dependencies updating to account for System.Text.Encodings.Web Remote Code Execution (RCE) CVE-2021-26701 CVSS 9.8 (Critical) Snyk scan report shows: Introduced through: › Azure.Storage.Blobs 12.14.1 › System.Text.Json 4.7.2 › System.Text.Encodings.Web 4.7.1 Environment No response
Client	Azure.Identity	[BUG] Authentication logs errors until succeeds in Azure Function	Library name and version Microsoft.Extensions.Azure 1.6.0 Describe the bug Using the dependency injection as described in the official documentation, an Azure Function running in isolated mode works but the authentication logs many errors before continue with normal execution. These are the logs, it starts attempting to authenticate after line 26, then it logs errors until line 243 when it successfully authenticates with Visual Studio and finally continues the execution in line 261. This is a sample project (branch debugging-di-errors) that can be used to validate the incorrect behavior. This does not happen when creating the client normally using DefaultAzureCredential: var client = new EventGridPublisherClient(new Uri(`https://evgt-pocif-dev-bs2-1.brazilsouth-1.eventgrid.azure.net/api/events`), new DefaultAzureCredential()); Expected behavior No error logging Actual behavior Error logging Reproduction Steps Create an Azure Event Grid resource and execute the following project in the branch debugging-di-errors Environment WindowsX64 VisualStudio 2022 17.4.4 dotnet --info .NET SDK: Version:   7.0.102 Commit:    4bbdd14480 Runtime Environment: OS Name:     Windows OS Version:  10.0.19045 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.102\ Host: Version:      7.0.2 Architecture: x64 Commit:       d037e070eb .NET SDKs installed: 7.0.102 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Other architectures found: x86   [C:\Program Files (x86)\dotnet] registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation] Environment variables: Not set global.json file: Not found Learn more: https://aka.ms/dotnet/info Download .NET: https://aka.ms/dotnet/download
Client	Service Bus	[BUG] Azure.Messaging.ServiceBus SendMessage MessageSizeExeeded in Azure - Regression	Library name and version Azure.Messaging.ServiceBus v7.12.0 Describe the bug When sending batches of messages that are relatively small (sub 1k), to a standard SKU Service Bus, with the following trivialized implementation: private ServiceBusSender _sender;  public async Task EnqueueBatchAsync<T>(List<T> messages, string correlationId) {  var count = 0;   while (count < messages.Count)  {   using var messageBatch = await _sender.CreateMessageBatchAsync();    while (count < messages.Count)   {    var message = messages[count];    var serializedMessage = JsonConvert.SerializeObject(message);     var serviceBusMessage = new ServiceBusMessage(serializedMessage)    {     ContentType = `application/json`,     MessageId = Guid.NewGuid().ToString(),     CorrelationId = correlationId    };        if (messageBatch.TryAddMessage(serviceBusMessage))    {     count++;     continue;    }    else    {     break;    }   }    await _sender.SendMessagesAsync(messageBatch);  } } even though the TryAddMessage attempt fails as expected before the batch is full, the batch fails to send with the following error message:  {`The message (id:15939002, size:265268 bytes) is larger than is currently allowed (262144 bytes). (MessageSizeExceeded). For troubleshooting information, see https://aka.ms/azsdk/net/servicebus/exceptions/troubleshoot.`}  This appears to be a regression of #19053 and downgrading from 7.12.0 to 7.11.1 fixes the issue. Expected behavior All metadata associated with the message should be included in the size calculation of TryAddMessage, ensuring that the batch can be sent. Actual behavior The total size is inaccurate, resulting in the batch not being sent. Reproduction Steps See above. Environment .NET 7 on Windows 10.
Client	Azure.Identity	[BUG] NullReferenceException when trying to authenticate KeyVault with TokenCredential	Library name and version Azure.Identity 1.8.1 + Azure.Security.KeyVault.Secrets 4.4.0 Describe the bug For context, I'm upgrading a Net Framework project to Net Core. This was previously running on Net Framework 4.8 in a TeamCity Windows Agent. It worked fine. I'm now targeting Net 7.0, and running in an Ubuntu Azure Pipeline agent. When retrieving a secret from KeyVault, and using a token Credential, I get the following NullReferenceException. However, if I run the same code on my machine (Windows 10), still using Net 7.0, it succeeds without any errors. In the stacktrace I can see this method being called, which seems wrong for an Ubuntu environment: DesktopOsHelper.GetWindowsVersionStringInternal()  Expected behavior The TokenCredential successfully retrieves a token, and KeyVault successfully authenticates, and I can retrieve the secret. Actual behavior NullReferenceException Azure.Identity.AuthenticationFailedException : ClientSecretCredential authentication failed: Object reference not set to an instance of an object   ----> System.NullReferenceException : Object reference not set to an instance of an object   Stack Trace:     at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow (System.Exception ex, System.String additionalMessage) [0x0001d] in <5230301ad3cd43c9a86f43eebe9aafe0>:0    at Azure.Identity.ClientSecretCredential.GetTokenAsync (Azure.Core.TokenRequestContext requestContext, System.Threading.CancellationToken cancellationToken) [0x000f5] in <5230301ad3cd43c9a86f43eebe9aafe0>:0    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+AccessTokenCache.GetHeaderValueFromCredentialAsync (Azure.Core.TokenRequestContext context, System.Boolean async, System.Threading.CancellationToken cancellationToken) [0x00092] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+AccessTokenCache.GetHeaderValueAsync (Azure.Core.HttpMessage message, Azure.Core.TokenRequestContext context, System.Boolean async) [0x0024f] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+AccessTokenCache.GetHeaderValueAsync (Azure.Core.HttpMessage message, Azure.Core.TokenRequestContext context, System.Boolean async) [0x003d0] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AuthenticateAndAuthorizeRequestAsync (Azure.Core.HttpMessage message, Azure.Core.TokenRequestContext context) [0x00082] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.AuthorizeRequestOnChallengeAsyncInternal (Azure.Core.HttpMessage message, System.Boolean async) [0x0026e] in <31557f31bf2346a09473c55e0ca82624>:0    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.ProcessAsync (Azure.Core.HttpMessage message, System.ReadOnlyMemory`1[T] pipeline, System.Boolean async) [0x0020e] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync (Azure.Core.HttpMessage message, System.ReadOnlyMemory`1[T] pipeline, System.Boolean async) [0x00090] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync (Azure.Core.HttpMessage message, System.ReadOnlyMemory`1[T] pipeline, System.Boolean async) [0x000b4] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync (Azure.Core.HttpMessage message, System.ReadOnlyMemory`1[T] pipeline, System.Boolean async) [0x00193] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync (Azure.Core.Request request, System.Threading.CancellationToken cancellationToken) [0x00093] in <dd68d57399de49deadd83c824627140d>:0    at Azure.Security.KeyVault.KeyVaultPipeline.SendRequestAsync (Azure.Core.Request request, System.Threading.CancellationToken cancellationToken) [0x0008e] in <31557f31bf2346a09473c55e0ca82624>:0    at Azure.Security.KeyVault.KeyVaultPipeline.SendRequestAsync[TResult] (Azure.Core.RequestMethod method, System.Func`1[TResult] resultFactory, System.Threading.CancellationToken cancellationToken, System.String[] path) [0x0009a] in <31557f31bf2346a09473c55e0ca82624>:0    at Azure.Security.KeyVault.Secrets.SecretClient.GetSecretAsync (System.String name, System.String version, System.Threading.CancellationToken cancellationToken) [0x00147] in <31557f31bf2346a09473c55e0ca82624>:0   --NullReferenceException   at Microsoft.Identity.Client.PlatformsCommon.Shared.DesktopOsHelper.GetWindowsVersionStringInternal () [0x0000f] in <5be217ef2a73444996a0399f2ee5f541>:0    at Microsoft.Identity.Client.PlatformsCommon.Shared.DesktopOsHelper+<>c.<.cctor>b__15_1 () [0x00000] in <5be217ef2a73444996a0399f2ee5f541>:0    at System.Lazy`1[T].ViaFactory (System.Threading.LazyThreadSafetyMode mode) [0x00049] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at System.Lazy`1[T].ExecutionAndPublication (System.LazyHelper executionAndPublication, System.Boolean useDefaultConstructor) [0x00030] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at System.Lazy`1[T].CreateValue () [0x0008c] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at System.Lazy`1[T].get_Value () [0x00018] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at Microsoft.Identity.Client.PlatformsCommon.Shared.DesktopOsHelper.GetWindowsVersionString () [0x00000] in <5be217ef2a73444996a0399f2ee5f541>:0    at Microsoft.Identity.Client.Platforms.net45.NetDesktopPlatformProxy.InternalGetOperatingSystem () [0x00000] in <5be217ef2a73444996a0399f2ee5f541>:0    at System.Lazy`1[T].ViaFactory (System.Threading.LazyThreadSafetyMode mode) [0x00049] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at System.Lazy`1[T].ExecutionAndPublication (System.LazyHelper executionAndPublication, System.Boolean useDefaultConstructor) [0x00030] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at System.Lazy`1[T].CreateValue () [0x0008c] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at System.Lazy`1[T].get_Value () [0x00018] in <12b418a7818c4ca0893feeaaf67f1e7f>:0    at Microsoft.Identity.Client.PlatformsCommon.Shared.AbstractPlatformProxy.GetOperatingSystem () [0x00000] in <5be217ef2a73444996a0399f2ee5f541>:0    at Microsoft.Identity.Client.Internal.MsalIdHelper.GetMsalIdParameters (Microsoft.Identity.Client.Core.ILoggerAdapter logger) [0x00057] in <5be217ef2a73444996a0399f2ee5f541>:0    at Microsoft.Identity.Client.Internal.Logger.LoggerHelper+<>c.<.cctor>b__16_4 () [0x00000] in <5be217ef2a73444996a0399f2ee5f541>:0    at System.Lazy`1[T].ViaFactory (System.Threading.LazyThreadSafetyMode mode) [0x0001f] in <12b418a7818c4ca0893feeaaf67f1e7f>:0  Reproduction Steps var keyVaultClient = new SecretClient(new Uri(`SomeKeyVaultUri`), new ClientSecretCredential(tenantId, clientId, clientSecret));  var secretResponse = await keyVaultClient.GetSecretAsync(`MySecret`); Environment Azure DevOps Pipeline Agent - Ubuntu - NET 7.0 OS is: Unix 5.15.0.1031 Runtime is: Mono 6.8.0.105 (Debian 6.8.0.105+dfsg-2 Wed Feb 26 23:23:50 UTC 2020)
Client	KeyVault	[BUG] Cannot resolve KeyVault hostname	Library name and version Azure.Core 1.27.0 Describe the bug I am running an availability test every 5 minutes on my application. The test call first the keyvault and never encounter issue connecting to the keyvault, but then transiently and quite often my application does retun me the error pasted later. which essentially tells me it can't resolve the host name of my keyavult. The error on the application also happen independently from the test without accessing first to the keyvault. I added the env information below as well as the whole thing is inside a private network. Could you help ? Expected behavior The application should be able to resolve the keyvault hostname Actual behavior {`ExceptionMessage`:`Retry failed after 4 tries. Retry settings can be adjusted in ClientOptions.Retry.`,`ExceptionHResult`:`-2146233088`,`ExceptionSource`:`Azure.Core`,`ExceptionStackTrace`:`   at Azure.Core.Pipeline.RetryPolicy.d__11.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Azure.Core.Pipeline.RetryPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipeline.Send(HttpMessage message, CancellationToken cancellationToken)\r\n   at Azure.Core.Pipeline.HttpPipeline.SendRequest(Request request, CancellationToken cancellationToken)\r\n   at Azure.Security.KeyVault.KeyVaultPipeline.SendRequest(Request request, CancellationToken cancellationToken)\r\n   at Azure.Security.KeyVault.KeyVaultPipeline.SendRequest[TResult](RequestMethod method, Func1 resultFactory, CancellationToken cancellationToken, String[] path)\r\n   at Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient.GetKey(CancellationToken cancellationToken)\r\n   at Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient.Initialize(String operation, CancellationToken cancellationToken)\r\n   at Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient.Decrypt(DecryptParameters decryptParameters, CancellationToken cancellationToken)\r\n   at Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient.Decrypt(EncryptionAlgorithm algorithm, Byte[] ciphertext, CancellationToken cancellationToken)\r\n   at Securibox_Connectors.Base.Crypto.AzureKeyVault.AzureKeyVaultCryptoClient.DecryptFromBase64(String input) in D:\a\1\s\Securibox-Connectors.Base.Crypto.AzureKeyVault\AzureKeyVaultCryptoClient.cs:line 118\r\n   at SecuriboxCloudAgents.AgentRole.WorkerRole.b__27_5(EntityQueueMessage message, ActivityReporter reporter) in D:\a\1\s\SecuriboxCloudAgents.AgentRole\WorkerRole.cs:line 322`,`ExceptionType`:`System.AggregateException`,`ExceptionTargetSite`:`Void MoveNext()`,`AggregateException_InnerException_ExceptionMessage`:`The remote name could not be resolved: 'sca-test0-dev.vault.azure.net'`,`AggregateException_InnerException_ExceptionHResult`:`-2146233088`,`AggregateException_InnerException_ExceptionSource`:`Azure.Core`,`AggregateException_InnerException_ExceptionStackTrace`:`   at Azure.Core.Pipeline.HttpWebRequestTransport.d__8.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Azure.Core.Pipeline.HttpWebRequestTransport.Process(HttpMessage message)\r\n   at Azure.Core.Pipeline.HttpPipelineTransportPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.RequestActivityPolicy.ProcessNextAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async)\r\n   at Azure.Core.Pipeline.RequestActivityPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.ResponseBodyPolicy.<ProcessAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Azure.Core.Pipeline.ResponseBodyPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.LoggingPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.<ProcessAsync>d__11.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.RedirectPolicy.<ProcessAsync>d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Azure.Core.Pipeline.RedirectPolicy.Process(HttpMessage message, ReadOnlyMemory1 pipeline)\r\n   at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)\r\n   at Azure.Core.Pipeline.RetryPolicy.d__11.MoveNext()`,`AggregateException_InnerException_ExceptionType`:`Azure.RequestFailedException`,`AggregateException_InnerException_ExceptionTargetSite`:`Void MoveNext()`,`AggregateException_InnerException_RequestFailedException_InnerException_ExceptionMessage`:`The remote name could not be resolved: 'sca-test0-dev.vault.azure.net'`,`AggregateException_InnerException_RequestFailedException_InnerException_ExceptionHResult`:`-2146233079`,`AggregateException_InnerException_RequestFailedException_InnerException_ExceptionSource`:`System`,`AggregateException_InnerException_RequestFailedException_InnerException_ExceptionStackTrace`:`   at System.Net.HttpWebRequest.GetResponse()\r\n   at Azure.Core.Pipeline.HttpWebRequestTransport.d__8.MoveNext()`,`AggregateException_InnerException_RequestFailedException_InnerException_ExceptionType`:`System.Net.WebException`,`AggregateException_InnerException_RequestFailedException_InnerException_ExceptionTargetSite`:`System.Net.WebResponse GetResponse()`,`EntityQueueMessage_FullType`:`Securibox_Connectors.Base.IQueue.EntityQueueMessage`,`EntityQueueMessage_Id`:`19050`,`EntityQueueMessage_EntityName`:`Account`,`EntityQueueMessage_DeliveryHandler`:`Default`,`EntityQueueMessage_DeliveryCount`:`1`} Reproduction Steps         _keyVaultClient = new KeyClient(new Uri(_vaultUri), new ClientSecretCredential(_tenantId, _authClientId, _authClientSecret));          var cryptoClient = _keyVaultClient.GetCryptographyClient(_keyName, _keyVersion);         var decrypted = cryptoClient.Decrypt(EncryptionAlgorithm.RsaOaep, dataBytes);  Environment The test is  written in .net6 using Azure.Security.KeyVault.Certificates 4.4.0 running in an isolated function integrated in my VNet with Route All enabled with a dedicated subnet hosted in a app service plan S1 My application is written in .net framework 4.8 using Azure.Security.KeyVault.Keys 4.4.0 running in a cloud service extended having a dedicated distinct subnet in the same VNet hosted on windows server 2022 My keyVault is called first by the test , then by the application. sku standard disable public access with an approved private endpoint to the same VNet via another distinct subent shared with other component also using private link (SQl server, Service bus , Storage, app insight)
Client	Data Lake Storage Gen2	[BUG] ErrorCode: InvalidQueryParameterValue	Library name and version Azure.Storage.Files.DataLake 12.12.1 Describe the bug Trying to load a file from Data Lake : var fileSystemClient = new DataLakeFileSystemClient(         new Uri(this.configuration.GetDataLakeBaseUrl()),         this.GetSharedKeyCredentials()); var directoryClient = fileSystemClient.GetDirectoryClient(directoryName); ... var fileClient= directoryClient.GetFileClient(fileName))) var downloadResponse = await fileClient.ReadAsync(); ...  Like described here : https://learn.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-directory-file-acl-dotnet#download-from-a-directory Directory and File exist on Azure. I double checked the account key and we seem to be authorized but we get the following error: Value for one of the query parameters specified in the request URI is invalid. RequestId:fa87970f-b01e-003e-540a-2c4808000000 Time:2023-01-19T13:30:55.2058024Z Status: 400 (Value for one of the query parameters specified in the request URI is invalid.) ErrorCode: InvalidQueryParameterValue  Additional Information: QueryParameterName: comp QueryParameterValue:  Reason:   Content: <?xml version=`1.0` encoding=`utf-8`?><Error><Code>InvalidQueryParameterValue</Code><Message>Value for one of the query parameters specified in the request URI is invalid. RequestId:fa87970f-b01e-003e-540a-2c4808000000 Time:2023-01-19T13:30:55.2058024Z</Message><QueryParameterName>comp</QueryParameterName><QueryParameterValue /><Reason /></Error>  Headers: Server: Microsoft-HTTPAPI/2.0 x-ms-request-id: fa87970f-b01e-003e-540a-2c4808000000 x-ms-client-request-id: 61e83173-d45d-498f-9506-d2e549e05ab2 x-ms-error-code: InvalidQueryParameterValue Date: Thu, 19 Jan 2023 13:30:55 GMT Content-Length: 351 Content-Type: application/xml  Expected behavior 200 OK Actual behavior 400 Bad Request Reproduction Steps  Create Data Lake Storage Account Create Directory Create File Download File via Code as described above  Environment .NET SDK: Version:   7.0.101 Commit:    bb24aafa11 Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.101\ Host: Version:      7.0.1 Architecture: x64 Commit:       97203d38ba .NET SDKs installed: 3.1.406 [C:\Program Files\dotnet\sdk] 3.1.426 [C:\Program Files\dotnet\sdk] 6.0.401 [C:\Program Files\dotnet\sdk] 6.0.405 [C:\Program Files\dotnet\sdk] 7.0.101 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 7.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 7.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.12 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 7.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Azure.Identity	[QUERY] How to use InteractiveBrowserCredential with Azure AD B2C User Flows	Library name and version Azure.Identity 1.8.1 Query/Question Is it possible to use InteractiveBrowserCredential with Azure AD B2C User Flows? This is the code i'm using at the moment: var options = new InteractiveBrowserCredentialOptions {     RedirectUri = new Uri(`http://localhost:5678`) }; var identity = new InteractiveBrowserCredential(`mytenant.onmicrosoft.com`, `myClientId`, options); var tokenRequestContext = new TokenRequestContext(new[] { `myScope` }); var tokenResponse = await identity.GetTokenAsync(tokenRequestContext); However, I see no way to define for e.g. the SignUpSignInPolicyId. When calling GetTokenAsync, I get the standard AD login screen - as expected. Is it somehow possible to define the Policies needed for ADB2C authentication? Thank your for your help! Environment .NET 7 Visual Studio 17.5.0
Client	Service Bus	[BUG] ASP.NET 4.7, ServiceBusProcessor.StartProcessingAsync() crashes website (The process was terminated due to an internal error in the .NET Runtime)	Library name and version Azure.Messaging.ServiceBus 7.12.0 Describe the bug We want to integrate ServiceBus into our old ASP.NET 4.7 MVC application. We do not consider upgrading to the newest .NET because of effort considerations. The most straightforward integration crashes our application. The same code works for a console application. We get The process was terminated due to an internal error in the .NET Runtime. link to a repository where you can test it. Here's a sample code:             var fullyQualifiedNamespace = `qcash-concert2-test.servicebus.windows.net`;             var queueName = `TestQueue`;             var credentials = new DefaultAzureCredential(new DefaultAzureCredentialOptions()             {                 ExcludeAzureCliCredential = false,                 ExcludeEnvironmentCredential = false,                 ExcludeManagedIdentityCredential = false,                 ExcludeSharedTokenCacheCredential = false,                 ExcludeInteractiveBrowserCredential = true,                 ExcludeVisualStudioCodeCredential = false,                 ExcludeVisualStudioCredential = false,             });              var serviceBusClient = new ServiceBusClient(fullyQualifiedNamespace, credentials, new ServiceBusClientOptions             {                 RetryOptions = new ServiceBusRetryOptions                 {                     MaxRetries = 5,    //The maximum number of retry attempts before giving up                     Mode = ServiceBusRetryMode.Exponential,        //The approach to use for calculating retry delays                     MaxDelay = TimeSpan.FromMilliseconds(90000)                 }             });              var administartionClient = new ServiceBusAdministrationClient(fullyQualifiedNamespace, credentials);              if (await administartionClient.QueueExistsAsync(queueName, CancellationToken.None) == false)             {                 var queueOptions = new CreateQueueOptions(queueName)                 {                     DeadLetteringOnMessageExpiration = true,                     EnableBatchedOperations = true,                     EnablePartitioning = false,                     MaxSizeInMegabytes = 1024,                     RequiresDuplicateDetection = false,                     RequiresSession = false,                 };                  queueOptions.AutoDeleteOnIdle = TimeSpan.FromMinutes(60);                  _ = await administartionClient.CreateQueueAsync(queueOptions, CancellationToken.None);             }              var processor = serviceBusClient.CreateProcessor(queueName, new ServiceBusProcessorOptions()             {                 AutoCompleteMessages = true,                 MaxConcurrentCalls = Environment.ProcessorCount,                 PrefetchCount = Environment.ProcessorCount * 100,                 ReceiveMode = ServiceBusReceiveMode.ReceiveAndDelete             });              processor.ProcessMessageAsync += (args) =>             {                 return Task.Run(() =>                 {                     Thread.Sleep(1000);                 });             };              processor.ProcessErrorAsync += OnMessageProcessingException;             await processor.StartProcessingAsync(CancellationToken.None);              await Task.Run(() =>             {                 Thread.Sleep(5 * 1000);             });  Logs from Event Viewer Application: iisexpress.exe Framework Version: v4.0.30319 Description: The process was terminated due to an internal error in the .NET Runtime at IP 00007FFC367F3D99 (00007FFC367F0000) with exit code 80131506.  Faulting application name: iisexpress.exe, version: 10.0.25095.1000, time stamp: 0x7d00e3ab Faulting module name: clr.dll, version: 4.8.4515.0, time stamp: 0x624ce98e Exception code: 0xc0000005 Fault offset: 0x0000000000003d99 Faulting process id: 0xc584 Faulting application start time: 0x01d929d2fecf87d7 Faulting application path: C:\Program Files\IIS Express\iisexpress.exe Faulting module path: C:\Windows\Microsoft.NET\Framework64\v4.0.30319\clr.dll Report Id: 137ef970-d27f-4f0b-b506-0f4879426b6d Faulting package full name:  Faulting package-relative application ID:   Expected behavior The website doesn't crash Actual behavior The website crashes Reproduction Steps  Clone repository Start web application. It's an asp.net MVC template application. Open the Contact tab  Environment .NET SDK (reflecting any global.json): Version:   6.0.401 Commit:    0906eae6f8 Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.401\ global.json file: Not found Host: Version:      6.0.13 Architecture: x64 Commit:       1af80ba017 .NET SDKs installed: 5.0.301 [C:\Program Files\dotnet\sdk] 5.0.408 [C:\Program Files\dotnet\sdk] 6.0.101 [C:\Program Files\dotnet\sdk] 6.0.113 [C:\Program Files\dotnet\sdk] 6.0.308 [C:\Program Files\dotnet\sdk] 6.0.401 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.32 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] VS 2022 Version 17.3.5
Client	Communication	Status of Azure.Communication.Email	Library name and version Azure.Communication.Email 1.0.0-beta.1 Query/Question Using this sdk looks a lot less compilcated then using MS Graph to send mail from my Azure Functions and other .net projects.  However, I'm a bit concerned as it appears nothing has happened with the git repository since May 2022.  Will this sdk ever be released? Thanks, Duane Environment Azure functions, .net 6, Blazor, iOS/SwiftUI
Client	Communication	[FEATURE REQ] Interface for Azure.Communication.Email.EmailClient	Library name Azure.Communication.Email Please describe the feature. Please provide an interface for the class Azure.Communication.Email.EmailClient. Suggestion: IEmailClient. This would help consuming applications make dependency injection easier and allow for more straightforward swaps of email clients such as for unit testing.
Client	Storage	[QUERY] Does QueueClient.SendMessage API perform internal retries	Library name and version Azure.Storage.Queues v12.12.0 Query/Question We had previously been using the old WindowsAzure.Storage SDK for using Azure Storage Queues. We are currently in the process of migrating to use the new SDK with the Azure.Storage.Queues v12.12.0 library. Previously, we had used the CloudQueue.AddMessage API to add messages to Azure Storage Queues, using QueueRequestOptions  to specify an exponential backoff policy for retrying this request. In the new SDK, we see the QueueClient.SendMessage API which does not appear to have any way to specify request options like with QueueRequestOptions class previously. We have 2 main questions:  Does QueueClient.SendMessage have any internal retries configured by default? Is there any way to specify request options for QueueClient.SendMessage?  Environment No response
Mgmt	Network	[QUERY] Where do GroupIds for PrivateLinkServiceConnection come from?	Library name and version Microsoft.Azure.Management.Network.Models 0.28.0-preview Query/Question I'm trying to deploy a PrivateEndpoint (from the namespace Microsoft.Azure.Management.Network.Models) to Azure Portal using C#. It will be connected to an Azure Monitor Private Link Scope (AMPLS), which is connected to a Log Analytics Workspace. The PrivateEndpoint class contains a required attribute IList groupIds (hierarchy shown below). I currently have the groupIds I need hardcoded in, and I would like to know where this value should come from so that it can be determined at runtime. I originally thought it might come from the AMPLS, but that class doesn't seem to contain a groupIds attribute. var privateEndpoint = new PrivateEndpoint( ... privateLinkServiceConnections: new List<PrivateLinkServiceConnection>() { new PrivateLinkServiceConnection( ... groupIds: new List<string>() { `azuremonitor` }) }); Environment Visual Studio 2022 netcoreapp6.0 C# Web Api Microsoft.Azure.Management.Network.Models 0.28.0-preview
Mgmt	ARM	[BUG] Deserializing ManagedServiceIdentity in GetGenericResourcesAsync	Library name and version Azure.ResourceManager v1.3.2 Describe the bug Calling the function GetGenericResourcesAsync on Subscription, the sdk deserializing ManagedServiceIdentity object and throws FormatException When doing the call `await subscription.GetGenericResourcesAsync()` an exception is throwing with Message: System.Text.Json.JsonException : The JSON value could not be converted to Azure.ResourceManager.Models.ManagedServiceIdentity. Path: $ | LineNumber: 0 | BytePositionInLine: 46 Exception type: System.FormatException Failed method: Azure.ResourceManager.Models.ManagedServiceIdentity.DeserializeManagedServiceIdentity This happen as of now only in Microsoft.DevTestLab/labs generic resource with api-version 2018-10-15-preview In the api-version 2018-09-15 of Microsoft.DevTestLab/labs the property identity is not returned at all. Expected behavior The call `await subscription.GetGenericResourcesAsync()` is not throwing FormatException Actual behavior The GetGenericResource method throws System.FormatException: The JSON value could not be converted to Azure.ResourceManager.Models.ManagedServiceIdentity. Reproduction Steps Unfortunately we cannot reproduce this behavior with new resources. Environment No response
Client	Event Hubs	[FEATURE REQ] Make EventData.SystemProperties with public set	Library name Azure.Messaging.EventHubs.EventData Please describe the feature. Cannot mock EventData.SystemProperties for unit test as it does not have a public set. It seems that there was an opened issue for that Azure/azure-event-hubs-dotnet#24 which has been fixed on Microsoft.Azure but now the latest SDK uses Azure.Messaging.EventHubs.EventData Please fix this to be able to create unit tests
Client	Search	[QUERY] Azure Search Service Distinct keyword	Library name and version Azure.Search.Documents 11.3.0 Query/Question Is there a way to get distinct results in results of document operations of a Azure Search Service? This question is for multiple APIs such as Search/SearchAsync, Suggest/SuggestAsync. Environment No response
Client	Azure.Identity	[BUG] Intermittent 'Authentication failed: Response was not set, make sure SendAsync' was called when authenticating	Library name and version Azure.ResourceManager 1.3.1 Describe the bug We are observing an 'Authentication failed: Response was not set, make sure SendAsync' was called when attempting to authenticate with Azure. We first starting noticing this error on 2023-01-04 (it was authenticating without error previously). Call Stack: at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage) at Azure.Identity.InteractiveBrowserCredential.d__39.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.InteractiveBrowserCredential.d__36.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Identity.InteractiveBrowserCredential.d__34.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult() t Kelverion.RunbookStudio.Cloud.Client.AutomationClientFactory.d__4.MoveNext() Expected behavior Should authenticate without error. Actual behavior Authentication fails with InvalidOperationException ''InteractiveBrowserCredential authentication failed: Response was not set, make sure SendAsync' exception. Reproduction Steps var options = new InteractiveBrowserCredentialOptions { ... } var credential = new InteractiveBrowserCredential(options); await credential.AuthenticateAsync(); Environment .NET Framework 4.8.1 Windows 10
Client	Functions	Service Bus Queue Trigger Retry Policy Not Working as expected	Hi Team, We are trying to retry 3 times on SB Queue failure . Here I followed as per this document : microsoft document `extensions`: { `serviceBus`: { `clientRetryOptions`:{ `mode`: `exponential`, `tryTimeout`: `00:01:00`, `delay`: `00:00:00.80`, `maxDelay`: `00:01:00`, `maxRetries`: 3 },         `autoCompleteMessages`: true          } }  I Configured in host.json file But still it is not working. --Please provide suggestion here Where as if we configured  like this it is working : [ExponentialBackoffRetry(5, `00:00:04`, `00:01:00`)] here problem is these values need to be configured at compile time means it can not be taken from config and want to know at what retry number it succeed for both configuration -- Please provide suggestion here For example I configured in azure portal queue deliver count : 2 Max Retry count =3 Now at first deliver count  : 1 and it succeeded at 3 retry now total count is 4 (default try + configured retry count) Now at second deliver count  : 2 and it succeeded at 2 retry now total count is 3 Now total  run to success processing is : first deliver count + first total retry is (3) +second delivery count+second retry current count (2) =7 (for above iteration) Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.8.1 version we are using. What to know at what iteration it succeeded. For example I configured in azure portal queue deliver count : 2 Max Retry count =3 Now at first deliver count  : 1 and it succeeded at 3 retry now total count is 4 Now at second deliver count  : 2 and it succeeded at 2 retry now total count is 3 Now total  run to success processing is : first deliver count + first total retry is (3) +second delivery count+second retry current count (2) =7 (for above iteration) PFB Sample application sampleapp.zip
Client	Azure.Identity	Token for Storage Account- Managed Identity	Library name and version Azure.Identity Version=1.5.0.0 Query/Question We are looking for an option to a get new token for each request. Currently, if a token is issued and there are any further requests to get token till the time first token is valid, we are getting the same token that was issued earlier.  var authResult = new DefaultAzureCredential(true).GetToken(new TokenRequestContext(             new[] { `https://storage.azure.com/.default` }));    We are using below Azure.Identity Version=1.5.0.0 Microsoft.Azure.Storage.Common, Version=11.2.3.0 Environment No response
Client	Azure.Identity	[QUERY] Which (ip)addresses to whitelist for ClientSecretCredential (and ConfidentialClientApplicationBuilder)	Library name and version Azure.Identity 1.8.0 Query/Question Within a big company we are using the Azure.Identity and Microsoft Identity classes to authenticate towards Azure using a client secret. Company policy restricts outgoing network traffic (using a firewall) on the machines that use these libraries. We would like to know which internet addresses the library (tries) to access to perform the authentication so that these (ip) addresses can be whitelisted. Currently we are using these two calls the Azure Identity and Microsoft Identity library which result in connection issues due to firewall restrictions. Azure Identity  new ClientSecretCredential(tenantId, clientId, clientSecret, new TokenCredentialOptions()); Microsoft Identity string authority = $`https://login.microsoftonline.com/{tenantId}/`; IConfidentialClientApplication app = ConfidentialClientApplicationBuilder   .Create(clientId)   .WithClientSecret(clientSecret)   .WithAuthority(authority)   .Build();  AuthenticationResult result = await app.AcquireTokenForClient(scopes).ExecuteAsync();  Environment Windows Server 2019 .NET Framework 4.7.2
Client	Search	[QUERY] Azure Search Index Alias	Library name and version Azure.Search.Documents 11.3.0 Query/Question Recently I came across this article which mentioned that we can create an Index Alias and use it to query documents. Alias is very helpful to avoid downtime when we have to change Index definition and to do that we need to drop and recreate index. https://learn.microsoft.com/en-us/azure/search/search-how-to-alias?tabs=rest However, this Index Alias feature is only available in Public Preview and can only be used by REST API using api-version 2021-04-30-preview. We are using Azure.Search.Documents NuGet Package and there is no option to use this api-version in it and hence to use Index Alias for our document operations. So it would be great if there was an option in this NuGet package/SDK to use this api-version while connecting to a Search Service Client. Additionally, I also wanted to know if we can use this feature of Index Alias in our sites like any other feature or not, what SLAs or restrictions are and so on. Environment No response
Client	Azure.Identity	[QUERY] Can I use Azure.Identity with WindowsAzure.Storage?	Library name and version Azure Identity 1.8.0 Query/Question I wonder if it's reliable to use an access token retrieved by Azure.Identity with the old Azure Storage client (CloudStorageAccount found in package WindowsAzure.Storage). In the migration guidance for App Authentication -> Azure Identity, it says:  If you have an existing application that uses AppAuthentication and want to use Azure.Identity, the preferred path is to update your application to use the new Azure client SDKs that support accepting TokenCredentials.  We have a huge application and upgrading Azure Identity and Azure Storage client SDK at the same time would be a too big risk, so I'm looking for alternative migration paths where it can be done more incrementally. I have written a small test application which retrieve an authentication token using Azure Identity and it seems to work fine to pass it to WindowsAzure.Storage client. I create an access token using Azure.Identity like this: static async Task<AccessToken> GetAccessToken() {    var resourceId = `https://storage.azure.com/`;     // Request access token via interactive browser    var browserCredential = new InteractiveBrowserCredential();    var accessToken = await browserCredential.GetTokenAsync(       new TokenRequestContext(scopes: new string[] { resourceId + `/.default` }) { }    );     return accessToken; }  ... and then I pass it into the Azure Storage client, roughly like this:  var accessToken = await GetAccessToken();  var tokenCredential = new TokenCredential(accessToken.Token, RenewToken, null, (accessToken.ExpiresOn - DateTimeOffset.UtcNow).Add(-TimeSpan.FromMinutes(5)));   var storageCredentials = new StorageCredentials(tokenCredential);  var account = new CloudStorageAccount(storageCredentials, `<my-storage-account>`, `core.windows.net`, true);  It looks like it's working fine. The token is retireved, I can access storage resources and the token is renewed properly before expiration. I have run tests both using InteractiveBrowserCredential and ClientCertificateCredential and both seems to be working fine. So what I am wondering is if there's something risky/bad with this approach? One specific concern I have is whether the TokenCredential class in WindowsAzure.Storage is thread safe - can it be passed into multiple instances of StorageCredentials on different threads, or would I need to request a new authentication token every time i create a new CloudStorageAccount (something which would be very very slow)? Looking at the https://github.com/Azure/azure-storage-net/blob/v9.3/Lib/Common/Auth/TokenCredential.cs, it looks like I could create a single TokenCredential at startup and then re-use in multiple ´StorageCredentialspassed toCloudStorageAccounts`, but it does not appear to be documented as thread safe. (I can't imagine that the design was that each thread needs to perform authentication against Azure AD on it's own) Environment .NET Framework 4.8
Service	Cognitive - QnA Maker	Why only 1 answer returns from Custom Question Answering project through Orchestration	Library name and version Azure.AI.Language.Conversations 1.0.0 Query/Question I have Orchestration workflow that contains `Conversational language understanding` and `Custom question answering` projects. After I ask question through the Orchestration, if my top intent is selected from `Custom question answering`, I can see there is property called `Answers` which supposed to be list of answers, however, it always returns only 1 answer versus I can see multiple intents from `Conversational language understanding` if my topIntent is selected with that project. How can I get multiple answers from the `Custom question answering` project through Orchestration? Or will it be available sometime soon? I am using Azure.AI.Language.Conversations 1.0.0 and calling AnalyzeConversation from ConversationAnalysisClient. Environment No response
Client	Service Bus	[QUERY] Azure.Messaging.ServiceBus performance issues ?	Library name and version Azure.Messaging.ServiceBus 7.11.1 Query/Question I'm trying to migrate from Microsoft.Azure.ServiceBus v5.0.0 to Azure.Messaging.ServiceBus v7.11.1, but I'm seeing huge performance drops in my use-case. I'm not sure if I'm doing something wrong or not. I have a service bus instance with ~1500 queues ; ~700 topics, and I need to query once all queues/topics/subscriptions to do some monitoring on a subset of it later. My previous code using ManagementClient looks like this, where I first get all queues, then all topics/subscriptions. private ManagementClient _managementClient = new ManagementClient(`Endpoint=sb://REDACTED.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=REDACTED`);  private async Task<List<string>> DiscoverQueuesAsync(string[] prefixes) {     const int count = 100;      var result = new List<string>();     var skip = 0;     IList<QueueDescription> callReturn;     do     {         callReturn = await _managementClient.GetQueuesAsync(count, skip);         result.AddRange(callReturn             .Where(qd =>prefixes.Any(p => qd.Path.StartsWith($`{p}/`, StringComparison.InvariantCultureIgnoreCase)))             .Select(qd => qd.Path));         skip += count;     } while (callReturn.Any());      return result; }  private async Task<TopicsAndSubscriptions> DiscoverTopicsAndSubscriptions(string[] topicPrefixes, string[] queuePrefixes) {     const int count = 100;      var result = new TopicsAndSubscriptions     {         Subscriptions = new List<Subscription>(),         Topics = new List<string>()     };     var skip = 0;     IList<TopicDescription> currentTopics;     do     {         currentTopics = await _managementClient.GetTopicsAsync(count, skip).ConfigureAwait(false);         foreach (var currentTopic in currentTopics))         {             if (topicPrefixes.Any(prefix => currentTopic.Path.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)))             {                 result.Topics.Add(currentTopic.Path);             }              var subscriptions = await _managementClient.GetSubscriptionsAsync(currentTopic.Path).ConfigureAwait(false);              result.Subscriptions.AddRange(subscriptions                 .Where(s => s.ForwardTo != null && queuePrefixes.Any(prefix => new Uri(s.ForwardTo).AbsolutePath.StartsWith($`/{prefix}/`, StringComparison.OrdinalIgnoreCase)))                 .Select(s => new Subscription(s.TopicPath, s.SubscriptionName, new Uri(s.ForwardTo).AbsolutePath.Substring(1))));         }          skip += count;     } while (currentTopics.Any());      return result; }  After moving to the new Azure.Messaging.ServiceBus package, my code looks like this, so I'm trying to use new Azure Identity (DefaultAzureCredential) with my local account (just in case this changes something). private ServiceBusAdministrationClient _administrationClient = new ServiceBusAdministrationClient(`REDACTED.servicebus.windows.net`, new DefaultAzureCredential(new DefaultAzureCredentialOptions         {             ExcludeManagedIdentityCredential = true         }));  private async Task<List<string>> DiscoverQueuesAsync(string[] prefixes) {     var result = new List<string>();      var pageableQueues = _administrationClient.GetQueuesAsync();     await foreach (var queue in pageableQueues)     {         if (prefixes.Any(p => queue.Name.StartsWith($`{p}/`, StringComparison.InvariantCultureIgnoreCase)))         {             result.Add(queue.Name);         }     }      return result; }  private async Task<TopicsAndSubscriptions> DiscoverTopicsAndSubscriptions(string[] topicPrefixes, string[] queuePrefixes) {     var result = new TopicsAndSubscriptions     {         Subscriptions = new List<Subscription>(),         Topics = new List<string>()     };      var pageableTopics = _administrationClient.GetTopicsAsync();     await foreach (var topic in pageableTopics)     {         if (topicPrefixes.Any(prefix => topic.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)))         {             result.Topics.Add(topic.Name);         }          var subscriptions = _administrationClient.GetSubscriptionsAsync(topic.Name);         await foreach (var subscription in subscriptions)         {             if (subscription.ForwardTo != null &&                  queuePrefixes.Any(prefix => new Uri(subscription.ForwardTo).AbsolutePath.StartsWith($`/{prefix}/`, StringComparison.OrdinalIgnoreCase)))             {                 result.Subscriptions.Add(new Subscription(subscription.TopicName, subscription.SubscriptionName, new Uri(subscription.ForwardTo).AbsolutePath.Substring(1)));             }         }     }      return result; }  Regarding performances when I launch my application:  With Microsoft.Azure.ServiceBus  DiscoverQueues: 4 618ms DiscoverTopicsAndSubscriptions: 18 628ms   With Azure.Messaging.ServiceBus:  DiscoverQueues: 7 792ms DiscoverTopicsAndSubscriptions: 127 779ms    Instead of starting in 23s, my apps needs more than 2 minutes with the new SDK! I tried several times, on different days, but I always see the same performance drop when using the new SDK. I tried to use Benchmark.net to compare performances of the two. But when I do, the 2 SDK have the same performances (about 5s for DiscoverQueues and 17s for DiscoverTopicsAndSubscriptions), it seems like the fact that Benchmark.net does warmup and stuff, the issue is not seen. I then tried to execute the DiscoverQueues + DiscoverTopicsAndSubscriptions methods two times in a row (while creating a new ServiceBusAdministrationClient between the two), but in the same application run: 1st DiscoverQueues: 11 374ms 1st DiscoverTopicsAndSubscriptions: 122 431ms 2nd DiscoverQueues: 7 058ms 2nd DiscoverTopicsAndSubscriptions: 17 235ms It looks like the issue is only present for the first calls, is something cached after? I'm not sure if this is related to the SDK, or if it is related to Service Bus when using an Azure Identity? Let me know if I can provide more things Environment No response
Mgmt	SQL	Cannot update Data Transparent Data Encryption State	Library name and version Azure.ResourceManager.Sql 1.1.0 Describe the bug I am trying to update data transparent data encryption state from C# code. However, i can not update due to NullReferenceException thrown from inside package:  My step is only getting it from azure resource and update state property to enable/disable it. Expected behavior Can enable/disable data encryption Actual behavior Throw NullReferenceException StackTrace: at Azure.ResourceManager.Sql.LogicalDatabaseTransparentDataEncryptionResource.d__16.MoveNext() at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult() Reproduction Steps  Retrieve logicalDatabaseTransparentDataEncryption set state = enable/disable Call  logicalDatabaseTransparentDataEncryptionResource.UpdateAsync with data above: logicalDatabaseTransparentDataEncryption  Environment NET SDK (reflecting any global.json): Version:   6.0.300 Commit:    8473146e7d Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.300\ Host (useful for support): Version: 6.0.5 Commit:  70ae3df4a6 .NET SDKs installed: 2.1.818 [C:\Program Files\dotnet\sdk] 6.0.300 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.5 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Service Bus	[BUG] ProcessSessionMessageEventArgs.ReleaseSession does not work correctly	Library name and version Azure.Messaging.ServiceBus 7.11.1 Describe the bug If you call the ReleaseSession() on multiple threads for the same session (using the ServiceBusSessionProcessor with the MaxConcurrentCallsPerSession > 1) the session does not close and the processor continues to process messages in the current session. Is this expected behavior? Adding a lock solves the problem. Expected behavior The processor will close the current session after processing all already received messages. Actual behavior The processor does not close the session and continues to process messages ignoring the ReleaseSession() call. Reproduction Steps var client = new ServiceBusClient(someConnectionString); var processor = client.CreateSessionProcessor(someQueueName, new ServiceBusSessionProcessorOptions() { MaxConcurrentSessions = 1, MaxConcurrentCallsPerSession = 3, AutoCompleteMessages = false }); processor.ProcessMessageAsync += Processor_ProcessMessageAsync;  ...  async Task Processor_ProcessMessageAsync(ProcessSessionMessageEventArgs arg) {  // lock (someLock) solves the problem  arg.ReleaseSession(); // this call has no effect  await Task.Delay(TimeSpan.FromSeconds(5));  await arg.CompleteMessageAsync(arg.Message); }  Environment No response
Client	Azure.Identity	When is Azure.Identity 1.9.0-beta.2 being released?	Library name and version Azure.Identity 1.9.0-beta.2 Query/Question I've been stuck on Azure Identity 1.6.0 for a while since there is a change in 1.7.0 that broke how MSI retrieval and how the fallback logic works. My scenario is a Developer environment running Visual Studio on an AVD Workstation. I believe that issue is finally fixed in the 1.9.0-beta.2, but it has been sitting in there since early November: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/CHANGELOG.md#190-beta2-unreleased Would really appreciate if beta2 could be released to nuget so I could validate this resolves the issue or file an issue. When should I expect for this to be released? Environment No response
Client	KeyVault	[QUERY] Replacing KeyVaultClient with SecretClient	Library name and version Azure.Security.KeyVault.Secrets Query/Question Hi,  We are using KeyVaultClient(Singleton) and used it to access multiple endpoints like below.  But we are currently migrating to use Azure.Security.KeyVault.Secrets. Looking at the way SecretClient is instantiated, we were supposed to supply endpoint(uri) at the time of instantiation itself and needs to call Defaultcredential(). I do know that I can try to cache a secret client per endpoint, but this raises a bit of complexity in our scenario since the endpoints can be dynamic. Now:  Creating SecretClient everytime we access new endpoint may cause performance regression.  So is there a way of using SecretClient to avoid such a regression? Environment No response
Client	Service Bus	How to set the timeout value of Queue/Topic Client	Library name and version Azure.Messaging.ServiceBus Query/Question When we use the Microsoft.Azure.ServiceBus，Microsoft.Azure.ServiceBus.Management sdk, we can set the timeout value of queue or tipic client, attached the sample code: _logoutDelQueueClient = new QueueClient(config.ServiceBusConnectionString, config.LogoutDelOmcTokenQueueName); _logoutDelQueueClient.OperationTimeout = TimeSpan.FromSeconds(config.ServiceBusOperationTimeout); _omcUserTopicClient = new TopicClient(config.ServiceBusConnectionString, config.OMCUserInfoTopic); _omcUserTopicClient.OperationTimeout = TimeSpan.FromSeconds(config.ServiceBusOperationTimeout); When we use the Azure.Messaging.ServiceBus sdk, we can not find the OperationTimeout properties, could you please help advice is there any way to setup the timeout for Queue/Topic Client based on the Azure.Messaging.ServiceBus sdk? var client = azureClientFactory.CreateClient(`OauthServiceBus`);  adminHelper.CreateQueueIfNotExist(config.DelAllTokensQueueName);  _delAllTokesQueueSender = client.CreateSender(config.DelAllTokensQueueName); adminHelper.CreateTopicIfNotExist(config.OmcTokenTopic);  _omcTokenTopicSender = client.CreateSender(config.OmcTokenTopic);   Environment No response
Client	Extensions	[BUG] Clients registered with `AddAzureClients` are not disposed	Library name and version Microsoft.Extensions.Azure 1.6.0 Describe the bug Not 100% if bug or intended behaviour, but could do with a documentation clarification if not. When using the Azure Client Builder/Factory, the registered clients aren't disposed along with the IServiceProvider. Expected behavior When calling provider.Dispose() in the provided code snippet, I would expect the resolved client instance to be disposed, because the Dependency Injection guidelines specify not to dispose of services resolved from the container manually. Actual behavior The resolved client is left undisposed because the object that actually gets registered with the IServiceCollection is the ClientRegistration object, which doesn't implement IDisposable. Reproduction Steps using Microsoft.Extensions.Azure; using Microsoft.Extensions.DependencyInjection;  public class Program {     public static void Main()     {         var services = new ServiceCollection();         services.AddAzureClients(builder => builder             .AddClient<MyDisposableClient, object>(_ => new MyDisposableClient()).WithName(`TestClient`)         );         var provider = services.BuildServiceProvider();                  var factory = provider.GetRequiredService<IAzureClientFactory<MyDisposableClient>>();                  var client = factory.CreateClient(`TestClient`);         client.Write(`Client created successfully.`);          provider.Dispose(); // <-- Expected dispose message to be printed at this point.         Console.WriteLine(`Provider disposed`);          Console.ReadLine();     }      class MyDisposableClient : IDisposable     {         public void Write(string message) => Console.WriteLine(message);         public void Dispose() => Write(`Client disposed`);     } } Environment IDE: Visual Studio Professional 2022 (64-bit) (17.4.2) .NET SDK:  Version:   7.0.101  Commit:    bb24aafa11  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.22621  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\7.0.101\  Host:   Version:      7.0.1   Architecture: x64   Commit:       97203d38ba
Client	Storage	[FEATURE REQ] Generate SAS Token for Blob directory	Library name Azure.Storage.Blobs Please describe the feature. Creating a sas token for a blob works as following: var container = new BlobContainerClient(connectionString, containerName); container.GetBlobClient(`a/b.txt`).GenerateSasUri(new BlobSasBuilder(BlobSasPermissions.All, DateTimeOffset.UtcNow.AddHours(1))); This does not work for directories like `a/`. According to the docs this should be possible if  i understand it right. Is there currently a way of archiving this? If not, can you  add this capability?
Client	Service Bus	[FEATURE REQ] Self-descriptive custom exception for case with message that is already being cancelled	Library name Azure.Messaging.ServiceBus Please describe the feature. I have small app where some of the messages are scheduled in service bus and there is scenario when some of that messages might be cancelled from scheduling by calling CancelScheduledMessageAsync() method in ServiceBusSender from SDK. And there are few cases when same message in ServiceBus is attempted to cancel from several different places almost simultaneously. One request to cancel is succesfull and another causes the exceptions. It's expected but the problem is when I am trying to catch and handle that exception. As I want to track only this specific cases with simultaneous cancelling of same message. But I am getting general InvalidOperationException and the only place there what can be used for identifying this case is exception's message field (which is sth. like: The scheduled message with SequenceNumber = 125125 is already being cancelled....  But using of exception's message field in catch (...) { ... } is not convenient and not beautifully) Possible solution: It would be nice to have some custom client exception here. As an idea maybe it would be good to throw ServiceBusException here like it is done for case when message was already cancelled but with different value of ServiceBusFailureReason enum for this case. Then it would be possible to do sth. like this:  But with different ServiceBusFailureReason
Client	Communication	[BUG] Communication.Email is impossible to use just with to and cc recipients	Library name and version Azure.Communication.Email_1.0.0-beta.1 Describe the bug In line 35 there is a bug in if condition which make the constructor of EmailRecipients fails if you use just To and Cc. https://github.com/Azure/azure-sdk-for-net/blob/Azure.Communication.Email_1.0.0-beta.1/sdk/communication/Azure.Communication.Email/src/Models/EmailRecipients.cs I saw this is already solved in main branch, please a new release of the package might fix it! Expected behavior Constructor working correctly Actual behavior Exception Reproduction Steps var recipients = new EmailRecipients(to, cc); Environment No response
Client	Event Hubs	Azure Event Hub - How to consume events with EventProcessorClient and save them on Sql Server	Library name and version Azure.Messaging.EventHubs.Processor 5.7.5 Query/Question Hi, reading a response to post on StackOverflow by @jsquire ( https://stackoverflow.com/questions/69133480/azure-event-hub-how-to-consume-events-parallelly-using-the-official-sdk ), I thought I could ask for some help here so I could fix a problem. I have an application in .NET 7, precisely a Worker that should infinitely read events (log in json format) from Azure Event Hub and write them to Sql Server. For the implementation I chose to use the EventProcessorClient, as it has to read from 3 partitions and I can use the Azure Blob Storage for checkpointing. Reading the official documentation and following the examples I wrote the following code: public class LogProcessorBackgroundService : BackgroundService {     // Omit configuration and initialization of objects      private readonly ConcurrentDictionary<Guid, KeyValuePair<DateTime, ClientEvent>> _clientEvents = new();      private readonly ILogger<LogProcessorBackgroundService> _logger;     private readonly IServiceProvider _serviceProvider;      public LogProcessorBackgroundService(ILogger<LogProcessorBackgroundService> logger,         IServiceProvider serviceProvider)     {         Guard.Against.Null(logger);         Guard.Against.Null(serviceProvider);          _logger = logger;         _serviceProvider = serviceProvider;     }      protected override async Task ExecuteAsync(CancellationToken stoppingToken)     {         try         {             var storageClient = new BlobContainerClient(StorageConnectionString, BlobContainerName);              var processor = new EventProcessorClient(                 storageClient, ConsumerGroup, EventHubConnectionString, EventProcessorClientOptions);              processor.ProcessEventAsync += OnProcessEvent;             processor.ProcessErrorAsync += OnProcessError;              await processor.StartProcessingAsync(stoppingToken);         }         catch (TaskCanceledException e)         {             _logger.LogError(e.Demystify(), `Task was canceled`);         }         catch (Exception e)         {             _logger.LogError(e.Demystify(), `An unhandled exception has occurred`);         }     }      private Task OnProcessError(ProcessErrorEventArgs errorEventArgs)     {         _logger.LogError(errorEventArgs.Exception, `OnProcess error`);          return Task.CompletedTask;     }      private async Task OnProcessEvent(ProcessEventArgs eventArgs)     {         try         {             if (eventArgs.Data?.EventBody is null ||                 eventArgs.Data.EventBody.ToString().Contains(Constants.EventType.Failure))                 return;                          var logAudit = JsonSerializer.Deserialize<LogAuditRoot>(eventArgs.Data.EventBody.ToString(),                 SerializerOptions);              var clientEvent = logAudit.ClientEvent;              if (_clientEvents.TryGetValue(clientEvent.ClientId, out var item))             {                 if (item.Key > clientEvent.TimeStamp)                     return;                  _clientEvents.Remove(clientEvent.ClientId, out _);             }              _clientEvents.TryAdd(clientEvent.ClientId,                 new KeyValuePair<DateTime, ClientEvent>(clientEvent.TimeStamp, clientEvent));              if (_clientEvents.Count == 100)             {                 await UpsertDataOnDatabase();                 eventArgs.UpdateCheckpointAsync(eventArgs.CancellationToken);                 _clientEvents.Clear();             }         }         catch (Exception e)         {             _logger.LogError(e, `ProcessEventHandler exception`);         }     }      private async Task UpsertDataOnDatabase()     {         using var scope = _serviceProvider.CreateScope();          var repository = scope.ServiceProvider.GetRequiredService<IRepository>();          _logger.LogInformation(`Count: {Count}`, _clientEvents.Count.ToString());          foreach (var item in _clientEvents)         {            // Some logic to update or insert data into sql server         }          await repository.SaveChangesAsync();     } } As reported by Jesse Squire however the processor '`For each partition owned by the processor, an independent background task works to read events from Event Hubs and dispatch them to your handler.` so I used a ConcurrentDictionary and implemented this logic to checkpoint every certain number of events, but it doesn't work correctly. Could you please help me understand if I'm on the right track or where I'm wrong and tell me what changes to make. Sorry for writing here, but unfortunately on the internet I have not found advanced examples on how to handle it, but only the basic ones. I hope you can help me. Thank you Environment  OS:  Windows 11, Windows Server 2016 Runtime: .NET  7.0.0 Project type: Worker project Database: SqlServer 2016
Mgmt	Media Services	Documentation & examples use deprecrated `windowsazure.mediaservices` & `Microsoft.Azure.Management.Media``	This is honestly pretty frustrating but maybe I'm looking in the wrong places too. I am attempting to migrate from v2 to v3 of the Media Service API but the documentation and code examples use deprecated packages so I have no idea where to begin. windowsazure.mediaservices is deprecated and says to use Microsoft.Azure.Management.Media which is also deprecated and says to use Azure.ResourceManager.Media. The issue with all of this is that I can find no examples of how to use the latest SDK nuget package (Azure.ResourceManager.Media) to connect to & interact with Media Services now. Any guidance would be appreciated.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 82f63abe-8f7d-b896-4826-1d9d335e365b Version Independent ID: 4d137a8f-0e3f-ddc3-237b-2c64927232c3 Content: Azure Media Services SDK for .NET - Azure for .NET Developers Content Source: api/overview/azure/latest/media-services.md Service: mediaservices GitHub Login: @pallavit Microsoft Alias: pallavit
Client	Functions	[BUG] Function App consumes only 8 messages per minute from Service Bus with Sessions Enabled topic	Library name and version Azure.Messaging.ServiceBus Describe the bug After consuming 8 messages from service bus, our function app sits idle for the remainder of the minute and does nothing. It consistently consumes 8 messages per minute and no more, despite there being hundreds of messages on the subscription  containing hundreds of different SessionIds. This appears related to the 'MaxConcurrentSessions' configuration which defaults to 8. This configuration seems to be ignored in the host.json, but when setting it in the functions app settings we saw a brief improvement (64 messages per minute when the configuration was set to 64), and then a reduction back to 8 after half an hour. There is something at play which is pulling this back to 8 per minute every time. Attached logs show a delay of 60 seconds between 2 messages (there was thousands of messages on this subscription at this point in time): 2022-12-14T15:20:40Z   [Information]   Executing 'MyEventHandler' (Reason='(null)', Id=799aa6c4-5ebe-4bad-9084-80869a8591c3) 2022-12-14T15:21:40Z   [Information]   Executing 'MyEventHandler' (Reason='(null)', Id=03415959-0d4a-46fd-8acd-6411bded1150)  delay_between_consumed_messages.txt Expected behavior We've made an additional simple test ServiceBusTrigger function app which simply waits for a second and exits. We would expect to see around 60 messages consumed a minute, but instead we see 8 consistently. Actual behavior Function Apps only consume 8 messages per minute from session enabled Service Bus topics. Reproduction Steps Create a Linux consumption plan function app, and have it consume messages from a session enabled subscription with a high number of messages. This is the function and startup we have in the simple test app (which is also limited to 8 messages per minute):  public class EventHandler {     [FunctionName(`EventHandler`)]     public async Task Run([ServiceBusTrigger(TopicName,             SubscriptionName,             Connection = `ServiceBusConnectionString`,             IsSessionsEnabled = true)]         ServiceBusReceivedMessage serviceBusReceivedMessage,         ILogger logger)     {         logger.LogInformation(`Consumed message!`);          await Task.Delay(1000);     } }  public class Startup : FunctionsStartup     {         public override void Configure(IFunctionsHostBuilder builder)         {             var config = new ConfigurationBuilder()                 .SetBasePath(Environment.CurrentDirectory)                 .AddEnvironmentVariables()                 .Build();              builder.Services.AddLogging();             builder.Services.AddSingleton<IConfiguration>(config);         }     }  Environment This is a v4 function app running on .net 6 Linux consumption plan Using the latest stable version of all nuget packages.
Client	Event Hubs	[BUG] Custom Timeout doesn't work in Azure.Messaging.EventHubs (5.7.4)	We are using the package Azure.Messaging.EventHubs version 5.7.4. And the CancellationToken Timeout is not working correctly with Azure.Messaging.EventHub, irrespective of whatever the cancellationToken timeout we set , it will always takes around 2 to 3 seconds and throws task canceled exception when the Azure Event Hub is taking time to respond back or got any issues. private async Task SendBatchAsync(EventDataBatch batch) {             var stopWatch = Stopwatch.StartNew();             try             {                 _logger.MemberEntry(`Sending batch of messages having {message_count} messages, size: {message_size_bytes} bytes`,                     new object[] { batch.Count, batch.SizeInBytes });                 using var cancellationTokenSource = new CancellationTokenSource();                 cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(4));                 await _eventHubProducer.SendAsync(batch, cancellationTokenSource.Token);             }             catch (Exception ex)             {                 _logger.Error(`Send batch failed for the event_hub {event_hub} with {exception}`,                     new object[] { _eventHubProducer.FullyQualifiedNamespace, ex });                 throw;             }             finally             {                 _logger.MemberExit(`Send batch completed for the event_hub {event_hub} in {elapsedmillisecond} ms`,                     new object[] { _eventHubProducer.FullyQualifiedNamespace, stopWatch.ElapsedMilliseconds });             }         }  Also, sometimes when the batch size is more, it takes more time to publish events. Example, when the batch size is around 1012618 bytes, I am getting TaskCanceledException after 2003 milliseconds. And when I retried after a second, it succeeded within 150 milliseconds.
Mgmt	Compute	[QUERY] Models from Compute like ManagedDiskData cannot be used in mocking, because you cannot add the properties you need	Library name and version Azure.ResourceManager.Compute Query/Question I am trying as part of testing to use some test instances for 'ManagedDiskData'. But I cannot actually give it a 'Name' because that property has no public set. (as an example we need the names to do some filtering) I looked to see if factories to create instances for this models exist, but found nothing. Other solutions to try and do this,  complicates the code a lot on my side (and feels wrong). What is the proposed solution? I clearly read this should replace the old Compute resources, but those could be mocked, this stuff can't. Yes, in some cases like: ManagedDiskCollection.GetManagedDisks() we can put another class between and that one can return the managed disks instead of the manageddiskcollection (by mocking). But for the models I  am not certain what to do. Going and generating my own models, doesn't feel as a correct way of doing this. Environment VS 17; .net 6; Azure Functions that manages resources in Azure
Client	Event Hubs	[QUERY] How does partition key work?	Library name and version Azure.Messaging.EventHubs 5.7.5 Query/Question I have many messages which has a user id. I need to consume the messages which have the same user id in an instance. The simple solution is set partition key with user id. But I use the EventHubProducerClient SendAsync. The EventBatch can only set a partition key. So, I want to set partition key with 'UserId mod 10', it will be [0,9]. Does it work? Environment Windows 10, .NET 6.0 Microsoft Visual Studio Community 2022 (64-bit) - Current Version 17.4.1
Client	Event Hubs	[BUG]EventHubProducerClient SendAsync is not a synchronous call.	Library name and version Azure.Messaging.EventHubs 5.7.5 Describe the bug I use EventHubProducerClient.SendAsync to send about 50,000 messages one by one. I use await this.Client.SendAsync(batch); It returns quickly. But I found that event hub sends message in background. It works like EventHubBufferedProducerClient. Expected behavior Event hub completed to send message when SendAsync returns. Actual behavior Event hub didn't complete to send message when SendAsync returns. Reproduction Steps Use EventHubProducerClient.SendAsync to send 10,000 messages one by one and await it. It will return quickly. Environment Windows 10, .NET 6.0 Microsoft Visual Studio Community 2022 (64-bit) - Current Version 17.4.1
Client	Event Hubs	[FEATURE REQ] Nullable reference types support in Azure.Messaging.EventHubs	Library name Azure.Messaging.EventHubs Please describe the feature. Please consider supporting nullable reference type annotations in Azure.Messaging.EventHubs. It would make it much easier to use the public APIs and types provided in the correct way, because sometimes it is so not obvious whether something could be null or not, and the documentation is silent on that topic. At the very least, it would be very helpful to clearly document it somewhere, whether the library supports nullable reference types or not, in order to not to create any false expectations.
Mgmt	Machine Learning	[FEATURE REQ] Supports `expandChildren`: true in Azure ML SDK	Library name Azure.ResourceManager.MachineLearning Please describe the feature.   Request Provide parameter bool? expandChildren  in -- Azure.ResourceManager.MachineLearning.MachineLearningExtensions.GetMachineLearningUsages() -- Azure.ResourceManager.MachineLearning.MachineLearningExtensions.GetMachineLearningQuotas() to return workspace/deployment quota usage. Current SDK only returns to parent level: region.   Why -- This parameter is supported in REST API service -- Similar parameter is supported by other SDK like Azure.ResourceManager.Sql: https://github.com/Azure/azure-sdk-for-net/search?q=expandChildren -- Python AML SDK already supports it by having kways params={'expandChildren': 'true'} in AzureMachineLearningWorkspaces.usages.list() -- Our service needs to identity sub->region->workspace quota usage before starting the deployments
Client	Cognitive - Form Recognizer	Not Getting Line Items from `prebuilt-invoice`	If I submit an invoice in the Form Recognizer Studio, it finds and presents the line items from the invoice in the result JSON in Documents.Fields.Items as an array. (I removed all the sensitive parts of the invoice I analyzed for this posting.) `Items`: {     `type`: `array`,     `valueArray`: [         {             `type`: `object`,             `valueObject`: {                 `Amount`: {                 },                 `Description`: {                 },                 `Quantity`: {                 },                 `Unit`: {                 },                 `UnitPrice`: {                 }             },             `content`: ``,             `boundingRegions`: [                 {                     `pageNumber`: 1,                     `polygon`: [                         0.2566,                         5.525,                         8.0689,                         5.525,                         8.0689,                         5.7782,                         0.2566,                         5.7782                     ]                 }             ],             `confidence`: 0.503,             `spans`: [                 {                     `offset`: 783,                     `length`: 84                 }             ]         }     ] },   If I then take that same invoice and submit it using the C# code (modeled after the code in Form Recognizer Studio), I do not get the line items in the JSON. Documents.Fields.Items is just this: `Items`: {     `FieldType`: 7,     `ExpectedFieldType`: 7,     `Value`: {},     `Content`: null,     `BoundingRegions`: [],     `Spans`: [],     `Confidence`: null },  I do get all the other data. Any idea why?     <TargetFramework>net6.0</TargetFramework>     <PackageReference Include=`Azure.AI.FormRecognizer` Version=`4.0.0` />      public async Task<IActionResult> ProcessInvoice(IFormFile pdfInvoice) {         try {             string endpoint = `https://xxx.cognitiveservices.azure.com/`;             string key = `xxx`;             AzureKeyCredential credential = new AzureKeyCredential(key);             DocumentAnalysisClient client = new DocumentAnalysisClient(new Uri(endpoint), credential);             using var stream = pdfInvoice.OpenReadStream();             AnalyzeDocumentOperation operation = await client.AnalyzeDocumentAsync(WaitUntil.Completed, `prebuilt-invoice`, stream);             AnalyzeResult result = operation.Value;              return Ok(JsonConvert.SerializeObject(result));         } catch (Exception ex) {             return BadRequest(ex.Message);         }     }
Client	Functions	[BUG] Function [XYZ]: cannot find value named 'ServiceBusConnection' in local.settings.json that matches 'connection' property set on 'serviceBusTrigger'	Library name and version microsoft.azure.webjobs.extensions.servicebus 5.8.1 Describe the bug I was trying to enable Managed Identity together with ServiceBusTrigger in my Azure Function according to the official guide here: https://learn.microsoft.com/en-us/azure/azure-functions/functions-identity-based-connections-tutorial-2. Expected behavior There is no MSBuild warning regarding missing setting in local.settings.json when using Managed Identity for Azure Functions. Actual behavior There is a warning Function [XYZ]: cannot find value named 'ServiceBusConnection' in local.settings.json that matches 'connection' property set on 'serviceBusTrigger' . This warning is misleading since according to the guide, there should not even be a setting like that since there is a ServiceBusConnection__fullyQualifiedNamespace present. Reproduction Steps Prepare an Azure Function based on the official page here: https://learn.microsoft.com/en-us/azure/azure-functions/functions-identity-based-connections-tutorial-2. Environment  macOS Ventura 13.0.1 .NET SDK 6.0.403 IDE: both Rider and Visual Studio
Mgmt	ARM	[FEATURE REQ] Better distinction between async and blocking operations	Library name Azure.ResourceManager.* (although I think others are affected as well) Please describe the feature. I think the Azure management SDKs are very intuitive to use, but I consistently find one aspect rather confusing: the inclusion of both asynchronous and blocking versions of every function. e.g. var s1 = armClient.GetSubscriptions().Get(`00000000-0000-0000-0000-000000000000`); var s2 = await armClient.GetSubscriptions().GetAsync(`00000000-0000-0000-0000-000000000000`); The subtle (but important!) distinction between these methods has tripped up both junior and senior developers on my team. The methods are particularly confusing for developers that are newer to C# or less familiar with asynchronous patterns. The inclusion of blocking methods right alongside async methods makes it too easy to unknowingly introduce performance issues. It is even more confusing for listing operations because there are four different ways to list many resources. e.g. foreach(var sub in armClient.GetSubscriptions().GetAll()) {} await foreach(var sub in armClient.GetSubscriptions().GetAllAsync()) {}  foreach(var sub in armClient.GetSubscriptions()) {} await foreach(var sub in armClient.GetSubscriptions()) {} Making the SubscriptionCollection implement IEnumerable and IAsyncEnumerable is kinda cool, but adds to the confusion and makes it even easier to mess up. Having  GetAll, GetAllAsync, and other methods defined on this collection doesn’t help. I realize that providing both asynchronous and synchronous method implementations is part of the Azure SDK design guidelines. Changing the SDK’s API surface would also be a prohibitively large breaking change. However, in an ideal world, I think the best solution would be to separate the asynchronous and synchronous APIs into a separate NuGet packages. Since such a large change is impractical at this point, I wonder if a more reasonable improvement would be to add an analyzer that suggests converting synchronous calls into asynchronous calls. Such an analyzer could be disabled entirely by teams that can’t use asynchronous APIs whereas I could set it to throw a compilation error, thereby protecting my codebase from performance issues that too easily slip through code reviews.
Client	Storage	[QUERY] Is OperationContext to correlate Storage logs and Application Insights telemetry Available in Azure.Storage.Queue v12	Library name and version Azure.Storage.Queues v12.12.0 Query/Question I see that the sample for tracking enqueue operations to storage is using the Azure SDK v11 (Microsoft.Azure.Storage.Queue) using CloudQueue.AddMessage (....). In v12 (Azure.Storage.Queues) there is QueueServiceClient.SendMessageAsync(....) but I couldn't find the way to send the correlation Id as this line explains         // Add operation.Telemetry.Id to the OperationContext to correlate Storage logs and Application Insights telemetry.         OperationContext context = new OperationContext { ClientRequestID = operation.Telemetry.Id };  Is there an equivalent using the Azure SDK v12? (Azure.Storage.Queues)? Environment No response
Client	Search	Sample code for IndexDocumentAsync	Is there any sample example how to use this searchindexingbufferedsender.IndexDocumentAsync()? What happens if there is any error in one of documents? entire request will be failed or only invalid docs? How to track the error/ failed docs?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 94bb8cc1-97c3-3914-3dcc-27dcdeeecd61 Version Independent ID: c0980e51-67e4-a170-a06c-ac73c9dee39d Content: SearchIndexingBufferedSender<T>.IndexDocumentsAsync Method (Azure.Search.Documents) - Azure for .NET Developers Content Source: [xml/Azure.Search.Documents/SearchIndexingBufferedSender1.xml](https://github.com/Azure/azure-docs-sdk-dotnet/blob/master/xml/Azure.Search.Documents/SearchIndexingBufferedSender1.xml) Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Mgmt	App Services	[QUERY] How to download public key/certificate from Azure App Services Certificates	Library name and version Azure.ResourceManager.AppService v1.0.0 Query/Question I want to download every public key/certificate from Azure App Service Certificates. AppServiceExtensions.GetAppCertificates() only returns certificate metadata such as thumbprint, issuer, and expiration data. Per the /certificate endpoint documentation, certificate data is not available using the GET method. Is there another way to consume App Service Certificates aside from what's detailed in this article? Environment Platform: .NET SDK:  Version:   7.0.100  Commit:    e12b7af219  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.19044  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\7.0.100\  Host:   Version:      7.0.0   Architecture: x64   Commit:       d099f075e4  .NET SDKs installed:   7.0.100 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.31 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 7.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Other architectures found:   x86   [C:\Program Files (x86)\dotnet]     registered at [HKLM\SOFTWARE\dotnet\Setup\InstalledVersions\x86\InstallLocation]  Environment variables:   Not set  global.json file:   Not found  Learn more:   https://aka.ms/dotnet/info  Download .NET:   https://aka.ms/dotnet/download  IDE version: Visual Studio 17.4.1
Client	Functions	[BUG] Azure Function Trigger with Managed Identity intermittently working on consumption plan	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.8.1 Describe the bug We followed the following documentation to use Managed Identity in combination with a ServiceBus trigger in our Azure Function running on a consutmpion plan (Y1): https://learn.microsoft.com/en-us/azure/azure-functions/functions-identity-based-connections-tutorial-2. The functions Managed Identity has the DataReader role on a specific ServiceBus topic. Our trigger looks like this: [FunctionName(nameof(MyConsumer))] [ExponentialBackoffRetry(MaxRetryCount, MinimumBackoffRetryInterval, MaximumBackoffRetryInterval)] public async Task Run([ServiceBusTrigger(`%SomeTopicName%`, `%SomeSubscriptionName%`, Connection = `ServiceBusConnection`)]        string myMessage,      int deliveryCount,     string messageId)     { ... }  In our appsettings.{environment}.json we have the following setting: `ServiceBusConnection`: {         `fullyQualifiedNamespace`: `{name}.servicebus.windows.net`   }  We load the appsettings.{environment}.json file on function startup like this: builder.AddJsonFile(Path.Combine(context.ApplicationRootPath, $`appsettings.{context.EnvironmentName}.json`), optional: true, reloadOnChange: false);  Initially this works, the function triggers when a new message is put on the topic. However, after a while the trigger stops working intermittently. Sometimes for a couple of seconds, sometimes for minutes, but we have seen cases where after a weekend messages were still sitting on the servicebus topic. It looks similar to the following (fixed) issue: #26663 Based on that I played with the following setting to get ScaleController logs: `name`: `SCALE_CONTROLLER_LOGGING_ENABLED`,`value`: `AppInsights:Verbose`  Soon enough we saw logs like: Specified connection string is null or empty for connection: ServiceBusConnection. Invalid connection. Based on this I got the hunch that maybe the appsetting from the json file was not available anymore, so I added the ServiceBusConnection__fullyQualifiedNamespace setting to the appsettings in the Configuration blade of the function, and the ScaleController logs changed to: Created ServiceBusClient with ManagedIdentity After this everything worked as expected. Expected behavior I would expect the appsettings.json settings to be used, also on a Consumption Plan. But maybe this assumption is wrong and this is by design, and the AppSettings on the Configuration blade of the Function App should always be used? Actual behavior See: Describe the bug Reproduction Steps Create a Function App with a ServiceBus trigger on a Consumption plan. Provide the Azure ServiceBus DataReader role on the topic to the Function Apps Identity. Provide the ServiceBusConnection__fullyQualifiedNamespace in the appsettings and load them on Startup. Send a couple of messages to the SB, wait for 10 minutes, send some more messages. The trigger is not fired. Environment Serviceplan Y1 on windows Function app: net6.0 Microsoft.Azure.Functions.Extensions: 1.1.0 Microsoft.Azure.WebJobs.Extensions.ServiceBus: 5.8.1 Microsoft.NET.Sdk.Functions: 4.1.3
Client	Search	Azure cognitive search with more fields	Library name and version Azure.Search.Documents(11.4.0) Query/Question I have more than 1000+ fields. Expecting more fields in the future as well. How can I achieve the search for all these fields? Sample Cosmos data, [{ `id`:1, `FirstName`:`first name`, `LastName`:`last name`, `MetaData`:{ `field1`:1, `field2`:`12/02/2020`, `field3`:`test string` }, { `id`:2, `FirstName`:`first name`, `LastName`:`last name`, `MetaData`:{ `field1`:1, `field4`:1, `field5`:`12/02/2020`, `field6`:`test string2`, `field7`:`test string 3`, `field8`: [`test1`,`test2`] } ...] MetaData will have dynamic fields. I need to create searchable index fields for all these metadata. since the index field max limit is 1000. I am unable to create index fields for metadata. https://learn.microsoft.com/en-us/azure/search/search-limits-quotas-capacity#index-limits Please suggest any other way of searching the metadata other than creating fields in the search index. Environment No response
Client	Azure.Core	[QUERY] Information level logs with Azure.Core.1 category	Library name and version latest Query/Question I see multiple logs of information log level with the category Azure.Core.1 showing in Application Insights. What is this, and why is it not using Azure.Core category? Environment N/A
Client	Service Bus	[QUERY] Why is there a length limit on `MessageId`, `SessionId`, `PartitionKey`, `ReplyToSessionId`	Library name and version Azure.Messaging.ServiceBus - 7.12.0-beta.1 Query/Question This is just a general inquiry on why there are length limits for the MessageId, SessionId, PartitionKey, ReplyToSessionId fields in  ServiceBusMessage? It doesn't seem like there is such limits in the go-lang sdk? Environment No response
Client	Tables	Fetch specific number of items from the table: what is the best way to replace the `Take`	Library name and version Azure.Data.Tables version 12.6.1 Query/Question what is the alternative that Azure.Data.Tables provides for the `Take` in the below reference: TableQuery query = new TableQuery().Where(TableQuery.GenerateFilterCondition(`PartitionKey`, QueryComparisons.Equal, item)).Take(10); Environment No response
Client	Communication - Chat	[BUG] Azure Communication Chat client - Sending message with ParticipantAdded type is not supported	Library name and version Azure.Communication.Chat 1.1.0 Describe the bug After sending a message with ChatMessageType.ParticipantAdded by Azure Communication Chat client to an existing thread. the error occurs:  Sending a message with ParticipantAdded type is not supported. Expected behavior Message is sent with ChatMessageType.ParticipantAdded. Actual behavior Message is not sent and an error occurs: Sending a message with ParticipantAdded type is not supported. Reproduction Steps  Create a thread using the Azure Communication Chat client Add new participant to the thread Send a message to this thread with the type ChatMessageType.ParticipantAdded  Environment .Net Core 6.0
Client	Azure.Identity	[BUG] Getting random error on initialization on Azure Container Instance Managed Identity: ManagedIdentityCredential authentication failed: 'R' is an invalid start of a value	Library name and version Azure.Identity 1.5.0 Describe the bug I have a logic App which creates a Azure Container Group on the fly and attached a Managed User Identity with the container Group. I have the following code written in the Program.cs:  Most of the time above logic works fine. But many times it fails with the following error: Startup Exception occurred: ManagedIdentityCredential authentication failed: 'R' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot  Expected behavior Code should throw no error while initializing the App Configuration connection using managed identity. Actual behavior Throwing error at startup: Startup Exception occurred: ManagedIdentityCredential authentication failed: 'R' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot  Reproduction Steps Its really very random. Hard to reproduce. Environment OS Type: Linux Code running in container inside Azure Container Instances
Client	Azure.Core	No Support for stage regions like South Central US Stage in Azure.Core.AzureLocation enum	Please add support for stage regions like South Central US Stage in Azure.Core.AzureLocation enum. As different teams are onboarding to stage regions for internal testing, this is a requirement now.
Client	Service Bus	[QUERY] What is the best practice around validating the `IsClosed` property?	Library name and version Azure.Messaging.ServiceBus 7.11.0 Query/Question I'm looking to see what the best practice is around connection persistence and checking the ServiceBusSender.IsClosed property before sending messages.  Should we be using that property to ensure the connection is not closed and if it is recreating the Client/Sender?  Or is connection persistence handled in the SDK internally? Environment Azure AppService .NET v6
Client	Storage	[QUERY] SAS Token with IPv6 as IpRange not working	Library name and version Azure.Storage.Blobs 12.13.0 Query/Question I'm trying to generate SAS token assigning an IPv6 as IpRange. I don't get any error when I generate the token and build the url on the code. But then when I try to navigate to the blob's URL I'm getting a HTTP 403 (Forbidden). It works perfectly when I use IPv4 though. Do you know if IPv6 is supported? var blobSasBuilder = new BlobSasBuilder {  ExpiresOn = expires,  Resource = `b`,  BlobContainerName = blob.BlobContainerName,  BlobName = blob.Name,  Protocol = SasProtocol.Https,  IPRange = new SasIPRange(IPAddress.Parse(`MyIPv6Address`)), };  On the other hand, when I try to build a SAS token throught the Azure Portal, it won't let me assign an IPv6 here. My 2 cents, IPv6 is not allowed, but I didn't find any documentation that says that explicitly.  Any help would be much appreciated! Environment net5.0; Azure Portal
Client	Event Hubs	[QUERY] Use EventProcessorClient to connect from an application with a valid oauth 2.0 token?	Library name and version Azure.Messaging.EventHubs 5.7.3 Query/Question Hi, in all .NET examples I have seen, to connect to eventhub the connectionstring is always used. Can you provide instructions or an example on how to connect with EventProcessorClient using an application's oauth 2.0 token? From the list of available constructors the only possibility is: EventProcessorClient(checkpointStore,  consumerGroup, fullyQualifiedNamespace, eventHubName, TokenCredential , EventProcessorClientOptions) TokenCredential is abstract and I see no implementation. Should I build my own TokenCredential or is there a default implementation? An example would be great! Environment No response
Client	KeyVault	Looking for exception throwned on operation fail	Does SetSecretAsync throw an exception if the secret creation fails? How can I check if the secret has been added to the vault, without directly read it in another operation (as a last chance)?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: c536dd25-1fd1-a53b-96f2-0cc17104befa Version Independent ID: c6b1cc8a-30b3-e73a-c5e5-c76367cbb7e3 Content: KeyVaultClientExtensions.SetSecretAsync Method (Microsoft.Azure.KeyVault) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.KeyVault/KeyVaultClientExtensions.xml Service: key-vault GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Storage	[BUG] SyncCopyFromUri works differently than StartCopyFromUri for copies within the same container.	Library name and version Azure.Storage.Blobs 12.14.1 Describe the bug SyncCopyFromUri and StartCopyFromUri have similar APIs, but SyncCopyFromUri implicitly waits for completion and has a size limit. But they do not appear to work the same, in practice, when copying within a container. Expected behavior SyncCopyFromUri should not need any more information than the source URI when copying from within the same container as the source, just like StartCopyFromUri does. Actual behavior SyncCopyFromUri throws an exception with the message `Server failed to authenticate the request. Please refer to the information in the www-authenticate header.` Reproduction Steps var container = new BlobServiceClient(/* omitted */).GetBlobContainerClient(`blobs`); var source = container.GetBlobClient(`test.txt`); var copy = container.GetBlobClient(`testcopy.txt`); copy.SyncCopyFromUri(source.Uri); // Server failed to authenticate the request. Please refer to the information in the www-authenticate header. copy.StartCopyFromUri(source.Uri).WaitForCompletion(); // Works Environment .NET 6 / Visual Studio 17.5.0 Preview 1.0. Also observed in .NET Framework 4.8 in an entirely different project and platform--it seems to be an issue with Azure.Storage.Blobs (or at least my usage of it), not an environmental issue.
Mgmt	Authorization	[BUG] GetDenyAssignments() throws an exception for GenericResource	Library name and version Azure.ResourceManager.Authorization, v1.0.0 Describe the bug I am using following client library `Azure.ResourceManager.Authorization, v1.0.0` to retrieve deny assignments for a resource. Following code throws exception at return line: public Pageable<DenyAssignmentResource> GetDenyAssignmentsForResource(GenericResource ga) {         DenyAssignmentCollection data = ga.GetDenyAssignments();         return data.GetAll(); }   The error message is following: `Value cannot be empty or contain only white-space characters. (Parameter 'resourceType')`. In fact, 'resourceType' is not null. Expected behavior Should return deny assignments specific to a resource. Actual behavior GetAll() in DenyAssignmentCollection throws an exception with the following message: `Value cannot be empty or contain only white-space characters. (Parameter 'resourceType')`. It looks like it happened on this line. It tries to create ResourceType based on empty string value for comparison and fails due to validation. Reproduction Steps  Retrieve list of resources for a given resource group:  ArmClient _armClient; //should be initialized  string resourceGroupName = `RESOURCE_GROUP_NAME`; var subscriptions = _armClient.GetSubscriptions(); SubscriptionResource subscription = subscriptions.Get(subscriptionId);  ResourceGroupCollection resGroupCollection = subscription.GetResourceGroups(); ResourceGroupResource resourceGroupResource = resGroupCollection.Get(resourceGroupName);  Pageable<GenericResource> resources = resourceGroupResource.GetGenericResources();   Run following code for a given resource  public Pageable<DenyAssignmentResource> GetDenyAssignmentsForResource(GenericResource ga) {         DenyAssignmentCollection data = ga.GetDenyAssignments();         return data.GetAll(); }  Environment dotnet --info: .NET SDK: Version:   7.0.100 Commit:    e12b7af219 Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\7.0.100\ Host: Version:      7.0.0 Architecture: x64 Commit:       d099f075e4
Mgmt	SQL	Action Microsoft.Sql/locations/shortTermRetentionPolicyAzureAsyncOperation/read does not exist	Hello, I have the following code, which works with my Admin Account.  However if a try a user with limited permission i get the following error message 403  The client '----' with object id '---' does not have authorization to perform action 'Microsoft.Sql/locations/shortTermRetentionPolicyAzureAsyncOperation/read' over scope '/subscriptions/---/resourceGroups/r---/providers/Microsoft.Sql/locations/westeurope/shortTermRetentionPolicyAzureAsyncOperation/0a84c678-f877-4f13-9241-3d4a8eb91cfb' or the scope is invalid. If access was recently granted, please refresh your credentials. When i try to find this right to add it to my role it says it does not exist.  I only can find :`Microsoft.Sql/locations/shortTermRetentionPolicyOperationResults/read` However this does not help. Please Advice.
Client	Azure.Identity	RequestFailedException due to authentication error excludes helpful www-authenticate response header value.	Library name and version Azure.Data.AppConfiguration 1.2.0 Query/Question Recently received the following exception when reaching out to Azure App Configuration due to an authenticate error. Configuration refresh failed from secondary configuration store with exception Azure.RequestFailedException: Service request failed. Status: 401 (Unauthorized)    Headers: Connection: keep-alive Content-Length: 0 Date: Tue, 08 Nov 2022 21:44:30 GMT Server: openresty/1.17.8.2 WWW-Authenticate: REDACTED x-ms-request-id: 35950586-3cb4-4706-87e0-5a2f9d7151fd x-ms-client-request-id: 00c334c5-cc56-4a4d-b545-08901f2362dd x-ms-correlation-request-id: 35950586-3cb4-4706-87e0-5a2f9d7151fd Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: REDACTED Strict-Transport-Security: max-age=15724800; includeSubDomains  Azure App Configuration returns helpful errors  in the WWW-Authenticate header to help describe any common authentication issue. The problem is that the value of WWW-Authenticate is redacted. How can I make the value appear in the exception? Environment No response
Client	Service Bus	Why does this code force use of a singleton Transaction.Current to check for transactions?	Library name and version Azure Service Bus .NET library Query/Question                azure-sdk-for-net/sdk/servicebus/Microsoft.Azure.ServiceBus/src/Core/MessageSender.cs                    Line 547       in       0a82584                                                 var ambientTransaction = Transaction.Current;                     We ran into this issue when we were running a SQL transaction via EF, while trying to send messages on the service bus, and we'd get an error like `The only supported IsolationLevel is Serializable` which makes no sense in this scenario. It appears this code is tightly coupling a transaction scope to something completely unrelated via a singleton. Why is it doing that, and surely there can be some injectable means of doing the same thing? Environment all (this is a base code issue)
Client	Tables	[FEATURE REQ] Expose an overload with RequestContext in Azure.Data.Tables	Library name Azure.Data.Tables Please describe the feature. Azure.Core offers the ability to customize error handling by passing a RequestContext specifying certain ErrorOptions, as documented in this sample. We wanted to leverage this feature in Azure.Data.Tables to stop the SDK from throwing exceptions when performing data operations that we expect to fail sometimes, e.g. when entities are not found. However, the APIs in Azure.Data.Tables don't offer the ability to pass in the RequestContext to leverage this feature. Unless I missed something, it is currently impossible to change the error behavior. Is this functionality in Azure.Core still supposed to be used in downstream libraries? If so, is it on the roadmap to incorporate it into downstream libraries such as Azure.Data.Tables?
Client	Tables	Unable to specify the operator, columns dynamically in the filter string in TableClient.CreateQueryFilter()	Library name and version Azure.Data.Tables version 12.6.1 Query/Question Please guide how can I generate the expected valid value of _filterCondition that can be used in the QueryAsync method for reading the data from the table. Summary of the issue: Expected value of _filterCondition = `CreatedDateTime ge datetime'00/08/2022 0 XXXXX'` This is working: _filterCondition = TableClient.CreateQueryFilter($`CreatedDateTime ge {((DateTimeOffset)filterExpression.Value)`); This isnt working: _filterConditionWrong = TableClient.CreateQueryFilter($`{filterExpression.PropertyName} {operation} {(DateTimeOffset)filterExpression.Value}`); where filterExpression.PropertyName = `CreatedDateTime`, operation = `ge` Where as the value in _filterConditionWrong = `'CreatedDateTime' 'ge' datetime'00/08/2022 0 XXXXX'` There are some extra single quotes are getting added in the filter string that which is not a valid filter for the QueryAsync method Environment No response
Client	Storage	[FEATURE REQ] Add timeout support for QueueClient methods.	Library name Azure.Storage.Queues Please describe the feature. According to the Azure documentation Storage Queue Operations allow to pass an optional timeout parameter. Unfortunately, none of the f QueueClient methods exposes this parameter to the user. This means I'm not able to implement any kind of server timeout operations. There already is an optional timeout parameter, in the internal MessagesRestClient class Related to #30079
Client	Service Bus	[BUG] ManagementClient use of HttpClient  (track one)	Library name and version Microsoft.Azure.ServiceBus Describe the bug Inside the ManagementClient a new HttpClient is created and stored as a private variable, which will eventually cause the garbage collector to dispose the HTTP Client, e.g. if the ManagementClient is created as Transient. See also https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines Offending code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Microsoft.Azure.ServiceBus/src/Management/ManagementClient.cs Expected behavior Use a static HttpClient or use HTTP Factory and create the client on demand. Actual behavior Http Client is created inside the constructor one time and stored as a private variable. Reproduction Steps Create a Class as Transient which is containing the ManagmentClient. The Http Client will get disposed at some point and null reference exception will occur. Environment Both .NET Fwk and .NET Classic
Client	Service Bus	Broken link	Sending and Receiving Messages  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: bff0d5e0-fa82-3c93-de88-41270ca813ac Version Independent ID: daae1611-8473-b884-e54e-44199a6168dd Content: Azure Service Bus libraries for .NET - Azure for .NET Developers Content Source: api/overview/azure/latest/service-bus.md Service: service-bus-messaging GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Synapse	TabularTranslator physicalType property	There is 'physicalType' property in 'mappings.source/sink' properties. What is the meaning of it and why is this not in the documentation? Please find an extract from Synapse Copy Activity below.  { `type`: `TabularTranslator`, `mappings`: [ { `source`: { `name`: `key`, `type`: `String`, `physicalType`: `varchar` }, `sink`: { `name`: `key`, `type`: `String`, `physicalType`: `varchar` } } ] } Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 1ab58a9b-db71-31a3-d48c-862c2800bce3 Version Independent ID: db59c73d-1a80-79e2-455b-465f6ad9eefb Content: TabularTranslator.Mappings Property (Azure.Analytics.Synapse.Artifacts.Models) - Azure for .NET Developers Content Source: xml/Azure.Analytics.Synapse.Artifacts.Models/TabularTranslator.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Core	[QUERY] Proxy without environmental value (eg. HTTP_PROXY)	Library name and version Azure.Storage.Blobs 12.14.1 Query/Question I'm trying to connect to my storage account with a proxy without using an environmental value (eg. HTTP_PROXY). I can't use environmental values (eg. HTTP_PROXY) since it breaks other parts of my application. I currenly have tried modifying transport:             x.Transport = new HttpClientTransport(new HttpClient(new HttpClientHandler             {                 Proxy = string.IsNullOrEmpty(app.Configuration[`proxy`]) ? null : new WebProxy(app.Configuration[`proxy`]),                 UseProxy = string.IsNullOrEmpty(app.Configuration[`proxy`]) ? false : true             }));  If I do the same with a HTTP client connect to my API, it works as intended, How can I set the default proxy in the Azure clients by using code? Thank you for your help. Environment No response
Client	Monitor	[QUERY] Mocking Monitor.Query Objects	Library name and version azure.monitor.query Query/Question Hi, I am using Azure.monitor.query and in my source code i am using function var queryResponse = await this.logAnalyticsClient.QueryWorkspaceAsync(workspaceId, query2, new QueryTimeRange(TimeSpan.FromDays(7))); I want to create a mock of LogAnalyticsClient in my tests, so i have created it like Substitute.For() I want to know how do i mock the response of function QueryWorkspaceAsync() ?? If you have any reference please share Thanks Environment No response
Client	Storage	[BUG] Bulk Archive throws exception: Expected 94300 responses for the batch request, not 1.	Library name and version Azure.Storage.Blobs.Batch 12.11.0 Describe the bug I'm using a slightly altered version of Microsofts Bulk archive found on the docs I'm trying to archive a specific set of blobs that are in virtual folders. When submitting the batch job, An exception is thrown. message: Invalid response Status: 202 (Accepted)  Headers: Transfer-Encoding: chunked Server: Windows-Azure-Blob/1.0,Microsoft-HTTPAPI/2.0 x-ms-request-id: bfaf37d6-e01e-0063-208c-ebeefd000000 x-ms-version: 2021-10-04 x-ms-client-request-id: b79b526a-5ad4-4e91-81fe-002c5bb9efef Date: Sat, 29 Oct 2022 11:48:23 GMT Content-Type: multipart/mixed; boundary=batchresponse_f453577e-10e5-43b3-8f08-61a3fe63f847  Inner exception Expected 94300 responses for the batch request, not 1.  stack trace    at Azure.Storage.Blobs.Specialized.BlobBatchClient.<UpdateOperationResponses>d__38.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBatchClient.<SubmitBatchInternal>d__36.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBatchClient.<SetBlobsAccessTierInteral>d__44.MoveNext()    at Azure.Storage.Blobs.Specialized.BlobBatchClient.<SetBlobsAccessTierAsync>d__43.MoveNext()    at Program.<<<Main>$>g__BulkArchiveContainerContents|0_0>d.MoveNext() in D:\GIT Repositories\BlobStorageBulkArchiver\BlobStorageBulkArchiver\BlobStorageBulkArchiver\Program.cs:line 60  the code I'm running: using Azure; using Azure.Identity; using Azure.Storage.Blobs; using Azure.Storage.Blobs.Models; using Azure.Storage.Blobs.Specialized; using System.Text.RegularExpressions;  Console.WriteLine(`Starting...`);  await BulkArchiveContainerContents(`storageaccountName`, `containerName`, `^(202[0-1])|^201[0-9]`);  static async Task BulkArchiveContainerContents(string accountName, string containerName, string regex) {     string containerUri = string.Format(`https://{0}.blob.core.windows.net/{1}`,                                     accountName,                                     containerName);      // Get container client, using Azure AD credentials.     BlobUriBuilder containerUriBuilder = new(new Uri(containerUri));     BlobContainerClient blobContainerClient = new(containerUriBuilder.ToUri(),                                                                       new DefaultAzureCredential());      // Get URIs for blobs in this container and add to stack.     var blobs = new List<Uri>();     var excludedBlobs = new List<Uri>();     try     {         await foreach (var item in blobContainerClient.GetBlobsAsync())         {             var match = Regex.Match(item.Name, regex, RegexOptions.IgnoreCase);             if (match.Success)             {                 blobs.Add(blobContainerClient.GetBlobClient(item.Name).Uri);             } else             {                 excludedBlobs.Add(blobContainerClient.GetBlobClient(item.Name).Uri);             }         }          Console.WriteLine($`Found a total of '{blobs.Count}' blobs and excluded '{excludedBlobs.Count}'`);          if (blobs.Count >= 1)         {             Console.WriteLine($`Example of included file: '{blobs.Last().AbsolutePath}'`);         }                  if (excludedBlobs.Count >= 1)         {             Console.WriteLine($`Example of excluded file: '{excludedBlobs.Last().AbsolutePath}'`);         }          // Get the blob batch client.         BlobBatchClient blobBatchClient = blobContainerClient.GetBlobBatchClient();          Console.WriteLine(`Press any key to continue`);          var reply = Console.ReadLine();         _ = await blobBatchClient.SetBlobsAccessTierAsync(blobUris: blobs, accessTier: AccessTier.Archive);     }     catch (RequestFailedException e)     {         Console.WriteLine(e.Message);     } } the amount of files that are to be archived is 94300. Even though an `accepted` is returned, the blobs are not archived. I created a new storage account with a similar structure, but only a few files, and that works without an issue. I tried changing the regex to ^2019 which included 6973 files. A similar Exception was thrown Expected behavior blobs should be archived. Actual behavior blobs are not archived and an exception is thrown Reproduction Steps unknown how to simply reproduce. Environment  Windows 11 .NET 6.0 StorageV2 Blob Soft Delete Enabled Contianer Soft Delete Enabled Versioning Enabled Change Log Enabled
Client	Kusto	[BUG] Can't authenticate using AZ CLI with Kusto on MacOS (System.PlatformNotSupportedException: Az-Cli does not support the current operting system)	Library name and version Kusto.Data 11.0 Describe the bug I'm facing an issue when trying to authenticate to my ADX cluster in a local C# Azure function using AZ CLI Authentication on MacOS: Error : System.PlatformNotSupportedException: Az-Cli does not support the current operting system    at Kusto.Cloud.Platform.Security.AzCliTokenProvider.LocateAzCli()    at Kusto.Cloud.Platform.Security.AzCliTokenProvider.GetTokenFromAzCli(String resource, Boolean interactive)    at Kusto.Cloud.Platform.Security.AzCliTokenProvider.GetCredentialsAsync(String targetResource)    at Kusto.Cloud.Platform.Http.TokenProviderHttpClientAuthenticator.AuthenticateAsync(HttpRequestMessage request)    at Kusto.Data.Net.Client.RestClient2.MakeHttpRequestAsyncImpl(String address, String csl, String ns, String databaseName, Boolean streaming, ClientRequestProperties properties, ServiceModelTimeoutKind timeoutKind, String clientRequestId, Stream body, StreamProperties streamProperties, CancellationToken cancellationToken, KustoProtocolRequest request)    at Kusto.Cloud.Platform.Utils.MonitoredActivity.InvokeAsync[TActivityType,TResult](TActivityType activityType, Func`1 func, String clientRequestId)    at Kusto.Cloud.Platform.Utils.MonitoredActivity.InvokeAsync[TActivityType,TResult](TActivityType activityType, Func`1 func, String clientRequestId)    at Kusto.Data.Net.Client.RestClient2.MakeHttpRequestAsync(ActivityType activityType, String baseAddress, String relativeAddress, String clientRequestIdPrefix, String ns, String databaseName, String csl, String addr, Boolean streaming, ClientRequestProperties properties, ServiceModelTimeoutKind timeoutKind, StreamProperties streamProperties, CancellationToken cancellationToken)    at Kusto.Data.Net.Client.RestClient2.ExecuteControlCommandAsync(String databaseName, String command, String addr, ClientRequestProperties properties)    at Kushy.ServerSymbolLoader.ExecuteControlCommandAsync[T](ICslAdminProvider provider, String database, String command, Boolean throwOnError, CancellationToken cancellationToken) in query-parsing-service/SymbolLoader.cs:line 324    at Kushy.ServerSymbolLoader.LoadTablesAsync(ICslAdminProvider provider, String databaseName, Boolean throwOnError, CancellationToken cancellationToken) in /query-parsing-service/SymbolLoader.cs:line 239    at Kushy.ServerSymbolLoader.LoadDatabaseAsync(String databaseName, String clusterName, Boolean throwOnError, CancellationToken cancellationToken) in query-parsing-service/SymbolLoader.cs:line 208    at Company.Function.QueryParsingService.Run(HttpRequest req, ILogger log) in query-parsing-service/QueryParsingService.cs:line 42  Am I missing something? Has the Kusto C# SDK not delivered this feature yet? TIA Expected behavior I expected it to behave in the same fashion as in Python. To use the AZ CLI to authenticate with Azure services. Actual behavior It's saying that my current platform (MacOS) is not supported yet. However I find that hard to believe because it works for the Python SDK. Reproduction Steps Here's the code: public static class QueryParsingService     {         [FunctionName(`QueryParsingService`)]         public static async Task<IActionResult> Run(             [HttpTrigger(AuthorizationLevel.Function, `get`, `post`, Route = null)] HttpRequest req,             ILogger log)         {             var cluster = System.Environment.GetEnvironmentVariable(`CLUSTER_ENDPOINT`);             var connection = new KustoConnectionStringBuilder(cluster).WithAadAzCliAuthentication(); // here             var server = new ServerSymbolLoader(connection);                         try             {                  var tableNames = await server.LoadDatabaseAsync(`DBName`, cluster,true); // the stacktrace points here but the object is instantiated above             }             catch (System.Exception err)             {                 System.Console.WriteLine(`Error : ` + err);             }             responseMessage.Add(`tables`, `OK`);              return new OkObjectResult(responseMessage);         }   Environment SDK .NET:  Version:   6.0.110  Commit:    ce0a42998a  Runtime environment :  OS Name:     Mac OS X  OS Version:  12.5  OS Platform: Darwin  RID:         osx.12-x64  Base Path:   /usr/local/share/dotnet/sdk/6.0.110/  global.json file:   Not found  Host:   Version:      6.0.10   Architecture: x64   Commit:       5a400c212a  .NET SDKs installed:   6.0.110 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 6.0.10 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 6.0.10 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]  IDE-wise, I'm using VSCode: 1.62.2 3a6960b964327f0e3882ce18fcebd07ed191b316 x64
Client	Cognitive - Form Recognizer	Is there any method to merge two FormElements?	We would like to merge two FormElements, but could not find any merge, concatenation or addition of FormElements. We are writing our own method.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 277708a3-a2b6-f115-28a3-77e9e30435ed Version Independent ID: 06a12831-b8e6-efb0-a69f-73b2eeb11774 Content: FormElement Class (Azure.AI.FormRecognizer.Models) - Azure for .NET Developers Content Source: xml/Azure.AI.FormRecognizer.Models/FormElement.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Mgmt	App Configuration	[BUG] Unable to get the keys of App Configuration	Library name and version Azure.ResourceManager.AppConfiguration 1.0.0 Describe the bug Hello, I am evaluating Azure.ResourceManager.AppConfiguration to see if I can use it manage a few instances of Azure App Configuration using C#. Basically I need to get the access keys and create/update/delete/get/list key-values. I was able to create/update/get/delete a key-value without issues however I am unable to get the list of every key-values: calling GetAll returns a 404. I tried calling the 'list endpoint' manually using the Try it out button from this page and I also get a 404 error so perhaps the issue is not with the library but with Azure itself. Expected behavior The expected behavior is getting the list of key-values. Actual behavior A 404 exception is thrown. Reproduction Steps You can use the code below to reproduce the issue: I created a .Net 6 console app (LinqPad) with the Azure.ResourceManager.AppConfiguration@1.0.0 and Azure.Identity@1.7.0 Nuget packages.  var creds2 = ...; // fill in with your usual way to get an identity in a console app, I'm using UsernamePasswordCredential for my tests  var subscriptionName = `...`;  var rgName = `...`;  var appCfgName = `...`;   ArmClient armClient = new ArmClient(creds2);  var subscriptions = armClient.GetSubscriptions();  var subscription = subscriptions.First(x => String.Equals(x.Data.DisplayName, subscriptionName, StringComparison.OrdinalIgnoreCase));    var rg = subscription.GetResourceGroup(rgName).Value;  var store = rg.GetAppConfigurationStore(appCfgName).Value;    var allKeyValues = store.GetAppConfigurationKeyValues().GetAll();    foreach(var kv in allKeyValues) // an exception is thrown with a 404  {   Console.WriteLine(kv.Data.Key);  } Environment I'm using LinqPad 7 and I'm targeting .Net 6 on Windows 10. Output of dotnet --info: .NET SDK (reflecting any global.json):  Version:   6.0.401  Commit:    0906eae6f8                                                                                                                                                                                                                          Runtime Environment:  OS Name:     Windows  OS Version:  10.0.19044  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\6.0.401\  global.json file:   Not found  Host:   Version:      6.0.10   Architecture: x64   Commit:       5a400c212a  .NET SDKs installed:   3.1.424 [C:\Program Files\dotnet\sdk]   5.0.203 [C:\Program Files\dotnet\sdk]   5.0.214 [C:\Program Files\dotnet\sdk]   6.0.100 [C:\Program Files\dotnet\sdk]   6.0.110 [C:\Program Files\dotnet\sdk]   6.0.305 [C:\Program Files\dotnet\sdk]   6.0.401 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.All 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]   Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]   Microsoft.AspNetCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.30 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Storage	[QUERY] await blobClient.UploadAsync(stream, true)  failing with Azure.RequestFailedException: Error while copying content to a stream.	Library name and version Azure.Storage.Blobs 12.12.0 Query/Question We have an    Azure  App  Service  API  (.Net Core 6)  is  uploading a  file stream to  BlobStorage   failing with following error (Intermittently).  Full stacktrace is provided below.  Any idea this could  be  ? await blobClient.UploadAsync(stream, true); System.AggregateException: Retry failed after 6 tries. Retry settings can be adjusted in ClientOptions.Retry. (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) ---> Azure.RequestFailedException: Error while copying content to a stream. ---> System.Net.Http.HttpRequestException: Error while copying content to a stream. ---> System.ObjectDisposedException: Cannot access a closed Stream. at System.IO.MemoryStream.Seek(Int64 offset, SeekOrigin loc) at Azure.Storage.NonDisposingStream.Seek(Int64 offset, SeekOrigin origin) at Azure.Core.RequestContent.StreamContent.WriteToAsync(Stream stream, CancellationToken cancellation) at Azure.Core.Pipeline.HttpClientTransport.PipelineRequest.PipelineContentAdapter.SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken) at System.Net.Http.HttpContent.g__WaitAsync|56_0(ValueTask copyTask) --- End of inner exception stack trace --- at System.Net.Http.HttpContent.g__WaitAsync|56_0(ValueTask copyTask) at System.Net.Http.HttpConnection.SendRequestContentAsync(HttpRequestMessage request, HttpContentWriteStream stream, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken) at System.Net.Http.DiagnosticsHandler.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpClient.g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async) --- End of inner exception stack trace --- at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async) at Azure.Core.Pipeline.HttpPipelineTransportPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline) at Azure.Core.Pipeline.RequestActivityPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.<ProcessAsync>g__ProcessAsyncInner|4_0(HttpMessage message, ReadOnlyMemory1 pipeline) at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) --- End of inner exception stack trace --- at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Storage.Blobs.BlockBlobRestClient.UploadAsync(Int64 contentLength, Stream body, Nullable1 timeout, Byte[] transactionalContentMD5, String blobContentType, String blobContentEncoding, String blobContentLanguage, Byte[] blobContentMD5, String blobCacheControl, IDictionary2 metadata, String leaseId, String blobContentDisposition, String encryptionKey, String encryptionKeySha256, Nullable1 encryptionAlgorithm, String encryptionScope, Nullable1 tier, Nullable1 ifModifiedSince, Nullable1 ifUnmodifiedSince, String ifMatch, String ifNoneMatch, String ifTags, String blobTagsString, Nullable1 immutabilityPolicyExpiry, Nullable1 immutabilityPolicyMode, Nullable1 legalHold, CancellationToken cancellationToken) at Azure.Storage.Blobs.Specialized.BlockBlobClient.UploadInternal(Stream content, BlobHttpHeaders blobHttpHeaders, IDictionary2 metadata, IDictionary2 tags, BlobRequestConditions conditions, Nullable1 accessTier, BlobImmutabilityPolicy immutabilityPolicy, Nullable1 legalHold, IProgress1 progressHandler, String operationName, Boolean async, CancellationToken cancellationToken) ---> (Inner Exception #1) Azure.RequestFailedException: Error while copying content to a stream. ---> System.Net.Http.HttpRequestException: Error while copying content to a stream. ---> System.ObjectDisposedException: Cannot access a closed Stream. at System.IO.MemoryStream.Seek(Int64 offset, SeekOrigin loc) at Azure.Storage.NonDisposingStream.Seek(Int64 offset, SeekOrigin origin) at Azure.Core.RequestContent.StreamContent.WriteToAsync(Stream stream, CancellationToken cancellation) at Azure.Core.Pipeline.HttpClientTransport.PipelineRequest.PipelineContentAdapter.SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken) at System.Net.Http.HttpContent.<CopyToAsync>g__WaitAsync|56_0(ValueTask copyTask) --- End of inner exception stack trace --- at System.Net.Http.HttpContent.<CopyToAsync>g__WaitAsync|56_0(ValueTask copyTask) at System.Net.Http.HttpConnection.SendRequestContentAsync(HttpRequestMessage request, HttpContentWriteStream stream, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken) at System.Net.Http.DiagnosticsHandler.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken) at System.Net.Http.HttpClient.<SendAsync>g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken) at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async) --- End of inner exception stack trace --- at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async) at Azure.Core.Pipeline.HttpPipelineTransportPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline) at Azure.Core.Pipeline.RequestActivityPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.g__ProcessAsyncInner|4_0(HttpMessage message, ReadOnlyMemory1 pipeline) at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory1 pipeline, Boolean async) at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)<--- ---> (Inner Exception #2) Azure.RequestFailedException: Error while copying content to a stream. ---> System.Net.Http.HttpRequestException: Error while copying content to a stream. ---> System.ObjectDisposedException: Cannot access a closed Stream. at System.IO.MemoryStream.Seek(Int64 offset, SeekOrigin loc) at Azure.Storage.NonDisposingStream.Seek(Int64 offset, SeekOrigin origin) at Azure.Core.RequestContent.StreamContent.WriteToAsync(Stream stream, CancellationToken cancellation) at Azure.Core.Pipeline.HttpClientTransport.PipelineRequest.PipelineContentAdapter.SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken) at System.Net.Http.HttpContent.g Environment Azure App Service .Net core 6
Client	Storage	[BUG] x-ms-version header not supported by Blob Service	Library name and version Azure.Storage.Blobs 12.14.1 Describe the bug After updating from version 12.13.0 to 12.14.1, our calls to all blob containers in one resource group are failing. There are no problems when reverting to 12.13.0 The same package works correctly for other storage accounts in different resource groups. Appears similar to this issue: #29098 Is it possible the latest Storage service version is not rolled out to all Storage Accounts in Azure? Expected behavior I would expect the call to not fail due to a package update. Actual behavior Error in FunctionApp:  Plain text error message (from AppService): The value for one of the HTTP headers is not in the correct format. RequestId: 6eab0834-301e-00de-2824-e592af000000 Time: 2022-10-21T08:08:11.5522799Z Status: 400 (The value for one of the HTTP headers is not in the correct format.) ErrorCode: InvalidHeaderValue Additional Information: HeaderName: x-ms-version HeaderValue: 2021-10-04 InvalidHeaderValue The value for one of the HTTP headers is not in the correct format. RequestId: 6eab0834-301e-00de-2824-e592af000000 Time: 2022-10-21T08:08:11.5522799Z x-ms-version 2021-10-04 Headers: Server: Windows-Azure-Blob/1.0,Microsoft-HTTPAPI/2.0 x-ms-request-id: 6eab0834-301e-00de-2824-e592af000000 Date: Fri, 21 Oct 2022 08:08:10 GMT Content-Length: 329 Content-Type: application/xml Reproduction Steps Sample code: var blobContainerClient = new BlobContainerClient(settings.ConnectionString, settings.ContainerName, new BlobClientOptions()); await blobContainerClient.CreateIfNotExistsAsync();  Environment .NET 6 AppService and Function App IDE(s) Occurs when debugging in VS2022 and JetBrainsRider, and in the cloud environment
Client	Storage	[BUG] Cannot get lease on container - HTTP 400 returned on header value	Library name and version Azure.Storage.Blobs 12.14.0 Describe the bug I'm using this code: var cred = new ChainedTokenCredential(new EnvironmentCredential(), new VisualStudioCredential(), new AzureCliCredential(), new AzurePowerShellCredential(), new InteractiveBrowserCredential()); var container = new BlobContainerClient(new Uri($`https://{input.AccountName}.blob.core.windows.net/{input.ContainerName}`), cred, options: retryOptions);  Console.WriteLine(`Connecting to container...`); if (!container.Exists()) {     Console.Error.WriteLine($@`Container '{input.ContainerName}' does not exist in storage account '{input.AccountName}'!`);     return; }  BlobLease? lease = null; try {     lease = container.GetBlobLeaseClient().Acquire(TimeSpan.FromMinutes(10)).Value;  ... to attempt to get a lease on a container while I do things in it. When I attempt to do this, the SDK throws an HTTP 400 error stating the header is in an incorrect format: Azure.RequestFailedException   HResult=0x80131500   Message=The value for one of the HTTP headers is not in the correct format. RequestId:a5fa6167-401e-00e6-4912-e32aa7000000 Time:2022-10-18T16:57:22.2360552Z Status: 400 (The value for one of the HTTP headers is not in the correct format.) ErrorCode: InvalidHeaderValue  Additional Information: HeaderName: x-ms-lease-duration HeaderValue: 600  Content: <?xml version=`1.0` encoding=`utf-8`?><Error><Code>InvalidHeaderValue</Code><Message>The value for one of the HTTP headers is not in the correct format. RequestId:a5fa6167-401e-00e6-4912-e32aa7000000 Time:2022-10-18T16:57:22.2360552Z</Message><HeaderName>x-ms-lease-duration</HeaderName><HeaderValue>600</HeaderValue></Error>  Headers: Server: Windows-Azure-Blob/1.0,Microsoft-HTTPAPI/2.0 x-ms-request-id: a5fa6167-401e-00e6-4912-e32aa7000000 x-ms-client-request-id: 01415325-0997-4c8d-90e6-07d8ba1803ed x-ms-version: 2021-10-04 x-ms-error-code: InvalidHeaderValue Date: Tue, 18 Oct 2022 16:57:21 GMT Content-Length: 328 Content-Type: application/xml    Source=Azure.Storage.Blobs   StackTrace:    at Azure.Storage.Blobs.ContainerRestClient.AcquireLease(Nullable`1 timeout, Nullable`1 duration, String proposedLeaseId, Nullable`1 ifModifiedSince, Nullable`1 ifUnmodifiedSince, CancellationToken cancellationToken) in /_/sdk/storage/Azure.Storage.Blobs/src/Generated/ContainerRestClient.cs:line 882    at Azure.Storage.Blobs.Specialized.BlobLeaseClient.<AcquireInternal>d__26.MoveNext() in /_/sdk/storage/Azure.Storage.Blobs/src/BlobLeaseClient.cs:line 365    at Azure.Storage.Blobs.Specialized.BlobLeaseClient.Acquire(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken) in /_/sdk/storage/Azure.Storage.Blobs/src/BlobLeaseClient.cs:line 183  Expected behavior A lease object is returned for the desired timespan Actual behavior No lease can be obtained, an exception is thrown Reproduction Steps Use the above code against a General Purpose storage account's blob container Environment Using .NET 6.0, latest
Client	Event Hubs	[FEATURE REQ] Support for managing Event Hubs using connection strings	Library name Event Hubs Please describe the feature. According to the official Event Hubs management libraries article you have to use AAD for managing Event Hubs. I would like to be able to manage Event Hubs with connection strings just like it is possible to manage Service Bus queues and topics with connection strings using the ServiceBusAdministrationClient class Since this is possible using the old WindowsAzure SDK it looks like the backend service support is there.
Client	Storage	[BUG] [DataLake] 3 http calls to upload one small document	Library name and version 12.12.1 Describe the bug When using UploadAsync to upload small document to the server, it does 3 http requests in background. This is unexpected and it has performance  implications. Here are all the calls:  It also has perf implications compared to Blob SDK client. In half of the cases it is almost 10 times slower:  Expected behavior I would expect, that simple UploadAsync call will do 1 http request to the server. Or at least it can be controlled by some settings. Actual behavior UploadAsync makes 3 http calls to the server. Reproduction Steps         var content = JsonConvert.SerializeObject(new         {             Property1 = `123`,             Property2 = `456`,         });          var stream = new MemoryStream(Encoding.UTF8.GetBytes(content ?? ``));          var uploadAsync = await fileClient.UploadAsync(stream);  Environment Windows 10, .NET6
Client	Event Hubs	[BUG] Connection timed out when connect to event hub	Library name and version `Azure.Messaging.EventHubs` Version=`5.7.2` Describe the bug System.Net.Sockets.SocketException (110): Connection timed out at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result) at Microsoft.Azure.Amqp.Transport.AmqpTransportInitiator.<>c.b__17_1(IAsyncResult r) at System.Threading.Tasks.TaskFactory1.FromAsyncCoreLogic(IAsyncResult iar, Func2 endFunction, Action1 endAction, Task1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location where exception was thrown --- at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.CreateAndOpenConnectionAsync(Version amqpVersion, Uri serviceEndpoint, Uri connectionEndpoint, EventHubsTransportType transportType, IWebProxy proxy, Int32 sendBufferSizeBytes, Int32 receiveBufferSizeBytes, RemoteCertificateValidationCallback certificateValidationCallback, String scopeIdentifier, TimeSpan timeout) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenProducerLinkAsync(String partitionId, TransportProducerFeatures features, PartitionPublishingOptions options, TimeSpan operationTimeout, TimeSpan linkTimeout, String linkIdentifier, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateLinkAndEnsureProducerStateAsync(String partitionId, String producerIdentifier, PartitionPublishingOptions partitionOptions, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateLinkAndEnsureProducerStateAsync(String partitionId, String producerIdentifier, PartitionPublishingOptions partitionOptions, TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Producer.EventHubProducerClient.CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Producer.EventHubProducerClient.CreateBatchAsync(CancellationToken cancellationToken) at Microsoft.Azure.WebJobs.Host.Executors.VoidTaskMethodInvoker2.InvokeAsync(TReflected instance, Object[] arguments) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\VoidTaskMethodInvoker.cs:line 20 at Microsoft.Azure.WebJobs.Host.Executors.FunctionInvoker2.InvokeAsync(Object instance, Object[] arguments) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionInvoker.cs:line 52 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.InvokeWithTimeoutAsync(IFunctionInvoker invoker, ParameterHelper parameterHelper, CancellationTokenSource timeoutTokenSource, CancellationTokenSource functionCancellationTokenSource, Boolean throwOnTimeout, TimeSpan timerInterval, IFunctionInstance instance) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 581 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.ExecuteWithWatchersAsync(IFunctionInstanceEx instance, ParameterHelper parameterHelper, ILogger logger, CancellationTokenSource functionCancellationTokenSource) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 527 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.ExecuteWithLoggingAsync(IFunctionInstanceEx instance, FunctionStartedMessage message, FunctionInstanceLogEntry instanceLogEntry, ParameterHelper parameterHelper, ILogger logger, CancellationToken cancellationToken) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 306 --- End of inner exception stack trace --- at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.ExecuteWithLoggingAsync(IFunctionInstanceEx instance, FunctionStartedMessage message, FunctionInstanceLogEntry instanceLogEntry, ParameterHelper parameterHelper, ILogger logger, CancellationToken cancellationToken) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 352 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.TryExecuteAsync(IFunctionInstance functionInstance, CancellationToken cancellationToken) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 108 �[40m�[37mdbug�[39m�[22m�[49m: Host.Triggers.RabbitMQ[0] Republishing message Expected behavior connect successful Actual behavior connect time out Reproduction Steps EventHubProducerClient client = new EventHubProducerClient(request.ConnectionString, request.EventHubName); EventDataBatch eventBatch = await client.CreateBatchAsync(); eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes(payload))); await client.SendAsync(eventBatch); Environment
Mgmt	SQL	Is there a way to update the retention period of an SQL database?	Library name and version Microsoft.Azure.Management.Sql 1.0.0.71 Query/Question Is there a way to update the retention period of an SQL database? I can't find any documentation showing an update at all. Where can I look or how can I do it? Environment .NET 6 Microsoft.Azure.Management.Fluent 1.38.1 Microsoft.Azure.Management.Sql 1.0.0.71
Client	Cognitive - Speech	USP error: timeout waiting for the first audio chunk	[Enter feedback here] CANCELED: Reason=Error CANCELED: ErrorCode=ServiceTimeout CANCELED: ErrorDetails=[USP error: timeout waiting for the first audio chunk] ¿what does this error mean ? , I am consuming the api from c#, CognitiveServices.Speech. previously everything was fine from one moment to another that error came out. Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 52987a51-b478-a25d-fb5c-ff9b82d937be Version Independent ID: 1e641ee3-40e0-82ff-603c-4fca6f2552de Content: CancellationDetails.Reason Property (Microsoft.CognitiveServices.Speech) - Azure for .NET Developers Content Source: xml/Microsoft.CognitiveServices.Speech/CancellationDetails.xml Service: cognitive-services GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Search	[BUG] SearchIndexerClient class's GetSkillsets return `Invalid URI: The URI is empty.` if the entitiesDefinitionUri is null in CustomEntityLookupSkill	Library name and version Azure.Search.Documents 11.4.0 Describe the bug SearchIndexerClient class's GetSkillsets return `Invalid URI: The URI is empty.` if the entitiesDefinitionUri is null in CustomEntityLookupSkill . Below is the exception and call stack: `System.UriFormatException: Invalid URI: The URI is empty.\r\n at System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind)\r\n at System.Uri..ctor(String uriString)\r\n at Azure.Search.Documents.Indexes.Models.CustomEntityLookupSkill.DeserializeCustomEntityLookupSkill(JsonElement element)\r\n at Azure.Search.Documents.Indexes.Models.SearchIndexerSkill.DeserializeSearchIndexerSkill(JsonElement element)\r\n at Azure.Search.Documents.Indexes.Models.SearchIndexerSkillset.DeserializeSearchIndexerSkillset(JsonElement element)\r\n at Azure.Search.Documents.Indexes.Models.ListSkillsetsResult.DeserializeListSkillsetsResult(JsonElement element)\r\n at Azure.Search.Documents.SkillsetsRestClient.List(String select, CancellationToken cancellationToken)\r\n at Azure.Search.Documents.Indexes.SearchIndexerClient.GetSkillsets(CancellationToken cancellationToken)\r\n at AzSearchLab.Models.SearchIndexModel.GetSkillSet(String searchName, String apiKey) in D:\yuehai\AzSearchLab\AzSearchLabSrc\AzSearchLab\Models\SearchIndexModel.cs:line 50` From call stack and source code. I can see it is because the entitiesDefinitionUri is empty in skill definition. https://github.com/Azure/azure-sdk-for-net/blob/Azure.Search.Documents_11.4.0/sdk/search/Azure.Search.Documents/src/Generated/Models/CustomEntityLookupSkill.Serialization.cs#L164 Expected behavior It should not raise exception if the entitiesDefinitionUri is null in CustomEntityLookupSkill. Becasue the inlineEntitiesDefinition is not null. And according to our document below, The parameter inlineEntitiesDefinition supersedes the entitiesDefinitionUri parameter if present. https://learn.microsoft.com/en-us/azure/search/cognitive-search-skill-custom-entity-lookup#skill-parameters. Actual behavior It raise exception if the entitiesDefinitionUri is null in CustomEntityLookupSkill. Reproduction Steps  Add below skill in skill set  { `@odata.type`: `#Microsoft.Skills.Text.CustomEntityLookupSkill`, `name`: `#7`, `description`: `extract custom entities`, `context`: `/document/merged_content`, `defaultLanguageCode`: `en`, `entitiesDefinitionUri`: ``, `globalDefaultCaseSensitive`: true, `globalDefaultAccentSensitive`: true, `globalDefaultFuzzyEditDistance`: 0, `inputs`: [ { `name`: `text`, `source`: `/document/merged_content` } ], `outputs`: [ { `name`: `entities`, `targetName`: `features` } ], `inlineEntitiesDefinition`: [ { `name`: `city`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] }, { `name`: `breakfast`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] }, { `name`: `restaurant`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] }, { `name`: `clean`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] }, { `name`: `free parking`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] }, { `name`: `budget`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] }, { `name`: `luxury`, `description`: null, `type`: null, `subtype`: null, `id`: null, `caseSensitive`: false, `accentSensitive`: null, `fuzzyEditDistance`: null, `defaultCaseSensitive`: false, `defaultAccentSensitive`: null, `defaultFuzzyEditDistance`: null, `aliases`: [] } ] },   Run below code. it will raise exception {`Invalid URI: The URI is empty.`}      string searchServiceUri = `https://` + searchName + `.search.windows.net`;      var indexerClient = new SearchIndexerClient(new Uri(searchServiceUri), new AzureKeyCredential(apiKey));       List<string> apiSkills = new List<string>();      try      {          var skillsetstest = indexerClient.GetSkillsets();      }      catch (Exception e)      {          var exceptionMsg = e.ToString();          var msgEx = e.Message;          var innerEx = e.InnerException;      }    Environment Azure.Search.Documents 11.4.0
Client	Monitor - ApplicationInsights	[QUERY] How to read Application Insights trace and exception events?	Library name and version Azure.Monitor.Query 1.1.0 Query/Question There was an SDK before called Microsoft.Azure.ApplicationInsights which apparently could read app insights data. This is exactly what we need. However, it's deprecated and if I try to use it, zero results are returned. Nuget says this is the lib to get but... all the docs say to connect to some other thing called a `workspace`. I looked at that, and it kind of seems like app insights... but it's not. I guess it collects data from virtual machines or something? Its pretty unclear what it is, but it's not app insights. Note: I tried fooling this lib by using the ID of app insights anyway, and it says `The workspace could not be found`. Can someone please just point out the exact way to use this new library to read from App Insights trace logs? Surely it's still possible, yes? Environment Azure
Mgmt	Media Services	How to clone media asset + blobs and give it a new streaming locator using Azure.ResourceManager.Media?	Library name and version Azure.ResourceManager.Media 1.0.0 Query/Question Using the new Azure.ResourceManager.Media package I can do these hops quite nicely (for reading):-  streaming locator id -> streaming locator -> media asset -> storage container uri -> blobs  This is for a video. What I have now been tasked to do is clone the media asset and its blobs, and give it a new streaming locator id.  (The blobs representing VTT subtitles files will then probably get updated with new content.  The original media asset and its blobs must never be modified.) Is such a cloning possible?  wise?  supported? If yes, is there documentation to show how to do this? Environment Visual Studio 17.3.6 .NET 6 Hosting: Azure
Mgmt	Monitor	Timeline for Microsoft.Azure.Management.Monitor to GA	Library name and version Microsoft.Azure.Management.Monitor, 0.28.0-preview Query/Question Hi I like to use Microsoft.Azure.Management.Monitor but it correctly in preview. Is there any timeline for the GA version of this library? In advanced, it seems that it's not sync with the latest version of the Microsoft.Azure.Management.Monitor (preview) API. Thanks Shay Environment No response
Client	Service Bus	[BUG] Spelling error in tracing logs	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus Describe the bug                azure-sdk-for-net/sdk/servicebus/Microsoft.Azure.WebJobs.Extensions.ServiceBus/src/Listeners/ServiceBusListener.cs                    Line 119       in       8947cc9                                                 _details = new Lazy<string>(() => $`namespace='{_client.Value?.FullyQualifiedNamespace}', enityPath='{_entityPath}', singleDispatch='{_singleDispatch}', ` +                     Code is logging `enityPath` instead of `entityPath`. e n i t y instead of e n t i t y Expected behavior Should be outputting `entityType` Actual behavior Is outputting `enityType` Reproduction Steps Use a batched Service Bus Trigger and look at the logs. Environment No response
Client	Storage	[BUG] ASP.net with Connected Services for Azure Storage gives a Header error.	Library name and version Azure.Storage.Queues 12.11.1 Describe the bug I have been unable to get the QueueClient object to work on Restful API both locally and on an app service. Expected behavior Expecting connected services setup for ASP.net to work upon starting initialization. Actual behavior When running the ASP.net locally the error is: RequestFailedException: Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature. RequestId:** Time:2022-10-08T10:32:05.0353431Z Status: 403 (Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature.) ErrorCode: AuthenticationFailed Additional Information: AuthenticationErrorDetail: Issuer validation failed. Issuer did not match. When running on the App Service: An unhandled exception occurred while processing the request. ArgumentNullException: Value cannot be null. (Parameter 'connectionString') Reproduction Steps The way it is being initialized: builder.Services.AddAzureClients(clientBuilder => { clientBuilder.AddQueueServiceClient(builder.Configuration[`SMSGet:queue`], preferMsi: true); }); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(`/Error`); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } Then I just create a model that does this: public TestModel(ILogger logger, QueueServiceClient graphServiceClient) { _logger = logger; _graphServiceClient = graphServiceClient; ; }     public async Task OnGet()     {         var queueClient = _graphServiceClient.GetQueueClient(`queuenamehere`);  Environment .net 6 both on app services and locally on windows 11 with visual studio 2022
Client	Service Bus	[BUG] Delivery count is 0	Library name and version Azure.Messaging.ServiceBus 7.10.0 Describe the bug I have a queue and registered handlers to that queue in my code. Everything worked perfectly, but saw a strange behavior yesterday where a message was not `delivered`. I can peek the message on Servicebus explorer, but when I trigger a receive, I am getting an alert saying `there are not messages to receive`. I tried purging the queue, but getting similar message that `There are no messages to purge`.   App Insights also shows that there were no faults with any message sends. Expected behavior Message is delivered or is faulted with an exception and deadlettered. Actual behavior Delivery count is 0 Reproduction Steps Not sure how to reproduce the issue. Environment No response
Mgmt	App Services	[BUG] AppService ResourceManager: Unexpected nulls	Library name and version Azure.ResourceManager.AppService Describe the bug Azure.ResourceManager.AppService Versions 1.0.0-beta.4 and 1.0.0. Site configuration tls version and ftp state returning nulls Part code below. Client is Authenticated and receiving values for other parts of the App service. Code and response attached Expected behavior Should return app configuration values of the app services such as TLS version, FTP state etc. Actual behavior returning nulls withing the Json Text Reproduction Steps using Azure.ResourceManager; using Azure.ResourceManager.AppService; using Azure.ResourceManager.Compute; using Azure.ResourceManager.Consumption; using Azure.ResourceManager.KeyVault; using Azure.ResourceManager.Kusto; using Azure.ResourceManager.Network; using Azure.ResourceManager.Resources; using Azure.ResourceManager.Sql; Svar ArmClient = MainAuth.GetArmClient(Credentials); //Authenticates custom arm client use any arm client from here SubScriptions TheSubscriptions = new SubScriptions(); var AppServices = ArmClient.GetSubscriptions().GetAll(); var Subs = AppServices.ToList(); //Gets AppServices based on Auth Information var FirstSub = Subs.FirstOrDefault(); foreach (var r in Subs) // going through Subs { var RSGs = r.GetResourceGroups().GetAll(); foreach (var rg in RSGs) // going through resource groups {     var AppPlans = rg.GetAppServicePlans().GetAll(); //goiung through app services      foreach (var appPlan in AppPlans)     {         Console.WriteLine(appPlan.Id);         Console.WriteLine(appPlan.Data.Name);         Console.WriteLine(appPlan.Data.Kind);          var theApps = appPlan.GetWebApps().ToList();           foreach (var app in theApps)         {             Console.ReadLine();             var FullAppCOnfig = appPlan.GetWebApps(app.Name, rg.Data.Name).FirstOrDefault(); //returns nulls also although other values are populated in this data              try             {                 Console.WriteLine(FullAppCOnfig.SiteConfig.MinTlsVersion);             }             catch             {              }             try             {                 var siteconf = app.SiteConfig;                 Console.WriteLine(siteconf.MinTlsVersion.Value); //returns nulls also although other values are populated in this data              }             catch             {              }         }      }  }  } [ response.txt ](url) Environment .NET SDK (reflecting any global.json): Version:   6.0.400 Commit:    7771abd614 Runtime Environment: OS Name:     Windows OS Version:  10.0.22621 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.400\ global.json file: Not found Host: Version:      6.0.8 Architecture: x64 Commit:       55fb7ef977 .NET SDKs installed: 6.0.201 [C:\Program Files\dotnet\sdk] 6.0.400 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Download .NET: https://aka.ms/dotnet-download Learn about .NET Runtimes and SDKs: https://aka.ms/dotnet/runtimes-sdk-info PM>
Mgmt	App Services	[BUG] AppServiceSkuCapacity not serializable	Library name and version Azure.ResourceManager.AppService 1.0.0-beta.4 Describe the bug When providing an AppServiceSkuCapacity to the AppServiceSkuDescription then the call CreateOrUpdate fails with an RequestFailedException. Expected behavior Call can be made. Actual behavior Call fails with Azure.RequestFailedException: 'The request content was invalid and could not be deserialized: 'Could not find member 'skuCapacity' on object of type 'ResourceSku'. Path 'sku.skuCapacity', line 1, position 99.'. Status: 400 (Bad Request) ErrorCode: InvalidRequestContent  Content: {`error`:{`code`:`InvalidRequestContent`,`message`:`The request content was invalid and could not be deserialized: 'Could not find member 'skuCapacity' on object of type 'ResourceSku'. Path 'sku.skuCapacity', line 1, position 99.'.`}}  Headers: Cache-Control: no-cache Pragma: no-cache x-ms-failure-cause: REDACTED x-ms-request-id: 326cafe7-f807-43db-8566-ee8b494fcc06 x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED Strict-Transport-Security: REDACTED X-Content-Type-Options: REDACTED Date: Wed, 05 Oct 2022 04:55:07 GMT Content-Type: application/json; charset=utf-8 Expires: -1 Content-Length: 234 '  Reproduction Steps var data = new AppServicePlanData(AzureLocation.WestEurope); data.IsPerSiteScaling = false; data.IsElasticScaleEnabled = false; data.IsZoneRedundant = false; data.IsReserved = true; data.Kind = `elastic`; data.MaximumElasticWorkerCount = 1: data.Sku.Name = `EP1`; data.Sku.Family = `EP`; data.Sku.Size = `EP1`; data.Sku.Tier = `ElasticPremium`; data.Sku.SkuCapacity = new AppServiceSkuCapacity {  Minimum = 1,  Maximum = 10, }; var resource = resourceGroup.GetAppServicePlans()  .CreateOrUpdate(WaitUntil.Completed, rid.Name, data)  .Value;  Environment .NET SDK (reflecting any global.json):  Version:   6.0.401  Commit:    0906eae6f8  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.19042  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\6.0.401\  global.json file:   C:\data\iot\iot-environment\pocket-nuke\global.json  Host:   Version:      6.0.9   Architecture: x64   Commit:       163a63591c  .NET SDKs installed:   3.1.422 [C:\Program Files\dotnet\sdk]   6.0.202 [C:\Program Files\dotnet\sdk]   6.0.303 [C:\Program Files\dotnet\sdk]   6.0.400 [C:\Program Files\dotnet\sdk]   6.0.401 [C:\Program Files\dotnet\sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.29 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.29 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.29 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 6.0.9 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Download .NET:   https://aka.ms/dotnet-download  Learn about .NET Runtimes and SDKs:   https://aka.ms/dotnet/runtimes-sdk-info  Microsoft Visual Studio Enterprise 2022 (64-bit) - Current Version 17.3.5
Service	Cognitive - Form Recognizer	[Featue Req] - Form Recognizer KeyValuePair Object missing Boundary Box Collection	Library name and version Azure.AI.FormRecognizer 4.0 Describe the bug From the DocumentKeyValuePair List of the result object there doens't seem to be a way to get the bounding polygon. Only the Key, Value and confidence seem to be available. Please add in the ability to retrieve the postiion from the DocumentKeyValuePair  list of the result object Expected behavior Expect to get the position of the KVPs from the DocumentKeyValuePair Actual behavior Can not get the position from the DocumentKeyValuePair  list of the result object Reproduction Steps Analyze a document with the prebuilt document model and iterate over the KeyValuePairs of the result. Environment Windows server 2016 .Net 4.7.2 Forms Recognizer 3 Azure.AI.FormRecognizer 4.0 Beta 5
Client	Service Bus	[BUG] AMQP 5671 communication with a SSL/TLS header	Library name and version Azure.Messaging.Servicebus 7.8.0 Describe the bug I am using the Azure Service Bus .net sdk 7.8.0 Azure.Messaging.ServiceBus. I am facing an issue w.r.t the firewall rules. My application uses transport type as amqptcp. I requested the outbound ports 5671,5672 be opened for the Service bus hostname in the firewall. I deployed this application to one customer and it is working fine. For another customer where the firewall shows 5671/2 are open, the application registers connection error logs. The firewall team says the application is sending SSL packets over 5671 which is a non-standard way of doing things. I am unable to understand why the same application is behaving differently in two places. The firewall team says TCP/5671 is open but there cannot be SSL headers or packets over it. The firewall is Layer7 PaloAlto for both customers. I tried to show the Microsoft documentation that it is AMQP over TLS and they still say SSL packets over 5671 are disallowed. Please throw some light. Expected behavior I think SSL header should not be sent with AMQP 5671 Actual behavior SSL header is sent Reproduction Steps I am using the Azure Service Bus .net sdk 7.8.0 Azure.Messaging.ServiceBus. I am facing an issue w.r.t the firewall rules. My application uses transport type as amqptcp. I requested the outbound ports 5671,5672 be opened for the Service bus hostname in the firewall. I deployed this application to one customer and it is working fine. For another customer where the firewall shows 5671/2 are open, the application registers connection error logs. The firewall team says the application is sending SSL packets over 5671 which is a non-standard way of doing things. I am unable to understand why the same application is behaving differently in two places. The firewall team says TCP/5671 is open but there cannot be SSL headers or packets over it. The firewall is Layer7 PaloAlto for both customers. I tried to show the Microsoft documentation that it is AMQP over TLS and they still say SSL packets over 5671 are disallowed. Please throw some light. Environment No response
Service	Cognitive - Form Recognizer	[BUG] Azure Form Recognizer Prebuilt Business Card Template code.	Library name and version Azure Form Recognizer (2022-08-31) (GA) Describe the bug Template Prebuilt Business Card operations with the Azure Form Recognizer client library code a bug AsList() , AsDictionary() , AsString() example ContactNamesField.AsList() contactNameField.AsDictionary(); firstNameField.AsString(); foreach (DocumentField contactNameField in **ContactNamesField.AsList()**)    if (contactNameField.**ValueType** == DocumentFieldType.Dictionary)                 {                     IReadOnlyDictionary<string, DocumentField> contactNameFields = **contactNameField.AsDictionary();**                      if (contactNameFields.TryGetValue(`FirstName`, out DocumentField firstNameField))                     {                         if (firstNameField.ValueType == DocumentFieldType.String)                         {                             string firstName **= firstNameField.AsString();**  Expected behavior Template Prebuilt Business Card operations with the Azure Form Recognizer client library code must be changed as AsList() , AsDictionary() , AsString() convert from Value field. ContactNamesField.Value.AsList() contactNameField.Value.AsDictionary() firstNameField.Value.AsString()  foreach (DocumentField contactNameField in **ContactNamesField.Value.AsList()**)                         {                             Console.WriteLine(`Contact Name: `);                              if (contactNameField.FieldType == DocumentFieldType.Dictionary)                             {                                 IReadOnlyDictionary<string, DocumentField> contactNameFields = **contactNameField.Value.AsDictionary()**;                                  if (contactNameFields.TryGetValue(`FirstName`, out DocumentField firstNameField))                                 {                                     if (firstNameField.FieldType == DocumentFieldType.String)                                     {                                         string firstName = **firstNameField.Value.AsString()**;                                     }                                 }   Actual behavior https://formrecognizer.appliedai.azure.com/studio/prebuilt?formType=businessCard Reproduction Steps https://formrecognizer.appliedai.azure.com/studio/prebuilt?formType=businessCard Refer Code area and select C# Environment https://formrecognizer.appliedai.azure.com/studio/prebuilt?formType=businessCard
Client	Event Hubs	partition availability and sdk behavior	Library name and version Azure.Messaging.EventHubs Query/Question Provided the client must have consistency, which is being achieved through adding the partitionKey when sending the message, the following things are unclear: Why does a partition become not available, and is there any exception/notification forwarded to the client by the sdk, so the client is aware a partition is down In case message A was sent with partitionKey PK and the partition becomes unavailable, when a new message B with the same partitionKey PK is published, to which partition will it end Environment No response
Client	Event Hubs	The processor instance ... owns a higher than recommended number of partitions for average workloads	Library name and version Azure.Messaging.EventHubs Query/Question Hi, With the latest SDK we started getting the below error: Azure.Messaging.EventHubs[104] The processor instance with identifier '696b32d5-0a4c-4a9f-b79e-7aabe9456f8a' for Event Hub: xxx-xxxxxxx-xxxx-xxxxxx-xxxxx owns a higher than recommended number of partitions for average workloads. Owning too many partitions can cause slow performance and stability issues. Consider monitoring performance and partition ownership stability to ensure that they meet expectations. If not, adding processors to the group may help. Total partition count: '4'. Owned partition count: '4'. Maximum recommended partitions owned: '3'. I cannot see any documentation regarding it, especially for the part `Consider monitoring performance and partition ownership stability to ensure that they meet expectations` - what exactly is unstable/slow in case too many partitions are handled by 1 EventProcessorClient? Additionally, why is there no way to suppress this? Standard Event Hubs do not allow changing the partition count after creation, so we are somehow punished all of a sudden for something we cannot even fix, or? Br, Deyan Environment No response
Client	Event Hubs	[BUG] EventDataBatch.TryAdd sporadic exceptions with same data	Library name and version Azure.Messaging.EventHubs 5.7.2 Describe the bug I have a function app with a function that needs to produce events for an EventHub. There is a class which has an initialized EventHubProducerClient called `client` and the method that sends the events is as follows: using Azure.Messaging.EventHubs; using Azure.Messaging.EventHubs.Producer; using Microsoft.Extensions.Logging; using XXX.YYY.Messaging.Interfaces; using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks;  namespace XXX.YYY.Messaging.Implementations {     public class SingleEventHubClient : ISingleEventHubClient     {         private readonly EventHubProducerClient client;         private readonly ILogger logger;          public string EventHubName => this.client.EventHubName;          public SingleEventHubClient(EventHubProducerClient client, ILogger logger)         {             if (client is null) throw new ArgumentNullException(nameof(client));             this.client = client;             this.logger = logger;         }          public static SingleEventHubClient Create(string connectionString, string targetEventHub, ILogger logger)         {             if (targetEventHub == null || string.IsNullOrEmpty(targetEventHub)) throw new ArgumentNullException(nameof(targetEventHub));             if (connectionString == null || string.IsNullOrEmpty(connectionString)) throw new ArgumentNullException(nameof(connectionString));              return new SingleEventHubClient(new EventHubProducerClient(connectionString, targetEventHub), logger);         }          /// <summary> Splits data in batches and calls the SendAsync on the EventClient as many times as needed</summary>         /// <param name=`events`></param>         public async Task<int> SendAsync(IEnumerable<EventData> events)          {             var eventsSent = 0;             if (events == null) throw new ArgumentNullException(nameof(events));             if (events.Count() == 0)             {                 return eventsSent;             }              var skipErrorMessage = $`Skipping single chunk of event data that exceeds the limit of EventHub message.`;             EventDataBatch batch = null;             try             {                 batch = await client.CreateBatchAsync().ConfigureAwait(false);                 foreach (var @event in events)                 {                                   if (!batch.TryAdd(@event))                     {                         //now either batch is full and ready to be sent or the single event is too big to be sent                         if (batch.Count == 0)                         {                             this.logger.LogError(skipErrorMessage);//we just skip but processing won't fail (like in previous implementation)                         }                         else                         {                             await this.client.SendAsync(batch).ConfigureAwait(false);                             eventsSent += batch.Count;                             batch.Dispose();                             batch = await client.CreateBatchAsync().ConfigureAwait(false);                             if (!batch.TryAdd(@event))                             {                                 //the batch was full, but also the single event is too big                                 this.logger.LogError(skipErrorMessage);//we just skip but processing won't fail (like in previous implementation)                             }                         }                     }                 }                 if(batch.Count > 0)//could be zero only if the last event is one of the `too big on its own` events                  {                     await this.client.SendAsync(batch).ConfigureAwait(false);                     eventsSent += batch.Count;                 }                  return eventsSent;             }             finally              {                 batch?.Dispose();             }                            }     } } Here is the calling class: using Azure.Messaging.EventHubs; using Microsoft.Extensions.Logging; using Newtonsoft.Json; using XXX.YYY.Common.ExtensionMethods; using XXX.YYY.Messaging.Exceptions; using XXX.YYY.Messaging.Interfaces; using System; using System.Collections.Generic; using System.Data; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace XXX.YYY.Messaging.Implementations {     public sealed class EventHubSender : IEventHubSender     {         private readonly ISingleEventHubClient[] eventHubClients;         private readonly ILogger logger;          public EventHubSender(IEnumerable<ISingleEventHubClient> eventHubClients, ILogger logger)         {             this.eventHubClients = eventHubClients.ToArray();             this.logger = logger;         }          public async Task<int> SendAsync<T>(IEnumerable<T> items)         {             if (items is null) throw new ArgumentNullException(nameof(items));              if (!items.Any()) return 0;              if (eventHubClients.Length <= 0)             {                 logger.LogInformation(`There are no consumer groups for this system type in this environment. No events will be sent.`);                 return 0;             }              var tasks = new List<Task<int>>();              var allEventData = ConvertToEventData(items);              foreach (var eventHubClient in this.eventHubClients)             {                 tasks.Add(eventHubClient.SendAsync(allEventData));             }              var results = await Task.WhenAll(tasks).ConfigureAwait(false);                          if(!results.All(x => x == results.First()))//if we sent different number of events to the various hubs something is wrong             {                 logger.LogError($`Different number of events send to the event hubs: {string.Join(` `, results)}`);                 throw new SentEventsNumberMismatchException();             }              return results.First();         }          private IEnumerable<EventData> ConvertToEventData<T>(IEnumerable<T> items)         {             var eventData = new List<EventData>();             foreach (var item in items)             {                 var bytesToSend = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(item));                 eventData.Add(new EventData(bytesToSend));             }             return eventData;         }     } } The list of messages needs to be sent to multiple event hubs at the same time, that's why the same list of messages is sent to multiple ISingleEventHubClients. Most of the times this works, but I randomly get the following exceptions: Collection was modified; enumeration operation may not execute.  System.InvalidOperationException:       at System.ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Collections.Generic.Dictionary`2+Enumerator.MoveNext (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at Azure.Messaging.EventHubs.Amqp.AmqpMessageConverter.BuildAmqpMessageFromEvent (Azure.Messaging.EventHubs, Version=5.7.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)       at Azure.Messaging.EventHubs.Amqp.AmqpEventBatch.TryAdd (Azure.Messaging.EventHubs, Version=5.7.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)       at Azure.Messaging.EventHubs.Producer.EventDataBatch.TryAdd (Azure.Messaging.EventHubs, Version=5.7.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)       at XXX.YYY.Messaging.Implementations.SingleEventHubClient+<SendAsync>d__6.MoveNext (XXX.YYY.Messaging, Version=1.0.0.45, Culture=neutral, PublicKeyToken=null)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.Messaging.Implementations.EventHubSender+<SendAsync>d__3`1.MoveNext (XXX.YYY.Messaging, Version=1.0.0.45, Culture=neutral, PublicKeyToken=null)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.DataProcessing.AggregateData.AggregateDataProcessor+<ProcessTriggerAsync>d__8.MoveNext (XXX.YYY.DataProcessing, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: D:\a\1\s\AggregateData\AggregateDataProcessor.cs:109)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.DataProcessing.AggregateData.AggregateDataProcessor+<ProcessTriggerAsync>d__8.MoveNext (XXX.YYY.DataProcessing, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: D:\a\1\s\AggregateData\AggregateDataProcessor.cs:151)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.DataProcessing.AggregateData.AggregateDataFunction+<Run>d__2.MoveNext (XXX.YYY.DataProcessing, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: D:\a\1\s\AggregateData\AggregateDataFunction.cs:43)  or Object reference not set to an instance of an object.  System.NullReferenceException:       at System.Collections.Generic.Dictionary`2.TryInsert (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)   at System.Collections.Generic.Dictionary`2.set_Item (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at Azure.Messaging.EventHubs.Diagnostics.EventDataInstrumentation.InstrumentEvent (Azure.Messaging.EventHubs, Version=5.7.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)       at Azure.Messaging.EventHubs.Producer.EventDataBatch.TryAdd (Azure.Messaging.EventHubs, Version=5.7.2.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)       at XXX.YYY.Messaging.Implementations.SingleEventHubClient+<SendAsync>d__6.MoveNext (XXX.YYY.Messaging, Version=1.0.0.45, Culture=neutral, PublicKeyToken=null)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.Messaging.Implementations.EventHubSender+<SendAsync>d__3`1.MoveNext (XXX.YYY.Messaging, Version=1.0.0.45, Culture=neutral, PublicKeyToken=null)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.DataProcessing.AggregateData.AggregateDataProcessor+<ProcessTriggerAsync>d__8.MoveNext (XXX.YYY.DataProcessing, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: D:\a\1\s\AggregateData\AggregateDataProcessor.cs:109)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.DataProcessing.AggregateData.AggregateDataProcessor+<ProcessTriggerAsync>d__8.MoveNext (XXX.YYY.DataProcessing, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: D:\a\1\s\AggregateData\AggregateDataProcessor.cs:151)       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)       at XXX.YYY.DataProcessing.AggregateData.AggregateDataFunction+<Run>d__2.MoveNext (XXX.YYY.DataProcessing, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: D:\a\1\s\AggregateData\AggregateDataFunction.cs:43)  The interesting thing is that the data passed as input is the same. Could this be a problem with the client? Maybe with multithreading? Expected behavior I do not get exceptions Actual behavior Please see description Reproduction Steps Difficult to reproduce because sporadic, see description for a possible code snippet. Environment  OS platform and version: Function app on Azure - Windows OS .NET Version: .NET Core 3.1 NuGet package version or commit ID: 5.7.2
Mgmt	App Services	Clarification of AppServicePlan.MaximumElasticWorkerCount property	This needs at least some minimal clarification of how this property relates to the AppServicePlan.MaximumElasticWorkerCount Property. I cannot find any documentation that clarifies it, and looking at properties on my Elastic App Service Plan to try to infer its use or meaning hasn't gotten anywhere.  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: af1d6c28-0206-83cb-5200-efe7c5625831 Version Independent ID: 918ddb5b-27e8-19e6-5c78-698b5347266f Content: AppServicePlan.MaximumNumberOfWorkers Property (Microsoft.Azure.Management.WebSites.Models) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Management.WebSites.Models/AppServicePlan.xml Service: app-service GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Identity	How to construct a client secret credential without providing a client secret	Library name and version Azure.Identity 1.7.0 Query/Question We are working on a CLI tool that has a login command in which the user provides a client id and a client secret to fetch the token and we enable token caching. Other commands need an access token that is stored in the cache. Can we instantiate a ClientSecretCredential class without providing the client secret and get a token from the store after the first log in that fetches the access token? Environment No response
Client	Azure.Core	[QUERY] Prevent `REDACTED` of some headers	Library name and version Azure.ResourceManager 1.3.1 Query/Question Is there a way to configure logging additional headers for request/response logging? I turned it on, but I need to log several headers that are REDACTED. For example, these two:  Azure-AsyncOperation x-ms-correlation-request-id  [Informational] Azure-Core: Request [1e5babb9-01f3-4b8e-8253-5ed1548e9faf] PUT https://management.azure.com/subscriptions/1d4a7bc7-6378-420f-900b-d1c7f8be28b7/resourceGroups/fct-ct-prod-auseast-full-944/providers/Microsoft.AVS/privateClouds/fct-ct-p01-auseast-full-944/workloadNetworks/default/vmGroups/fctVmGroup2?api-version=2022-05-01 Accept:application/json x-ms-correlation-request-id:REDACTED x-ms-client-request-id:1e5babb9-01f3-4b8e-8253-5ed1548e9faf x-ms-return-client-request-id:true User-Agent:azsdk-net-ResourceManager.Avs/1.0.0-beta.2,(.NET 6.0.9; Linux 5.4.0-1091-azure #96~18.04.1-Ubuntu SMP Tue Aug 30 19:15:32 UTC 2022) Authorization:REDACTED Content-Type:application/json client assembly: Azure.ResourceManager [Verbose] Azure-Core: Request [1e5babb9-01f3-4b8e-8253-5ed1548e9faf] content: {`properties`:{`displayName`:`fctVmGroup2`,`members`:[`TNT11-NSX-APP01`]}} [Informational] Azure-Core: Response [1e5babb9-01f3-4b8e-8253-5ed1548e9faf] 201 Created (01.2s) Cache-Control:no-cache Pragma:no-cache Retry-After:10 x-ms-ratelimit-remaining-subscription-writes:REDACTED Azure-AsyncOperation:REDACTED x-ms-client-request-id:1e5babb9-01f3-4b8e-8253-5ed1548e9faf x-ms-request-id:883e2e56-ff9e-4e99-bea5-024801065b12 Strict-Transport-Security:REDACTED x-ms-correlation-request-id:REDACTED x-ms-routing-request-id:REDACTED X-Content-Type-Options:REDACTED Date:Thu, 22 Sep 2022 08:16:40 GMT Content-Length:404 Content-Type:application/json; charset=utf-8 Expires:-1  I see an `allow` list may currently hardcoded:                azure-sdk-for-net/sdk/mgmtcommon/ClientRuntime/ClientRuntime/Utilities/HttpRequestSanitizer.cs                   Lines 16 to 44       in       25b9d3c                                                 private readonly static HashSet<string> _allowedHeaders = new HashSet<string>(new string[]                                           {                                               `x-ms-request-id`,                                               `x-ms-client-request-id`,                                               `x-ms-return-client-request-id`,                                               `traceparent`,                                               `MS-CV`,                                                                                          `Accept`,                                               `Cache-Control`,                                               `Connection`,                                               `Content-Length`,                                               `Content-Type`,                                               `Date`,                                               `ETag`,                                               `Expires`,                                               `If-Match`,                                               `If-Modified-Since`,                                               `If-None-Match`,                                               `If-Unmodified-Since`,                                               `Last-Modified`,                                               `Pragma`,                                               `Request-Id`,                                               `Retry-After`,                                               `Server`,                                               `Transfer-Encoding`,                                               `User-Agent`,                                               `WWW-Authenticate` // OAuth Challenge header.                                               }, StringComparer.OrdinalIgnoreCase);                     If we could configure a `deny` list, that would be even better. Environment No response
Client	Service Bus	[QUERY] What is the value of using ModelFactory classes over interfaces?	Library name and version Azure.Messaging.ServiceBus Query/Question Out of curiosity, could anyone please help us understand the value of this ModelFactory class giving us real implementation objects for testing purposes, as opposed to the objects themselves implementing interfaces? (which makes them easily mockable) Take SubscriptionProperties for example, if this class simply implemented an interface we could mock it in a single line of code. Instead we need to use a static ModelFactory class to new it up, and give it all the min/max values it needs even if they're not relevant to our test, for our test to then run the real implementation code for SubscriptionProperties. https://github.com/Azure/azure-sdk-for-net/blob/62f2223e46c33825628443d11b8267de4e72a1c6/sdk/servicebus/Azure.Messaging.ServiceBus/src/Primitives/ServiceBusModelFactory.cs Environment No response
Mgmt	Compute	[BUG] WaitForCompletionResponseAsync on ComputeArmOperation seems to be stuck in infinite loop	Library name and version Azure.ResourceManager.Compute 1.0.0 Describe the bug When calling (and awaiting) VirtualMachineResource.PowerOnAsync(Azure.WaitUntil.Completed), or VirtualMachineResource.PowerOnAsync(Azure.WaitUntil.Started) and then ArmComputeOperation.WaitForCompleteResponseAsync() thereafter, it seems the operation does not complete in a foreseeable amount of time. Specifically, my underlying (Linux) VM is already good and ready to go (SSH-able) in around 1-2min but the operation can go on for more than 5 minutes without any response. Expected behavior PowerOnAsync(Azure.WaitUntil.Completed) should return once the VM has started (usually not more than 1-2 min). Actual behavior PowerOnAsync(Azure.WaitUntil.Completed) stays in an infinite loop as seen in WaitForCompletionAsync(bool async, OperationInternalBase operation, TimeSpan? suggestedInterval, CancellationToken cancellationToken) in OperationPoller.cs Reproduction Steps Calling PowerOnAsync(Azure.WaitUntil.Completed) on VirtualMachineResource. Environment No response
Client	Service Bus	azure service bussss session processor	Library name and version Azure.Messaging.ServiceBus   7.5.1 Describe the bug i use    c#   7.5.1  Azure.Messaging.ServiceBus  sdk , use session queue consumer message . language is c#  .aspnetcore web . cause Azure.Messaging.ServiceBus.ServiceBusException: The session lock has expired on the MessageSession. Accept a new MessageSession. this exception cause my new message cannot consumer( some new message cannot execute by MessageHandler ) . how to consumer this message . Expected behavior 1 Actual behavior Azure.Messaging.ServiceBus.ServiceBusException: The session lock has expired on the MessageSession. Accept a new MessageSession. Reproduction Steps 1 Environment aspnet core web  3.1
Client	Azure.Identity	App authentication with ManagedIdentityCredential for MySQL Entity Framework Core	Library name and version Azure.Identity Query/Question I'm unsure whether this is a bug, or something that isn't supported at the moment, or whether this is an issue with entity framework. I currently use AzureServiceTokenProvider for app authentication with user managed identity to connect to mysql database like: var provider = new AzureServiceTokenProvider($`RunAs=App;AppId={managedIdentityClientId}`); var token = await provider.GetAccessTokenAsync(_dbScope); connection.Password = token; optionsBuilder.UseMySQL(connection);  This works fine, but then I've read https://learn.microsoft.com/en-us/dotnet/api/overview/azure/app-auth-migration mentioning   that AzureServiceTokenProvider will eventually be deprecated. Looking at the documents, it says to use new ManagedIdentityCredential(appId) instead. However, altering my code to use like: var cred = new ManagedIdentityCredential(managedIdentityClientId); var token = await cred .GetTokenAsync(new Azure.Core.TokenRequestContext(new[] { `https://ossrdbms-aad.database.windows.net` })); connection.Password = token.Token; optionsBuilder.UseMySQL(connection);  Doesn't work. To be accurate... the token DOES work when I try to connect to the database myself using the same managed identity's user that was set up on server side. But when ran in an azure container app, it will throw an exception of: System.InvalidOperationException: No database provider has been configured for this DbContext I've also tried using DefaultAzureCredentials and have the same result. As soon as I use AzureServiceTokenProvider, it works again. Looking at https://learn.microsoft.com/en-us/azure/app-service/tutorial-connect-msi-azure-database?tabs=mysql%2Cuserassigned%2Cdotnet%2Cps#3-modify-your-code it does give an example with using MySqlClient. Am I doing something wrong? Environment  .net 6.0 Azure Container Apps MySql.Data.EntityFramework Azure Database for MySQL servers
Client	Cognitive - Form Recognizer	No guidelines regarding the lifecycle of the client	Creating a new instance of HttpClient on every request can lead to socket exhaustion. If the DocumentAnalysisClient uses an HttpClient or similar internally, creating a new instance of DocumentAnalysisClient on every request can also lead to socket exhaustion. It would be nice to point out in this page or elsewhere in the documentation what are the recommended guidelines regarding the client. Should we use a single instance (or a few instances) for the entire lifecycle of our app? Is it ok to create a new instance each time? On a related note, if a single instance is recommended, are the client methods thread-safe?  Document Details ⚠ Do not edit this section. It is required for learn.microsoft.com ➟ GitHub issue linking.  ID: 85001c09-27e6-e148-5636-466cee185617 Version Independent ID: e858d687-fa9e-1916-c5a6-a26eda23aeda Content: DocumentAnalysisClient Class (Azure.AI.FormRecognizer.DocumentAnalysis) - Azure for .NET Developers Content Source: xml/Azure.AI.FormRecognizer.DocumentAnalysis/DocumentAnalysisClient.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Service Bus	[BUG] - Trace ParentId is not restored from Diagnostic-Id message property	Library name and version Azure.Messaging.ServiceBus 7.10.0 Describe the bug I'm investigating W3C context propagation over ServiceBus. It looks like message sent correctly with valid Diagnostic-Id is not correlated correcly during the message read handling. For both servicebusreceiver.receive and servicebusprocessor.processmessage operations the ParentId property is null. Because of that, these operations are reported as separated traces instead of one trace, started on the web api request.  I tried to set ParentId manually with lines like:     private async Task ProcessorOnProcessMessageAsync(ProcessMessageEventArgs arg)     {         var bodyAsString = arg.Message.Body.ToString();         var diagnosticsId = arg.Message.ApplicationProperties[`Diagnostic-Id`].ToString();         using var activity = new Activity(`ServiceBusProcessor.processing`);         activity.SetParentId(diagnosticsId);         activity.Start();          [...]         activity.Stop();     } but it moves only user-code to the correct trace. Both servicebusreceiver.receive and servicebusprocessor.processmessage operations are received outside of the flow  Expected behavior ServiceBus reader (both processor and receiver) should use TraceId from Diagnostic-Id as a ParentTraceId Actual behavior servicebusreceiver.receive and servicebusprocessor.processmessage don't read ParentTraceId Reproduction Steps Available at https://github.com/lukasz-pyrzyk/opentelemetry-demo, API and webjob project, together with HTTP request to start the flow. Environment No response
Client	Tables	[QUERY] How to query by Timestamp in Azure.Data.Tables?	Library name and version Azure.Data.Tables 12.6.1.0 Query/Question I'm sure I'm just missing something here, but I'm having an issue trying to query entities from my tables when filtering only by Timestamp.  I've tried the following filter conditions to retrieve data: Expression Filter var results = table.Query<TableEntity>(x => x.Timestamp >= DateTime.Parse(`2021-09-10T14:26:22.251Z`)) OData Filter var results = table.Query<TableEntity>(filter: `Timestamp ge datetime'2021-09-10T14:26:22.251Z'`); As previously mentioned, both queries do not return any results. I've verified there's data in my table that satisfies this condition by running a  query that filters by a PartitionKey and inspecting the return data.  I'm on a fairly tight deadline for this work, so any help would be greatly appreciated! Environment OS: Windows - net4.8 IDE: Microsoft Visual Studio Professional 2022 (64-bit) - Current Version 17.3.4
Client	Search	[BUG] Search: Protocol validation prevents use with local emulator	Library name and version Azure.Search.Documents Describe the bug On this line: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/search/Azure.Search.Documents/src/SearchClient.cs#L196 Its throwing an error if the endpoint isn't https. I am using an emulator for local development and it is http instead. This class shouldn't attempt to validate the scheme, it's not really its concern. Expected behavior I expect it to not throw an exception when provided an http scheme endpoint url. Actual behavior It throws an ArgumentException saying the scheme must be https. Reproduction Steps new SearchClient(`http://localhost:8080`, `test`, null);  Environment > dotnet --info .NET SDK (reflecting any global.json):  Version:   6.0.202  Commit:    f8a55617d2  Runtime Environment:  OS Name:     Mac OS X  OS Version:  12.5  OS Platform: Darwin  RID:         osx.12-x64  Base Path:   /usr/local/share/dotnet/sdk/6.0.202/  Host (useful for support):   Version: 6.0.4   Commit:  be98e88c76  .NET SDKs installed:   5.0.400 [/usr/local/share/dotnet/sdk]   6.0.200 [/usr/local/share/dotnet/sdk]   6.0.201 [/usr/local/share/dotnet/sdk]   6.0.202 [/usr/local/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.App 5.0.9 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.2 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 6.0.4 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 5.0.9 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.2 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.3 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 6.0.4 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]  To install additional .NET runtimes or SDKs:   https://aka.ms/dotnet-download
Client	Synapse	[QUERY] Dynamic Spark pool allocation	Library name and version Azure.Analytics.Synapse.Artifacts 1.0.0-preview.15 Query/Question I would like to find which Spark Pool is being used, and which has free resources, in order to choose a pool dynamically at runtime, based on availability. I do not believe BigDataPoolResourceInfo can tell us that? Thank you Environment Microsoft Visual Studio Enterprise 2022 (64-bit) - Version 17.2.7 .Net 6.0
Client	Cosmos	The example does not show how to actually create a new serializer	[Enter feedback here]  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: bcf65e06-a315-9182-3fb6-a2926733ad10 Version Independent ID: e2e4e384-de01-a52e-5c00-f49fd8561a0f Content: CosmosClientOptions.Serializer Property (Microsoft.Azure.Cosmos) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Cosmos/CosmosClientOptions.xml Service: cosmos-db GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Mixed Reality	[QUERY] Spatial Anchors cannot locate assembly	Library name and version Microsoft.Azure.SpatialAnchors.AnchorLocateCriteria..ctor Query/Question DllNotFoundException: AzureSpatialAnchors assembly: type: member:(null) Microsoft.Azure.SpatialAnchors.AnchorLocateCriteria..ctor () (at Library/PackageCache/com.microsoft.azure.spatial-anchors-sdk.windows@62b3e83507a2/Runtime/AzureSpatialAnchorsBridge_Windows.cs:1938) AnchorModuleScript. Start () (at Assets/MRTK.Tutorials.AzureSpatialAnchors/Scripts/AnchorModuleScript.cs:42) Environment No response
Mgmt	Container Instances	[BUG] Microsoft.Azure.Management.ContainerInstance.Models.InstanceView.CurrentState.State is always empty	Library name and version Assembly Microsoft.Azure.Management.ContainerInstance, Version=7.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35 Describe the bug I am trying to get the state of a Azure Container Group's container, here is my code: ` IAzure azure = Microsoft.Azure.Management.Fluent.Azure.Authenticate(azureCredential).WithSubscription(_containerOptions.AzureSubscriptionId); var response = (await client.ContainerGroups.ListByResourceGroupWithHttpMessagesAsync(_containerOptions.ResourceGroup));         foreach (var containerGroup in response.Body.Where(cg=>cg.ProvisioningState == `Succeeded` &&              cg.Name.StartsWith(_containerOptions.AzureContainerPrefix, StringComparison.InvariantCultureIgnoreCase)))         {             If (containerGroup.Containers[0].InstanceView.CurrentState.State == `something`)             {                    do something             }  ` Expected behavior Microsoft.Azure.Management.ContainerInstance.Models.InstanceView.CurrentState.State should return actual state of a container, such as Running, Failed, Terminated, etc Actual behavior It returns empty string Reproduction Steps deploy a container instance, using helloworld image. use the code above to get the state of that container Environment I run that code in Azure function
Client	Functions	[BUG] Service Bus - Renew Message Lock Exception	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.7.0 Azure.Messaging.ServiceBus 7.10.0 Describe the bug An unexpected error occurs terminating the process whilst attempting to renew a message lock within a V4 Azure Function (.NET 6 in process) using the Service Bus Queue Trigger. Using the following libraries and their versions: Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.7.0 Azure.Messaging.ServiceBus 7.10.0 Expected behavior The message lock is renewed for the duration set for the service bus queue. Actual behavior An error occurs whilst attempting to renew the message lock throwing an exception with the following message: System.Private.CoreLib: Exception while executing function: ImportServiceBus. System.Private.CoreLib: Could not find the resource `Azure.Messaging.ServiceBus.Resources.resources` among the resources `` embedded in the assembly `Microsoft.Azure.WebJobs.Extensions.ServiceBus`, nor among the resources in any satellite assemblies for the specified culture. Perhaps the resources were embedded with an incorrect name. The actual exception is: System.Resources.MissingManifestResourceException Reproduction Steps To reproduce, it requires the following:  Azure Service Bus Queue (in the example code below, this queue is called 'import queue') with sessions enabled V4 Azure Function (in process .NET 6) using the service bus queue trigger Add aforementioned packages (in bug description) to project using Nuget Use the following code below to replace the pre-existing run method for the function.  public async Task Run([ServiceBusTrigger(`import-queue`, Connection = `ConnectionString`, IsSessionsEnabled = true)] ServiceBusReceivedMessage message, ServiceBusSessionMessageActions sessionActions, ServiceBusReceiveActions receiveActions)   {   await sessionActions.RenewMessageLockAsync(message); return;}  Run the function Send a message to queue and an error occurs when attempting to call the renew message lock  Environment Windows 10 .NET 6 (6.0.302) Microsoft Visual Studio Community 2022 (64-bit) 17.2.6
Client	Service Bus	[BUG] Service Bus Extension: Unable to process the request exceptions	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.3 Transitive package: Azure.Messaging.ServiceBus 7.7.0 SDK version | azurefunctions: 4.8.0.0 Describe the bug Hi, I’m using Azure Service Bus and get a very weird exception in Application Insights which I cannot figure out what could it mean and how can I fix it. It appears in our Function apps only therefore I suspect that the problem could happen in the Microsoft.Azure.WebJobs.ServiceBus.Listeners.ServiceBusListener. Exception: Azure.Messaging.ServiceBus.ServiceBusException Message: The service was unable to process the request; please retry the operation. For more information on exception types and proper exception handling, please refer to http://go.microsoft.com/fwlink/?LinkId=761101, SystemTracker:gateway7, Timestamp:2022-09- 06T20:11:33 (GeneralError) Failed method: Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<ReceiveMessagesAsyncInternal>d__39.MoveNe xt Category: Microsoft.Azure.WebJobs.ServiceBus.Listeners.ServiceBusListener Formatted message: An unhandled exception occurred in the message batch receive loop (singleDispatch='False', isSessionsEnabled='False') Call Stack: Azure.Messaging.ServiceBus.ServiceBusException: at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+&lt;ReceiveMessagesAsyncInternal&gt;d__39.MoveNe xt (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+&lt;&gt;c+&lt;&lt;ReceiveMessagesAsync&gt;b__38_0&gt;d.Move  Next (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Threading.Tasks.ValueTask`1.get_Result (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1+ConfiguredValueTaskAwaiter.G etResult (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy+&lt;RunOperation&gt;d__21`2.MoveNext (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy+&lt;RunOperation&gt;d__21`2.MoveNext (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+&lt;ReceiveMessagesAsync&gt;d__38.MoveNext (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)  at Azure.Messaging.ServiceBus.ServiceBusReceiver+&lt;ReceiveMessagesAsync&gt;d__39.MoveNext (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Azure.Messaging.ServiceBus.ServiceBusReceiver+&lt;ReceiveMessagesAsync&gt;d__38.MoveNext (Azure.Messaging.ServiceBus, Version=7.7.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e) at Microsoft.Azure.WebJobs.ServiceBus.Listeners.ServiceBusListener+&lt;RunBatchReceiveLoopAsync&gt;d_ _28.MoveNext (Microsoft.Azure.WebJobs.Extensions.ServiceBus, Version=5.3.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)  The use case is that I have a Service Bus Queue and a function app receives list of Service Bus messages. The exception does not happen during processing of these messages but by during message consumption it looks like. Any help or some further/deeper insights would be appreciated. Thanks a lot! Expected behavior No exception is thrown Actual behavior There are some exceptions daily and irregularly Reproduction Steps Just receive batch of messages from a Service Bus Queue in an Azure Function app. Environment No response
Client	Service Bus	[QUERY] Azure.Messaging.ServiceBus_7.11.0-beta.1	Library name and version Azure.Messaging.ServiceBus Query/Question The release notes for Azure.Messaging.ServiceBus 7.11.0-beta.1 state there's a breaking change  Breaking Changes Improved performance of sending messages by using the ServiceBusMessageBatch type, by caching the underlying AMQP message as opposed to recalculating it when sending. Because of this change, any changes to a ServiceBusMessage after it has already been added to the batch will no longer be reflected in the batch and what is ultimately sent to the service. To avoid any issues from this change, ensure that yo are not modifying the ServiceBusMessage after adding it to a batch.  As a breaking change, I'd expect the package to be released with a new major. What's the reason it's released as a minor? Environment No response
Client	Event Hubs	[QUERY] Is ProcessEventAsync & ProcessErrorAsync are thread safe?	Library name and version Azure.Messaging.EventHubs.Processor 5.7.2 Query/Question I was thinking of using EventProcessorClient as a singleton. It is mentioned here  The EventProcessorClient is safe to cache and use as a singleton for the lifetime of the application, which is best practice when events are being read regularly. The clients are responsible for efficient management of network, CPU, and memory use, working to keep usage low during periods of inactivity. Calling StopProcessingAsync or StopProcessing on the processor is required to ensure that network resources and other unmanaged objects are properly cleaned up.  Just wanted to make sure that ProcessEventAsync & ProcessErrorAsync will be thread-safe. Or they will be shared by the thread? Environment No response
Client	Service Bus	[BUG][ServiceBus] Cannot reuse ServiceBusClient to read from 2 topics in the same namespace	Library name and version Azure.Messaging.ServiceBus 7.10.0 Describe the bug Despite what the docs say:  The ServiceBusClient, senders, receivers, and processors are safe to cache and use as a singleton for the lifetime of the application, which is best practice when messages are being sent or received regularly. They are responsible for efficient management of network, CPU, and memory use, working to keep usage low during periods of inactivity.  It seems that I cannot reuse a ServiceBusClient instance in order to read from 2 topics from the same namespace. The first PeekLock succeeds, while the second one always fails with UnauthorizedAccessException: Put token failed. status-code: 401, status-description: InvalidAudience: The authorization header contains a token with a wrong audience.. It does not matter which topic I read the first. The first one can be read from in the context of the ServiceBusClient. If I create a new client and swap topics, still the first one can be read from, while the attempt to read from the second fails. Expected behavior Reading topics. topic1 = A, topic2 = B PeekLock succeded for A/Subscriptions/default PeekLock succeded for B/Subscriptions/default PeekLock succeded for B/Subscriptions/default PeekLock succeded for A/Subscriptions/default Reading topics. topic1 = B, topic2 = A PeekLock succeded for B/Subscriptions/default PeekLock succeded for A/Subscriptions/default PeekLock succeded for A/Subscriptions/default PeekLock succeded for B/Subscriptions/default Actual behavior Reading topics. topic1 = A, topic2 = B PeekLock succeded for A/Subscriptions/default PeekLock failed for B/Subscriptions/default PeekLock failed for B/Subscriptions/default PeekLock succeded for A/Subscriptions/default Reading topics. topic1 = B, topic2 = A PeekLock succeded for B/Subscriptions/default PeekLock failed for A/Subscriptions/default PeekLock failed for A/Subscriptions/default PeekLock succeded for B/Subscriptions/default Reproduction Steps var sendReceiveConnectionString = config.GetValue<string>(`sendReceiveConnectionString`); //Endpoint=sb://NAMESPACE.servicebus.windows.net/;SharedAccessKeyName=SAKN;SharedAccessKey=SAK  async Task ReadTopics(string topic1, string topic2) {     Console.WriteLine($`Reading topics. topic1 = {topic1}, topic2 = {topic2}`);     var serviceBusClient = new ServiceBusClient(sendReceiveConnectionString);      const string subscriptionName = `default`;      await using var receiver1 = serviceBusClient.CreateReceiver(topic1, subscriptionName);     await using var receiver2 = serviceBusClient.CreateReceiver(topic2, subscriptionName);      async Task PeekMessagesAsync(ServiceBusReceiver receiver)     {         const int messagesCount = 1;         try         {             await receiver.PeekMessagesAsync(messagesCount);             Console.WriteLine($`PeekLock succeded for {receiver.EntityPath}`);         }         catch (UnauthorizedAccessException)         {             Console.WriteLine($`PeekLock failed for {receiver.EntityPath}`);         }     }      foreach (var receiver in new[] { receiver1, receiver2 })     {         await PeekMessagesAsync(receiver);     }     foreach (var receiver in new[] { receiver2, receiver1 })     {         await PeekMessagesAsync(receiver);     } }  var topicA = config.GetValue<string>(`topicA`); var topicB = config.GetValue<string>(`topicB`);  await ReadTopics(topicA, topicB); await ReadTopics(topicB, topicA);  Environment No response
Client	Cognitive - Form Recognizer	Please make DocumentFields usable as part of external unit tests	I am attempting to write unit tests for code that uses the form recogniser, I can obviously mock and wrap the actual extraction part. What I cannot do is anything with these fields as they only have internal constructors and can't be inherited from to create wrappers around. I want to be able to create an instance of one of these fields with a simulated content In order that I can test the logic in my application which receives an analysed document and make sure it is using the extracted field values correctly. Perhaps I am missing something in which case I would love to know the best way of adding tests that include these fields or mocking them in a more appropriate way. If there is no more appropriate way, please can you make them testable as I am now missing important logic from my coverage with no easy way I can see to achieve that.
Client	Azure.Core	[FEATURE REQ] Make Argument class public instead of internal	Library name Azure.Core Please describe the feature. Per the guidelines for implementations outlined here: https://azure.github.io/azure-sdk/dotnet_implementation.html#dotnet-parameter-validation-class It is self-defeating to keep such a useful utility as internal. Developers of 3rd party packages should be able to take advantage of this class even if they are not writing a direct native Azure.* package themselves. Please consider making this a public part of the Azure.Core package so 3rd party packages can offer the same level of consistency provided by first class Azure.* packages. Edit: To further clarify you cannot extend the object as it is a static object hence the point of this issue. Example:
Client	Search	[FEATURE REQ] Search: Allow participation/override of document serialization	Library name Azure.Search.Documents Please describe the feature. As I don't have complete control over my POCOs that I need to index, I would like to serialize them myself to eg. skip properties or otherwise customize the serialization of the uploaded documents. Right now I resort to batch uploading dicitonaries of string,object ... it's fine I guess. But no doubt, I would have been able to skip a lot of the meta programming if we had a bit more ways of plugging into this.             var batch = IndexDocumentsBatch.Create(documents.Select(d => IndexDocumentsAction.Upload(d.Properties.ToDictionary(p => p.Name, p => p.Value))).ToArray());              await SearchClient.IndexDocumentsAsync(batch);
Client	Extensions	[BUG] CVE in Azure.Storage.Blobs dependency of Azure.Extensions.AspNetCore.DataProtection.Blobs	Library name and version Azure.Extensions.AspNetCore.DataProtection.Blobs Describe the bug Azure.Extensions.AspNetCore.DataProtection.Blobs uses Azure.Storage.Blobs (>= 12.8.0). Dotnet restore creates lock file with 12.8.0 dependency which has CVE-2022-30187. Expected behavior Update Azure.Storage.Blobs to (>= 12.13.0) and release a new version Actual behavior  Reproduction Steps -- Environment No response
Client	Event Hubs	[QUERY] End to end latency in Azure Event Hub (EventProcessorClient) over 50ms	Library name and version Azure.essaging.EventHubs 5.7.2 Query/Question Hello All, I am measuring latency between sending an event and receiving it on the same machine. Azure Hub and sender/receiver box are in the same Azure region. I calculate latency as: a) DateTime.UtcNow - EnqueuedTime b) DateTime.UtcNow - [utc property inside message object being sent] No matter how I calculate latency it is over 50ms, which is double compared to say, same experiment using a storage queue. Is this kind of latency normal? Environment Windows, .NET 6
Client	Event Hubs	A load balancing cycle has taken too long to complete.	I am getting an error, given below, after some time, how to handle it and stopped to raise. i am using Azure.Messaging.EventHubs.Processor 5.7.2 with dotnet 6.0 Azure.Messaging.EventHubs.EventHubsException(GeneralError): `A load balancing cycle has taken too long to complete. A slow cycle can cause stability issues with partition ownership. Consider investigating storage latency and thread pool health. Common causes are soft delete being enabled for storage and too many partitions owned. You may also want to consider increasing the 'PartitionOwnershipExpirationInterval' in the processor options. Cycle Duration: '100.91' seconds. Partition Ownership Interval '1:20' seconds.`)]
Client	Service Bus	ServiceBusReceiveActions Azure function binding parameter missing `Peek` method.	the current version of ServiceBusReceiveActions binding parameter has the ability to receive additional messages according to this example: ServiceBusReceiveActions  // attempt to receive additional messages in this session await receiveActions.ReceiveMessagesAsync(maxMessages: 10);   It would be very helpful if we had to PeekMessagesAsync() method that could also check Scheduled messages.
Client	Service Bus	What is the proper way to batch receive messages using ServiceBus?	Library name and version Azure.Messaging.ServiceBus, Version=7.8.1 Query/Question I have .NET 6 core app Azure.Messaging.ServiceBus, Version=7.8.1 My scenario is the next. I have some topic which contains messages of the next structure: {  `DeviceId`: 1,  `DateTime`: `2022-08-31T12:00:00.000Z`  ... }  If I have few messages with the same DeviceId, only the last does matter. Processing of other messages besides last one is a waste of time and resources. My idea is to get each time N messages, take the latest ones by some key and date, process only these the latest, complete all the received messages. Something like batch processing. I did an experiment. I published my app into Azure (to make my app being as close to ServiceBus as it can), added 1000 messages into topic and run 5 times the next method: public static async Task<(double receiveMessagesMs, int receivedMessagesCount, double completeMessageMs)> Start(int maxMessages, TimeSpan maxWaitTimeout) {  var client = new ServiceBusClient(`...`);  var receiver = client.CreateReceiver(`topic`, `subscription`);   var sw = new Stopwatch();  sw.Start();   var messages = await receiver.ReceiveMessagesAsync(maxMessages, maxWaitTimeout);   sw.Stop();  var receiveMessagesMs = sw.Elapsed.TotalMilliseconds;   sw.Restart();  foreach (var message in messages)  {   await receiver.CompleteMessageAsync(message);  }  sw.Stop();  var completeMessageMs = sw.Elapsed.TotalMilliseconds;   return (receiveMessagesMs, messages.Count, completeMessageMs); }  maxMessages = 200, maxWaitTimeout = TimeSpan.FromSeconds(5) Here are the results: {   `receiveMessagesMs`: 352.8505,   `receivedMessagesCount`: 78,   `completeMessageMs`: 5615.8155 }  {   `receiveMessagesMs`: 88.9605,   `receivedMessagesCount`: 200,   `completeMessageMs`: 13531.9432 }  {   `receiveMessagesMs`: 191.5732,   `receivedMessagesCount`: 200,   `completeMessageMs`: 19735.9566 }  {   `receiveMessagesMs`: 289.4094,   `receivedMessagesCount`: 67,   `completeMessageMs`: 4320.9614 }  {   `receiveMessagesMs`: 115.2187,   `receivedMessagesCount`: 56,   `completeMessageMs`: 4598.4822 }   Here are the questions:  I've read there is no guarantee when you call ReceiveMessagesAsync you get messages count you've set. I thought it might be in one from two cases:   maxWaitTimeout has timed out. your subscription contains less messages than you have set in method call. But let's take a look at 1,4,5 results items above. I know the subscription contains more than 200 messages at any point of time. But despite that, Service Bus Receiver retrieved noticeably fewer messages than expected wherein it waited much less time than I allowed him. Why does this happen?  I have made more measurements than 5 and very rarely I met receivedMessagesCount similar to 200. About half of all my tries showed less than 50 received messages. One time it was 2. Two messages and it took 342.4529 ms. Although during all the measurements subscription contained more messages than I tried to receive.  A lot of time is spent to messages completion. I rewrote that peace of code in the following way:  List<Task> completeonTasks = new List<Task>(); foreach (var message in messages)              completeonTasks.Add(receiver.CompleteMessageAsync(message));   await Task.WhenAll(completeonTasks);  Completion results became much more better. But as I understand there are still N requests to Service Bus to complete each message. I hope there is the API something like .CompleteMessagesAsync(messages) where you can pass list of something and as a result there will not be one request per each message but there will be some butches of messages if not one request at all which contains the whole list. I found examples where exists CompleteAsync method which accepts IEnumerable of LockToken: var client = new MessageReceiver(connection, entityPath); // Receive up to 50 messages var messages = await client.ReceiveAsync(maxMessageCount: 50); // Complete the messages in a batch var tokens = messages.Select(m => m.SystemProperties.LockToken); await client.CompleteAsync(tokens);  But as I understand, all these examples are based on some old API which is https://github.com/Azure/azure-service-bus-dotnet. Is there really nothing like this here in Azure.Messaging.ServiceBus? Environment App is hosted in Azure dotnet --info Host (useful for support): Version: 6.0.6 Commit:  7cca709db2 .NET runtimes installed: Microsoft.AspNetCore.App 6.0.6 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 6.0.6 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
Mgmt	Functions	[QUERY] Using the management libraries to work with Function Apps?	Library name and version Azure.ResourceManager Query/Question I'm attempting to setup a pipeline for provisioning a function app and its dependencies. Although I'm not seeing any libraries for Azure Function Apps. Can someone please let me know if this feature needs to be requested, or what library I'll be able to find that in? Environment No response
Client	Storage	[QUERY] Is it any way to achieve download continuation when network issue and pause/continuation	Library name and version Azure.Storage.Blobs Query/Question is it possible to get blob storage stable downloader When the blob file is large, we need continuation when network issues and pause/continuation functionality. Environment .NET CORE / C# .
Mgmt	Storage	[QUERY] Which SDK should we use to create tables, queues, containers, ... in Azurite?	Library name and version Azure.ResourceManager.Storage 1.0.0-beta12 Query/Question I am using IaC (Pulumi or Terraform depending on projects) to manage my Azure Resources and in particular my Azure Storage. However when I want to debug my application locally, I use Azurite to emulate my storage account. However I need to manually create everything I created using IaC (queues, tables, containers, import static data, ...) for my application to work like in Azure. My idea was to use Azure SDK to do that but I don't know if I should use Azure.ResourceManager.Storage or the Azure.Storage.* SDK. Which one do you recommand? The SDK should be able to connect to Azurite from its connection string in order to create the tables and everything. Environment No response
Client	Extensions	[FEATURE REQ] Rename Azure.Extensions.AspNetCore.Configuration.Secrets	Library name Azure.Extensions.AspNetCore.Configuration.Secrets Please describe the feature. Isn't this supposed to be the Azure SDK for .NET not Azure SDK for AspNetCore? Currently using `Azure.Extensions.AspNetCore.Configuration.Secrets` to access secrets from KeyVault from a .NET 6 Worker (dotnet new worker) project, it works fine, but a bit misleading to call it AspNetCore, when it's just a generic library, that also work with .Net 6 workers? Wouldn't something like: `Azure.Extensions.Configuration.Secrets` be better / more generic, it would certainly have made it a lot easier to find out it does indeed work in non aspnetcore projects.
Client	Service Bus	ServiceBusTrigger - receive message in all running instances of service	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.5.1.0 Query/Question I have a Azure Functions App with a ServiceBusTrigger Function which is connected to a ServiceBus Queue. Now I want to publish a Message to that Servicebus Queue which is received (and therefor triggers the function) on any currently running instance of the Azuer Functions App. Is there a way to do this? the function looks like this: [FunctionName(`MappingCreatedIntegrationEventHandler`)]         public Task Run(                     //trigger                     [ServiceBusTrigger(nameof(MappingCreatedIntegrationEvent), Constants.SUBSCRIPTION_NAME, Connection = `ServiceBusConnectionString`)] MappingCreatedIntegrationEvent[] events,              ILogger log)     {         log.LogInformation(`MappingCreatedIntegrationEventHandler {@events}`,events);         objectQueries.ResetCache();         propertyMappingQueries.ResetCache();          return Task.CompletedTask;     }  Environment Azure Functions App (Windows Host) .NetFramework 6.0
Client	Tables	Is it right to call this method (TableClient.QueryAsync) xxxAsync?	I thought the norm was that methods named xxxAsync returns Tasks and were awaitable. I keep sticking await before my calls to TableClient.QueryAsync and then getting very confused as to the red squiggly line and the error message. I think that if I had written this method I would not have called it xxxAsync, but something else that denotes its asynchronousness yet also denotes that it doesn't return a Task.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 73b5d036-c2df-203c-f426-5e65fbf87b5b Version Independent ID: 8ab169e5-cd67-456e-a5d1-0ab9ae1119c3 Content: TableClient.QueryAsync Method (Azure.Data.Tables) - Azure for .NET Developers Content Source: xml/Azure.Data.Tables/TableClient.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Storage	[BUG] Using batch delete on a blob with more than 1 version fails when there is a lease present	Library name and version Azure.Storage.Blobs 12.13.0 & Azure.Storage.Blobs.Batch 12.10.0 Describe the bug If you call the batch DeleteBlob() with the specified LeaseID for the file, there is an exception thrown after the batch is submitted: Status: 412 (There is currently no lease on the blob.) Expected behavior Delete should succeed, with no exceptions thrown Actual behavior Delete fails with Status 412 (There is currently no lease on the blob) Reproduction Steps  Upload a new file to Blob Storage Create a new version of the file (in this case, I updated the metadata, by adding a key/value pair) Acquire a Lease on the File Use the BlobBatchClient to batch delete this file with the lease ID:  BlobBatchClient batchClient = _client.GetBlobBatchClient(); BlobBatch batch = batchClient.CreateBatch(); batch.DeleteBlob(blobUri, conditions: new BlobRequestConditions()                     {                         LeaseId = leaseId                     }); await batchClient.SubmitBatchAsync(batch, throwOnAnyFailure: true);  The exception thrown is as follows: System.AggregateException: '1 batch operation(s) failed. (There is currently no lease on the blob. RequestId:07579938-a01e-003f-807b-b1c9ba1e3472 Time:2022-08-16T14:21:07.9125816Z Status: 412 (There is currently no lease on the blob.) ErrorCode: LeaseNotPresentWithBlobOperation  Note: Using the same steps 1-3 but using the regular delete API (non-batching) with the lease ID, the call succeeds, and the file is deleted. Environment OS: Windows 10, .NET 6 IDE: Visual Studio Professional 2022 Version 17.2.5
Client	Search	[QUERY] Normalizers are not working with SearchFields	Library name and version Azure.Search.Documents 11.4.0-beta9 Query/Question Normalizers are not applied when SearchFields are used, ex. SearchOptions options = new SearchOptions() { Filter = filter, SearchMode = SearchMode.All, QueryType = SearchQueryType.Simple }; options.SearchFields.Add(`searchableTitle`); If SearchFields are not added and azure search is working with the deafult selected in the indexer (Content and Metadata), then normalizer is working fine. If SearchFields are used, then the normalizer is no longer applied. Could you please help resolve the issue? Environment Windows 10 .NET 6 Visual Studio 17.1.0 Preview 1.1
Client	Service Bus	Determining servicebus connection at runtime	We deploy our function apps as docker containers and store secrets/connection string in a key vault, associating each environment's key vault to the function app in ConfigureAppConfiguration. However, with the managed identity configuration the required name is `servicebus__fullyQualifiedNamespace` and `_` is not a valid character in a key vault secret name. What is the recommended solution to configuring the service bus connection string at runtime?  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: dab2626a-9579-fe2b-f11b-0ffec8666fcf Version Independent ID: 9f48d2bc-eda0-57e8-1ecd-a2489f1cb862 Content: Azure WebJobs Service Bus client library for .NET - Azure for .NET Developers Content Source: api/overview/azure/microsoft.azure.webjobs.extensions.servicebus-readme-pre.md Service: webjobs Product: azure Technology: azure GitHub Login: @ramya-rao-a Microsoft Alias: ramyar
Client	Service Bus	[QUERY] How to specify maxMessages for ServiceBusProcessor?	Library name and version Azure.Messaging.ServiceBus 7.9.0 Query/Question Hi, It is possible to specify maxMessages if we use ServiceBusReceiver/ServiceBusSessionReceiver ServiceBusReceiver receiver = client.CreateReceiver(queueName); IReadOnlyList<ServiceBusReceivedMessage> receivedMessages = await receiver.ReceiveMessagesAsync(maxMessages: 2);  But I haven't found a way to specify maxMessages for ServiceBusProcessor/ServiceBusSessionProcessor. Why this option is not available for ServiceBusProcessor/ServiceBusSessionProcessor? Environment No response
Client	Azure.Core	Azure.Core, Version=1.25 is trying to load System.Text.Json, Version=4.0.1.2	This is happening in an ASP.NET 4.8 MVC 5 app.  The same code works fine if I revert back to Azure.Core, Version=1.14 Fusion Log: === Pre-bind state information === LOG: DisplayName = System.Text.Json, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51 (Fully-specified) LOG: Appbase = file:///C:/Users/msherrane/Source/Workspaces/TFS/Dev/Web/ELinkMvc/ELinkMvc/ LOG: Initial PrivatePath = C:\Users\User\Source\Workspaces\TFS\Dev\Web\ELinkMvc\ELinkMvc\bin Calling assembly : Azure.Core, Version=1.25.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8. LOG: This bind starts in default load context. LOG: Using application configuration file: C:\Users\User\Source\Workspaces\TFS\Dev\Web\ELinkMvc\ELinkMvc\web.config LOG: Using host configuration file: C:\Windows\Microsoft.NET\Framework64\v4.0.30319\aspnet.config LOG: Using machine configuration file from C:\Windows\Microsoft.NET\Framework64\v4.0.30319\config\machine.config. LOG: Post-policy reference: System.Text.Json, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51 LOG: Attempting download of new URL file:///C:/Windows/Microsoft.NET/Framework64/v4.0.30319/Temporary ASP.NET Files/elinkmvc/55fc4c7c/d2691189/System.Text.Json.DLL. LOG: Attempting download of new URL file:///C:/Windows/Microsoft.NET/Framework64/v4.0.30319/Temporary ASP.NET Files/elinkmvc/55fc4c7c/d2691189/System.Text.Json/System.Text.Json.DLL. LOG: Attempting download of new URL file:///C:/Users/User/Source/Workspaces/TFS/Dev/Web/ELinkMvc/ELinkMvc/bin/System.Text.Json.DLL. WRN: Comparing the assembly name resulted in the mismatch: Major Version ERR: Failed to complete setup of assembly (hr = 0x80131040). Probing terminated. Stack Trace: at Azure.Core.Pipeline.ClientDiagnostics.CreateRequestFailedExceptionAsync(Response response, ResponseError error, IDictionary2 additionalInfo, Exception innerException) at Azure.Storage.Blobs.BlobRestClient.<GetPropertiesAsync>d__11.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Storage.Blobs.Specialized.BlobBaseClient.<GetPropertiesInternal>d__119.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Storage.Blobs.Specialized.BlobBaseClient.<ExistsInternal>d__113.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Azure.Storage.Blobs.Specialized.BlobBaseClient.<ExistsAsync>d__112.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter1.GetResult() at Custard.BusinessObjects.Entities.BusinessObjectBase1.<>c__DisplayClass14_0.<<DownloadBlob>b__0>d.MoveNext() in C:\Users\User\Source\Workspaces\TFS\Dev\Assemblies\BusinessObjects\Entities\BusinessObjectBase.cs:line 163 at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter1.GetResult() at Custard.Classes.AsyncUtil.RunSync[TResult](Func1 task) in C:\Users\User\Source\Workspaces\TFS\Dev\Assemblies\Classes\UnsecuredBusinessBase.cs:line 2614 at Custard.BusinessObjects.Entities.BusinessObjectBase1.DownloadBlob(String azureBlobPath) in C:\Users\User\Source\Workspaces\TFS\Dev\Assemblies\BusinessObjects\Entities\BusinessObjectBase.cs:line 157 at Custard.BusinessObjects.Entities.BusinessObjectBase`1.RetrieveAttachmentFromStorage(String callingMemberName) in C:\Users\User\Source\Workspaces\TFS\Dev\Assemblies\BusinessObjects\Entities\BusinessObjectBase.cs:line 253 at Custard.BusinessObjects.Entities.ClaimPhoto.get_Attachment_DatabaseOrBlobValue() in C:\Users\User\Source\Workspaces\TFS\Dev\Assemblies\BusinessObjects\Entities\ClaimPhoto.cs:line 530 at ELinkMvc.Controllers.PhotoController.d__62.MoveNext() in C:\Users\USer\Source\Workspaces\TFS\Dev\Web\ELinkMvc\ELinkMvc\Controllers\PhotoController.cs:line 1386 at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Web.Mvc.Async.TaskAsyncActionDescriptor.EndExecute(IAsyncResult asyncResult) at System.Web.Mvc.Async.AsyncControllerActionInvoker.<>c__DisplayClass8_0.b__1(IAsyncResult asyncResult) at System.Web.Mvc.Async.AsyncControllerActionInvoker.EndInvokeActionMethod(IAsyncResult asyncResult) at System.Web.Mvc.Async.AsyncControllerActionInvoker.AsyncInvocationWithFilters.<>c__DisplayClass11_0.b__0() at System.Web.Mvc.Async.AsyncControllerActionInvoker.AsyncInvocationWithFilters.<>c__DisplayClass11_2.b__2() at System.Web.Mvc.Async.AsyncControllerActionInvoker.AsyncInvocationWithFilters.<>c__DisplayClass11_2.b__2() at System.Web.Mvc.Async.AsyncControllerActionInvoker.EndInvokeActionMethodWithFilters(IAsyncResult asyncResult) at System.Web.Mvc.Async.AsyncControllerActionInvoker.<>c__DisplayClass3_6.b__4() at System.Web.Mvc.Async.AsyncControllerActionInvoker.<>c__DisplayClass3_1.b__1(IAsyncResult asyncResult)
Client	Cosmos	Get Cosmos Consumption RU value	Library name and version Microsoft.Azure.Cosmos 3.29.0 Query/Question I am trying to get the current RU consumption value on Cosmos but I don't see any API to get this value. I have gone through this API but it doesn't provide the current RU consumption value, it gives the current RU value configured on the container. Container.ReadThroughputAsync https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.container.readthroughputasync?view=azure-dotnet Is there any way I can get the live RU consumption value when hit to a container through an API?
Client	Cognitive - Form Recognizer	[BUG] The requested operation requires an element of type 'Number', but the target element has type 'String'.	Library name and version Azure.AI.FormRecognizer Version 3.1.1 Describe the bug Calling UpdateStatysAsync crashes on json deserialization In general this works - for a certain document we tried it crashes. Expected behavior Should not crash deserializing the result from Azure Api. Actual behavior The following exception is thrown. Microsoft.Azure.WebJobs.Host.FunctionInvocationException: Exception while executing function: WaitOnOcrCompletion  ---> System.InvalidOperationException: The requested operation requires an element of type 'Number', but the target element has type 'String'.    at System.Text.Json.JsonDocument.TryGetValue(Int32 index, Single& value)    at System.Text.Json.JsonElement.GetSingle()    at Azure.AI.FormRecognizer.Models.FieldValue_internal.DeserializeFieldValue_internal(JsonElement element)    at Azure.AI.FormRecognizer.Models.DocumentResult.DeserializeDocumentResult(JsonElement element)    at Azure.AI.FormRecognizer.Models.AnalyzeResult.DeserializeAnalyzeResult(JsonElement element)    at Azure.AI.FormRecognizer.Models.AnalyzeOperationResult.DeserializeAnalyzeOperationResult(JsonElement element)    at Azure.AI.FormRecognizer.FormRecognizerRestClient.GetAnalyzeFormResultAsync(Guid modelId, Guid resultId, CancellationToken cancellationToken)    at Azure.AI.FormRecognizer.Models.RecognizeCustomFormsOperation.UpdateStatusAsync(Boolean async, CancellationToken cancellationToken)    at Azure.AI.FormRecognizer.Models.RecognizeCustomFormsOperation.UpdateStatusAsync(CancellationToken cancellationToken)  Reproduction Steps string operationId = 22976b9b-45cc-4479-b567-b46eb06e68e4/analyzeresults/fc97d418-1bb2-413d-9029-7886398cf5af var newOp = new RecognizeCustomFormsOperation(operationId, _formRecognizer); await newOp.UpdateStatusAsync(); This only crashes on this one result from Azure.  (started today). Environment Azure function 4, dotnet 6
Client	Event Hubs	Same PartitionKey does not guarantee same Partition	Hello, issue: Setting (the same) PartitionKey does not guarantee all events will appear in the same partition when sending them in different 'chunks' context: Our downstream processing needs ordered processing. We assumed all our events with the same partition key would be processed in order, as long as we use a PartitionKey to publish our events to event hubs. This did not work out as expected. After some troubleshooting we pinpointed the problem to race conditions as a result of parallel processing. This happened because the events were spread over different partitions, even though the same PartitionKey was supplied. Our assumption was based on this quote found in this documentation page:  When publishing events, it may be desirable to request that the Event Hubs service keep the different event batches together on the same partition. This can be accomplished by setting a partition key when creating the batch. The partition key is NOT the identifier of a specific partition. Rather, it is an arbitrary piece of string data that Event Hubs uses as the basis to compute a hash value. Event Hubs will associate the hash value with a specific partition, ensuring that any events published with the same partition key are routed to the same partition.  If the documentation text is right, then how can we acheive this? Below is some sample code to reproduce the issue. Sample code to send items: using System.Text; using Azure.Messaging.EventHubs; using Azure.Messaging.EventHubs.Producer;  namespace ConsoleApp;  internal class Program {     private const string ConnectionString = `...`;     private const string EventHubName = `myexperimenthub`;          private static readonly EventHubProducerClient ProducerClient = new EventHubProducerClient(ConnectionString, EventHubName);      private static async Task Main()     {         const int amountOfBatches = 100;         const int batchSize = 20;         var partitionKey = $`some-partition-key_{Guid.NewGuid()}`;          Console.Write($`Sending '{amountOfBatches * batchSize}' events to event hubs in '{amountOfBatches}' batches of '{batchSize}' items, using '{partitionKey}' as partition key for every batch...`);          var sendEventOptions = new SendEventOptions { PartitionKey = partitionKey };          for (var batchIndex = 0; batchIndex < amountOfBatches; batchIndex++)         {             var eventBodyList = new List<string>();             for (var eventIndex = 0; eventIndex < batchSize; eventIndex++)             {                 eventBodyList.Add($`event {eventIndex} from batch {batchIndex}`);             }              var eventDataList = eventBodyList.Select(eventBody => new EventData(Encoding.UTF8.GetBytes(eventBody)));             await ProducerClient.SendAsync(eventDataList, sendEventOptions);         }          Console.WriteLine(`Done`);     } }  Console output: Sending '2000' events to event hubs in '100' batches of '20' items, using 'some-partition-key_99e37fa3-ff2b-4edf-9b4f-74aed7ec5cab' as partition key for every batch...Done  Sample code used to receive the events (Azure Function with EventHubTrigger): using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq; using System.Text; using Azure.Messaging.EventHubs; using Azure.Messaging.EventHubs.Consumer; using Microsoft.Azure.WebJobs; using Microsoft.Extensions.Logging;  namespace FunctionApp;  public static class ReceivingFunction {     private static readonly ConcurrentBag<EventInfo> InformationStore = new();      [FunctionName(nameof(ReceivingFunction))]     public static void Run(         [EventHubTrigger(`myexperimenthub`, Connection = `EventHubConnectionString`)]         EventData[] events,         PartitionContext partitionContext,         ILogger logger)     {         foreach (var eventData in events)         {             InformationStore.Add(new EventInfo(eventData.PartitionKey, partitionContext.PartitionId));         }                  var logMessage = InformationStore.ToList().SummarizeEverything();         logger.LogInformation(logMessage.Replace(`\r\n`,`\n`));     } }  public static class LogMessageExtensions {     public static string SummarizeEverything(this IEnumerable<EventInfo> bag)     {         var summary = new StringBuilder();         summary.AppendLine(`Summary of the situation so far:`);         foreach (var infoByPartitionKey in bag.GroupBy(i => i.PartitionKey))         {             var numberOfEvents = infoByPartitionKey.Count();             var infoByPartitionId = infoByPartitionKey.GroupBy(i => i.PartitionId);              summary.AppendLine($`'{infoByPartitionId.Count()}' PartitionId(s) were used for PartitionKey '{infoByPartitionKey.Key}' ('{numberOfEvents}' events  received).`);         }          return summary.ToString();     } }  public class EventInfo {     public EventInfo(string partitionKey, string partitionId)     {         PartitionKey = partitionKey;         PartitionId = partitionId;     }      public string PartitionKey { get; }     public string PartitionId { get; } }  Last prompted console output: [2022-08-05T12:21:32.972Z] Summary of the situation so far: '32' PartitionId(s) were used for PartitionKey 'some-partition-key_99e37fa3-ff2b-4edf-9b4f-74aed7ec5cab' ('2000' events  received).
Client	Service Bus	[BUG] Message lock renewal not working for 10+ minutes processin durationg when using different `ServiceBusReceiver` instances for `CompleteMessageAsync` and `RenewMessageLockAsync`	Library name and version Azure.Messaging.ServiceBus 7.8.0, 7.8.1 and 7.9.0 Describe the bug When using transactions and invoking RenewMessageLockAsync on a different ServiceBusReceiver and processing durations are over 10 minutes then invoking CompleteMessageAsync CAN results in a MessageLockLost if that is the only message concurrently being processed. A similar bug was reported earlier. This has been fixed in 7.8.0 when invoking invoking CompleteMessageAsync on the same receiver as CompleteMessageAsync.  #28025  Expected behavior The client not gets into a faulty state where lock renewal seems to succeed but when CompleteMessageAsync is invoked that it fails with MessageLockLost. Actual behavior The client can get into a faulty state where:  any message that will be ack'd via CompleteMessageAsync where processing is longer then the queue lock duration will fail any message that result in a lock renewal via RenewMessageLockAsync will incorrectly succeed  Reproduction Steps var lockDuration = TimeSpan.FromMinutes(5); var renewalInterval = lockDuration - TimeSpan.FromSeconds(10); var queueName = `test-` + DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(); var cs = Environment.GetEnvironmentVariable(`AzureServiceBus_ConnectionString`); var admin = new ServiceBusAdministrationClient(cs); await admin.CreateQueueAsync(new CreateQueueOptions(queueName) { LockDuration = lockDuration, AutoDeleteOnIdle = TimeSpan.FromMinutes(10) }); var sw = Stopwatch.StartNew(); using var logger = new AzureEventSourceListener((ea, m) => Console.Out.WriteLineAsync($`{sw.Elapsed,-15:g} [{ea.Level,-13}] {m}`), EventLevel.Verbose); await using var client = new ServiceBusClient(cs, new ServiceBusClientOptions { EnableCrossEntityTransactions = true }); await using var sender = client.CreateSender(queueName); await sender.SendMessageAsync(new ServiceBusMessage()); await using var receiver = client.CreateReceiver(queueName);  var message = await receiver.ReceiveMessageAsync(); Trace.Assert(message != null); using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(11)); await RenewLockAsync(message!, cts.Token); using var ts = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled); await sender.SendMessageAsync(new ServiceBusMessage()); await receiver.CompleteMessageAsync(message); ts.Complete();  async Task RenewLockAsync(ServiceBusReceivedMessage message, CancellationToken cancellationToken) {     var renewLockReceiver = client.CreateReceiver(queueName);      while (!cancellationToken.IsCancellationRequested)     {         var delayTask = await Task.Delay(renewalInterval, cancellationToken)             .ContinueWith(t => t, TaskContinuationOptions.ExecuteSynchronously);         if (delayTask.IsCanceled) return;         await renewLockReceiver.RenewMessageLockAsync(message);     } } Environment  net6 windows 10
Client	Azure.Identity	Azure.Identity 1.6.0 - AuthenticationFailedException: ManagedIdentityCredential authentication failed: No Managed Identity found	Library name and version Azure.Identity 1.6.0 Describe the bug We make use of Azure Key Vault and use a system-assigned managed identity of the Azure Function to connect to KV at runtime. With Azure.Identity 1.6.0 we get `AuthenticationFailedException: ManagedIdentityCredential authentication failed: No Managed Identity found for specified ClientId/ResourceId/PrincipalId` Reverting back to Azure.Identity 1.5.0 fixes it with no other changes our side. We are using 'DefaultAzureCredential' to provide credentials to Key Vault SecretClient. DefaultAzureCredentialOptions credentialOptions = new DefaultAzureCredentialOptions() {  ExcludeAzureCliCredential = true,  ManagedIdentityClientId = _configuration.ManagedIdentityClientId }; SecretClientOptions clientOptions = GetClientOptions(); _client = new SecretClient(new Uri(_configuration.KeyVaultUrl), new DefaultAzureCredential(credentialOptions), clientOptions);   See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/managedidentitycredential/troubleshoot Exception: Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: No Managed Identity found for specified ClientId/ResourceId/PrincipalId. Status: 400 (Bad Request)     at Azure.Identity.ManagedIdentitySource.HandleResponseAsync(Boolean async, TokenRequestContext context, Response response, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityClient.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage)    at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted[T](ValueTask`1 task)    at Azure.Identity.ManagedIdentityCredential.GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenFromSourcesAsync(TokenCredential[] sources, TokenRequestContext requestContext, Boolean async, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex, String additionalMessage)    at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted[T](ValueTask`1 task)    at Azure.Identity.DefaultAzureCredential.GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueFromCredentialAsync(TokenRequestContext context, Boolean async, CancellationToken cancellationToken)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueAsync(HttpMessage message, TokenRequestContext context, Boolean async)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueAsync(HttpMessage message, TokenRequestContext context, Boolean async)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted[T](ValueTask`1 task)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AuthenticateAndAuthorizeRequest(HttpMessage message, TokenRequestContext context)    at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.AuthorizeRequestInternal(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted(ValueTask task)    at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.AuthorizeRequest(HttpMessage message)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted(ValueTask task)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted(ValueTask task)    at Azure.Core.Pipeline.RedirectPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.TaskExtensions.EnsureCompleted(ValueTask task)    at Azure.Core.Pipeline.RetryPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipelinePolicy.ProcessNext(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy.Process(HttpMessage message, ReadOnlyMemory`1 pipeline)    at Azure.Core.Pipeline.HttpPipeline.Send(HttpMessage message, CancellationToken cancellationToken)    at Azure.Core.Pipeline.HttpPipeline.SendRequest(Request request, CancellationToken cancellationToken)    at Azure.Security.KeyVault.KeyVaultPipeline.SendRequest(Request request, CancellationToken cancellationToken)    at Azure.Security.KeyVault.KeyVaultPipeline.SendRequest[TResult](RequestMethod method, Func`1 resultFactory, CancellationToken cancellationToken, String[] path)    at Azure.Security.KeyVault.Secrets.SecretClient.GetSecret(String name, String version, CancellationToken cancellationToken)    at Onsend.Lib.Core.KeyVault.KeyVaultManager.GetSecret(String secretName) in /_/Onsend.Lib/Core/KeyVault/KeyVaultManager.cs:line 117    at Onsend.Lib.Core.KeyVault.KeyVaultSecretProvider.GetSecret(String key, Boolean required) in /_/Onsend.Lib/Core/KeyVault/KeyVaultSecretProvider.cs:line 59  Expected behavior Gets managed identity. Actual behavior Throws exception. AuthenticationFailedException: ManagedIdentityCredential authentication failed: No Managed Identity found for specified ClientId/ResourceId/PrincipalId Reproduction Steps Upgrade from Azure.Identity 1.5.0 to 1.6.0 Environment Azure Functions: FUNCTIONS_EXTENSION_VERSION: ~4 FUNCTIONS_WORKER_RUNTIME: dotnet-isolated
Client	Service Bus	[QUERY] Deferred messages in session-enabled queue	Library name and version Azure.Messaging.ServiceBus Query/Question I have a scenario where in a queue, which is session-enabled, I need to defer some messages for later processing. However, in rare circumstances, the process loses track of the sessions, and the messages seem to remain trapped for eternity. I need to accomplish one of the these two things:  Be able to iterate through the deferred messages. If this message wasnt session-enabled I would be able to get all messages and inspect their state. However, the AcceptNextSessionAsync() it never goes through the deferred messages, but rather throws ServiceTimeout exception as sessions do not exist. How do I get to these messages, in a session enabled queue? Be able to expire them and send them to DLQ after a certain period of time. I was expecting the deferred messages to go to DLQ just like the regular expired messages, but that does not seem the case. Is there a way I can accomplish this?  Thanks. Environment No response
Mgmt	Compute - Managed Disks	[BUG] Managed Disk SetTag broken in latest stable version of Azure.ResourceManager.Compute	Library name and version Azure.ResourceManager.Compute 1.0.0 Describe the bug After upgrading from latest beta version to stable version, the ManagedDisk SetTag method is broken. Expected behavior SetTags method work as before. Actual behavior SetTags returning an exception and don't apply any tag in resource Reproduction Steps Run this code using the latest beta version (it will work) and run the same piece of code using the latest stable version it will fail. var osDisk = resourceGroup.GetManagedDisk($`MyTest`); IDictionary<string, string> iDictionary = new Dictionary<string, string>(); iDictionary.Add(`mytag`,`tag1`); osDisk.Value.SetTags(iDictionary); Environment .NET SDK (reflecting any global.json): Version:   6.0.302 Commit:    c857713418 Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.302\ global.json file: Not found Host: Version:      6.0.7 Architecture: x64 Commit:       0ec02c8c96 .NET SDKs installed: 2.1.526 [C:\Program Files\dotnet\sdk] 2.1.818 [C:\Program Files\dotnet\sdk] 3.1.421 [C:\Program Files\dotnet\sdk] 5.0.408 [C:\Program Files\dotnet\sdk] 6.0.302 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Download .NET: https://aka.ms/dotnet-download Learn about .NET Runtimes and SDKs: https://aka.ms/dotnet/runtimes-sdk-info
Client	Storage	Azure Blob Service Library - ListBlob with Filter	Thanks for the reply, however I cannot see the ListBlobs Method. This method is not available within the new Azure.Storage.Blobs Package. (https://github.com/Azure/azure-sdk-for-net/tree/Azure.Storage.Blobs_12.13.0/sdk/storage/Azure.Storage.Blobs) The ListBlobs method you are referring to is from the depricated Microsoft.Azure.Storage.Blob Package. (https://github.com/Azure/azure-storage-net) Am I missing something here? Originally posted by @Dan127001 in #29961 (comment)
Client	Azure.Identity	[BUG] MAUI refusing to build for iOS with package	Library name and version Azure.Identity 1.6.0 Describe the bug I am currently having an issue with building a MAUI project with the Azure.Identity 1.6.0 library installed. When I try to build it, I get a 'clang++ exited with code 1' error in the console and refuses to go any further. It works building for Windows. Expected behavior It should be able to build for the iOS platform Actual behavior I refuses to build for the iOS platform with the error 'clang++ exited with code 1' Reproduction Steps  Create a new default MAUI project Import the Azure.Identity 1.6.0 library Make sure you are paired to a Mac device Switch the Build Device to an iOS simulator or Remote Device Run the project on simulator or remote device The error will happen in the build process  Attached is a project I quickly got together: MauiAzureTest.zip Environment Using: Visual Studio 2022 Preview 3.0 (Version 17.3.0 Preview 3.0) MAUI version 6.0.408 .NET 6
Client	Event Hubs	[QUERY] Does the EventProcessorClient automatically checkpoint?	Library name and version Azure Event Hubs - New EventProcessrClient  - StopProcessingAsync Query/Question Hi,  would like to know if this method also updates the checkpoint status for all partitions. Environment No response
Client	Service Bus	`This value starts at 1.` should be clarified	The page says `This value starts at 1.` - this should be clarified. The value starts at zero. When a receiver receives the message the received message DeliveryCount will be 1 or more. When a receiver abandons or fails a message then the subscription message will have it's DeliveryCount incremented.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 7f54ee0d-4a21-4e76-b6e1-f1e7f518c9a4 Version Independent ID: b75735b5-4f6d-0027-3998-46e59e873fe1 Content: Message.SystemPropertiesCollection.DeliveryCount Property (Microsoft.Azure.ServiceBus) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.ServiceBus/Message+SystemPropertiesCollection.xml Service: service-bus-messaging GitHub Login: @rloutlaw Microsoft Alias: routlaw
Mgmt	Data Factory	Values InvokedByType can take	Could you pls elaborate on the values `InvokedByType` can take  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 7192a737-84ab-45ce-4644-9af69c04fd94 Version Independent ID: d2b86151-1d6e-fec8-551d-f8935dcfdf10 Content: PipelineRunInvokedBy.InvokedByType Property (Microsoft.Azure.Management.DataFactory.Models) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Management.DataFactory.Models/PipelineRunInvokedBy.xml Service: data-factory GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	KeyVault	[BUG] Method SecretClient.GetPropertiesOfSecretsAsync is not awaitable in Azure.Security.KeyVault.Secrets	Library name and version Azure.Security.KeyVault.Secrets 4.3.0 Describe the bug I am trying to use the method SecretClient.GetPropertiesOfSecretsAsync in .NET Core and noticed it is not awaitable. Expected behavior Method should support the use of await operator. Actual behavior The method behaves as a synchronous process. Reproduction Steps The code below will not run: var secretClient = new SecretClient(new Uri(keyVaultEndpoint), keyVaultCredential); var secrets = await secretClient.GetPropertiesOfSecretsAsync();  Environment .NET SDK (reflecting any global.json): Version:   6.0.302 Commit:    c857713418 Runtime Environment: OS Name:     Windows OS Version:  10.0.22000 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.302\ global.json file: Not found Host: Version:      6.0.7 Architecture: x64 Commit:       0ec02c8c96 .NET SDKs installed: 3.1.421 [C:\Program Files\dotnet\sdk] 6.0.202 [C:\Program Files\dotnet\sdk] 6.0.301 [C:\Program Files\dotnet\sdk] 6.0.302 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.26 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.27 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.6 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Container Registry	[Container Registry] Does not support import operation	Library name Container Registry Please describe the feature. az cli and PowerShell support image import: https://docs.microsoft.com/en-us/azure/container-registry/container-registry-import-images?tabs=azure-cli az acr import \   --name myregistry \   --source mysourceregistry.azurecr.io/aci-helloworld:latest \   --image aci-helloworld:latest  The DotNet SDK ContainerRegistryClient does not have an Import method
Client	Storage	Get latest timestamp file from container/blob	Library name and version Azure Storage Blob 12.2.0 Query/Question How do I get the latest modified file from a Blob? I have a  container in which there is a blob named cache:  I have the following code where I’m trying to get the latest modified file from the container: using Azure.Identity; using Azure.Storage.Blobs;  var storageAccountName = `storageAccountName`; var containerName = `containerName`]; var containerUrl = $`https://{storageAccountName}.blob.core.windows.net/{containerName}`; var containerClient = new BlobContainerClient(new Uri(containerUrl), new DefaultAzureCredential());  public async Task GetBlobItems() {                      foreach (var blobItem in containerClient.GetBlobs())             {                 var blobClient = _containerClient.GetBlobClient(blobItem.Name);                 var blobExists = await blobClient.ExistsAsync();                 if (blobExists)                 {                     var properties = await blobClient.GetPropertiesAsync();                     var lastModified = properties.Value.LastModified;                 }             } }  How do I get the latest modified file from 'cache' blob? Please note that I need the latest modified file from 'cache' blob. Environment No response
Client	Azure.Identity	[FEATURE REQ] Add Integrated Windows Authentication support within TokenCredential interface	Library name Azure.Storage.Blobs Please describe the feature. I am running into this issue with Azure.Storage.Blobs but I believe this will be the case for other libraries accepting TokenCredential as well. I tried to make it work with Integrated Windows Authentication but failed to find the appropriate descendant of TokenCredential to supply into the constructor of BlobContainerClient. After asking a question on StackOverflow I was pointed to the migration guide where IWA is marked is not supported. I am not sure why Integrated Windows Authentication is not supported. This must be pretty popular demand in the Enterprise world. I ended up writing my own implementation of TokenCredential interface: internal class IwaCredential : TokenCredential {     private readonly IPublicClientApplication _application;     private readonly string[] _scopes;      public IwaCredential(IPublicClientApplication app, string[] scopes)     {         _application = app;         _scopes = scopes;     }      private async Task<AuthenticationResult> AuthenticateAsync()     {         AuthenticationResult? result = null;         var accounts = await _application.GetAccountsAsync();          if (accounts.Any())         {             try             {                 result = await _application.AcquireTokenSilent(_scopes, accounts.FirstOrDefault()).ExecuteAsync();             }             catch (MsalUiRequiredException)             {             }         }          if (result == null)         {             result = await _application.AcquireTokenByIntegratedWindowsAuth(_scopes).ExecuteAsync();         }          return result;     }      private async Task<AccessToken> GetAccessTokenAsync()     {         var authResult = await AuthenticateAsync();         return new AccessToken(authResult.AccessToken, authResult.ExpiresOn);     }      public override AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken)     {         return GetAccessTokenAsync().GetAwaiter().GetResult();     }      public override ValueTask<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)     {         return new ValueTask<AccessToken>(GetAccessTokenAsync());     } }  Now we are able to supply it into BlobContainerClient (or other): var appOptions = new PublicClientApplicationOptions {     ClientId = `...`,     TenantId = `...`, }; var app = PublicClientApplicationBuilder.CreateWithApplicationOptions(appOptions).Build(); var cred = new IwaCredential(app, new string[] { `https://storage.azure.com/user_impersonation` }); var client = new BlobContainerClient(new Uri(`https://foobar.blob.core.windows.net/upload`), cred); // obtain your file... var res = await client.UploadBlobAsync(`prefix/my.file`, file); Console.WriteLine(res); }  I ask you to please include an equivalent of IwaCredential above into the standard of Azure.Identity. See also my question on StackOverflow (and comments).
Client	Service Bus	InvalidOperationException	Does this happen to throw an InvalidOperationException, if I call SendMessagesAsync with a batch before the previous call has finished? It's not documented here and I tried to follow https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements?tabs=net-standard-sdk-2#concurrent-operations . There it is done with SendMessageAsync - Tasks are awaited all at the end. This does not seem to work with SendMessagesAsync, is that correct?  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: eb6fd36b-5867-fee8-adc4-97034c315899 Version Independent ID: c7bfcaa6-c427-d56f-e154-38d3f3c60d46 Content: ServiceBusSender.SendMessagesAsync Method (Azure.Messaging.ServiceBus) - Azure for .NET Developers Content Source: xml/Azure.Messaging.ServiceBus/ServiceBusSender.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Monitor	No info on running test from multiple locations in availabilitytelemetry.runlocation	[Enter feedback here] I want to availability test from 5 different locations but runlocation does not support that, so I want to know how to run the test from different locations. But there is no info on that in this document Thank you in advance  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: ee9c6226-f05e-cb2f-b828-fbd83fc22343 Version Independent ID: aee9ec31-a2a4-0b5f-9dc6-2e4d2fc15e41 Content: AvailabilityTelemetry.RunLocation Property (Microsoft.ApplicationInsights.DataContracts) - Azure for .NET Developers Content Source: xml/Microsoft.ApplicationInsights.DataContracts/AvailabilityTelemetry.xml Service: application-insights GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Schema Registry	[QUERY] Fetching a schema by a consistent identifier	Library name and version Azure.Data.SchemaRegistry 1.2.0 Query/Question According to the docs, retrieving a schema from the schema registry can only be done by using the schema Id. As far as I understand the schema Id is assigned by the schema registry upon creation, and will be different per environment. My service is deployed in a number of different environments, and I don't want to be dependent on the Id that the schema registry generated in each such environment. Therefore I would like to use a shared identifier that would be consistent across the different environments. Is there a way for me to retrieve a schema by it's group name + name? Alternatively, can I control / set the schema Id during schema creation? Environment No response
Client	Event Hubs	[QUERY] Error Handling in an Event Hub consumer - Best Practices	Library name and version Azure.Messaging.EventHubs 5.7.0 Query/Question I am wondering how I should go about handling failures in an Event Hub consumer. In this issue (18344) on the Java SDK repository James explains that Event Hubs don't have the concept of a dead-letter queue because messages are not destroyed upon consumption. Therefore, the consumer can then independently keep track of failed messages and retry them whenever it wishes. What would a realistic best practice be? I imagine everyone who ever had to implement an Event Hub consumer has encountered this same question, and had to invent their own solution. The most basic solution I can think of is to leverage the already-existing checkpoint storage account and create 2 Azure queues in it.  In queue 1 I will store identifiers (Partition Id, Offset, Sequence Number) of messages that I have retried too many times queue 2 would be a replay queue that I would listen to IN ADDITION to the Event Hub An external process would then move messages between queue 1 and queue 2. It can be smart about it and only move messages that failed on non-permanent errors. If the consumer fails on processing a message in queue 2 too many times, the messages will be moved back to queue 1  My questions are:  Is there a better recommended way to handle processing failures? If not, does the Event Hub SDK expose a random access API to allow me to listen on queue 2 like that? I know the client allows to listen to a partition STARTING from a given Offset, but that's not really what I am looking for. I simply want to fetch a message by it's identifier to process it specifically (without any  checkpointing)  Environment No response
Client	Search	Unable to add FieldMappings to a new SearchIndexer object	I am upgrading a library for my current company from .net core 3.1 to .net 6.0, and as part of that upgrade I have swapped out the old Azure lib Microsoft.Azure.Search for the new one Azure.Search.Documents (v11). I am currently attempting to migrate a block of code which built an Indexer object (now SearchIndexer) however I find that I am unable to either add or initialise any FieldMappings, which the existing code does contain. Looking at the documentation and also Github repo for the component I see that the setter was removed for the FieldMappings collection however there doesn't seem to be any way now to add Field Mappings, which as far as I can tell are supported when using raw JSON. Here is the original code var indexer = new Indexer             {                 Name = blobIndexerName,                 DataSourceName = dataSourceName,                 TargetIndexName = $`{AzureSearch.IndexName}-{env}`,                 Schedule = new IndexingSchedule(TimeSpan.FromMinutes(5)),                 Parameters = new IndexingParameters                 {                     Configuration = new Dictionary<string, object>                     {                         { `excludedFileNameExtensions`, `.pdf` },                         { `skipContent`, false },                         { `useJsonParser`, false },                         { `failOnUnprocessableDocument`, false },                         {                            `indexStorageMetadataOnlyForOversizedDocuments`,                            true                         }                     }                 },                 FieldMappings = new List<FieldMapping>                 {                     new FieldMapping(`metadata_storage_name`, `id`),                     new FieldMapping(`metadata_storage_name`, `storage_name`),                     new FieldMapping(                        `metadata_storage_last_modified`,                        `storage_last_modified`)                 }             };  I also noticed under the Configuration property I do not seem to be able to set all of the sub properties (skipContent and useJsonParser although I'm not 100% sure if this matters.
Client	Event Hubs	[QUERY] ProcessingStoppedReason for DeveloperCodeException / EventHubsException	Library name and version Azure.Messaging.EventHubs 5.7.0 Query/Question Hi! Is there any reason why ProcessingStoppedReason is set to OwnershipLost when partition processing task was faulted due to exception thrown in user code (DeveloperCodeException) or because particular consumer group does not exists (EventHubsException)? I find it a little misleading. What about having another value (UnhandledProcessingError?) for that case? I think it is caused by partitionProcessor.ProcessingTask.IsCompleted check. Environment No response
Client	Service Bus	[BUG] Session concurrency not firing concurrently with service bus azure function trigger	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus 5.5.1 Describe the bug The session concurrency functionality for a service bus triggered function does not appear to be behaving as I'd expect. What I'm seeing in my testing is that it will receive for a single session in the correct order (FIFO), once all of the messages for that session have processed and the receive link for that session closes (after a minute), it will pick up the next session.  I'd expect that these sessions would process concurrently based on my settings. I'm wondering if there is some problem with how I have configured my function and/or settings. This is a new project, we have a lot of volume on SQL Service Broker we're looking to eventually migrate onto service bus via service bus triggered functions with concurrent session processing. Expected behavior Sessions are processed concurrently up to the number set by the maxConcurrentSessions value Actual behavior Sessions are handled one after another, not at the same time. Messages within a session are processed in the correct order. Reproduction Steps I've included a sln with a function and a sender.  You'll need to set the service bus conn str in the sender Program.cs, and the SessionFunction > local.settings.json The sender sends messages interleaved for one of two sessions (odd, even) The function receives all for odd first, a minute passes for the receive lock to release, then the even session messages are handle SessionConcurrency.zip d  Environment Windows Azure Function Reproducible locally with Function Runtime Version: 4.5.2.18383
Client	Search	[BUG] ScoringFunctions property in ScoringProfile class cannot be set.	Library name and version Azure.Search.Documents.Indexes.Models 11.3.0 Describe the bug In the current implementation of the ScoringProfile class, the property Functions is read-only. As I haven't found any other way of setting ScoringFunctions in a ScoringProfile class (its constructor doesn't accept an IList), I assume this is a bug. I also haven't found any documentation that would describe how to set ScoringFunctions in v11. In earlier SDK-versions this was an easy thing to do as the property was writable. Expected behavior Make the ScoringFunctions property writable ({ get; set; }). Or document any other way to set scoring functions (my goal is to rank newer items higher than older items). Actual behavior ScoringFunctions property is read-only. No other way of setting it is documented. Reproduction Steps This implementation is documented here: https://docs.microsoft.com/en-us/dotnet/api/azure.search.documents.indexes.models.scoringprofile.functions?view=azure-dotnet#azure-search-documents-indexes-models-scoringprofile-functions Environment No response
Client	Event Hubs	[BUG] Simultaneous EventHub healthchecks result in 'This operation is only allowed using a successfully authenticated context.'	Library name and version Microsoft.Azure.WebJobs.Extensions.EventHubs 5.1.0 Describe the bug I have a simple .NET 6 WebJob (Console App) with Kafka input / EventHub output function. Dummy code since I cannot share exact production code for obvious reasons: public async Task KafkaConsumer_OutputEventHubAsync(         [KafkaTrigger(`kafkaserver`, `topic`, ConsumerGroup = `consumergroup`)] KafkaEventData<string, string>[] kafkaEvents,         [EventHub(`eventhubname`, Connection = `ehnconnstring`)]         IAsyncCollector<string> outputMessages, ILogger logger)         {             foreach (var kafkaEvent in kafkaEvents)             {                 try                 {                     await outputMessages.AddAsync(kafkaEvent.Value);                 }                  catch                  {                      handle_error();                 }              }          } So nothing extraordinary here BUT since I have it running in Kubernetes (AKS) and it's set up with autoscaler (KEDA), I also need to check readiness and liveness of Kafka consumers. So readiness probe checks connectivity to Kafka and EventHub, for Kafka everything works fine but for EventHub I get a lot of exceptions `'This operation is only allowed using a successfully authenticated context.` and that happens almost always only for topics which are being consumed by multiple consumers at once (autoscaled by KEDA) and that problem doesn't seem to happen if there is only 1 consumer running. So the logic of readiness healthcheck is a simple TCP listener: Program.cs registration: services.AddHealthChecks()             .AddCheck<ReadinessprobeHealthCheck>(`readiness_probe_hc`); services.AddHostedService<TcpHealthProbeService>();  public class TcpHealthProbeService : BackgroundService     {         private readonly TcpListener _listenerReadiness;          public TcpHealthProbeService(HealthCheckService healthCheckService)         {             _healthCheckService = healthCheckService;             _listenerReadiness = new TcpListener(IPAddress.Any, readyPort);         }          protected override async Task ExecuteAsync(CancellationToken stoppingToken)         {             await Task.Yield();             Log.Information(`Started health check service.`);             _listenerReadiness.Start();             while (!stoppingToken.IsCancellationRequested)             {                 await UpdateHeartbeatAsync(stoppingToken);                 Thread.Sleep(TimeSpan.FromSeconds(30));             }             _listenerReadiness.Stop();         }  private async Task UpdateHeartbeatAsync(CancellationToken token)         {             try             {                 var result = await _healthCheckService.CheckHealthAsync(token);                  if (result.Entries[`readiness_probe_hc`].Status != HealthStatus.Healthy)                 {                     _listenerReadiness.Stop();                     Log.Error(`Service is not ready. Readiness probe failed. Listener stopped.`);                     return;                 }                  _listenerReadiness.Start();                 while (_listenerReadiness.Server.IsBound && _listenerReadiness.Pending())                 {                     var client = await _listenerReadiness.AcceptTcpClientAsync();                     try                     {                         client.Client.Shutdown(SocketShutdown.Both);   // I tried with or without it, doesn't make any difference                     }                     finally                     {                         client.Close();                     }                 }             }             catch (Exception ex)             {                 Log.Error($`An error occurred while checking health probes. Ex: {ex.Message});             }         } And finally the EventHub check itself: public class ReadinessprobeHealthCheck : IHealthCheck     {         private readonly IConfiguration _configuration;          public ReadinessprobeHealthCheck(IConfiguration configuration)         {             _configuration = configuration;         }          public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())         {                 var connectionString = _configuration[`ehnconnstring`];                 var eventHubName = _configuration[`eventhubname`];                // I have also tried EventHubConsumerClient, there is no difference at all                 var eventHubProducer = new EventHubProducerClient(connectionString, eventHubName);                 _ = await eventHubProducer.GetEventHubPropertiesAsync(cancellationToken);             }             catch (Exception ex)             {                 return Task.FromResult(new HealthCheckResult(HealthStatus.Unhealthy, exception: ex)).Result;             }             return Task.FromResult(new HealthCheckResult(HealthStatus.Healthy)).Result;         }     } And I have similar logic for Kafka consumer, I set up a Kafka consumer and get some metadata and if it gets picked up properly then I consider Kafka available. Expected behavior GetEventHubPropertiesAsync should always return properties without throwing an error even if there are multiple instances of the same consumer app requesting for it at the same time (which is probably the case, I am not sure). Actual behavior Regularly throwing: `An exception occurred while retrieving properties for Event Hub: eventhubname. Error Message: 'This operation is only allowed using a successfully authenticated context.` And there is like absolutely nothing about such error in the docs, I don't even know where to start. Since that kinda points to authentication, I'll add that I am using SAS policy with all the claims (Listen, Send, Manage) to authenticate to EventHub. It's basically exactly the same as Output trigger of the function. I am thinking if maybe the readiness probe is triggered too fast but I already delayed it quite a bit and the app doesn't take long to start, in fact it starts pretty quickly. Just for the record configuration of the probe: readinessProbe:             tcpSocket:               port: 1000             initialDelaySeconds: 25   //that should be plenty and it's been increased already, doesn't make any difference             failureThreshold: 2             timeoutSeconds: 5             periodSeconds: 120 I am not sure what could cause this, is there a limit of `metadata` requests that EventHub can handle and it just starts rejecting them once they come to often? I have up to 10 consumers running per topic so it's 10 consumers requesting for eventhub properties every 2 minutes. This doesn't seem like a lot but maybe it is? Reproduction Steps Pretty much exact code in description but it won't happen unless you run multiple instances for the same topic at once. Environment AKS on Ubuntu nodes Kubernetes: 1.22.6 Nodes: AKSUbuntu-1804gen2containerd-2022.05.10 Dotnet: .NET 6 standalone WebJob based on Console App template Deploy: Docker image
Client	Tables	[QUERY] Why does TableClient.UpdateEntity need a dedicated ETag argument?	Library name and version Azure.Data.Tables 12.6.0 Query/Question Why does TableClient.UpdateEntity have a dedicated ETag argument when it's already part of the entity argument (T:ITableEntity)? Does this extra argument mean that TableClient.UpdateEntity() ignores ITableEntity.ETag? Environment No response
Client	Monitor - ApplicationInsights	Dependency diagnostics comes as Traces with severity level normal in Application Insights	Library name and version Azure.Data.Tables 12.5.0 Query/Question This question pertains the use of logging to Application Insights through DiagnosticSource in the new Data/Storage SDKs and how logs are defined in Application Insight. I have an Azure Functions running as a .NET Core 3.1 app on runtime-version 3 using the legacy Microsoft.Azure.Storage-client libraries for table/queue/blob operations. In this application runtime state, all operations on these infrastructure services where logged as Dependencies in the connected Application Insights. After upgrading the use of client-libraries to the new Azure.Storage.Blob/Queue and Azure.Data.Tables SDKs, the operations no longer are shown as Dependencies but only comes as Traces with Severity level Information. All other things as configuration on the function host regarding logging is unchanged. Is there a setting/SDK dependency that could be reason for this behaviour? Environment Azure Function Function runtime version: 3.7.1.0 App .NET version: .NET Core 3.1
Client	Tables	Fetching the highest value from CosmosDb table	Library name and version Azure.Data.Tables 12.4.0 Query/Question With the SDK of Azure.Data.Tables I’m trying to write a query that groups the data and fetches the highest value from each group. Is there a way to achieve this? Currently I’m fetching all the data and executing the following LINQ query:     public class SomeClass     {         public string CompanyName { get; set; }         public long SomeValue { get; set; }         public string ProperyAttribute1 { get; set; }         public string ProperyAttribute2 { get; set; }         public long ProperyAttribute3 { get; set; }     }      List<SomeClass> someList = FetchingDataFromCosmosDbTableStorage(); //fetching all the data     var result = someList.GroupBy(x => x.CompanyName)                          .Select(y => y.OrderByDescending(i => i.SomeValue).First())                          .ToList();  Instead of filtering all the data in my application I would prefer to write a query to get the same result from CosmosDb Table. Environment Hosting platform: netcoreapp3.1 IDE: Rider 2022.1.2
Client	Service Bus	[QUERY] incorrect or Increased message DeliveryCount on ReceiveAsync() in dot net core 3.1	Library name and version Microsoft.Azure.ServiceBus 5.1.3 Query/Question HI Team, Message has its own DeliveryCount set to its system properties. But when we are trying to pick the message using ReceiveAsync() method it is giving wrong DeliveryCount in system properties. It is giving higher Count. We can not use peek method as we want to remove that message from that queue once it is picked.  So once it is received we are using CompleteAsync method. Package used Microsoft.Azure.ServiceBus 5.1.3 Coding Framework used Dot net core 3.1 Kindly help on the same. Environment No response
Client	Service Bus	[BUG] - ServiceBusSessionReceiver logs error when trying to get next session and none is available	Library name and version Azure.Messaging.ServiceBus 7.7.0 Describe the bug When creating a ServiceBusSessionReceiver using ServiceBusClient.AcceptNextSessionAsync, given that there are no available sessions and given that the user code catches and handles the ServiceBusException (ServiceTimeout) exception that signifies it, and error is still logged to Microsoft.Extensions.Logging and the Error level. This causes a large amount of log messages and extra cost in ApplicationInsights, and doesn't seem to warrant the Error level, since all that is required is to see if there is a next session available to process. DEBUG log from catching the exception when no available sessions are found (user code) [10:41:04 DBG] No unlocked sessions found: workflow-events/processing/processed-layer-input-changed/36e7dd97-ad58-4856-b476-baeb1b4d4757 Azure.Messaging.ServiceBus.ServiceBusException: The operation did not complete within the allocated time 00:01:00 for object receiver126. (ServiceTimeout)  ---> System.TimeoutException: The operation did not complete within the allocated time 00:01:00 for object receiver126.    at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result)    at Microsoft.Azure.Amqp.AmqpObject.OpenAsyncResult.End(IAsyncResult result)    at Microsoft.Azure.Amqp.AmqpObject.EndOpen(IAsyncResult result)    at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location ---    at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenAmqpObjectAsync(AmqpObject target, TimeSpan timeout, CancellationToken cancellationToken, String entityPath)    at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenReceiverLinkAsync(String identifier, String entityPath, TimeSpan timeout, UInt32 prefetchCount, ServiceBusReceiveMode receiveMode, String sessionId, Boolean isSessionReceiver, CancellationToken  cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.OpenReceiverLinkAsync(TimeSpan timeout, UInt32 prefetchCount, ServiceBusReceiveMode receiveMode, String identifier, CancellationToken cancellationToken)    at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)    at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)    at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<OpenLinkAsync>b__72_0>d.MoveNext() --- End of stack trace from previous location ---    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.OpenLinkAsync(CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.ServiceBusReceiver.OpenLinkAsync(CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.ServiceBusSessionReceiver.CreateSessionReceiverAsync(String entityPath, ServiceBusConnection connection, ServiceBusSessionReceiverOptions options, String sessionId, CancellationToken cancellationToken, Boolean isProcessor)    at Azure.Messaging.ServiceBus.ServiceBusClient.AcceptNextSessionAsync(String queueName, ServiceBusSessionReceiverOptions options, CancellationToken cancellationToken)    at PremierCrop.Workflow.Framework.Events.Services.EventSessionManager.RunHandlerAsync(CancellationToken cancellationToken) in C:\dev\pcs\repos\PremierCrop\src\Workflow\PremierCrop.Workflow\Framework\Events\Services\EventSessionManager.cs:line 72  Duplicate ERROR level framework log fail: Azure.Messaging.ServiceBus[79]       An exception occurred while creating a ServiceBusSessionReceiver (Namespace 'pcs-live-jobs.servicebus.windows.net', Entity path 'workflow-events/processing/processed-layer-input-changed/36e7dd97-ad58-4856-b476-baeb1b4d4757'). Error Message: 'Azure.M essaging.ServiceBus.ServiceBusException: The operation did not complete within the allocated time 00:01:00 for object receiver134. (ServiceTimeout)        ---> System.TimeoutException: The operation did not complete within the allocated time 00:01:00 for object receiver134.          at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result)          at Microsoft.Azure.Amqp.AmqpObject.OpenAsyncResult.End(IAsyncResult result)          at Microsoft.Azure.Amqp.AmqpObject.EndOpen(IAsyncResult result)          at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)       --- End of stack trace from previous location ---          at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenAmqpObjectAsync(AmqpObject target, TimeSpan timeout, CancellationToken cancellationToken, String entityPath)          at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenReceiverLinkAsync(String identifier, String entityPath, TimeSpan timeout, UInt32 prefetchCount, ServiceBusReceiveMode receiveMode, String sessionId, Boolean isSessionReceiver, Cancellatio nToken cancellationToken)          at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.OpenReceiverLinkAsync(TimeSpan timeout, UInt32 prefetchCount, ServiceBusReceiveMode receiveMode, String identifier, CancellationToken cancellationToken)          at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)          at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)          at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<OpenLinkAsync>b__72_0>d.MoveNext()       --- End of stack trace from previous location ---          at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)          --- End of inner exception stack trace ---          at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.OpenLinkAsync(CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.ServiceBusReceiver.OpenLinkAsync(CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.ServiceBusSessionReceiver.CreateSessionReceiverAsync(String entityPath, ServiceBusConnection connection, ServiceBusSessionReceiverOptions options, String sessionId, CancellationToken cancellationToken, Boolean isProcessor)'  Expected behavior Only actual Errors are logged, especially in noisy code paths. Specifically, when checking if there is an open session to handle, if there isn't one, do not produce error logs. Actual behavior Logs fill up with errors that are not errors Reproduction Steps  Create Service Bus Queue with session enabled Create ServiceBusClient Request ServiceBusClient.AcceptNextSessionAsync from created queue  Environment No response
Client	Service Bus	[BUG] Service Bus reconnection not behaving as expected	Library name and version Azure.Messaging.ServiceBus (7.6.0) Describe the bug We have noticed we sometimes get exceptions from Service Bus that look something like the following  ScheduleMessageAsync Exception: Azure.Messaging.ServiceBus.ServiceBusException: The link 'G23:RR:213866011:637468380794500000:<queue-name-here>$management:103182:sender' is force detached. Code: ServerError. Details: AmqpControlProtocolClient.Fault. TrackingId:4dbabb40-1cc1-4165-84d9-208b5d2968ef_B35, SystemTracker:<queue-name-here>, Timestamp:2022-05-28T07:21:30 Reference:3bc9b3fb-f97a-4f20-8106-68e709da3b08, TrackingId:1685d478-88e8-4bfd-b2a6-7093948b2e31_G23, SystemTracker:NoSystemTracker, Timestamp:2022-05-28T07:21:30 (GeneralError)    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.ScheduleMessageInternalAsync(IReadOnlyList`1 messages, TimeSpan timeout, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.ScheduleMessageInternalAsync(IReadOnlyList`1 messages, TimeSpan timeout, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<>c.<<ScheduleMessagesAsync>b__24_0>d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Amqp.AmqpSender.ScheduleMessagesAsync(IReadOnlyList`1 messages, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.ServiceBusSender.ScheduleMessagesAsync(IEnumerable`1 messages, DateTimeOffset scheduledEnqueueTime, CancellationToken cancellationToken).  I did some light searching and couldn't seem to find any information on the most meaningful parts of the error. Once we see this error it seems the client gets into a state where it will no longer send any messages, and we usually have to restart the service. Even if we leave it for hours, it never seems to reconnect. The documentation for Service Bus seems to suggest that reconnection should be handled automatically by the library so we were unsure what the recommended way of handling this occurrence is, or how to programmatically spot it to know when to try something more forceful. Expected behavior After server failure, client library should reconnect Actual behavior After server failure, client library does not reconnect Reproduction Steps Unfortunately I do not have any. The problem seems intermittent and caused by something server side. Environment  .NET Core 3.1 Docker container (mcr.microsoft.com/dotnet/aspnet:3.1) Running in AKS  If any more detailed information is required I am happy to provide it but I don't know what would be useful.
Client	Schema Registry	When cloning the repo git warns that a json file path is too long (part of the test json data).	This then results in git thinking that the file was deleted as well.
Mgmt	ARM	[QUERY] What is the syntax for creating generic resources?	Library name and version Azure.ResourceManager 1.0.0 Query/Question The way I did this on the old fluent API:          var insights = await ResourceManager       .Configure()       .Authenticate(creds).WithSubscription(subscriptionName)       .GenericResources.Define(deploymentName)       .WithRegion(regionName)       .WithExistingResourceGroup(rgName)       .WithResourceType(`typeOfRg`)       .WithProviderNamespace(`Microsoft.XXX`)       .WithoutPlan()       .WithApiVersion(`2020-06-01-preview`)      .WithProperties(propertiesJSON)      .CreateAsync();   I am unable to figure out how to do this on this new API version and have been trying to guess how to do it. The closest I could find was this file https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/resources/Microsoft.Azure.Management.Resource/src/Customizations/Models/GenericResource.cs      /// <summary>     /// Initializes a new instance of the GenericResource class.     /// </summary>     /// <param name=`id`>Resource ID</param>     /// <param name=`name`>Resource name</param>     /// <param name=`type`>Resource type</param>     /// <param name=`location`>Resource location</param>     /// <param name=`tags`>Resource tags</param>     /// <param name=`plan`>The plan of the resource.</param>     /// <param name=`properties`>The resource properties.</param>     /// <param name=`kind`>The kind of the resource.</param>     /// <param name=`managedBy`>ID of the resource that manages this     /// resource.</param>     /// <param name=`sku`>The SKU of the resource.</param>     /// <param name=`identity`>The identity of the resource.</param>   But I can't determine what the one to one mapping is from the old API to this new one. I also can't find any examples of this in the repo. Can someone please assist? Environment No response
Mgmt	ARM	Obsolete SDK - Microsoft.Azure.Management.ResourceManager.Fluent	[Enter feedback here] Does not specify if this nuget package is actively being developed or in maintenance mode, and what the replacement is.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 54b34178-4c56-b4e0-8775-2bab5f2b1a36 Version Independent ID: 203f9bf5-e743-871e-8b35-8d037d2bd431 Content: AzureCredentialsFactory Constructor (Microsoft.Azure.Management.ResourceManager.Fluent.Authentication) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Management.ResourceManager.Fluent.Authentication/AzureCredentialsFactory.xml Service: azure-resource-manager GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Service Bus	[BUG]  ServiceBusClient cannot be mocked	Library name and version Azure.Messaging.ServiceBus 7.8.0 Describe the bug Using Moq I'm unable to create a mock of ServiceBusClient. Additionally, when I tried to work-around the issue by extending ServiceBusClient and adding a default constructor to my `mockable` class, Moq still failed with the following error: System.ArgumentException : Type to mock ({0}) must be an interface, a delegate, or a non-sealed, non-static class. ----> System.TypeLoadException : Method 'GetTransportMetrics' on type 'Castle.Proxies.MockableServiceBusClientProxy' from assembly 'DynamicProxyGenAssembly2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' is overriding a method that is not visible from that assembly. Expected behavior Should be able to use mockClient created as follows in unit tests. var mockClient = new Mock(); Actual behavior Mocking fails because default constructor is protected. Additionally, when I tried to work-around the issue by extending ServiceBusClient and adding a default constructor to my `mockable` class, Moq still failed with the following error: System.ArgumentException : Type to mock ({0}) must be an interface, a delegate, or a non-sealed, non-static class. ----> System.TypeLoadException : Method 'GetTransportMetrics' on type 'Castle.Proxies.MockableServiceBusClientProxy' from assembly 'DynamicProxyGenAssembly2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' is overriding a method that is not visible from that assembly. Reproduction Steps [Test] public void FailsWithoutWrapper() { var mockClient = new Mock(); var obj = mockClient.Object;  // Throws an exception } [Test] public void FailsWithWrapper() { var mockClient = new Mock(); var obj = mockClient.Object;  // Throws an exception } public class MockableServiceBusClient : ServiceBusClient { public MockableServiceBusClient() : base(`Endpoint=sb://test.test.net`) { } } Environment Any
Client	Azure.Identity	[BUG] EnvironmentCredential intermittently fails in Visual Studio	Library name and version Azure.Security.KeyVault.Secrets 4.3.0 Describe the bug I'm getting an error retrieving a key from KeyVault that eventually succeeds.  This is when running code in Visual Studio 2022 locally.   Strange, that this same approach for getting a key works in  other projects.  I'm signed into Visual Studio, so I don't think it can be that.   Nothing is different from other projects where this works.  What could the issue be? Expected behavior Get a key without errors like other projects Actual behavior Somehow it is trying to access a 169.254 network prefix, but I'm connected to a network. Error message: [2022-05-12T12:56:21.586Z] Request [704d096f-51e1-449d-a5b7-030ea10a6681] GET http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=REDACTED&client_id=REDACTED [2022-05-12T12:56:21.991Z] EnvironmentCredential.GetToken was unable to retrieve an access token. Scopes: [ https://vault.azure.net/.default ] ParentRequestId: 1b0814a5-c799-414f-ae0f-a1e5ae636392 Exception: Azure.Identity.CredentialUnavailableException (0x80131500): EnvironmentCredential authentication unavailable. Environment variables are not fully configured. See the troubleshooting guide for more information. https://aka.ms/azsdk/net/identity/environmentcredential/troubleshoot[2022-05-12T12:56:22.024Z] Metadata:REDACTED[2022-05-12T12:56:21.322Z] testhubname-control-02: Successfully acquired lease [2022-05-12T12:56:22.025Z] Request [12902295-6022-4cd2-981d-e1868e69e467] PUT Reproduction Steps We have a KeyVault helper class like so.  The exceptions happen when retrieving a key value in the GetKeyVaultSecretValueAsync method  ublic class KeyVaultHelper {     private SecretClient _secretClient;     private readonly IConfiguration _configuration;     public KeyVaultHelper(IConfiguration configuration)     {         _configuration = configuration;         InitSecretClient();     }     public async Task<string> GetKeyVaultSecretValueAsync(string secret)     {         var secretVal = (await _secretClient.GetSecretAsync(secret)).Value.Value;         return secretVal;     }      private void InitSecretClient()     {         string KeyVaultURI = _configuration[`KeyVaultURI`].ToString();         string TenantId = _configuration[`TenantId`].ToString();         string ManagedIdentityId = _configuration[`ManagedIdentityId`].ToString();          var o = new DefaultAzureCredentialOptions();          o.InteractiveBrowserTenantId = TenantId;         o.VisualStudioTenantId = TenantId;         o.ManagedIdentityClientId = ManagedIdentityId;         o.SharedTokenCacheTenantId = TenantId;         o.VisualStudioCodeTenantId = TenantId;          o.ExcludeInteractiveBrowserCredential = false;         o.ExcludeVisualStudioCodeCredential = false;         o.ExcludeVisualStudioCredential = false;         o.ExcludeSharedTokenCacheCredential = false;         o.ExcludeAzureCliCredential = false;         o.ExcludeManagedIdentityCredential = false;          var ac = new DefaultAzureCredential(o);          _secretClient = new SecretClient(         new Uri(KeyVaultURI),         ac);     }  Environment Azure functions project .Net 6 Visual Studio 2022 Enterprise 17.0.0 Widows 10
Client	Event Hubs	[QUERY] EventHubsConnectionStringBuilder in Azure.Messaging.EventHubs?	Library name and version latest Query/Question I have an old codebase (Microsoft.Azure.EventHubs-based) that uses EventHubsConnectionStringBuilder like this: var connectionStringBuilder = new EventHubsConnectionStringBuilder(configConnectionString); connectionStringBuilder.OperationTimeout = TimeSpan.FromSeconds(configOpTimeoutSeconds);  First off, there is no EventHubsConnectionStringBuilder or replacement (at least I didn't see one). Secondly, I don't see a replacement for OperationTimeout. How would I correctly translate this code to A.M.EH? Thanks. Environment No response
Client	Service Bus	[QUERY] Routing messages to the same runned consumers	Library name and version Azure.Messaging.ServiceBus 7.7.0 Query/Question I had that scenario in Kafka and now I want accomplish similar behavior with Service bus. I have topic and subscription on it. Every message in this topic have some key which is customer id. If I run few consumers, every consumer will consume some message randomly, but it's not I really want. What I want. I have customers with id 1,2,3,4,5,6. I run 2 consumers and send 6 messages every of which contains customer id 1-6. In perfect case I want consumer1 and consumer2 will receive 3 messages each. It doesn't matter what exactly id they receive, important if I send the same messages again, consumer1 and consumer 2 will receive the same messages. It will be okay if consumer1 receives messages with customer id 1-4, consumer 2 with 5-6. I mean it's not required every consumer receive exactly the same count of messages. But it's really highly desirable that each consumer receive more or less similar count of messages. If I add third consumer I want each of three consumers to receive ~2 messages each. And it also doesn't matter who receive specific messages. It's important each of them receives messages with id which doesn't receive any other consumer. I have read about sessions. It seems like session is purposed for my scenario. But there are some unpleasant moments:  With sessions you have to set session for consumer before start receiving. First, in my case I will have thousands of sessions and this looks strange to me. Second, there will be new customers that don't yet have an ID at the time the consumers are launched. I have read somewhere that you should close sessions explicitly when receive last message in the session. In my case session can live infinity time and I don't know if it already finished yet or not.  Considering that 2 points I think sessions doesn't suitable for my scenario. In Kafka, you can implement this scenario with partitions. Each message with specified key will be sent to one specific partition. Every consumer reads from particular partition and you don't have to think about all that because all that is implemented at the Kafka's protocol level. Knowing that I also tried use partitions in Service bus when was creating a topic and passing PartitionKey in every message. But consumers still receive messages randomly. How can I achieve different consumers don't receive messages with the same key given that amount of keys is large and at starting moment I even don't know all possible keys? Environment No response
Client	Service Bus	[QUERY] Prewarm link to ServiceBus	Library name and version Azure.Messaging.ServiceBus 7.7.0 Query/Question Hi, I noticed that when the first message is sent to the Service Bus queue, it takes significant (~3-5s) time to send the message. The next messages are sent pretty fast. I am using managed identity to connect to the service bus. I am guessing that when the message is first sent, you establish a link to the Service Bus and obtaining the identity token takes a major portion of the time. The question is: Is there a way to prewarm the link so that the first message is sent quickly? This was also mentioned in: #13010 Environment Azure Function with latest SDK (4.3.*)
Client	Azure.Identity	[BUG] : SQL connection pool issue when using the MSI token for SQL generated with Azure.Identity	Library name and version Azure.Identity 1.5.0 Describe the bug We migrated our solution from ADAL to MSAL , and in our code we were using Microsoft.Azure.Services.AppAuthentication which was used to get the MSI token and that token was used by SQL (entity framework core) to authenticate. As this Microsoft.Azure.Services.AppAuthentication package has a dependency on ADAL we have replaced it with Azure.Identity 1.5.0. So when we use the MSI token generated for SQL with Azure.Identity , SQL connection pooling seems to be broken , as we started getting below error related to the SQL connection pool. Error : Resource ID : 2. The session limit for the elastic pool is 30000 and has been reached. See 'http://go.microsoft.com/fwlink/?LinkId=267637' for assistance. Changed database context to ''. Changed language setting to us_english. when we keep all settings same and switch back to old code which was using MSI tokens generated from : Microsoft.Azure.Services.AppAuthentication we do not see this error on same load test execution. Expected behavior The expected behavior is that it should not break the SQL connection pooling with MSI token generated with Azure.Identity. Actual behavior We are getting SQL connection pooling error with MSI token generated with Azure.Identity, Error : Resource ID : 2. The session limit for the elastic pool is 30000 and has been reached. See 'http://go.microsoft.com/fwlink/?LinkId=267637' for assistance. Changed database context to ''. Changed language setting to us_english. Reproduction Steps   Generate the MSI token for SQL resource var tokenCredential = new Azure.Identity.DefaultAzureCredential(); var managedIdentityTokenForSql = tokenCredential.GetToken( new Azure.Core.TokenRequestContext( new[] { `https://database.windows.net/.default` }, tenantId: `your_tenantId`)).Token;   Now use this token and pass to the entity framework core : var connection = Database.GetDbConnection() as SqlConnection; if (connection != null) { connection.AccessToken = managedIdentityTokenForSql; }   perform load test on this where more number of transactions are executed against SQL DB.   Environment  The Server API Layer which interacts with DB through Entity framework code is deployed to Azure Web App service. Managed identity is enabled on the that Azure App service. The web app is built using .NET core 3.1 version. EF core Version=3.1.7.0 .
Client	Service Bus	How is RabbitMQ faster than Service Bus?	Library name and version Azure.Messaging.ServiceBus 7.7.0 Query/Question I'm comparing the performance between RabbitMQ and Azure Service Bus. The difference is huge up to a 1000 times to send a simple message. I want to understand how this difference is so huge while both seem to use the amqp protocol? Environment Both run on azure.
Client	Event Hubs	[QUERY] Event Hub EnqueueTime latency	Library name and version Azure.Messaging.EventHubs 5.6.2 Query/Question Hi, I have a following setup:  1 Event Hub with 10 partitions 1 producer 2 consumers in 1 consumer group  I am sending messages in consecutive batches (lets say 1k of batches one after another) using SendAsync method. Each batch consists of 3592 messages. I also log:  batch creation time time after SendAsync is completed message enqueue time  Now, SendAsync is super fast, it takes like milliseconds to execute. But what is strange is an enqueue time. It seems like messages in the batch are sent to 4 different partitions, and enqueue time for each partition is very different from one another. For example 892 messages sent to one partition are enqueued immediately, another 892 messages sent to other partition are enqueued after (respectively): 34 seconds, 1min 7sec, and 1min 40sec. This happens with every single batch. Here are some examples (logs ordered by Batch Index and Enqueue time):    Batch Index Message created After SendAsync EnqueueTime Messages Count     0 09:18:26.6965485 09:18:27.0697804 00:00:00.0000000 898   0 09:18:26.6965485 09:18:27.0697804 00:00:34.7122196 898   0 09:18:26.6965485 09:18:27.0697804 00:01:07.3632196 898   0 09:18:26.6965485 09:18:27.0697804 00:01:40.0412196 898   1 09:18:27.0704663 09:18:27.4179192 00:00:00.0000000 898   1 09:18:27.0704663 09:18:27.4179192 00:00:34.3940808 898   1 09:18:27.0704663 09:18:27.4179192 00:01:07.0530808 898   1 09:18:27.0704663 09:18:27.4179192 00:01:39.7370808 898    And so on and so on. My question is: how this can be explained? Any help would be highly appreciated
Service	Service Bus	[BUG] ServiceBusException with MessagingEntityNotFound when unauthorized?	Library name and version Azure.Messaging.ServiceBus 7.7.0 Describe the bug When trying to connect to the service using ServiceNamespace and credentials (ChainedTokenCredential), if using managed identity with an identity (client id) that as no access to the service, the library throws a ServiceBusException with reason MessagingEntityNotFound. The operation being called is ServiceBusAdministrationClient.DeleteTopicAsync(), do this behavior makes it impossible to distinguish between an unauthorized error (the case) or the error that should happen when the topic does not exist. Expected behavior I think this should raise an UnauthorizedAccessException (?). Actual behavior The exception that is being raised by the library follows: Azure.Messaging.ServiceBus.ServiceBusException: Service request failed. Status: 404 (Not Found)  Content: <Error><Code>404</Code><Detail>No service is hosted at the specified address. TrackingId:2e8f1d1c-7330-4506-9feb-5a20cb71b26c_G30, SystemTracker:hydrogen-tests.servicebus.windows.net:HT-AEBMSfdb33562-96b1-4b50-a136-ed040106e234, Timestamp:2022-04-28T10:25:21</Detail></Error>  Headers: Transfer-Encoding: chunked Server: Microsoft-HTTPAPI/2.0 Strict-Transport-Security: REDACTED Date: Thu, 28 Apr 2022 10:25:20 GMT Content-Type: application/xml; charset=utf-8  (MessagingEntityNotFound)  ---> Azure.RequestFailedException: Service request failed. Status: 404 (Not Found)  Content: <Error><Code>404</Code><Detail>No service is hosted at the specified address. TrackingId:2e8f1d1c-7330-4506-9feb-5a20cb71b26c_G30, SystemTracker:hydrogen-tests.servicebus.windows.net:HT-AEBMSfdb33562-96b1-4b50-a136-ed040106e234, Timestamp:2022-04-28T10:25:21</Detail></Error>  Headers: Transfer-Encoding: chunked Server: Microsoft-HTTPAPI/2.0 Strict-Transport-Security: REDACTED Date: Thu, 28 Apr 2022 10:25:20 GMT Content-Type: application/xml; charset=utf-8     --- End of inner exception stack trace ---    at Azure.Messaging.ServiceBus.Administration.HttpRequestAndResponse.ThrowIfRequestFailedAsync(Request request, Response response)    at Azure.Messaging.ServiceBus.Administration.HttpRequestAndResponse.SendHttpRequestAsync(Request request, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Administration.HttpRequestAndResponse.DeleteEntityAsync(String entityPath, CancellationToken cancellationToken)    at Azure.Messaging.ServiceBus.Administration.ServiceBusAdministrationClient.DeleteTopicAsync(String name, CancellationToken cancellationToken)    at Primavera.Hydrogen.EventBus.Azure.AzureEventBusManagementService.<>c__DisplayClass20_0.<<DeletePathAsync>b__0>d.MoveNext() in D:\GitHub\lithium-product-core.hydrogen\src\server\EventBus.Azure\AzureEventBusManagementService.cs:line 231 --- End of stack trace from previous location ---    at Primavera.Hydrogen.EventBus.Azure.AzureEventBusExceptionHandler.HandleAsync(Func`1 action, Target target, Object[] args) in D:\GitHub\lithium-product-core.hydrogen\src\server\EventBus.Azure\AzureEventBusExceptionHandler.cs:line 53  Reproduction Steps See above.  Create a new instance of ServiceBusAdministrationClient using ChainedTokenCredential with managed identity and an existing client that has no access to the service bus service (e.g. the identity of an app service for example).  NOTE: I used the client id for the managed identity given that this is being tested from a local development machine).  Invoke ServiceBusAdministrationClient.DeleteTopicAsync() on a topic that does not exist.  Environment .NET SDK (reflecting any global.json): Version:   6.0.202 Commit:    f8a55617d2 Runtime Environment: OS Name:     Windows OS Version:  10.0.19042 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.202\ Host (useful for support): Version: 6.0.4 Commit:  be98e88c76 .NET SDKs installed: 2.1.526 [C:\Program Files\dotnet\sdk] 5.0.300 [C:\Program Files\dotnet\sdk] 5.0.405 [C:\Program Files\dotnet\sdk] 6.0.202 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.22 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.24 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.22 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.24 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.22 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.24 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Tables	Tables migration guide - guidance on migrating segmented queries, with continuation tokens	Library name and version Azure.Data.Tables @ 12.5.0 Query/Question I have CloudTable code that calls ExecuteQuerySegmented to get (say) 200 entities at a time.  It passes back the entities, plus the returned continuation token (base64-encoded), from the web server to the web client.  When the user clicks on `Load more` the web client makes another request, and passes up the continuation token.  Pretty easy stuff. I am working my way through translating this into Azure.Data.Tables.  It's not plain sailing. Perhaps you can give some guidance in this ticket, and also include this topic in the Migration Guide? Environment Windows 10 .NET 6 Visual Studio 2022
Mgmt	KeyVault	[QUESTION] Is there no Purge feature for Key Vaults in the new Management SDK for .net?	Library name and version Azure.ResourceManager.KeyVault v1.0.0-beta.8 Query/Question We want to Purge the keyvault resource using SDK but we are not able to find the required method in the current SDK for .net. Is there a plan to add it? Environment Hosting platform or OS and .NET runtime version : Azure AppService DotNet Core 5 IDE and version : Version 17.2.0 Preview 5.0
Client	Event Hubs	Multiple consumer instances from a same Azure Event Hub partition, avoid duplicates using checkpointing	Library name and version Azure.Messaging.EventHubs 5.6.2 Query/Question I see in the Azure Event Hub documentation that `There can be at most 5 concurrent readers on a partition per consumer group` also `if you have multiple readers on the same partition, then you process duplicate messages`. I also read several articles; they all recommend to have only one reader per partition per consumer group. We have a scenario in which producers push events to partitions based on a partition key/id. We have several such producers each pushing messages to its partition. We have a single consumer group and several consumers in it in which each reader reads from a partition using partition id.  Sometimes, more events gets pushed in a particular partition due to the increase of input generated by the producer sending to that partition. During this scenario we are planning to increase the number of the instances of the consumer of that particular partition alone. But the consumer instances should not end up receiving the same events. Is there a way/sample in which consumers of the same partition can receive unique events (probably each consumer creating a checkpoint for the other, or something of that fashion). I read this and also other related threads, but our scenario is different I guess. Kindly provide your thoughts. Environment No response
Client	Service Bus	[FEATURE REQ] Peek scheduled messages.	Library name Azure.Messaging.ServiceBus Please describe the feature. I'm not sure if this should be a bug instead. Feel free to change this as necessary. In the previous iterations of the Azure Services Bus client libraries for .NET (WindowsAzure.ServiceBus and Microsoft.ServiceBus.Messaging) it was possible to peek scheduled messages with TopicClient.Peek() and TopicClient.PeekAsync() According to this previously closed issue:  Scheduled messages reside in the topic until the scheduled time, and users should peek into the topic if they want to see the scheduled messages. Scheduled Messages can not be peeked from a subscription since they are not present in the subscription.  (strangely, the information added to the docs in this issue, seems to be gone again) However in Azure.Messaging.ServiceBus, there is no equivalent to TopicClient, Instances of ServiceBusReceiver are always configured to a subscription on a topic, and never directly to the topic. Thus there is no way to peek scheduled messages, using Azure.Messaging.ServiceBus, despite the documentation here stating so. Seeing as the the service bus API's and earlier .NET client libraries support peeking scheduled messages directly on a topic, Azure.Messaging.ServiceBus should as well.
Client	Tables	[BUG] Using storage table int properties starting with lowercase will crash your app	Library name and version Azure.Data.Tables 12.5.0 Describe the bug If you have in your storage table and your model a property that is int and starts with lower case, your query on it will crash with `System.InvalidCastException: 'Unable to cast object of type 'System.String' to type 'System.Int32'.'` If you change your model and put the first letter of your property name with upper case there will be no error, but the value of that field will be 0 (because there is no match in the column name from the table). If you change the table also and put the property name with first letter uppercase, everything works normal. If you use TableEntity instead of a model (like T), you can access the property with [`propertyName`] and everything works. Expected behavior You can use table storage properties starting with lowercase and uppercase. Actual behavior The application crashes with `System.InvalidCastException: 'Unable to cast object of type 'System.String' to type 'System.Int32'.'` Reproduction Steps Have a model class:  In the storage have like this for example:  Using the following ways to read the storage table will crash:  or  Environment Windows 11, C#, .NET6, Visual Studio Professional 2022 (17.1.3)
Client	Tables	[BUG] Tables: Query with a Type that contains a decimal returns an incorrect value	Library name and version Azure.Data.Tables 12.5.0.0 Describe the bug Using Query or QueryAsync with a Type that contains a decimal returns an instance with that decimal property being set to 0. Writing it works as expected and the value can be seen with azure storage explorer. If I change the type to double and request the existing record(which was saved with a decimal property type) the instance contains the expected value. Expected behavior Querying should return an instance of the object with the same values as they were written to the datatable Actual behavior Querying returns an instance of the object where decimal properties are set to 0 Reproduction Steps class sample: internal class CustomTableEntity : Azure.Data.Tables.ITableEntity     {         public string PartitionKey { get; set; }         public string RowKey { get; set; }         public DateTimeOffset? Timestamp { get; set; }         public ETag ETag { get; set; }           public CustomTableEntity() { }      }      internal class ForexEntity : CustomTableEntity     {         public string Currency { get; set; }         public decimal ForexRate { get; set; }         public DateTime? ForexTimestamp { get; set; }         public DateTime? recDateTime { get; set; }         public ForexEntity() { }      } code sample:             var tableClient = tableServiceClient.GetTableClient(forexTable);              var status = tableClient.CreateIfNotExists();             var result = tableClient.Query<ForexEntity>(filter: $`PartitionKey eq '{partitionKey}'`).FirstOrDefault(); Tested with unit under Net6 and Net 4.6.2 Decimals worked just fine with the old API (Microsoft.WindowsAzure.Storage). Is there some magic serialization option one needs to turn on? Because the odata response seems perfectly ok: {`odata.metadata`:`https://lukadevelopment.table.core.windows.net/$metadata#Forex`,`value`:[{`odata.etag`:`W/\`datetime'2022-04-14T13%3A29%3A03.0553874Z'\``,`PartitionKey`:`EUR`,`RowKey`:`2517523578601951356`,`Timestamp`:`2022-04-14T13:29:03.0553874Z`,`Currency`:`EUR`,`ForexRate`:1.1,`recDateTime@odata.type`:`Edm.DateTime`,`recDateTime`:`2022-04-14T13:28:57.8103894Z`}]} Environment Visual studio 2022 (64-bit) Version 17.1.3 Windows 11 Pro 21H2 22000.593 Tested with Net 6 and Net 4.6.2
Client	Event Hubs	Event hub get partition id from key	Library name and version Azure.Messaging.EventHubs 5.6.2 Query/Question I have two questions  While sending events to an event hub I am doing the below             var producer = new EventHubProducerClient(connectionString, eventHubName);              try             {                 var batchOptions = new CreateBatchOptions                 {                     PartitionKey = `PartitionKeyName`                 };                  using EventDataBatch eventBatch = await producer.CreateBatchAsync(batchOptions);                  for (var index = 0; index < 5; ++index)                 {                     var eventData = new EventData($`Event #{ index }`);                      if (!eventBatch.TryAdd(eventData))                     {                         throw new Exception($`The event at { index } could not be added.`);                     }                 }                  await producer.SendAsync(eventBatch);             } While receiving, I need to receive from the same partition that I used for sending                 await foreach (PartitionEvent partitionEvent in consumer.ReadEventsFromPartitionAsync(                     partitionId,                     startingPosition,                     cancellationSource.Token)); The second parameter needs the partitionid. Is there a way I can get partition id from the partition key (which I used for sending)?  I need to create a consumer group dynamically. I found an answer in the link below.  https://github.com/Azure/azure-event-hubs/blob/master/samples/Management/DotNet/EventHubsManagementSample/EventHubsManagementSample.cs But it needs client id, client secret, tenant id and subscription id. Can't I create a consumer group using the Azure.Messaging.EventHubs or some other library using the connection string of the event hub? Environment .NET 6 console app running in a Windows 10 machine.
Client	Storage	[QUERY] Which AccessTiers are queried by the FindBlobsByTagsAsync method on the BlobContainerClient	Library name and version Azure.Storage.Blobs 12.11.0 Query/Question Does the FindBlobsByTagsAsync method return results for blobs in the archive tier?  And if so is there anyway to filter those out? Environment No response
Client	Service Bus	Batch complete not available	I am trying to use the ServiceBusReceiver from the packages here  and Ive noticed there is no batch operations except for read and send. Is there a reason we arent given this option? Ive tried several methods, but the underlying problem is that the requests only ever send one message (for a batch of 9k messages this is 9k queries!) so its very slow.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 0adc2721-d8e1-adb7-d99f-a6307882e3c4 Version Independent ID: f7c2edbf-0b8a-ec2f-e0e8-26d896a21f60 Content: ServiceBusReceiver.CompleteMessageAsync(ServiceBusReceivedMessage, CancellationToken) Method (Azure.Messaging.ServiceBus) - Azure for .NET Developers Content Source: xml/Azure.Messaging.ServiceBus/ServiceBusReceiver.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Identity	Connect to KeyVault in Azure China	Library name and version Azure.Security.KeyVault.Certificates 4.2.0 Query/Question I use this code for Azure KeyVault Service and it works well with a regular Azure     ClientSecretCredential clientCredential = new(options.KeyVaultTenantId, options.KeyVaultClientId, options.KeyVaultClientSecret);     KeyVaultCertificateWithPolicy rootCertificate = new CertificateClient(vaultUri, _clientCredential).GetCertificate(_rootCertificateId).Value;  however, I need to connect to Azure China. The code fails with message:  AADSTS90002: Tenant 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' not found. Check to make sure you have the correct tenant ID and are signing into the correct cloud. Check with your subscription administrator, this may happen if there are no active subscriptions for the tenant  I found this but I don't know where to set ActiveDirectoryServiceSettings.AzureChina in my code. Please suggest     <PackageReference Include=`Azure.Identity` Version=`1.5.0` />     <PackageReference Include=`Azure.Security.KeyVault.Certificates` Version=`4.2.0` />     <PackageReference Include=`Azure.Security.KeyVault.Keys` Version=`4.2.0` />     <PackageReference Include=`Azure.Security.KeyVault.Secrets` Version=`4.2.0` />  Environment .NET SDK (reflecting any global.json): Version:   6.0.201 Commit:    ef40e6aa06 Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.201\ Host (useful for support): Version: 6.0.3 Commit:  c24d9a9c91 .NET SDKs installed: 5.0.404 [C:\Program Files\dotnet\sdk] 6.0.100 [C:\Program Files\dotnet\sdk] 6.0.201 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.22 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.22 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Tables	Applying Scopes to TableClient with TokenCredential	Library name and version Azure.Data.Tables 12.5.0 Query/Question Table client constructor has an overload that takes a TokenCredential but I cannot see a best practice way to pass in alternative Authentication Scopes. Background : I'm working on a blazor WASM application which uses MSAL  for user authentication. The app uses several API's and so I cannot set multiple default scopes in MSAL, and must request separate tokens for each service. By using the above mentioned overload, I can delegate the token requesting process to MSAL during service creation. At the moment I have this working by implementing a custom TokenCredential which takes an IAccessTokenProvider the scopes and which overrrides the GetTokenAsync method as below. class MsalTokenCredential : TokenCredential     {         IAccessTokenProvider _provider = null!;         string[] scopes = null!;     public MsalTokenCredential(IAccessTokenProvider MsalProvider, string[] Scopes)         {             _provider = MsalProvider;             scopes = Scopes;         }          public override ValueTask<Azure.Core.AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)         {             var getter = async () =>             {                 var tro = new AccessTokenRequestOptions();                 tro.Scopes = scopes;                 var atr = await _provider.RequestAccessToken(tro);                 if (atr.TryGetToken(out var token))                 {                     return new Azure.Core.AccessToken(token!.Value, token!.Expires);                 }                 throw new ApplicationException(`Unable to get token for Azure tables`);             };             return new ValueTask<Azure.Core.AccessToken>(getter());         }     }  However this discards the TokenRequestContext passed to the overload. Looking though the source of TableClient it appears that internally the scope is defaulted to `https://storage.azure.com/.default` and so dropping the passed in TokenRequestContext is not a huge issue if the above implementation is used. The only other way I could see of solving the problem was to provide a Transport in the TableClientOptions but I didn't attempt that as directly modifying the HttpMessage smelt worse that the above solution. Whilst the above works for my situation, it feels hacky and leaves me thinking there should be a neater approach. Is there  ? Environment .NET SDK (reflecting any global.json): Version:   6.0.201 Commit:    ef40e6aa06 Runtime Environment: OS Name:     Windows OS Version:  10.0.22000 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.201\ Host (useful for support): Version: 6.0.3 Commit:  c24d9a9c91 .NET SDKs installed: 5.0.406 [C:\Program Files\dotnet\sdk] 6.0.201 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Visual Studio 17.1.2
Client	Event Grid	Support for aeg-channel-name header in Azure.Messaging.EventGrid	Partner Events in Event Grid recommend routing via Channels - https://docs.microsoft.com/en-us/azure/event-grid/partner-events-overview-for-partners#channel. Routing via Channels is to be supported via HTTP Header aeg-channel-name The Microsoft API documentation also mentions use of aeg-channel-name in request header for publishing to partner namespaces https://docs.microsoft.com/en-us/rest/api/eventgrid/dataplane/publish-cloud-event-events/publish-cloud-event-events However I wasn't able to see support for specifying this header while creating EventGridPublisherClient (https://github.com/Azure/azure-sdk-for-net/tree/Azure.Messaging.EventGrid_4.10.0/sdk/eventgrid/Azure.Messaging.EventGrid). Is this header not yet supported in SDK, if not when is the plan to implement it's support.
Client	Monitor	[FEATURE REQ] Query to support parameters	Library name Azure.Monitor.Query Please describe the feature. Use QueryWorkspaceAsync as an example, it only accepts a query string. When I create my query and pass my parameters into a query, I have to do verification to make sure the parameter is valid and basically to avoid a query injection attack(not sure if that's a thing, but you know, this is a query) Is it possible to implement an overload method to take parameters? I am seeing some examples here but not for Azure.Monitor.Query https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/queryparametersstatement?pivots=azuredataexplorer
Mgmt	Marketplace Ordering	[BUG] Microsoft.Azure.Management.MarketplaceOrdering NuGet package is out of date and missing a lot of functionality	Library name and version Microsoft.Azure.Management.MarketplaceOrdering 1.0.1 Describe the bug The latest NuGet package version of Microsoft.Azure.Management.MarketplaceOrdering 1.0.1 appears to be out of date. It was last updated in 2018 and the following problems have been found which look like they'd be resolved by releasing a new update:  A lot of MarketplaceAgreementsOperationsExtensions methods listed here are missing:  Sign SignAsync Cancel CancelAsync GetAgreement GetAgreementAsync List ListAsync    Like above, the underlying IMarketplaceAgreementsOperations methods listed here are missing:  SignWithHttpMessagesAsync CancelWithHttpMessagesAsync GetAgreementWithHttpMessagesAsync ListWithHttpMessagesAsync    Another complication with this package being out of date is that its method signatures are inconsistent with the other Azure SDK client libraries. For example, the constructors for MarketplaceOrderingAgreementsClient do not accept an HttpClient. Please can the NuGet package be updated to reflect these changes to the SDK? Expected behavior All of these methods should be available when using the C# NuGet package. Actual behavior None of these methods (and more) are available when using the C# NuGet package. Reproduction Steps Pull the latest version of the C# NuGet package into a project and attempt to use any of the methods listed above. You should see reference errors. Alternatively, if you decompile the assembly you can see that those methods are missing. Environment  .NET 6.0 JetBrains Rider 2021.2.1
Client	Event Grid	[BUG] [EventGrid] Cloud event time serialization	Library name and version Azure.Messaging.EventGrid Describe the bug Hello When I publish cloud events with time in the UTC format - I see time with offset but should be without offset, just with Z in the end. Could you please add a custom serialization or make this field virtual or string or something else? Thank you, best regards. Expected behavior `time`: `2022-04-05T19:19:42.58Z` Actual behavior `time`: `2022-04-05T19:19:42.5805717+00:00` Reproduction Steps Publish cloud events with time in the UTC format. Environment No response
Client	Event Hubs	[QUERY] How to use an active/active pattern for event processing using Event Hubs.	Library name and version Azure.Messaging.EventHubs Query/Question Today I use Front Door and Function Apps to relay events into Event Hubs. I do this so that we can use an active/active pattern that weights traffic evenly for efficient processing, and gain automatic fail over which solves zero downtime deployments and geo disaster recovery. I have additional Function Apps that pull events from Event Hub to do most of the business processing and data manipulations. I like Event Hubs because it allows my functions to scale with the event traffic and it gives me a way to ingest events without worrying about long running processes. My question is if this is the correct way to implement an active/active pattern for event processing? Is there a better way to implement this? I've looked into using active/passive patterns and using Event Hubs directly to ingest events but it doesn't meet all of our fail over requirements. I would really love the ability to use Front Door directly in front of Event Hubs without needing an HTTP receiver in between. That doesn't seem to be possible today due to networking constraints with Event Hubs. Environment No response
Client	Storage	So what are the possible values for the content types? Why not list them	[Enter feedback here]  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 07b1f22d-9cef-a2ca-edd2-3094d81f73a5 Version Independent ID: 285b2f60-7604-6090-fa7e-21848beb025f Content: BlobProperties.ContentType Property (Microsoft.Azure.Storage.Blob) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Storage.Blob/BlobProperties.xml Service: storage GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	KeyVault	[QUERY] KeyVault libraries - data cryptography	Library name and version Microsoft.Azure.KeyVault.* 4.x.x Query/Question Hi all! Do KeyVault libraries (Microsoft.Azure.KeyVault.* or Azure.Security.KeyVault.*) support data cryptography? When my application gets or sets keys (and values), inside library, are data stored in memory with cryptography or clear text? Scenario: I am evaluating best practices to keep secrets secure to avoid leaks in Kubernetes Pods. My application runs on AKS. Thanks. Environment .NET Core 3.1 and 5, AKS Linux Containers (Alpine Linux) IDE version: not applicable
Client	Service Bus	[QUERY] Porting to .net 6 - behind a proxy - connection string induced amqpwebsockets transport type - seems not working anymore	Library name and version Microsoft.Azure.WebJobs.Extensions.ServiceBus/Azure.Messaging.ServiceBus Query/Question Porting our Azure function to .net core 6/fn v 4 so this involved switching Microsoft.Azure.WebJobs.Extensions.ServiceBus over to 5.3.0 so internally it switches from deprecated SB SDK to Azure.Messaging.ServiceBus we are running behind a corp proxy here we used to be able to append transport mode to connection string to switch over to amqpwebsockets (443) as in `ServiceBusQueueConnection`: `Endpoint=sb://....;TransportType=AmqpWebSockets`, this no longer works and I have to switch the transport mode via config (which is fine) or code I guess e.g. `AzureFunctionsJobHost:extensions:ServiceBus:TransportType`: `AmqpWebSockets`, Just wondering if this is recognized `breaking change` or essentially a bug? Environment .net60 local env on VS 17.1.2 azure function tooling 4.0.1
Client	Storage	When using CloudBlob.DownloadRangeToByteArrayAsync (byte[] target, int index, long? blobOffset, long? length)  to download, each How many http connections are used in one call?	Library name and version Microsoft.Azure.Storage.Blob, Version=11.2.3.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35 Query/Question When using CloudBlob.DownloadRangeToByteArrayAsync (byte[] target, int index, long? blobOffset, long? length)  to download, each How many http connections are used in one call? Environment Core3.1 Ubuntu 18.4   VM(IOT device 1Core + 1G)
Client	Event Grid	Update nuget package reference from beta	Probably should update the client library reference from 4.0.0-beta.4 to something like 4.9.0  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 0e236e89-a929-1c68-0dee-246b2a5b4a5f Version Independent ID: 99f80e40-5907-c1b4-4da2-24830f53d3ba Content: Azure Event Grid client library for .NET - Azure for .NET Developers Content Source: api/overview/azure/messaging.eventgrid-readme-pre.md Service: eventgrid Product: azure Technology: azure GitHub Login: @ramya-rao-a Microsoft Alias: ramyar
Client	Service Bus	[BUG] ServiceBusRetryOptions seems to be not working	Library name and version Azure.Messaging.ServiceBus 7.6.0 Describe the bug We recently experienced ServiceBus issues where after receiving a bunch of ServiceTimeout exceptions noticed in application insights no retries. We have ServiceBusRetryOptions setup as follows for our client: var serviceBusClientOptions = new ServiceBusClientOptions()             {                 RetryOptions = new ServiceBusRetryOptions()                 {                     MaxRetries = 5,                     Mode = ServiceBusRetryMode.Exponential,                     MaxDelay = TimeSpan.FromSeconds(30),                     TryTimeout = TimeSpan.FromSeconds(30)                 }             };  And in application insights it is shown to only have taken 30s.  Expected behavior Expect request duration to be longer as it should include all 5 retries. Actual behavior Request seems to return ServiceTimeout exception after first attempt. Reproduction Steps Difficult to reproduce on demand. Environment Azure AppService .Net Version: 6.0.1
Client	Event Hubs	[BUG] Event Hubs trigger logging is too verbose	Library name and version Microsoft.Azure.WebJobs.Extensions.EventHubs 5.0.1 Describe the bug With debug level set to information or trace, blob storage logging it continually written to the log file. This has started since upgrading from 4.x -> 5.x func Information: 0 : 2022-03-17 15:08:19.132 -07:00 [Information] Request [f8477694-d7fa-481e-a951-014bb17f3031] PUT http://127.0.0.1:10000/devstoreaccount1/azure-webjobs-hosts/locks/testapp3650-1196446786/host?comp=lease x-ms-lease-action:renew x-ms-lease-id:00000000-0000-0000-0000-0000d1faff4c x-ms-version:2020-08-04 Accept:application/xml x-ms-client-request-id:f8477694-d7fa-481e-a951-014bb17f3031 x-ms-return-client-request-id:true User-Agent:azsdk-net-Storage.Blobs/12.9.0,(.NET 6.0.0-rc.2.21480.5; Microsoft Windows 10.0.22000) x-ms-date:Thu, 17 Mar 2022 22:08:19 GMT Authorization:REDACTED client assembly: Azure.Storage.Blobs func Information: 0 : 2022-03-17 15:08:19.151 -07:00 [Information] Response [f8477694-d7fa-481e-a951-014bb17f3031] 200 OK (00.0s) Transfer-Encoding:chunked ETag:`0x8DA08629E2F6570` Server:Windows-Azure-Blob/1.0,Microsoft-HTTPAPI/2.0 x-ms-request-id:01b14da5-79bb-4b42-87b8-9804f824869f x-ms-version:2020-08-04 x-ms-lease-id:00000000-0000-0000-0000-0000d1faff4c Date:Thu, 17 Mar 2022 22:08:19 GMT Last-Modified:Thu, 17 Mar 2022 22:08:08 GMT Expected behavior Heavy logging is something that must be enabled specifically rather than the default.  The ability to disable via log level is possible in the host.json. Actual behavior Logging can only be disabled by turning log level to warning or above. Reproduction Steps  Create Azure Function in VS 2022 with an Event Hub trigger Run application  Logging is captured around writes to blob storage host.json { `version`: `2.0`, `logging`: { `LogLevel`: { `Default`: `Information` }, `applicationInsights`: { `samplingSettings`: { `isEnabled`: true, `excludedTypes`: `Request` } } } } Environment Azure Functions IDE: VS2022 Microsoft Visual Studio Community 2022 (64-bit) - Preview Version 17.2.0 Preview 1.0 Rider 2021.3.3 .NET SDK (reflecting any global.json): Version:   6.0.200 Commit:    4c30de7899 Runtime Environment: OS Name:     Windows OS Version:  10.0.22000 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.200\ Host (useful for support): Version: 6.0.2 Commit:  839cdfb0ec
Client	Service Bus	[BUG] IHostedService (CTRL+C) - A receive operation was cancelled while stopping the processor or scaling down concurrency.	Library name and version Azure.Messaging.ServiceBus 7.7.0 Describe the bug I'm using Azure Service Bus with a background service (IHostedService) and while doing some testes I saw the following exception in the logs after pressing CTRL+C in the console to close the application: <queue_name>-6ea8be48-aea6-4673-b555-253549a9fa72: StopProcessingAsync start. dbug: Azure.Messaging.ServiceBus[110]       A receive operation was cancelled while stopping the processor or scaling down concurrency. (Identifier 'backupuploadfinished-01001256-1213-496f-81da-e3572c618bac'). Error Message: 'System.Threading.Tasks.TaskCanceledException: A task was canceled.          at Microsoft.Azure.Amqp.ExceptionDispatcher.Throw(Exception exception)          at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result)          at Microsoft.Azure.Amqp.ReceivingAmqpLink.ReceiveAsyncResult.End(IAsyncResult result, IEnumerable`1& messages)          at Microsoft.Azure.Amqp.ReceivingAmqpLink.EndReceiveMessages(IAsyncResult result, IEnumerable`1& messages)          at Microsoft.Azure.Amqp.ReceivingAmqpLink.<>c.<ReceiveMessagesAsync>b__27_1(IAsyncResult r)          at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)       --- End of stack trace from previous location ---          at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsyncInternal(Int32 maxMessages, Nullable`1 maxWaitTime, TimeSpan timeout, CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<ReceiveMessagesAsync>b__38_0>d.MoveNext()       --- End of stack trace from previous location ---          at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func`4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, CancellationToken cancellationToken)          at Azure.Messaging.ServiceBus.ServiceBusReceiver.ReceiveMessagesAsync(Int32 maxMessages, Nullable`1 maxWaitTime, Boolean isProcessor, CancellationToken cancellationToken)' info: Azure.Messaging.ServiceBus[54] <queue_name>-6ea8be48-aea6-4673-b555-253549a9fa72: StopProcessingAsync done.  Is this normal? I'll leave the code that i'm using: Program.cs using PoC; using Microsoft.Extensions.Azure; using Azure.Messaging.ServiceBus;  IHost host = Host.CreateDefaultBuilder(args)     .ConfigureServices((hostContext, services) =>     {         services.Configure<AzureServiceBusSettings>(hostContext.Configuration.GetSection(nameof(AzureServiceBusSettings)));          var options = hostContext.Configuration.GetSection(nameof(AzureServiceBusSettings)).Get<AzureServiceBusSettings>();         services.AddAzureClients(clientsBuilder =>    {        clientsBuilder.AddServiceBusClient(options.ConnectionString);    });         services.AddSingleton<ServiceBusProcessor>(opt =>         {             var client = opt.GetRequiredService<ServiceBusClient>();             return client.CreateProcessor(options.QueueName);         });          services.AddHostedService<Worker>();     })     .Build();  await host.RunAsync(); Worker.cs using Azure.Messaging.ServiceBus;  namespace PoC;  public class Worker : IHostedService {     private readonly ILogger<Worker> _logger;     private readonly ServiceBusClient serviceBusClient;     private readonly ServiceBusProcessor serviceBusProcessor;     public Worker(ILogger<Worker> logger,     ServiceBusClient serviceBusClient,     ServiceBusProcessor serviceBusProcessor)     {         _logger = logger;         this.serviceBusClient = serviceBusClient;         this.serviceBusProcessor = serviceBusProcessor;     }      public async Task StartAsync(CancellationToken cancellationToken)     {         serviceBusProcessor.ProcessMessageAsync += MessageHandler;         serviceBusProcessor.ProcessErrorAsync += ErrorHandler;         await serviceBusProcessor.StartProcessingAsync(cancellationToken);     }      private Task ErrorHandler(ProcessErrorEventArgs arg)     {         return Task.CompletedTask;     }      private Task MessageHandler(ProcessMessageEventArgs arg)     {         return Task.CompletedTask;     }      public async Task StopAsync(CancellationToken cancellationToken)     {         await serviceBusProcessor.StopProcessingAsync(cancellationToken);     } } Expected behavior I was not expecting to see an exception in the logs Actual behavior System.Threading.Tasks.TaskCanceledException was logged Reproduction Steps Just run the code that I've pasted and stop the console application with CTRL+C Environment .NET SDK (reflecting any global.json): Version:   6.0.101 Commit:    ef49f6213a Runtime Environment: OS Name:     Windows OS Version:  10.0.22000 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.101\ Host (useful for support): Version: 6.0.1 Commit:  3a25a7f1cc .NET SDKs installed: 3.1.302 [C:\Program Files\dotnet\sdk] 3.1.403 [C:\Program Files\dotnet\sdk] 3.1.417 [C:\Program Files\dotnet\sdk] 5.0.101 [C:\Program Files\dotnet\sdk] 5.0.104 [C:\Program Files\dotnet\sdk] 5.0.212 [C:\Program Files\dotnet\sdk] 5.0.302 [C:\Program Files\dotnet\sdk] 5.0.303 [C:\Program Files\dotnet\sdk] 5.0.402 [C:\Program Files\dotnet\sdk] 5.0.406 [C:\Program Files\dotnet\sdk] 6.0.100 [C:\Program Files\dotnet\sdk] 6.0.101 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.18 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.23 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.18 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.23 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.18 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.23 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.9 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Event Hubs	[QUERY] Zero downtime Event Hub processor migration from v4 to v5	Library name and version Azure.Messaging.EventHubs 5.6.2 Query/Question Is it possible to achieve zero-downtime migration of Event Hub consumers using v4 (Microsoft.Azure.EventHubs) to v5 (Azure.Messaging.EventHubs)? If not, do you have any tips on minimizing the downtime? The breaking change in checkpoint format is a major problem in migration. Currently we have following plan:  Use custom EventProcessor<TPartition> which is able to read legacy checkpoints (in OnInitializingPartitionAsync). The old consumers are running on side A. Deploy new code to side B. Events are not consumed here since v5 SDK uses epoch value 0 and consumers are endlessly restarting due to encountering `epoch exception` [1]. Disconnect old consumers by stopping side A. New consumers start consuming events in side B.  There is a possibility of downtime between steps 4 and 5 (depending on how fast you can stop old consumers + how fast Azure Event Hub service detects the disconnects + how fast new consumers detect the disconnects). Are there any settings in SDK or Azure portal that would allow to minimize that? The best option would be to pass higher epoch in v5 SDK (forcing old consumers to disconnect) but it is not possible - the 0 value is hardcoded in EventProcessor class. [1] Exception Message `Receiver 'e69d42ae-72a6-418e-be1f-4d388a390188' with a higher epoch '2' already exists. Receiver 'P1-b47177da-cf2b-46f0-8cd1-dfa007165fd9' with epoch 0 cannot be created. Make sure you are creating receiver with increasing epoch value to ensure connectivity, or ensure all old epoch receivers are closed or disconnected.  Environment No response
Mgmt	Websites	[QUERY] How to call unsupported APIs	Library name and version Microsoft.Azure.Management.Websites 3.1.2 Query/Question There are now ARM APIs for managing Azure Function keys (function, master and system). I don't believe the official docs include them yet but it's documented in Azure/azure-functions-host#3994 (comment) and my colleague blogged about them here. How can we use Microsoft.Azure.Management.Websites or similar to call these APIs given that there are no .NET methods.  Does the SDK provide a convenient method to provide a URI, HTTP method and payload etc and it handles the API version, authentication etc? Thank you Environment No response
Client	Storage	[BUG] Azure Storage Blob Copy across containers, doesn't work with M.I.	Library name and version Azure.Storage.Blobs 12.10.0 Describe the bug Using the following method to copy blobs from one location to another. The method works when I copy blobs within the same account, but when I attempt to copy to another account I receive a 401 error with the following Azure.RequestFailedException: Server failed to authenticate the request. Please refer to the information in the www-authenticate header. RequestId:fb222ea8-001e-0045-79e8-2f3812000000 Time:2022-03-04T16:51:34.6883284Z Status: 401 (Server failed to authenticate the request. Please refer to the information in the www-authenticate header.) ErrorCode: CannotVerifyCopySource  I am a storage account contributor and Storage Blob Data Owner on both accounts. The following works when I use a SAS generated URI, but the client cannot generate a SAS URI when generated via DefaultAzureCredential(); The method I am using is in the reproduction steps. Expected behavior When I call StartCopyFromUriAsync() with the URI, the blob should copy successfully from container A to container B. Actual behavior I recieve a 401 error when attempting the copy. Reproduction Steps Using the following method, attempt to copy a file from source to destination, in which the destination is a different account than the source. public async Task<bool> CopyBlockBlobAsync(string sourceAccountName, string sourceContainerName, string sourceBlobName,             string destAccountName, string destContainerName, string destBlobName)         {             // Construct the blob container endpoint from the arguments.             string sourceContainerEndpoint = string.Format(`https://{0}.blob.core.windows.net/{1}`,                                                         sourceAccountName,                                                         sourceContainerName.ToLower());              string destContainerEndpoint = string.Format(`https://{0}.blob.core.windows.net/{1}`,                                                         destAccountName,                                                         destContainerName.ToLower());               // Get a credential and create a service client object for the blob container.             BlobContainerClient sourceContainerClient = new BlobContainerClient(new Uri(sourceContainerEndpoint),                                                                             new DefaultAzureCredential());              BlobContainerClient destContainerClient = new BlobContainerClient(new Uri(destContainerEndpoint),                                                                            new DefaultAzureCredential());               try             {                 // Create the container if it does not exist.                 await destContainerClient.CreateIfNotExistsAsync();                  var sourceBlobClient = sourceContainerClient.GetBlobClient(sourceBlobName);                 var destBlobClient = destContainerClient.GetBlobClient(destBlobName);                  var x = sourceContainerClient.CanGenerateSasUri;                                  await destBlobClient.StartCopyFromUriAsync(sourceBlobClient.Uri);              }             catch (RequestFailedException e)             {                 if (e.Status == StatusCodes.Status404NotFound)                     return false;                  Console.WriteLine(e.Message);                 throw e;             }             return true;         }  Environment .NET 6 Running locally in VS 2022 for Mac Also when deployed to an App Service
Client	KeyVault	Any breaking dependencies when upgrading from v1.0.0 to latest 3.0.5 via nuget in VS2017?	Library name and version Microsoft Azure Key Vault Core Class Library Query/Question There are vulnerabilities in the version 1.0.0 of Microsoft Azure Key Vault Core Class Library so want to upgrade my project. Need to know if there are any code changes needed if I just use nuget to update to v3.0.5 or not? Environment Visual Studio 2017, Windows 10 Pro, large C# MVC web project.
Client	Service Bus	[BUG] Disabled ServiceBus queue causes fixed retry after 300ms	Library name and version Azure.Messaging.ServiceBus 7.6.0 Describe the bug Disabled ServiceBus queue causes the ServiceBus client to retry consuming messages after a fixed retry inverval of ~300ms. If MaxConcurrentCalls is set in a ServiceBusProcessorOptions, it will try connect (and fail) that many times in parallel. This happens regardless of what the retry policy is configured to. In my case this results in a virtually infinite loop and causes the application to hog CPU usage if the queue is disabled. Expected behavior I expect the client to adhere to the retry policy and retry according to what the retry policy says if the queue is disabled. Actual behavior The client will retry consuming messages after ~300ms if the ServiceBus queue is disabled, regardless of what the retry policy says. Reproduction Steps Create a queue and disable it in in Azure ServiceBus, then try consume the messages using this .NET 6 app: using Azure.Messaging.ServiceBus;  var clientOptions = new ServiceBusClientOptions {     RetryOptions = new ServiceBusRetryOptions     {         Delay = TimeSpan.FromSeconds(10),         Mode = ServiceBusRetryMode.Exponential     } }; var client = new ServiceBusClient(`Endpoint=sb://sb-namespace.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=secret`, clientOptions); var processorOptions = new ServiceBusProcessorOptions {     MaxConcurrentCalls = 100 };  var processor = client.CreateProcessor(`some.queue.name`, processorOptions);  processor.ProcessMessageAsync += (_ => Task.CompletedTask); processor.ProcessErrorAsync += args => {     Console.WriteLine($`ServiceBus adapter error: ` + args.Exception.Message);     return Task.CompletedTask; };  await processor.StartProcessingAsync();  Console.ReadLine(); The application will spam the following message without a 10 second wait between each try: ServiceBus adapter error: Messaging entity 'sb://sb-namespace.servicebus.windows.net/some.queue.name' is currently disabled. For more information please see https://aka.ms/ServiceBusExceptions . TrackingId:e5f67fd40bf64f088abb211a8a62ed5f_G12, SystemTracker:gateway7, Timestamp:2022-03-02T13:44:02 (MessagingEntityDisabled)  Environment .NET SDK (reflecting any global.json):  Version:   6.0.101  Commit:    ef49f6213a  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.19044  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\6.0.101\  Host (useful for support):   Version: 6.0.1   Commit:  3a25a7f1cc
Client	Service Bus	Azure.Messaging.ServiceBus.ServiceBusException: System.Net.Sockets.SocketException (110): Operation timed out	Hi, I use the below code to schedule the messages in Azure Web Job ServiceBusTrigger. However I am getting the below error immediately after starting the AKS containers Azure.Messaging.ServiceBus` Version=`7.5.0` var client = new ServiceBusClient(ConnectionString);                         var sender = client.CreateSender(TopicName);                         var scheduledMessage = new ServiceBusMessage(message);                         await sender.ScheduleMessageAsync(scheduledMessage, DateTimeOffset.UtcNow.AddMinutes(_serviceBusConfig.ScheduledEnqueueTimeInMinutes));                         await messageActions.CompleteMessageAsync(message);  Azure.Messaging.ServiceBus.ServiceBusException: Operation timed out ErrorCode: TimedOut (ServiceCommunicationProblem) ---> System.Net.Sockets.SocketException (110): Operation timed out at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result) at Microsoft.Azure.Amqp.Transport.AmqpTransportInitiator.<>c.b__17_1(IAsyncResult r) at System.Threading.Tasks.TaskFactory1.FromAsyncCoreLogic(IAsyncResult iar, Func2 endFunction, Action1 endAction, Task1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.CreateAndOpenConnectionAsync(Version amqpVersion, Uri serviceEndpoint, ServiceBusTransportType transportType, IWebProxy proxy, String scopeIdentifier, TimeSpan timeout) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.OnCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout) at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenManagementLinkAsync(String entityPath, String identifier, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.OpenManagementLinkAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.OnCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton1.GetOrCreateAsync(TimeSpan timeout) at Azure.Messaging.ServiceBus.Amqp.ManagementUtilities.ExecuteRequestResponseAsync(AmqpConnectionScope connectionScope, FaultTolerantAmqpObject1 managementLink, AmqpRequestMessage amqpRequestMessage, TimeSpan timeout) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.ScheduleMessageInternalAsync(IReadOnlyList1 messages, TimeSpan timeout, CancellationToken cancellationToken) --- End of inner exception stack trace --- at Azure.Messaging.ServiceBus.Amqp.AmqpSender.ScheduleMessageInternalAsync(IReadOnlyList1 messages, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<>c.<<ScheduleMessagesAsync>b__24_0>d.MoveNext() --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.ScheduleMessagesAsync(IReadOnlyList1 messages, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusSender.ScheduleMessagesAsync(IEnumerable`1 messages, DateTimeOffset scheduledEnqueueTime, CancellationToken cancellationToken)
Client	Extensions	[QUERY]When using DI to create clients (via Microsoft.Extensions.Azure), should we try to use .NET's IHttpClientFactory for the underlying HttpClient?	Library name and version Azure.Storage..., Azure.Messaging... Query/Question The recommended pattern to obtain various kinds of Azure service clients (QueueServiceClient,  EventHubProducerClient etc) in modern .NET applications is to use DI registered via helper methods provided by Microsoft.Extensions.Azure such as: services.AddAzureClients(builder => {      builder.AddQueueServiceClient(uri)           .WithCredential(...)         //...other options }               Looking through the documentation, it seems the SDKs internally use shared singleton HttpClient instances, though they do expose the Transport property on client config options to pass in custom HttpClient. Given the known drawbacks of regular singleton HttpClient, is it worth the effort of using .NET's IHttpClientFactory to create named HttpClient and pass them to Transport when configuring these SDKs via DI? Or these SDKs have sufficient internal optimization on client management etc that in majority cases we probably don't need to bother? Environment No response
Client	Service Bus	[QUERY] Why is `using Azure.Messaging.ServiceBus;` not working inside a namespace?	Library name and version Azure.Messaging.ServiceBus 7.6.0 Query/Question I have a .net core project where I am trying to use using Azure.Messaging.ServiceBus;. I have realized that if i import this outside the namespace then it dotnet is able to recognize the library however if i import it inside it then dotnet is not able to recognize it. working  Not working  Environment observed in net5.0 and .netcore3.1
Client	Azure.Identity	[QUERY] Why is key auth authentication slow in Azure?	Library name and version Azure.Identity 1.5.0.0 Query/Question We are running microservices in AKS and these services need to connect to Azure Key Vault to retrieve secrets. However, I am seeing excessive latency around the AD calls to make this work. I setup the SecretClient like this: var kvClient = new SecretClient(new Uri(url), new ClientSecretCredential(tenantId, clientId, clientSecret)); but when calling a method which access the key vault, I see times like these:  It all works OK but just seems a very slow and clunky way of accessing something when I am passing clientid and secret directly to the key vault client. Sometimes it is quick but this extra dependency would really hurt performance at scale. Is this just something that happens once or could it happen each time we make a call to the key vault? Environment Microservices are dotnet core 3.1 running on AKS v 1.21.9
Client	Event Hubs	[QUERY] [EventHub] PartitionKey HashCode Generation	Library name and version Azure.Messaging.EventHubs Query/Question When converting PartitionResolver.ComputeHash to span and BinaryPrimitives it would be possible to squeeze out some perf. See the below benchmark BenchmarkDotNet=v0.13.1, OS=Windows 10.0.22000 11th Gen Intel Core i7-1185G7 3.00GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK=6.0.102   [Host]     : .NET 6.0.2 (6.0.222.6406), X64 RyuJIT   DefaultJob : .NET 6.0.2 (6.0.222.6406), X64 RyuJIT      Method Mean Error StdDev StdErr Median Min Q1 Q3 Max Op/s Ratio RatioSD     ComputeHashBitConverter 9.599 ns 0.3469 ns 1.007 ns 0.1022 ns 9.421 ns 7.989 ns 8.835 ns 10.279 ns 12.61 ns 104,174,105.6 1.00 0.00   ComputeHashSpan 8.792 ns 0.4335 ns 1.216 ns 0.1274 ns 8.444 ns 6.987 ns 7.875 ns 9.409 ns 12.60 ns 113,736,404.7 0.93 0.16    Is that something you'd be interested in? Another thing. I noticed currently it is required to allocate a byte array to compute the hash and the size of the byte array is proportional to the size of the partition key. I see the following options:  Pool the buffer Stackalloc the buffer for short string and for longer pool the buffer If the EnqueueEventOptions are most likely to be reused per partition, it would be possible to turn the partition key into bytes there and the just pass those bytes into ComputeHash method (then the options act as sort of root for the byte array)  Just as an example, pooling the byte array there is slightly slower but gets rid of all the allocations on that path. BenchmarkDotNet=v0.13.1, OS=Windows 10.0.22000 11th Gen Intel Core i7-1185G7 3.00GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK=6.0.102   [Host]     : .NET 6.0.2 (6.0.222.6406), X64 RyuJIT   DefaultJob : .NET 6.0.2 (6.0.222.6406), X64 RyuJIT      Method Mean Error StdDev StdErr Min Q1 Median Q3 Max Op/s Ratio RatioSD Gen 0 Allocated     Pooled 67.84 ns 1.171 ns 1.038 ns 0.277 ns 66.13 ns 67.12 ns 67.67 ns 68.67 ns 69.39 ns 14,740,063.2 1.15 0.09 - -   NonPooled 55.45 ns 1.686 ns 4.892 ns 0.497 ns 47.37 ns 51.71 ns 54.57 ns 58.57 ns 68.62 ns 18,033,322.7 1.00 0.00 0.0102 64 B    Environment No response
Client	Azure.Identity	Managed Identity token lifetime	Hi, We are using the DefaultAzureCredential class along with the environment variable AZURE_CLIENT_ID to acquire an oauth token for the function app's user assigned managed identity, which is then passed on when making calls to other API:s within the system. This works fine, except for that the token has a lifetime of 24 hours and 5 minutes. This causes a lot of problems when we want to change the claims of this managed identity (for example add or remove an AD group membership), and we have to wait up to 24 hours for the change to take effect. Stopping and starting the function app does nothing, the same token will be returned. The only workaround I've found is via the very brute force approach of removing the managed identity, create it again, set up permissions all over again, etc. I have not found a way to explicitly ask for a new token (`force refresh`), or any settings in the AD that controls the lifetime of these tokens. So my questions are:  Is it possible to explicitly ask for a new token? Is it possible to control what the lifetime of these tokens should be?  Please let me know if you require any additional information!  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 414d8832-9224-3bb5-2bf4-1197c41fdedf Version Independent ID: 02d95dd6-bf1b-5cef-bc94-ac187b133c45 Content: DefaultAzureCredential Class (Azure.Identity) - Azure for .NET Developers Content Source: xml/Azure.Identity/DefaultAzureCredential.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Service Bus	[QUERY] How can the SequenceNumber be set on ServiceBusReceivedMessage	Library name and version Azure.Messaging.ServiceBus 7.5.1 Query/Question How can we set sequence number in this latest version? In Microsoft.Azure.ServiceBus we can set like below. ServiceBusMessage TestMessage { get; } = new ServiceBusMessage(); TestMessage.SystemProperties.SetSequenceNumber(0); Environment No response
Client	Service Bus	[QUERY] How does ServiceBusClient coorespond with `Active Connections` in Azure Metrics	Library name and version Azure.Messaging.ServiceBus 7.5.1 Query/Question I have a question about the `Active Connections` metric that I see about service bus. From my understanding a ServiceBusClient should open 1 Active AMPQ connection. Our implementation is using 11 clients. 2 for receiving and 9 for sending. In the metrics I often see connections opening and closing sometimes the Active Connections gets up to 11 as expected but a lot of the time they are lower around 9 or 10. I'd like to know a little more about how the ServiceBusClient opens a connection. Does it close them due to inactivity or something like that? Trying to understand what we are seeing with respect to `Active Connections` metrics in Azure. Environment .net 5
Mgmt	ARM - Core	[BUG] ApplicationTokenProvider should reuse HttpClientHandler instead of creating it on every call	Library name and version Microsoft.Rest.ClientRuntime.Azure.Authentication 2.4.1 Describe the bug Problem Every call to ApplicationTokenProvider.LoginSilentAsync creates a new HttpClientHandler that will only be used only for the duration of the call. This can easily lead to socket/port exhaustion. The issue frequently creating and disposing HttpClientHandler explained in detail in the official Microsoft docs They mention HttpClient, but essentially the issue is with the HttpClientHandler that is created in HttpClient default constructor  Though this class implements IDisposable, declaring and instantiating it within a using statement is not preferred because when the HttpClient object gets disposed of, the underlying socket is not immediately released, which can lead to a socket exhaustion problem. For more information about this issue, see the blog post You're using HttpClient wrong and it's destabilizing your software.  After HttpClientHandler is disposed, the underlaying socket connections are still active for some time. This issue caused (or contributed to) socket exhaustion on one of our production instances. I also found a related unanswered stackoverlfow issue describing exactly that problem. Proposed solution Most of the other azure sdk libraries provide a way to pass your own HttpClient. In our case, we use the default HttpClientFactory from ASP.NET that managers the lifetime of HttpClientHandler and clients. There should be a way to pass HttpClient or HttpManager or something like that to ApplicationTokenProvider.LoginSilentAsync call. The currently referenced version of Microsoft.IdentityModel.Clients.ActiveDirectory (4.3.0) does not support using IHttpClientFactory, the creation of HttpClientHandler is hard coded However, an option to pass IHttpClientFactory was introduced from version 5.0.1-preview Here's a link to the instructions on how to use IHttpClientFactory with ADAL: IHttpClientFactory myHttpClientFactory = new MyHttpClientFactory();  AuthenticationContext authenticationContext = new AuthenticationContext(      authority: `https://login.microsoftonline.com/common`,      validateAuthority: true,      tokenCache: <some token cache>,      httpClientFactory: myHttpClientFactory); That probably means changes to the following code and its callers to be able to pass IHttpClientFactory.                azure-sdk-for-net/sdk/mgmtcommon/Auth/Az.Auth/Az.Authentication/ApplicationTokenProvider.cs                   Lines 678 to 687       in       f9858ea                                                     private static AuthenticationContext GetAuthenticationContext(string domain, ActiveDirectoryServiceSettings serviceSettings, TokenCache cache)                                               {                                                   return (cache == null)                                                           ? new AuthenticationContext(serviceSettings.AuthenticationEndpoint + domain,                                                               serviceSettings.ValidateAuthority)                                                           : new AuthenticationContext(serviceSettings.AuthenticationEndpoint + domain,                                                               serviceSettings.ValidateAuthority,                                                               cache);                                               }                                           }                     Workaround I think I can replicate the behaviour of this ApplicationTokenProvider.LoginSilentAsync overload in our codebase to be able to pass HttpClientFactory to AuthenticationContext, but it should be fixed at the package level. Expected behavior It should be possible to pass HttpClient to ApplicationTokenProvider.LoginSilentAsync or to configure ApplicationTokenProvider to reuse HttpClientHandler to prevent socket exhaustion Actual behavior It should not possible to pass HttpClient to ApplicationTokenProvider.LoginSilentAsync or to configure ApplicationTokenProvider to reuse HttpClientHandler to prevent socket exhaustion. And it caused (or contributed to) a socket exhaustion in our production instance Reproduction Steps Here's an example Program.cs that runs LoginSilentAsync in a loop and reports the count of active Tcp connections before and after each call. Please note, the count always increases, the connections are not even released on application stop.  Program.cs using System; using System.Threading.Tasks; using Microsoft.IdentityModel.Clients.ActiveDirectory; using Microsoft.Rest.Azure.Authentication;  namespace HttpClientTestingTest {     class Program     {         static async Task Main(string[] args)         {             var clientCredential = new ClientCredential(`123`, `345`);              for (var i = 0; i < 10; i++)             {                 try                 {                     ReportConnectionCount($`Before {i}`);                     await ApplicationTokenProvider.LoginSilentAsync(`http://localhost/test`, clientCredential, ActiveDirectoryServiceSettings.Azure);                 }                 catch                 {                     ReportConnectionCount($`After {i}`);                 }             }         }          static void ReportConnectionCount(string info)         {             var properties = System.Net.NetworkInformation.IPGlobalProperties.GetIPGlobalProperties();             Console.WriteLine($`ConnectionCount: {properties.GetActiveTcpConnections().Length} - {info}`);         }     } }  Environment The production issue was happening in Azure App Service The reproduction on MacOS using netcore 3.1 and .NET 5.
Client	Cosmos	It should be noted ReadManyItemsStreamAsync is unordered	[Enter feedback here] It should be noted ReadManyItemsStreamAsync is unordered. It will not match the order of the list passed in,  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 819245a4-835a-64aa-d195-60871cacc13c Version Independent ID: 5cabd119-cec0-b932-0311-cb739ac51939 Content: Container.ReadManyItemsStreamAsync(IReadOnlyList<ValueTuple<String,PartitionKey>>, ReadManyRequestOptions, CancellationToken) Method (Microsoft.Azure.Cosmos) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Cosmos/Container.xml Service: cosmos-db GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	KeyVault	[QUERY] Encryption with Azure Key Vault CryptographyClient - where is encrypt/decrypt happenning? my backend or Azure server side	Library name and version Azure Key Vault Query/Question Hi there, I have raised this stack overflow question yesterday but no answer yet. So I gonna try to repost here. I'm currently using Azure Key vault .net SDK to encrypt/decrypt some data. Azure SDK for .net has a build-in Class called `CryptographyClient` and it has built-in method for doing that: CryptographyClient.decrypt and CryptographyClient.encrypt The key I'm using is a RSA key and algorithm I use is RsaOaep, so I assume it is asymmetric encryption. I followed this article to write my c# code. Basically, I get the public part of the asymmetric key from the key vault first, then use it to create a CryptographyClient. Usually, for asymmetric encryption, we gonna use the public key to encrypt while the private key is for decryption only. So basically, the private key will never leave the Azure Key Vault (always at the Azure server, is it true?). Now my question is: when I call CryptographyClient.encrypt, is it only running on the client-side (my local server)? or will it send my plaintext to Azure server and send back the encrypted text? when I call CryptographyClient.decrypt, since the private key should never leave Azure and you can only decrypt with the private key, is it only running on the Azure server-side? Mean that my local server will need to send the encrypted text to Azure and wait for decryption? I got a feeling that both of those methods are only happening on the client-side and this is what I want. But then it doesn't make sense for decryption. Thanks for the clarification as I can't find any MS documentation for this. Environment No response
Mgmt	Network - Front Door	[QUERY] Is Azure Front Door Standard/Premium (Preview) available in the sdk yet?	Library name and version Microsoft.Azure.Management.FrontDoor 4.0.0 Query/Question Is Azure Front Door Standard/Premium (Preview) available in the sdk yet? It seems when I create a Front Door with the above library's version it defaults to creating it as a Classic Front Door, and there is no option (as of 02/01/2022) to create the Standard or Premium Front Doors. Environment Azure Front Door Visual Studio Enterprise 2022 17.0.4
Client	Cognitive - Text Analytics	[How to migrate language studio project along with blob content from one environment (DEV/QA) to another(QA/PROD)]	Library name and version azure.ai.textanalytics.5.2.0-beta.2 Query/Question We have created a `Custom Named Entity Recognition ( Custom NER)` project in Language Studio. We are using the Text Analytics SDK version (azure.ai.textanalytics.5.2.0-beta.2). We are trying to migrate the language studio project from one environment(DEV/QA) to another(QA/PROD) along with its blob contents. Is there any way available to migrate the projects from one environment (DEV/QA) to another(QA/PROD) along with its blob contents ? Note : - we are using the below mentioned block of codes to analyze the text from the document. https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/textanalytics/Azure.AI.TextAnalytics/tests/samples//Sample9_RecognizeCustomEntitiesAsync.cs Environment We are hosting our application in Azure and using dot net 5 version to build our application along with Azure AI form recognizer 3.1.1 and Azure AI Text Analytics 5.2 beta 2.
Client	Azure.Core	[BUG] Error: Dependency loop detected for package 'Azure.Messaging.EventHubs' in PowerShell	Library name and version Azure.Messaging.EventHubs version 5.6.2 Describe the bug Using PowerShell to create a simple Event sender, I start my cmdlet by checking if the package is installed and if not, install it using the following: $packageName = `Azure.Messaging.EventHubs` $packageSource = `https://www.nuget.org/api/v2` Install-Package -Name $packageName -Source $packageSource -Force -ErrorAction SilentlyContinue  This returns an error stating as follows: `Dependency loop detected for package 'Azure.Messaging.EventHubs'.` Expected behavior The package 'Azure.Messaging.EventHubs' version 5.6.2 should be installed as a package in PowerShell. Then we can proceed to reference Event Hub objects. Actual behavior PowerShell throws an error stating that there is a `Dependency loop detected for package 'Azure.Messaging.EventHubs'.` No stack trace, HResult: -2146233088 Reproduction Steps In either PowerShell 5 or 7, run the following: $packageName = `Azure.Messaging.EventHubs` $packageSource = `https://www.nuget.org/api/v2` Install-Package -Name $packageName -Source $packageSource -Force -ErrorAction SilentlyContinue  Environment OS: Windows 11 Version 21H2 (OS Build 22000.434) PowerShell 7: 7.2.1 Windows PowerShell: 5.1.22000.282 (CLR: 4.0.30319.4200)
Client	Azure.Identity	[BUG] Azure Identity 1.5 - ChainedTokenCredential will throw when work with ClientCertificateCredential	Library name and version Azure Identity v1.5 Describe the bug var certificate = store.Certificates.Cast() .FirstOrDefault(cert => cert.Thumbprint == `XXXX`); var credential = new ChainedTokenCredential(new ClientCertificateCredential(tenantId, clientId, certificate), new VisualStudioCredential()); Hi there,  if I chain ClientCertificateCredential with VisualStudioCredential. It will throw if the certificate is null instead of trying the second method (VS credential). Usually, the certificate only exists for prod and it should be null when debugging locally. Expected behavior If the certificate is null, then try the second method to authenticate. Actual behavior If will throw {`Value cannot be null.\r\nParameter name: certificate`} and stop autenticating with other methods. Reproduction Steps var store = new X509Store(StoreName.My, StoreLocation.LocalMachine); store.Open(OpenFlags.ReadOnly); var certificate = store.Certificates.Cast() .FirstOrDefault(cert => cert.Thumbprint == `XXXX`); store.Close(); var credential = new ChainedTokenCredential(new ClientCertificateCredential(tenantId, clientId, certificate), new VisualStudioCredential()); make sure you do not have a matching certificate in your local store Environment VS 2022 - windows 11
Client	Service Bus	[QUERY] ServiceBus Request-Response pattern resulting in exception `Operation is not valid due to the current state of the object.`	Library name and version Azure.Messaging.ServiceBus 7.5.1 Query/Question This is a 2 fold question and/or issue.  I have a request response pattern implementation that is behaving odd.  The processor receive mode is PeekLock.  And the response queue is a session enabled queue. When run through without calling CompleteMessageAsync, the messages are removed from the queue.  If I call CompleteMessageAsync AFTER I send the response message is sent, I get an exception in the error handler.  Could for sure be something I've done incorrectly.  I've created a test app and replicated the behavior.  This is using .Net 6 and Azure.Messaging.Services 7.5.1. My main process looks like this: `    Main Process using Azure.Messaging.ServiceBus;  string connectionString = `Endpoint=andSoOn`; string queueName = `posearch`;  ServiceBusClient client = new ServiceBusClient(connectionString); TestHandler._serviceBusClient = client;  ServiceBusProcessorOptions sbpo = new ServiceBusProcessorOptions() {     ReceiveMode = ServiceBusReceiveMode.PeekLock }; ServiceBusProcessor processor = client.CreateProcessor(queueName, sbpo);  processor.ProcessMessageAsync += TestHandler.MessageHandler; processor.ProcessErrorAsync += TestHandler.ErrorHandler;  await processor.StartProcessingAsync();  Console.WriteLine($`Press Enter key to end`); Console.ReadLine();`  The TestHandler looks like the following: `    TestHandler public class TestHandler {     public static ServiceBusClient _serviceBusClient;      public static async Task MessageHandler(ProcessMessageEventArgs args)     {         string body = args.Message.Body.ToString();         string responseQueueName = args.Message.ReplyTo;         string responseSessionId = args.Message.MessageId;          ServiceBusSender sender = _serviceBusClient.CreateSender(responseQueueName);          var message = new ServiceBusMessage(body)         {             SessionId = responseSessionId         };          try         {             await sender.SendMessageAsync(message);             //_ = args.CompleteMessageAsync(args.Message);    <<<<<<<<<         }         catch (Exception ex)         {             Console.WriteLine($`Send Exception: {ex.Message}`);         }     }       public static Task ErrorHandler(ProcessErrorEventArgs args)     {         Console.WriteLine($`ErrorHandler Exception: {args.Exception.Message}`);          return Task.CompletedTask;     } }`  As shown, Error Handler is not called, however the entry in the receivequeue is removed. With the commented out call to CompleteMessageAsync complied in, ErrorHandler is called and the exception is `Operation is not valid due to the current state of the object.` With the commented out call to CompleteMessageAsync before the call to SendMessageAsync everything behaves as I would expect it to.  But I do not want to complete the message until after the response is successfully sent. Environment Occurring on my Windows 10 development machine.  .Net 6 build with VS 2022 Version 17.0.4.
Client	Storage	[QUERY] Do Storage.Blobs clients auto refresh ClientCertificateCredential token on expiry?	Library name and version Azure.Storage.Blobs 12.10.0, Azure.Data.Tables 12.3.0 Query/Question I didn't find this info mentioned explicitly any where in the docs so I wanted to double check if we need to handle the token renewer and refresh mechanism ourselves like in SDK V11 or is it provided by default by the storage SDKs? Environment No response
Mgmt	Network - Front Door	[QUERY] Front Door RulesEngine Rule creation: @odata.type InvalidResource	Library name and version Microsoft.Azure.Management.FrontDoor 4.0.0 Query/Question When trying to create a RulesEngine Rule Action, and I use this json block:               `rulesEngineRules`: [ { `name`: `rulesEngine1`, `priority`: 1, `matchProcessingBehavior`: `Continue`, `action`: { `routeConfigurationOverride`: { `@odata.type`: `#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration`, `backendPool`: { `id`: `string` }, `cacheConfiguration`: { `dynamicCompression`: `string`, `queryParameterStripDirective`: `string` }, `customForwardingPath`: `string`, `forwardingProtocol`: `string` }, `requestHeaderActions`: [ { `headerActionType`: `string`, `headerName`: `string`, `value`: `string` } ], `responseHeaderActions`: [ { `headerActionType`: `string`, `headerName`: `string`, `value`: `string` } ] }, `matchConditions`: [ { `negateCondition`: `bool`, `rulesEngineMatchValue`: [ `string` ], `rulesEngineMatchVariable`: `string`, `rulesEngineOperator`: `string`, `selector`: `string`, `transforms`: [ `string` ] } ] } ] The error response I'm receiving says: `{\n  \`error\`: {\n    \`code\`: \`InvalidResource\`,\n    \`message\`: \`Invalid @odata.type property value.\`\n  }\n}` I am using this documentation to follow the Rules Engine Rule creation: docs.microsoft.com/en-us/azure/templates/microsoft.network/2020-05-01/frontdoors/rulesengines?tabs=json Am I doing something wrong here? Environment .NET Core 3.1 VS Enterprise 2022 17.0.4
Client	Cognitive - Text Analytics	[BUG] Text Analytics: Feature Availability	Library name and version Azure.AI.TextAnalytics 5.1.X Describe the bug I am trying to use this library with custom NER and classification, but its not working, only version 5.2.0-beta.2 is working. If this is the case, please call it out in the file to guide the users. Expected behavior It should work Actual behavior Its now working with 5.1.X version Reproduction Steps see description Environment No response
Client	Storage	[QUERY] Clarification on Snapshot propery in BlobItem	Library name and version Azure.Storage.Blobs 12.10.0 Query/Question Background We are currently working on migrating a Service Fabric application from Azure Storage SDK 11.x to make use of the updated Azure Storage SDK 12.x.  This application is responsible for various tasks including copying blob snapshots to different storage accounts, as well as being able to select a specific snapshot to restore. In the past, the CloudBlob.SnapshotTime  was represented as a DateTime offset and we stored this DateTime in SQL for future reference for restoration.  Now, there is the BlobItem.Snapshot property which is of type string but represents the DateTime of the snapshot, seemingly according to ISO8610. Question Is it safe to interpret this string as a DateTime type object and store it as a DateTime, so long as we reformat the DateTime to the correct string format when attempting to access a specific snapshot?  Is it expected for this string formatting for the Snapshot property to change often? Environment Windows 10 Visual Studio 17.0.5
Client	Service Bus	SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.	Library name and version Azure.Messaging.ServiceBus 7.4.0 Describe the bug Sometimes if my connection goes off, i receive this error.I Output: Exception thrown: 'System.Net.Sockets.SocketException' in Microsoft.Azure.Amqp.dll Exception thrown: 'System.Net.Sockets.SocketException' in System.Private.CoreLib.dll Exception thrown: 'System.IO.IOException' in System.Net.Security.dll Exception thrown: 'System.IO.IOException' in System.Private.CoreLib.dll An exception of type 'System.IO.IOException' occurred in System.Private.CoreLib.dll but was not handled in user code The read operation failed, see inner exception.  Trace: at System.Net.Security.SslStream.<ReadAsyncInternal>d__181`1.MoveNext() in /_/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs:line 915  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 173  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 150  at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 364  at System.Threading.Tasks.TaskToApm.End[TResult](IAsyncResult asyncResult) in /_/src/libraries/Common/src/System/Threading/Tasks/TaskToApm.cs:line 59  at System.Net.Security.SslStream.EndRead(IAsyncResult asyncResult) in /_/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.cs:line 783  at Microsoft.Azure.Amqp.Transport.TlsTransport.HandleOperationComplete(IAsyncResult result, Boolean write, Boolean syncComplete)` string  Expected behavior I want it to keep trying until it gains the connection back, but the application stops.  I added this:                 serviceBusRetryOptions.Delay = TimeSpan.FromSeconds(120);                 serviceBusRetryOptions.MaxDelay = TimeSpan.FromSeconds(1080);                 serviceBusRetryOptions.MaxRetries = 99; Actual behavior Would like to find a way to keep trying to gain the connection back without any exception, or at least I can handle the exception. Reproduction Steps It's random, sometimes if my connection to the internet is off for just 2-3 minutes, I get this exception, sometimes if I put the connection off for hours, I get no expectation at all. Environment Windows 10
Client	Azure.Core	[BUG] Warnings on func.exe startup and elsewhere on non-success Azure Blob Storage responses.	Library name and version Microsoft.Azure.WebJobs.Extensions.EventHubs (5.0.0) Describe the bug When creating a vanilla Azure Function application with a reference to Microsoft.Azure.WebJobs.Extensions.EventHubs.5.0.0, three warnings about ContainerAlreadyExists/BlobNotFound are reported on startup. It seems a warning logging has been added somewhere when Azure Blob Storage return a non-success error code, Please note that although I am using Function startup as a minimal reproducer, this is now also an issue everywhere in application code when using Azure Blobs Storage. Even if we handle the expected exceptions e.g. ContainerAlreadyExists, BlobNotFound, we now get warnings in the logs. This was not the case with the previous 4.3.1 version of Microsoft.Azure.WebJobs.Extensions.EventHubs. Expected behavior No warnings when getting a non-success response from Azure Blob storage. Actual behavior Azure Functions Core Tools Core Tools Version:       4.0.3928 Commit hash: 7d1d4a32700695bbf290a871c7492fde84bb767e  (64-bit) Function Runtime Version: 4.0.1.16815  [2022-01-13T09:46:05.372Z] Found C:\*****\FunctionApp1\FunctionApp1\FunctionApp1.csproj. Using for user secrets file configuration.  Functions:          Function1: eventHubTrigger  For detailed output, run func with --verbose flag. [2022-01-13T09:46:07.714Z] Error response [24a653b5-abe5-4c25-970f-2f0639039571] 409 The specified container already exists. (00.1s) [2022-01-13T09:46:07.715Z] Server:Azurite-Blob/3.14.3 [2022-01-13T09:46:07.715Z] x-ms-error-code:ContainerAlreadyExists [2022-01-13T09:46:07.716Z] x-ms-request-id:991c90d9-7323-49ed-b6b5-f286021ca30a [2022-01-13T09:46:07.717Z] Date:Thu, 13 Jan 2022 09:46:07 GMT [2022-01-13T09:46:07.718Z] Connection:keep-alive [2022-01-13T09:46:07.718Z] Keep-Alive:REDACTED [2022-01-13T09:46:07.719Z] Transfer-Encoding:chunked [2022-01-13T09:46:07.720Z] Content-Type:application/xml [2022-01-13T09:46:07.721Z] [2022-01-13T09:46:07.821Z] Error response [2fb6eea3-e89b-4e6a-8fbe-fd1feb66f458] 404 The specified blob does not exist. (00.0s) [2022-01-13T09:46:07.822Z] Server:Azurite-Blob/3.14.3 [2022-01-13T09:46:07.823Z] x-ms-error-code:BlobNotFound [2022-01-13T09:46:07.824Z] x-ms-request-id:5b22999a-9123-4e74-aab4-8502802de705 [2022-01-13T09:46:07.825Z] Date:Thu, 13 Jan 2022 09:46:07 GMT [2022-01-13T09:46:07.826Z] Connection:keep-alive [2022-01-13T09:46:07.827Z] Keep-Alive:REDACTED [2022-01-13T09:46:07.827Z] [2022-01-13T09:46:07.846Z] Error response [3f9092d4-fe47-475a-8727-a9432cb30f84] 404 The specified blob does not exist. (00.0s) [2022-01-13T09:46:07.848Z] Server:Azurite-Blob/3.14.3 [2022-01-13T09:46:07.848Z] x-ms-error-code:BlobNotFound [2022-01-13T09:46:07.849Z] x-ms-request-id:ef9e96fc-82ca-48a9-a71b-6927d5937201 [2022-01-13T09:46:07.850Z] Date:Thu, 13 Jan 2022 09:46:07 GMT [2022-01-13T09:46:07.851Z] Connection:keep-alive [2022-01-13T09:46:07.852Z] Keep-Alive:REDACTED [2022-01-13T09:46:07.853Z] Transfer-Encoding:chunked [2022-01-13T09:46:07.857Z] Content-Type:application/xml [2022-01-13T09:46:07.858Z] [2022-01-13T09:46:12.360Z] Host lock lease acquired by instance ID '000000000000000000000000F42E305D'.  Reproduction Steps Create an Azure Function app using the standard template in Visual Studio 2022. Add a reference to Microsoft.Azure.WebJobs.Extensions.EventHubs.5.0.0 and have the function implement an eventhub-trigger:     public class Function1     {         [FunctionName(`Function1`)]         public Task Run([EventHubTrigger(`%EventHubName%`, Connection = `EventHubConnection`)] EventData[] events, ILogger log)         {             // Nothing here             return Task.CompletedTask;         }     } Environment Visual Studio 2022 (17.0.4) TargetFramework: net6.0 AzureFunctionsVersion: v4 Azure Function Core Tools Version:   4.0.3928
Mgmt	ARM	[QUERY] How to access Subscriptions from multiple tenants	Library name and version Azure.ResourceManager 1.0.0-beta.7 Query/Question I am an Azure user with access to multiple tenants.  My primary tenant is my organization and I was invited into another tenant.  In Azure portal I can toggle between tenants by using the Switch Directory feature. When I use DefaultAzureCredential to create the ArmClient I'm seeing this behavior: calling armClient.GetTenants().GetAll() - I see both tenants being returned calling armClient.GetSubscriptions().GetAll() - I see only subscriptions from my primary tenant being returned I would like to either see all subscriptions returned from both tenants at once, or be able to set my active tenant and return subscriptions for that Tenant only.  Is there a way to do it? Environment Windows 10 .NET Framework 4.6.1
Client	Azure.Identity	AKV10032: Invalid issuer when we try to fetch key-vault information using DefaultCredential()	Library name and version Azure.Identity 1.5.0 & Azure.Security.KeyVault.Secrets 4.20 Query/Question In the Azure portal, a user is added as a Guest in the Tenant where the key-vault resource resides. In addition, the user has associated with default account tenants. As per the new Identity Framework, the  DefaultCredentials() is used to fetch the secret info from Azure Key-Vault. I got the below error message when it executed from the Visual Studio AKV10032: Invalid issuer. Expected one of https://sts.windows.net/456***********/, https://sts.windows.net/s38**************/, https://sts.windows.net/e4*****************/, found https://sts.windows.net/080**************************/. Status: 401 (Unauthorized) ErrorCode: Unauthorized Even we tried adding tenantId in the default credentials but no luck. Below is the code that we have used in the VisualStudio code.   var options = new DefaultAzureCredentialOptions { VisualStudioTenantId = `s38*****************` }; var client = new SecretClient(vaultUri: new Uri(keyVaultUrl), new DefaultAzureCredential(options)); But able to access the key-vault information using Azure CLI when followed the below steps  az login az account list az account set --subscription `my cloud`   ( set with tenant where key-vault resides, in my case which start with s38***********) az keyvault secret list --vault-name `my key vault name`  Is there any way to resolve this issue in Visual Studio? Environment Visual Studio 2019 16.11.7 Windows  10 .NET Framework 4.6.1
Mgmt	SQL	[BUG] MinimalTlsVersion missing in Azure SQL Server	Library name and version Microsoft.Azure.Management.Sql 2.0.0-preview Describe the bug Getting and setting this here is not possible via SDK https://docs.microsoft.com/en-us/azure/azure-sql/database/connectivity-settings#set-the-minimal-tls-version-via-powershell Expected behavior Should be able to get and set this property. Actual behavior Not possible. Reproduction Steps Not much to reproduce, it's not available and should be, because it's available in all other packages like Azure PowerShell and CLI. Environment No response
Client	Service Bus	Creation of test resources fails when running ServiceBus tests	Library name and version Azure.Messaging.ServiceBus.Tests Describe the bug From VS2022, I try to run the samples that are in the project Azure.Messaging.ServiceBus.Tests. In doing so, the Powershell script New-TestResources.ps1 is called to setup a resource group in my Azure subscription. This results in an exception: 15:41:08 - TestApplicationId was not specified; creating a new service principal in subscription 'mySubscriptionId' WARNING: We have migrated the API calls for this cmdlet from Azure Active Directory Graph to Microsoft Graph. Visit https://go.microsoft.com/fwlink/?linkid=2181475 for any permission issues. WARNING: Attempt 1 failed: Exception calling `Invoke` with `0` argument(s): `Cannot bind argument to parameter 'ServicePrincipalId' because it is an empty string.`. Trying again in 10 seconds... WARNING: Attempt 2 failed: Exception calling `Invoke` with `0` argument(s): `Cannot bind argument to parameter 'ServicePrincipalId' because it is an empty string.`. Trying again in 20 seconds...  The service principal gets created ok, but the New-AzADSpCredential call (currently on line 152) fails which should create the credentials for the new service principal. I could reproduce the error in Powershell. I've also tried $credential = New-AzADSpCredential -PasswordCredentials $password -ServicePrincipalName $servicePrincipal.DisplayName which is throwing the same exception. I'm running version 7.1.0 of the Az Powershell module on my laptop. Expected behavior The test resources should be created successfully. Actual behavior Aforementioned Powershell script doesn't create the required resources in my subscription. Reproduction Steps In VS2022 build the Azure.Messaging.ServiceBus solution and debug a test. For example SendAndReceiveMessage in Sample01_HelloWorld.cs. Environment  Windows 11 Visual Studio 2022 17.0.4 Az Powershell module 7.1.0
Client	Service Bus	[a client library upgrade saga] Does a `batch` message settlement/completion corollary exist?	Library name and version Azure.Messaging.ServiceBus 7.5.1 Query/Question Hello! Extent of My Current Understanding Microsoft.Azure.ServiceBus.MessageReceiver enables fine-grained control over batch message receipt and batch message settlement. Azure.Messaging.ServiceBus.ServiceBusReceiver enables fine-grained control over batch message receipt and single message settlement. Current Dilemma In an as-of-yet-failed attempt to upgrade to the prescribed Azure.Messaging.ServiceBus client library, I'm struggling to find a performance-friendly means of marking a list of batch-received messages as complete (ideally, w/ a single invocation, much like the Microsoft.Azure.ServiceBus.MessageReceiver.CompleteAsync that accepts an IEnumerable<string> message lock token argument). Question Am I overlooking a more appropriate set of code artifacts in the Azure.Messaging.ServiceBus library that might help achieve both batch message receipt and settlement/completion? Thanks much in advance for your time and wisdom! Environment Ubuntu 20.04, .NET 6.0
Client	Service Bus	ServiceBus fails to send messages if folder contains Microsoft.Azure.Amqp version 2.5.8 instead of 2.5.6	The following exception is thrown when output folder contains Microsoft.Azure.Amqp version= 2.5.8  and 'Azure.Messaging.ServiceBus version=7.5.1.0: The type initializer for 'Azure.Messaging.ServiceBus.Amqp.AmqpTransactionManager' threw an exception. ---> System.TypeInitializationException: The type initializer for 'Azure.Messaging.ServiceBus.Amqp.AmqpTransactionManager' threw an exception. ---> System.TypeLoadException: Method 'OnCreateAsync' in type 'Azure.Messaging.ServiceBus.Amqp.AmqpTransactionEnlistment' from assembly 'Azure.Messaging.ServiceBus, Version=7.5.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8' does not have an implementation. at Azure.Messaging.ServiceBus.Amqp.AmqpTransactionManager..ctor() at Azure.Messaging.ServiceBus.Amqp.AmqpTransactionManager..cctor() --- End of inner exception stack trace --- at Azure.Messaging.ServiceBus.Amqp.AmqpTransactionManager.get_Instance() at Azure.Messaging.ServiceBus.Amqp.AmqpSender.SendBatchInternalAsync(IEnumerable1 messages, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.SendBatchInternalAsync(IEnumerable1 messages, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.<>c.<b__18_0>d.MoveNext() --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<>c__201.<<RunOperation>b__20_0>d.MoveNext() --- End of stack trace from previous location --- at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1,TResult](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.RunOperation[T1](Func4 operation, T1 t1, TransportConnectionScope scope, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.Amqp.AmqpSender.SendBatchAsync(ServiceBusMessageBatch messageBatch, CancellationToken cancellationToken) at Azure.Messaging.ServiceBus.ServiceBusSender.SendMessagesAsync(ServiceBusMessageBatch messageBatch, CancellationToken cancellationToken) This is because after version 2.5.6 Microsoft.Azure.Amqp contains breaking change: base class named Singleton changed OnCreateAsync method parameters and Azure.Messaging.ServiceBus.Amqp.AmqpTransactionManager cannot be instantiated anymore as abstract method is not implemented. Note that assembly version of Microsoft.Azure.Amqp did not change at all. I don't think it is correct way to do breaking changes.
Client	Storage	Queue SDK 12.8.0 Returns Multiple Error Patterns for Enqueue to Deleted Storage Account - AggregateException Inner RequestFailedException is Missing ErrorCode	Hi Azure Devs, I am writing an auto failover class that enables our queue wrapper to fall back to a backup storage account via circuit breaker, to handle cases where someone may accidentally delete a storage account in prod. I've noticed two separate exception patterns in this case:  RequestFailedException with error code `ResourceNotFound` and message `The specified resource does not exist.` AggregateException, with InnerException being RequestFailedException, and a blank error code, and message `Name or service not known`  The bug is that I would expect the InnerException in the AggregateException to have the `ResourceNotFound` error code.
Client	KeyVault	[QUERY] Azure KeyVault client every time makes a request to get an access token	Library name and version Microsoft.Azure.KeyVault 3.0.5 Query/Question I have the following code in Startup.cs services.AddSingleton<KeyVaultClient>(_ => {  return new(async (authority, resource, _) =>  {   var adCredential = new ClientCredential(options.KeyVaultClientId, options.KeyVaultClientSecret);   var authenticationContext = new AuthenticationContext(authority, null);   var authResult = await authenticationContext.AcquireTokenAsync(resource, adCredential);   return authResult.AccessToken;  }); });  Then, I inject KeyVaultClient in many places. For example one request to my Web API, first validates a certificate in one class: await _keyVaultClient.VerifyAsync(_options.KeyVaultUrl, _options.RootCertificateId,     string.Empty, JsonWebKeySignatureAlgorithm.RS256, digest, signature);  then sign JWT token in another class: await _keyVaultClient.SignAsync(_options.KeyVaultUrl, _options.RootCertificateId,     string.Empty, JsonWebKeySignatureAlgorithm.RS256, digest);  As a result, on every request, I got 2 login.windows.net operations which takes much time  POST Tokens/Token POST /{TenantId}/oauth2/token POST //keys/MD-CARoot-dev//verify POST /{TenantId}/oauth2/token POST //keys/MD-CARoot-dev//sign  Is there a way to avoid these long operations every time you use KeyVaultClient? Is it optimal to acquire a new token every time while the previous one is still valid? Why the SDK doesn't use some cache? Environment .NET SDK (reflecting any global.json): Version:   6.0.101 Commit:    ef49f6213a Runtime Environment: OS Name:     Windows OS Version:  10.0.19044 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\6.0.101\ Host (useful for support): Version: 6.0.1 Commit:  3a25a7f1cc .NET SDKs installed: 6.0.100 [C:\Program Files\dotnet\sdk] 6.0.101 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.30 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.21 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 6.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 6.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
Client	Service Bus	[FEATURE REQ] Service Bus: Core classes public instead of internal	Library name Azure.Messaging.ServiceBus Please describe the feature. Currently trying to `MOCK` ServiceBus for local-only development with a Filesystem implementation, been going through the source code and the best level of intervening would be on TransportReceiver and TransportSender level. However, ServiceBusConnection, TransportClient, TransportSender, and TransportReceiver are internal classes which makes it unnecessarily difficult. It would also be good to be able to inject a custom implementation of ServiceBusConnection into the ServiceBusClient
Client	Service Bus	Microsoft.Azure.ServiceBus.ServiceBusException: 'sender9' is closed	Library name and version Microsoft.Azure.ServiceBus 5.1.3 Query/Question Hi Team, We are having application in dot net core and hosted on fargate container. This application continuously listen to queue on one service bus. On receiving any message it sends that message to another queue of same service bus. To send a message we are creating MessageSender using queue path at the start of the application itself. Also we are using AMQPWebSockets as transport type. But during this we are experiencing intermittently exception as Microsoft.Azure.ServiceBus.ServiceBusException: 'sender9' is closed. Also on very next attempt using service bus retry it gets successfully send to that queue. We are not doing any reset or any explicit retry for this. Exception : Microsoft.Azure.ServiceBus.ServiceBusException: 'sender9' is closed\n   at Microsoft.Azure.ServiceBus.Core.MessageSender.OnSendAsync(IList1 messageList)\\n   at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func1 operation, TimeSpan operationTimeout)\n   at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func1 operation, TimeSpan operationTimeout)\\n   at Microsoft.Azure.ServiceBus.Core.MessageSender.SendAsync(IList1 messageList)\n   at ManagedSubscriber.Core.ServiceBusOperations.Complete(Message auditMessage, ServiceBusEntites serviceBusEntites, Message retrievedMessage, MessageProcessingReport messageProcessingReport) Service bus package : Microsoft.Azure.ServiceBus Version : 5.1.3 AMQP package : Microsoft.Azure.Amqp version : 2.4.11 Dot net core : 3.1 Kindly guide us on the same. Environment Dot net core 3.1
Client	Tables	[QUERY] Replace SAS token for a TableServiceClient	Library name and version Azure.Data.Tables 12.3.0 Query/Question We use SAS token to access our Azure Storage Tables. The SAS token is configured to have a short valid time, typically 4 hours. When the SAS token expires, a new SAS token should be used to allow the client to access the table service. In earlier SDK version (Microsoft.WindowsAzure.Storage 9.3.2), we use the following 2 functions provided by the SDK to work with the SAS token authentication:  The CloudTableClient has a DefaultRequestOptions which allows us to inject a custom IRetryPolicy implementation. We extend the default ExponetialRetry and further check if the failure is 403 Forbidden. If yes, we consider this as a sign of SAS token expiry, and will refresh the SAS token and retry the request. (By default, 403 error is not considered as retryable.) The CloudStorageAccount has a Credentials property which allows us to replace the SAS token (if the credential is indeed a SAS token) with the UpdateSASToken method. This is called in the above hook to replace the expired token. It will fetch a new SAS token from KeyVault (the storage account is managed by the KeyVault), and update it to the storage account.  With these two functions we are able to refresh the SAS token automatically when it is expired. However, when we tried to migrate to the new Azure.Data.Tables library, we found we are not able to do it the same way:  The RetryPolicy is now fixed in the HttpPipelineBuilder. We can only configure some of its properties such as mode, delay, max retries, but we are not able to customize the policy itself. For example, we are not able to define a new policy which retries on 403 error. Without this, we need to manually parse the SAS token to get the expiry time, and get a new token before it expires. This is not supported in the SDK too, and the SAS token format looks to be implementation specific and should not parsed by our application logic. SAS token passed to the TableServiceClient is now hidden in the authPolicy, which is just one policy in the per retry group. We are not able to access this policy or update the SAS token through the TableServiceClient. To use a new SAS token, we have to recreate the TableServiceClient instance. However, currently we use DI and register the table client on application starts, and inject it into the data access layer. To replace the TableServiceClient, the whole DI chain needs to be refactored.  We would like to know:  If we are going to improve this (e.g., support customizable retry policy, replaceable SAS token)? If not, what's the recommended way to work with the SAS token refresh scenario?  Thanks, Environment Environment neutral
Client	Tables	[QUERY] How to take only one entity using TableClient.Query(filter, maxPerPage, select, cancellationToken)	Library name and version Azure.Data.Tables 12.3.0 Query/Question I'm working on migrating some code flows about azure storage table from WindowsAzure.Storage.Table to Azure.Data.Tables. When using WindowAzure.Storage.Table, we can call TableQuery.Take(1) to get only one entity, just as following: query = query.Take(1);  However, TableQuery class does not exist in newer version library, and we can only use TableClient.CreateQueryFilter() to construct certain query statement, which is used as the first parameter in TableClient.Query(). So could you please help me how to specify the count of retrieved result? Thanks! Environment Microsoft Visual Studio Enterprise 2022 (64-bit) Version 17.0.1
Client	Service Bus	[BUG] Timeout when you keep sending 200 KB sized messages to standard service bus queue in loop at a high rate	Library name and version Azure.Messaging.Servicebus 7.5.1 Describe the bug I was trying to test the limits of Azure Messaging Service Bus SDK and was sending 200KB message in the loop to Azure Service Bus using the latest SDK. I see that after a while all the requests are timed out stating the operation could not be completed within 0:00:60. I am using D8s_v3 VM in Azure which has sufficient cpu, memory, and network bandwidth to push just 200 KB messages. Why is it timing out for such a small packet but in quick succession? I don't think there was throttling too, because as per the service bus documentation, I must be getting a `MessagingException` instead of timeout. Can someone check this and let me know? https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-exceptionsmessages The cpu, memory, and network metrics are pretty healthy. Expected behavior Should not timeout Actual behavior Timeout exception Reproduction Steps Send 200KB messages in a continuous loop to Azure Standard Service bus queue. using System; using System.Text; using System.Threading.Tasks; using Azure.Messaging.ServiceBus;  // connection string to your Service Bus namespace string connectionString = `Endpoint=Removed`;  // name of your Service Bus topic string topicName = `datafeedtest`; //this actually a queue  // the client that owns the connection and can be used to create senders and receivers ServiceBusClient client;  // the sender used to publish messages to the topic ServiceBusSender sender;  // number of messages to be sent to the topic int numOfMessages = 0;  string strdata = GenerateString(); {     // The Service Bus client types are safe to cache and use as a singleton for the lifetime     // of the application, which is best practice when messages are being published or read     // regularly.     //     // Create the clients that we'll use for sending and processing messages.     client = new ServiceBusClient(connectionString,      new ServiceBusClientOptions()      {          //RetryOptions = new ServiceBusRetryOptions() { TryTimeout = TimeSpan.FromMinutes(5) }       });      sender = client.CreateSender(topicName);      try     {         ServiceBusMessage msg = new ServiceBusMessage(strdata);         List<Task> tasksList = new List<Task>();         for (int i = 0; i <= 100000; i++)         {             Task t = sender.SendMessageAsync(msg);             Console.WriteLine($`Message submitted Successfully ` + DateTime.Now.ToString());             //Thread.Sleep(1000);             tasksList.Add(t);         }         await Task.WhenAll(tasksList);     }     catch (Exception ex)     {         Console.Write(ex.Message);     }     finally     {         // Calling DisposeAsync on client types is required to ensure that network         // resources and other unmanaged objects are properly cleaned up.         await sender.DisposeAsync();         await client.DisposeAsync();     }      Console.WriteLine(`Press any key to end the application`);     Console.ReadKey();   }  String GenerateString() {     int length = 200000;     StringBuilder sb = new StringBuilder();      for (int i = 0; i < length; i++)     {         sb.Append('A');     }      return sb.ToString();  } Environment .net 4.8
Client	KeyVault	[QUERY] How can I determine when a secret from Key Vault has been purged?	Library name and version Azure.Security.KeyVault.Secrets 4.2.0 Query/Question I have code to restore a key vault secret from a backup. Calling RestoreSecretBackupAsync will return a conflict if the secret exists in the key vault, so I delete the secret first using the following two lines, per the documentation. var operation = await secretClient.StartDeleteSecretAsync(secretName).ConfigureAwait(false); await operation.WaitForCompletionAsync().ConfigureAwait(false);  After the second line returns, I now have to purge the secret. After this, I confirm that the secret is no longer in the key vault by calling both GetSecret and GetDeletedSecret. Both return 404 indicating that the secret is neither active in the vault, nor is it in a deleted state. Immediately following this I perform the restore with RestoreSecretBackupAsync which fails with a status of 409 Conflict because  the key vault is saying that the secret still exists. The secret is in some limbo state it seems where it is no longer in the deleted state but it hasn't been purged. After waiting anywhere from 1 to 5 seconds, I can restore. I have to do this by repeatedly attempting to restore until it succeeds. My question: Is there a different way for me to determine if a secret has been completely purged? I would rather not rely on repeatedly failing to complete a restore. Environment .NET 4.7.1
Mgmt	Compute	[QUERY] What is the right way to run a RunCommand?	Library name and version Azure.ResourceManager.Compute Query/Question Currently I run the RunCommand this way, but it does not work. VirtualMachine testVM = await vmCollection.GetAsync(vmName); Azure.ResourceManager.Compute.Models.RunCommandInput cmd = new Azure.ResourceManager.Compute.Models.RunCommandInput(`RunPowershellScript`); Azure.ResourceManager.Compute.Models.RunCommandInputParameter cmdInput = new Azure.ResourceManager.Compute.Models.RunCommandInputParameter(`Script`, `Restart-Service -Name Test`); cmd.Parameters.Add(cmdInput); testVM.RunCommand(cmd); There is no 'Setter' for RunCommandInput as well. Please advice the correct way to use this. Thanks. Environment OS: Windows 10 .NET Framework 6 Visual Studio 17.0.0
Client	Storage	[BUG] BlobClient.Upload throws exception on stream from another BlobClient.OpenRead with ClientSideEncryptionOptions	Library name and version Azure.Storage.Blobs 12.11.0-beta.2, Azure.Storage.Blobs 12.10.0 Describe the bug Tried with: Azure.Storage.Blobs 12.11.0-beta.2 Azure.Storage.Blobs 12.10.0 I'm trying to transfer a blob which is encrypted on the source blobstorage and should be written decrypted to the destination. While I want to avoid downloading and uploading the file as a whole this streaming approach looked suitable. Unfortunately this approach times out and stops uploading the blobs. Snippet causing the issue: blob = blob.WithClientSideEncryptionOptions(options);  using (var sourceBlob = await blob.OpenReadAsync()) {  await exportBlob.UploadAsync(sourceBlob, overwrite: true); }  A workaround is using the following: blob = blob.WithClientSideEncryptionOptions(options);  var uploadOptions = new BlobUploadOptions() {  TransferOptions = new StorageTransferOptions()  {   InitialTransferSize = 4096,   MaximumTransferSize = 4096  } };  await using (var sourceBlob = await blob.OpenReadAsync()) {  await exportBlob.UploadAsync(sourceBlob, uploadOptions); }  The BlobServiceClient is using a static HttpClient initialized as following: private static HttpClient _httpClient = new HttpClient() { Timeout = Timeout.InfiniteTimeSpan }; And the used BlobClientOptions in the BlobServiceClient are: new BlobClientOptions() {  Transport = new HttpClientTransport(_httpClient),  Retry = { NetworkTimeout = Timeout.InfiniteTimeSpan } // This had to be removed for the Exception to be thrown, otherwise it will never timeout };  The exception is thrown for both Upload and UploadAsync It looks like there is bug when trying to use the Upload function without uploadOptions when doing an OpenRead on a blob with ClientSideEncryptionOptions and using that stream on another blob on another blobstorage with the Upload function Although the first Upload succeeded with a filesize of 196421 bytes the upload hangs until the exception is throw. I was debugging this with the Service Fabric deployed locally and the Actor ran into the Breakpoint set to the Upload function 4 times but reached the end of the function only 1 time which were the above mentioned 196421 bytes. Exception thrown:  System.AggregateException`,`message`:`Retry failed after 6 tries. Retry settings can be adjusted in ClientOptions.Retry. (The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.) (The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.) (The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.) (The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.) (The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.) (The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.)`, `hasFullStack`:true,`parsedStack`: [ { `level`:0, `method`:`Azure.Core.Pipeline.RetryPolicy+d__11.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:1, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:2, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:3, `method`:`Azure.Storage.Blobs.BlockBlobRestClient+d__6.MoveNext`, `assembly`:`Azure.Storage.Blobs, Version=12.11.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:4, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:5, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:6, `method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable1+ConfiguredTaskAwaiter.GetResult`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`Azure.Storage.Blobs.Specialized.BlockBlobClient+<UploadInternal>d__33.MoveNext`, `assembly`:`Azure.Storage.Blobs, Version=12.11.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:8, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:10, `method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable1+ConfiguredTaskAwaiter.GetResult`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`Azure.Storage.Blobs.Specialized.BlockBlobClient+<>c__DisplayClass64_0+<b__0>d.MoveNext`, `assembly`:`Azure.Storage.Blobs, Version=12.11.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:12, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:13, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:14, `method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable1+ConfiguredTaskAwaiter.GetResult`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:15, `method`:`Azure.Storage.PartitionedUploader2+d__20.MoveNext`, `assembly`:`Azure.Storage.Blobs, Version=12.11.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:16, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:17, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:18, `method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable1+ConfiguredTaskAwaiter.GetResult`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:19, `method`:`Azure.Storage.Blobs.BlobClient+<StagedUploadInternal>d__41.MoveNext`, `assembly`:`Azure.Storage.Blobs, Version=12.11.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:20, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:21, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:22, `method`:`System.Runtime.CompilerServices.TaskAwaiter1.GetResult`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:23, `method`:`TransferActorTransferActor+d__4.MoveNext`, `assembly`:`TransferActor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`, `fileName`:`Transfer.cs`, `line`:70 }, { `level`:24, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:25, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:26, `method`:`System.Runtime.CompilerServices.TaskAwaiter1.GetResult`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:27, `method`:`TransferActor.Transfer+<Transfer>d__19.MoveNext`, `assembly`:`TransferActor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`, `fileName`:`Transfer`, `line`:484 } ] }, { `id`:33780062, `outerId`:23577166, `typeName`:`System.Threading.Tasks.TaskCanceledException`, `message`:`The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:1, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:2, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:3, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:5, `method`:`Azure.Core.Pipeline.HttpPipelineSynchronousPolicy+<<ProcessAsync>g__ProcessAsyncInner|4_0>d.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:6, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:8, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`Azure.Core.Pipeline.RedirectPolicy+<ProcessAsync>d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:10, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:12, `method`:`Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 } ] }, { `id`:11797342, `outerId`:33780062, `typeName`:`System.Threading.Tasks.TaskCanceledException`, `message`:`The operation was canceled.`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`System.Net.Http.HttpConnection+<SendAsyncCore>d__53.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:1, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:2, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:3, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Net.Http.HttpConnectionPool+<SendWithNtConnectionAuthAsync>d__48.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:5, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:6, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Net.Http.HttpConnectionPool+<SendWithRetryAsync>d__47.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:8, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:10, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`System.Net.Http.RedirectHandler+<SendAsync>d__4.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:12, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:13, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:14, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:15, `method`:`System.Net.Http.HttpClient+<FinishSendAsyncUnbuffered>d__71.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:16, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:17, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:18, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:19, `method`:`Azure.Core.Pipeline.HttpClientTransport+<ProcessAsync>d__10.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:20, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:21, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:22, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:23, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 } ] }, { `id`:17281586, `outerId`:11797342, `typeName`:`System.IO.IOException`, `message`:`Unable to read data from the transport connection: Der E/A-Vorgang wurde wegen eines Threadendes oder einer Anwendungsanforderung abgebrochen..`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.ThrowException`, `assembly`:`System.Net.Sockets, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:1, `method`:`System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.GetResult`, `assembly`:`System.Net.Sockets, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:2, `method`:`System.Net.Security.SslStream+<<FillBufferAsync>g__InternalFillBufferAsync|215_0>d1.MoveNext`, `assembly`:`System.Net.Security, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:3, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:5, `method`:`System.Net.Security.SslStream+d__2141.MoveNext`, `assembly`:`System.Net.Security, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:6, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:8, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`System.Net.Http.HttpConnection+<SendAsyncCore>d__53.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 } ] }, { `id`:59859578, `outerId`:17281586, `typeName`:`System.Net.Sockets.SocketException`, `message`:`Der E/A-Vorgang wurde wegen eines Threadendes oder einer Anwendungsanforderung abgebrochen.`, `hasFullStack`:true }, { `id`:19288682, `outerId`:23577166, `typeName`:`System.Threading.Tasks.TaskCanceledException`, `message`:`The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:1, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:2, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:3, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:5, `method`:`Azure.Core.Pipeline.HttpPipelineSynchronousPolicy+<<ProcessAsync>g__ProcessAsyncInner|4_0>d.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:6, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:8, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`Azure.Core.Pipeline.RedirectPolicy+<ProcessAsync>d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:10, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:12, `method`:`Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 } ] }, { `id`:51819871, `outerId`:19288682, `typeName`:`System.Threading.Tasks.TaskCanceledException`, `message`:`The operation was canceled.`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`System.Net.Http.HttpConnection+<SendAsyncCore>d__53.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:1, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:2, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:3, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Net.Http.HttpConnectionPool+<SendWithNtConnectionAuthAsync>d__48.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:5, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:6, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Net.Http.HttpConnectionPool+<SendWithRetryAsync>d__47.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:8, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:10, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`System.Net.Http.RedirectHandler+<SendAsync>d__4.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:12, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:13, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:14, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:15, `method`:`System.Net.Http.HttpClient+<FinishSendAsyncUnbuffered>d__71.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:16, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:17, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:18, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:19, `method`:`Azure.Core.Pipeline.HttpClientTransport+<ProcessAsync>d__10.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:20, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:21, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:22, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:23, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 } ] }, { `id`:13920292, `outerId`:51819871, `typeName`:`System.IO.IOException`, `message`:`Unable to read data from the transport connection: Der E/A-Vorgang wurde wegen eines Threadendes oder einer Anwendungsanforderung abgebrochen..`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.ThrowException`, `assembly`:`System.Net.Sockets, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:1, `method`:`System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.GetResult`, `assembly`:`System.Net.Sockets, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:2, `method`:`System.Net.Security.SslStream+<<FillBufferAsync>g__InternalFillBufferAsync|215_0>d1.MoveNext`, `assembly`:`System.Net.Security, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:3, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Net.Security.SslStream+d__214`1.MoveNext`, `assembly`:`System.Net.Security, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:5, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:6, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Net.Http.HttpConnection+d__87.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:8, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`System.Net.Http.HttpConnection+d__84.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 }, { `level`:10, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:12, `method`:`System.Net.Http.HttpConnection+d__53.MoveNext`, `assembly`:`System.Net.Http, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a`, `line`:0 } ] }, { `id`:46515337, `outerId`:13920292, `typeName`:`System.Net.Sockets.SocketException`, `message`:`Der E/A-Vorgang wurde wegen eines Threadendes oder einer Anwendungsanforderung abgebrochen.`, `hasFullStack`:true }, { `id`:21450663, `outerId`:23577166, `typeName`:`System.Threading.Tasks.TaskCanceledException`, `message`:`The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout.`, `hasFullStack`:true, `parsedStack`:[ { `level`:0, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:1, `method`:`Azure.Core.Pipeline.ResponseBodyPolicy+d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:2, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:3, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:4, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:5, `method`:`Azure.Core.Pipeline.HttpPipelineSynchronousPolicy+<g__ProcessAsyncInner|4_0>d.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:6, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:7, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:8, `method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:9, `method`:`Azure.Core.Pipeline.RedirectPolicy+d__5.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 }, { `level`:10, `method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:11, `method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`, `assembly`:`System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`, `line`:0 }, { `level`:12, `method`:`Azure.Core.Pipeline.RetryPolicy+d__11.MoveNext`, `assembly`:`Azure.Core, Version=1.21.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`, `line`:0 } ] }, { `id`:25220526, `outerId`:23577166, `typeName`:`Microsoft.ApplicationInsights.DataContracts.InnerExceptionCountExceededException`, `message`:`The number of inner exceptions was 25 which is larger than 10, the maximum number allowed during transmission. All but the first 10 have been dropped.`, `hasFullStack`:true } ]  Expected behavior blob = blob.WithClientSideEncryptionOptions(options);  using (var sourceBlob = await blob.OpenReadAsync()) {  await exportBlob.UploadAsync(sourceBlob, overwrite: true); }  This snippet does not fail and should work as well as using above mentioned workaround with using BlobUploadOptions Actual behavior An OpenRead on a Blob with ClientSideEncryptionOptions on one storage and using that stream for the Upload on a blob on another blobstorage should not result in the Exception mentioned in the description Reproduction Steps blob = blob.WithClientSideEncryptionOptions(options);  using (var sourceBlob = await blob.OpenReadAsync()) {  await exportBlob.UploadAsync(sourceBlob, overwrite: true); }  Environment Locally debugging Service Fabric with an Actor which tries to transfer a blob from one blobstorage with ClientSideEncryptionOptions to another blob on another blobstorage which should be decrypted
Client	Service Bus	[QUERY] How to implement AcknowledgeAsync and CompleteAsync ?	Library name and version Azure.Messaging.Servicebus 7.5.1 Query/Question While migrating from legacy service bus SDK, i noticed two methods AcknowledgeAsync and CompleteAsync. How do I implement/realize them in the latest SDK? Reference Links: https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.queueclient.abandonasync?view=azure-dotnet https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.queueclient.completeasync?view=azure-dotnet Environment .net 4.8
Client	Service Bus	[QUERY] Equivalent of Microsoft.ServiceBus.ServiceBusEnvironment	Library name and version Azure.Messaging.Servicebus 7.5.1 Query/Question What is the Equivalent of `Microsoft.ServiceBus.ServiceBusEnvironment` in the new SD `Azure.Messaging.Servicebus 7.5.1` https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.servicebusenvironment?view=azure-dotnet Environment .net 4.8 and net core 3.1
Client	Service Bus	[BUG] Camel case is not supported for application properties(keys)	Library name and version Azure.Messaging.ServiceBus, Version=7.0.0.0 Describe the bug when created service bus message with application properties serviceBusMessage.ApplicationProperties.Add(`ApiVersion`, 1); serviceBusMessage.ApplicationProperties.Add(`CreateTimestamp`, dateNow); and we send it to topic (on azure topic we still have all keys in lowercase) so we have  so, please fix it, for our client is very needed to have camelCase Expected behavior camelCase for aplication properties on azure service bus explorer topic message Actual behavior lowercase for aplication properties on azure service bus explorer topic message Reproduction Steps ServiceBusMessage serviceBusMessage = new ServiceBusMessage(message); serviceBusMessage.ApplicationProperties.Add(`EventEntity`, `LoyaltyAccount`); serviceBusMessage.ApplicationProperties.Add(`ApiVersion`, 1); serviceBusMessage.ApplicationProperties.Add(`CreateTimestamp`, dateNow); await sender.SendMessageAsync(serviceBusMessage); Environment No response
Client	Event Grid	[QUERY] EventGrid client publish retries	Library name and version Azure.Messaging.EventGrid Query/Question Are there recommended approaches for retries when publishing custom events using the client? Environment No response
Client	Event Hubs	Release ETA?	What's the ETA for this feature to go out of Preview?  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 36ba3c46-71b7-2d92-1535-e9ab6c9ff6c6 Version Independent ID: eeb50376-6a63-b39c-6c60-99bdbb4eeef9 Content: EventHubBufferedProducerClient Class (Azure.Messaging.EventHubs.Producer) - Azure for .NET Developers Content Source: xml/Azure.Messaging.EventHubs.Producer/EventHubBufferedProducerClient.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Storage	[BUG] CryptographicException: Padding is invalid and cannot be removed.	Library name and version Azure.Storage.Blobs 12.10.0 Describe the bug An exception is thrown when doing multiple UploadAsync and DownloadAsync in parallel with ClientSideEncryption enabled. Exception: System.Security.Cryptography.CryptographicException: Padding is invalid and cannot be removed when doing Background information: We are migrating from Microsoft.Azure.Storage.Blob to Azure.Storage.Blobs. While doing a stress test on our service, we started seeing these exceptions. I've isolated the code to a single Unit Test which should be helpful to reproduce the issue. I've also tried several variants resulting in the same exception:  New BlobClient per request Using streams for uploading and downloading  Expected behavior No exception. Actual behavior A System.Security.Cryptography.CryptographicException: Padding is invalid and cannot be removed when doing is thrown. Reproduction Steps [TestMethod] public async Task TestUploadAsyncScenarios2() {     var keyVaultUri = new Uri(`https://***.vault.azure.net`);     var keyVaultSecretName = `***`;     var keyVaultTenantId = `***`;     var keyVaultClientId = `***`;     var certificateThumbprint = `***`;      var x509Store = new X509Store(StoreName.My, StoreLocation.CurrentUser);     x509Store.Open(OpenFlags.ReadOnly);     var certificates = x509Store.Certificates.Find(X509FindType.FindByThumbprint, certificateThumbprint, false);     var certificate = certificates[0];     x509Store.Close();      var credential = new ClientCertificateCredential(keyVaultTenantId, keyVaultClientId, certificate);     var secretClient = new SecretClient(keyVaultUri, credential);     var secret = secretClient.GetSecret(keyVaultSecretName);      var keyResolver = new KeyResolver(credential);     var keyEncryptionKey = keyResolver.Resolve(secret.Value.Id);      var clientSideEncryptionOptions = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V1_0)     {         KeyEncryptionKey = keyEncryptionKey,         KeyResolver = keyResolver,         KeyWrapAlgorithm = `A256KW`     };      var blobConnectionString = `***`;     var blobContainerName = `***`;     var blobName = `test`;     var blobContents = `test content`;      var blobContainerClient = new BlobContainerClient(blobConnectionString, blobContainerName);     var blobClient = blobContainerClient.GetBlobClient(blobName);     var encryptedBlobClient = blobClient.WithClientSideEncryptionOptions(clientSideEncryptionOptions);      await UploadAsync();      while (true)     {         try         {             await Task.WhenAll(                 UploadAsync(),                 DownloadAsync(),                 UploadAsync()             );         }         catch (Exception)         {             throw;         }     }      Task UploadAsync() => encryptedBlobClient.UploadAsync(new BinaryData(blobContents), new BlobUploadOptions { });     Task DownloadAsync() => encryptedBlobClient.DownloadContentAsync(); } Environment Windows 10 .NET Standard 2.0 Visual Studio 16.10.3
Mgmt	App Services	ListFunctionKeys fail for Serverless Azure Function App running on Linux	[Enter feedback here] When trying to retrieve functions keys of the function app deployed as a serverless function app on Linux call to ListFunctionKeys fails, When function app is redeployed to run on windows, call to ListFunctionKeys succeed, All other calls to a IFunctionApp api work correctly (ex, ListFunctions) on both Linux and Windows deployment. When calling ListFunctionKeys on Linux deployed function app the first REST call to get GetFunctionsAdminToken fails: invocationId: 1 instance: Microsoft.Azure.Management.AppService.Fluent.FunctionAppImpl method: Get parameters: {functionName=ChangePlayerMissionResultFunction,cancellationToken=System.Threading.CancellationToken} invocationId: 2 instance: Microsoft.Azure.Management.AppService.Fluent.WebAppsOperations method: GetFunctionsAdminToken parameters: {resourceGroupName=Gunzilla_backend_dev,name=g01-dev-missions-app,cancellationToken=System.Threading.CancellationToken} invocationId: 2 request: Method: GET, RequestUri: 'https://management.azure.com/subscriptions/*****/resourceGroups/*****/providers/Microsoft.Web/sites/g01-dev-missions-app/functions/admin/token?api-version=2019-08-01', Version: 1.1, Content: <null>, Headers: {   Results is the wrong response: Response:   headers:     Cache-Control : private     ETag : `1D7E686E0127DB5`     Vary : Accept-Encoding     x-ms-ratelimit-remaining-subscription-reads : 11988     Strict-Transport-Security : max-age=31536000; includeSubDomains     Server : Microsoft-IIS/10.0     X-AspNet-Version : 4.0.30319     X-Powered-By : ASP.NET     x-ms-request-id : 0cbed0ab-b115-410d-bba8-bf73c8944585     x-ms-correlation-request-id : 0cbed0ab-b115-410d-bba8-bf73c8944585     x-ms-routing-request-id : GERMANYWESTCENTRAL:20211201T103648Z:0cbed0ab-b115-410d-bba8-bf73c8944585     X-Content-Type-Options : nosniff     Date : Wed, 01 Dec 2021 10:36:47 GMT <!DOCTYPE html> <html> <head>     <title>Your Azure Function App is up and running.</title>     <style type=`text/css`>         @font-face {             font-family: 'SegoeLight';             src: url(//:) format('no404'), url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAFbcABAAAAAAjewAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABbAAAABsAAAAcWqtaPUdERUYAAAGIAAAAHQAAACABGAADT1MvMgAAAagAAABYAAAAYGrqcLZjbWFwAAACAAAAAaIAAAIKczqUA2N2dCAAAAOkAAAATAAAAEwOEAwRZnBnbQAAA/AAAAGxAAACZQ+0L6dnYXNwAAAFpAAAAAwAAAAMAAMAB2dseWYAAAWwAABJAAAAe3CDYeDNaGVhZAAATrAAAAAxAAAANvjlJxhoaGVhAABO5AAAACAAAAAkDm4GkWhtdHgAAE8EAAACNgAAA6yU7F4gbG9jYQAAUTwAAAHOAAAB2DtSXCptYXhwAABTDAAAACAAAAAgAg8B1G5hbWUAAFMsAAAA5wAAAZ4hIT5EcG9zdAAAVBQAAAH4AAAC+Je8aS1wcmVwAABWDAAAAM8AAAFulHbF13jaY2BgYGQAguP/NtwH0SfDQtZA6Y0AWbsHmQB42mNgZGBg4ANiCQYQYGIA8V8BSRYwjwEADksBHAAAAHjaY2BmfsOow8DKwMI6i9WYgYFhBYRmkmZIY0rjYGLiZmZiYWVhYmJewMC03oFBIZoBCnyDFRSAlMJvFra0f2kMDOzpTJxAgfkgORYG1lkgOQZGAGSzDHF42mNgYGBmgGAZBkYgycDIAuQxgvksDC+AtBmDApAlxlDH8J/RkDGYsYLpGNMtpjssbCwcLGEsEQpcCiIKUgpyCkoKagr6ClYK8QprFJUeMPxm+s3y/z9QvwLDAqC+IAx9DAoCChIKMlB9lnB9jCB9/x//P/R/4v/C/77/GP6+/fvmj9of1d/ffn99cPLBkQcHHxx4sPfBrgebHqx80PrA8v4Rheesz1mfQdxPDmBkY4BrZmQCEkzoCoBBxMLKxs7BycXNw8vHLyAoJCwiKiYuISklLSMrJ6+gqKSsoqqmrqGppa2jq6dvYGhkbGJqZm5haWVtY2tn7+Do5Ozi6ubu4enl7ePr5x8QGBQcEhoWHhEZFR0TGxefkMjQ1t7ZPXnGvMWLlixbunzl6lVr1q5ft2Hj5q1btu3Yvmf33n0MRSmpmfcrFhZkPyvLYuiYxVDMwJBeDnZdTg3Dil2NyXkgdm7tg6Sm1umHj1y/cefuzVs7GQ4eZXj66PGLlwyVt+8xtPQ093b1T5jYN3Uaw5Q5c2cfOnaikIHh   ...  It just returns the page that says `Your Azure Function App is up and running` Using Microsoft.Azure.Management.Fluent version 1.38.0  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 4d9605b4-c336-7d46-c56d-f30192ae02b8 Version Independent ID: e059c4a1-f7cd-5474-0528-284a40b12d5b Content: IFunctionApp.ListFunctionKeys(String) Method (Microsoft.Azure.Management.AppService.Fluent) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Management.AppService.Fluent/IFunctionApp.xml Service: app-service GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Service Bus	Migration from WindowsAzure.ServiceBus (legacy) to Azure.Messaging.ServiceBus (latest)	Library name and version WindowsAzure.ServiceBus 5.1.0 Query/Question Our project currently uses the `Windows.Azure.ServiceBus 5.1.0` to communicate with the service bus. I have two questions,  Is there a migration guide for migrating from WindowsAzure.ServiceBus to the latest Azure.Messaging.ServiceBus? Is there any performance improvement in terms of sending if I choose to have the latest SDK to communicate with the service bus? If yes, is there any documentation showing the improvement?  Environment No response
Client	Storage	[QUERY] Storage: Query queue runtime properties	Library name and version Azure.Storage.Queues latest Query/Question Hello I have a requirement to create some functionality for some queues that resembles the Azure Service Bus' `Auto Delete When Idle`. Is there a possibility in the Sdk to retrieve Storage Queue metadata, more precisely when it was last used/accessed, or when was the last message posted or retrieved or deleted? So I can determine since when the queue was idle. Thanks Herald Environment No response
Client	Event Grid	CloudNative CloudEvent for Event grid domain	Newly created library Microsoft.Azure.Messaging.EventGrid.CloudNativeCloudEvents does not work with Event grid domain
Client	Service Bus	Can the property `ServiceBusMessage.Subject` be automatically set by Azure Services like IoT Hub custom Service Bus Endpoint, or Event Grid Service Subscription?	I need to collect events from different sources (e.g., IoT hub and Custom Event Grid) and process them in a on-premise application. To preserve the temporal order (the order in which they were enqueued in the service bus), I want to send them to the same Service Bus Topic. Since, I have to handle messages originating from different sources differently (e.g., IoT hub device-to-cloud messages, IoT Hub device-twin-change-events, different custom Event Grid events), I would like to identify the source of a service bus message. My understanding is that the ServiceBusReceivedMessage.Subject property would be the adequate field, but it seems that the Azure services (e.g., Event Grid, IoT Hub ...) do not set this field. Am I missing something? Thank you in advance!  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 100e1e77-75dc-4531-f483-78426f625c19 Version Independent ID: 58687af5-4f4a-ae23-2ae5-a82daad4371d Content: ServiceBusReceivedMessage.Subject Property (Azure.Messaging.ServiceBus) - Azure for .NET Developers Content Source: xml/Azure.Messaging.ServiceBus/ServiceBusReceivedMessage.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Azure.Identity	Azure.Identity release notes	Query/Question I want to know whether it is worthwhile updating our dependency on Azure.Identity from 1.4.1 to 1.5, but I have no information as to what has changed.
Client	Tables	[BUG] Azure.Data.Tables - GetDateTime - Throws casting error	Very simple retrieve of an entity from a table. Reading the entity form the query filter and using the default caster (GetDateTime) to read one of the properties that is a non-null Utc datetime. It throws an exception: System.InvalidOperationException HResult=0x80131509 Message=Cannot return System.Nullable`1[System.DateTime] type for a System.DateTimeOffset typed property. Source=Azure.Data.Tables StackTrace: at Azure.Data.Tables.TableEntity.EnforceType(Type requestedType, Type givenType) at Azure.Data.Tables.TableEntity.GetValue(String key, Type type) at Azure.Data.Tables.TableEntity.GetValue[T](String key) at Azure.Data.Tables.TableEntity.GetDateTime(String key) at ConsoleApp_TestingDatesInAzure.Program.Main(String[] args) in D:\ConsoleApp_TestingDatesInAzure\Program.cs:line 41 It should return the DateTime in Utc, without any exception. The actual value is not null and it is in Utc. But even if it was null it should return null instead and not throw an exception Here is the code:  var strongEntity = new AzureTestTableEntity             {                 PartitionKey = `20211113`,                 RowKey = $`ROWKEY`,                 ETag = new ETag(`*`),                 Timestamp = DateTime.UtcNow,                  EffectiveDate = DateTime.UtcNow,                 LastReadDate = DateTime.UtcNow,              };               Pageable<TableEntity> queryResultsFilter = tc.Query<TableEntity>(filter: $`PartitionKey eq '{`20211113`}'`);               foreach (var qEntity in queryResultsFilter)             {                 Console.WriteLine($`{qEntity.GetDateTime(`EffectiveDate`)}: {qEntity.GetDateTime(`LastReadDate`)}`);             }              Console.WriteLine($`The query returned {queryResultsFilter.Count()} entities.`);   Environment:  Azure.Data.Tables 12.3.0 Windows 10 - .net 5.0 Microsoft Visual Studio Community 2019 Version 16.11.6
Client	Cosmos	What is the default sorting of GetItemLinqQueryable?	I want to construct a query with optional parameters in LINQ, basically this code: IOrderedQueryable<User> query = _userContainer.GetItemLinqQueryable<User>(); if (id != null) {     query = query.Where(user => user.Id == id); // returns IQueryable } if (name != null) {     query = query.Where(user => user.Name == name); // returns IQueryable } This doesn't work because IQueryable cannot be assigned to IOrderedQueryable which GetItemLinqQueryable returns. To avoid doing an expensive sort operation my theory is that I can apply the same sorting that GetItemLinqQueryable uses in each of these if-blocks. I didn't find the default sort mentioned in the documentation, so anyone knows what it is?  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 0207c888-39da-2768-71b5-2fc219f5ebad Version Independent ID: 4ed5c6d6-170d-50a5-7ac2-e8e64bd7d0f6 Content: Container.GetItemLinqQueryable<T>(Boolean, String, QueryRequestOptions, CosmosLinqSerializerOptions) Method (Microsoft.Azure.Cosmos) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.Cosmos/Container.xml Service: cosmos-db GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	KeyVault	CryptographyClient - Using the WebJsonKey decrypting not working locally.	Describe the bug Current architecture is: Azure Function -> 1 Activity Function -> Batches iteration (synch) -> Individual batch iteration (async) -> Decrypting and Encrypting for each record using CryptographyClient We need to process 40 million requests, our process will decrypt and encrypt for every iteration, and is not able to handle even a 1000 requests. I noticed that can handle only 999 at the top. So the statistics shown in this page https://docs.microsoft.com/en-us/azure/key-vault/general/service-limits doesn’t seem accurate, that is one thing. Now, trying to improve the performance, to do all parts of the process asynchronous and running in parallel, the other issue is, I’m trying to setup the CryptographyClient using the WebJsonKey which seems to work for Encrypting without doing the roundtrip to Key Vault, it does the encryption locally, but is not working the same for decrypting using the WebJsonKey, is throwing an error: Key does not exist. How do we overcome this 2 problems? Expected behavior CryptographyClient using the WebJsonKey should also work for decrypting locally. Actual behavior (include Exception or Stack Trace) CryptographyClient using the WebJsonKey which seems to work for Encrypting without doing the roundtrip to Key Vault, it does the encryption locally, but is not working the same for decrypting using the WebJsonKey, is throwing an error: Key does not exist. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) Environment:  Name and version of the Library package used: [e.g. Azure Function, Azure KeyVault] Hosting platform or OS and .NET runtime version - .net core 3.1 application hosted on Azure Function
Client	Azure.Identity	[FEATURE REQ] RESILIENCY: GA Support ESTS-R in Azure.Identity SDK	Library or service name. What library or service is this request related to? [e.g. Azure.Storage.Blobs] Azure.Identity SDK Is your feature request related to a problem? Please describe. What feature would you like to get added? What problem is it solving? Our 1st party app Dev is blocked for using Azure. Identity SDK to adopt ESTS-R, due to the lack of autodetect region in GA.
Client	Cognitive - Translator	[FEATURE REQ] Cognitive-Translator client SDK is missing a method to enumerate languages	Library or service name. Cognitive - Translator Is your feature request related to a problem? Please describe. Document Translation SDK is missing a method to enumerate the available languages You should not expect the client developer to manually maintain a list of valid languages. Example Here is my implementation of that functionality: https://github.com/MicrosoftTranslator/DocumentTranslationService/blob/master/Language.cs
Mgmt	ARM	[QUERY]DefaultAzureCredential failed to retrieve a token from the included credentials. - EnvironmentCredential authentication unavailable. Environment variables are not fully configured. - ManagedIdentityCredential authentication failed.	Query/Question I'm using  user managed identity to get azure credentials However  I'm getting the following error : DefaultAzureCredential failed to retrieve a token from the included credentials. - EnvironmentCredential authentication unavailable. Environment variables are not fully configured. - ManagedIdentityCredential authentication failed: Service request failed. Status: 400 (Bad Request) Content: {`statusCode`:400,`message`:`Unable to load requested managed identity.`,`correlationId`:`3181b895-9ff4-4f55-a1e3-c6fc2ad3c73f`} Headers: Date: Wed, 10 Nov 2021 18:34:52 GMT Server: Kestrel Transfer-Encoding: chunked Content-Type: application/json; charset=utf-8 - SharedTokenCacheCredential authentication failed: Value cannot be null. (Parameter 'attributeValue1') - Operating system Linux 5.4.0-1031-azure #32~18.04.1-Ubuntu SMP Tue Oct 6 10:03:22 UTC 2020 isn't supported. - VisualStudioCodeCredential authentication failed: Unable to load shared library 'libsecret-1.so.0' or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable: liblibsecret-1.so.0: cannot open shared object file: No such file or directory - Azure CLI not installed var tokenCred = new Azure.Identity.DefaultAzureCredential(new DefaultAzureCredentialOptions { ManagedIdentityClientId = `client id` });     var armToken = tokenCred.GetToken(new TokenRequestContext(scopes: new[] { `https://management.azure.com/.default` }, parentRequestId: null), default).Token;     var armCreds = new Microsoft.Rest.TokenCredentials(armToken);      var graphToken = tokenCred.GetToken(new TokenRequestContext(scopes: new[] { `https://graph.windows.net/.default` }, parentRequestId: null), default).Token;     var graphCreds = new Microsoft.Rest.TokenCredentials(graphToken);     return new AzureCredentials(armCreds, graphCreds, Environment.GetEnvironmentVariable(@`AZURE_TENANT_ID`), AzureEnvironment.AzureGlobalCloud); });  Environment:  Microsoft.Azure.Management.ResourceManager.Fluent  1.0.0.66 Azure AppService
Client	Service Bus	Service Bus: provide batch API to complete/abandon message	Library or service name. Azure.Messaging.ServiceBus Is your feature request related to a problem? Please describe. With latest version of SDK I can retrieve messages in batch but I cannot complete or abandon those messages in batch, I have to go message by message. It would be nice to have a batch API to avoid multiple calls to Azure endpoint.
Mgmt	App Services	[QUERY] Can we get InstanceId for app service workers	Query/Question How can we help?  we can use https://docs.microsoft.com/en-us/rest/api/appservice/web-apps/list-instance-identifiers to get the instance Id for the workers but when we use SDK, webSiteManagementClient.WebApps.ListInstanceIdentifiersAsync can't get the correct instance Id   Our customer want to get the instance id from SDK, would you help, thanks. Environment:  Name and version of the Library package used: Microsoft.Azure.Management.Fluent 1.38.0 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): .NET SDK (reflecting any global.json): Version:   5.0.208 Commit:    d21a38d788  Runtime Environment: OS Name:     Windows OS Version:  10.0.19042 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\5.0.208\ Host (useful for support): Version: 5.0.11 Commit:  f431858f8b .NET SDKs installed: 3.1.414 [C:\Program Files\dotnet\sdk] 5.0.208 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.App 3.1.20 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 3.1.20 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.20 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] To install additional .NET runtimes or SDKs: https://aka.ms/dotnet-download  IDE and version : [e.g. Visual Studio 16.9.12]
Mgmt	Compute - VMSS	[BUG] Can't pass in ids for VirtualMachineScaleSetVMInstanceIDs in Azure.ResourceManager.Compute.Models	Describe the bug In Azure.ResourceManager.Compute VirtualMachineScaleSet class, many functions (ReImage, ReImageAll, PowerOff, PowerOn) relies on input instanceIds of type VirtualMachineScaleSetVMInstanceIDs. However, the VirtualMachineScaleSetVMInstanceIDs constructor can not pass in any instanceIds list, nor it allows to set the List instanceIds. As a result, we can't execute any of those functions. Expected behavior What is the expected behavior? VirtualMachineScaleSetVMInstanceIDs constructor should allow pass in InstanceIds parameter. Actual behavior (include Exception or Stack Trace) What is the actual behavior? VirtualMachineScaleSetVMInstanceIDs constructor does not allow pass in InstanceIds parameter. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)   Environment:  Name and version of the Library package used: [Azure.ResourceManager.Compute.1.0.0-beta.2] Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [Windows 10 .NET Framework 4.8] IDE and version : [e.g. Visual Studio 16.3]
Client	Event Hubs	Should Last* fields in Azure.Messaging.EventHubs.EventData be public?	azure-sdk-for-net/sdk/eventhub/Azure.Messaging.EventHubs/src/EventData.cs                    Line 309       in       6819082                                                 internal long? LastPartitionSequenceNumber => _amqpMessage.GetLastPartitionSequenceNumber();                     I'm using EventProcessor<TPartition>, and I'd like access to the LastPartitionSequenceNumber, LastPartitionOffset, and LastPartitionEnqueuedTime for determining processing lag in our implementation of OnProcessingEventBatchAsync.
Client	Tables	Will TableEntity's Timestamp hold in court?	[Enter feedback here] I am curious as to the possibility of relying on Azure Table Storage's Timestamp field, to prove in court that a piece of specific information was present at a specific point in time. This could be useful in applications such as digital document signatures. Was the hash of that document inserted before that date and time? It would be a great feature and can be built upon if we can have read-only tables, where we only insert but can't accidentally update content or their timestamp.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 0dfc53f5-8eae-c63d-3765-6d37774c2153 Version Independent ID: 6aec37d1-c5bb-6b4e-39e0-24a695c93952 Content: TableEntity.Timestamp Property (Azure.Data.Tables) - Azure for .NET Developers Content Source: xml/Azure.Data.Tables/TableEntity.xml Service: azure GitHub Login: @rloutlaw Microsoft Alias: routlaw
Client	Monitor - Exporter	[QUERY]question about distributed tracing with opentelemtry and Azure Monitor Exporter	Query/Question Hi, My team would like to collect and consume traces by using Opentelemtry and Azure Monitor exporter. We still have some questions and hope you could help us. the first question: I found the sampling supported in Opentelemtry is not supported in Azure Monitor Opentelemtry Exporter according to this guide: https://docs.microsoft.com/en-us/azure/azure-monitor/app/opentelemetry-enable?tabs=net . so, for the latest version, is it supported? the second question: I succeed to run my web app and the data showed up in the AppInsights. but, in the transaction detail, it showed 0 traces.  it should have 1 trace with 5 spans. I don't know why it shows 0 traces Environment: Azure.Monitor.OpenTelemetry.Exporter 1.0.0-beta.3 .NET 5.0 Opentelemetry  1.20-beta1
Client	Azure.Identity	[BUG]  `Azure.Identity.AuthenticationFailedException : ManagedIdentityCredential authentication failed: Cannot access a closed Stream` after update Azure.Identity from 1.4.0 or 1.4.1 to 1.5.0 beta	I have a bunch of integration tests that get secrets from an Azure keyvault. When I run these tests on my machine tests work as expected and pass, but when these tests run in a Azure DevOps pipeline they are failing with the exception   Azure.Identity.AuthenticationFailedException : ManagedIdentityCredential authentication failed: Cannot access a closed Stream. The issue is happening only with 1.5.0 beta version, I rollback the version to 1.4.1 and 1.4.0 and in tests run well on the Azure Devops pipeline. The code failing is:             Configuration = configBuilder                 .AddAzureKeyVault(new Uri(builtConfig[`key_vault_name`]), new DefaultAzureCredential())                 .Build(); This code is inside a class to initialize the tests. Expected behavior To run the tests in the pipeline in the same way than in a local machine. Actual behavior (include Exception or Stack Trace)   Error Message:    Azure.Identity.AuthenticationFailedException : ManagedIdentityCredential authentication failed: Cannot access a closed Stream. ---- System.ObjectDisposedException : Cannot access a closed Stream.   Stack Trace:      at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex)    at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenFromSourcesAsync(TokenCredential[] sources, TokenRequestContext requestContext, Boolean async, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex)    at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueFromCredentialAsync(TokenRequestContext context, Boolean async, CancellationToken cancellationToken)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueAsync(HttpMessage message, TokenRequestContext context, Boolean async)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AccessTokenCache.GetHeaderValueAsync(HttpMessage message, TokenRequestContext context, Boolean async)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.AuthenticateAndAuthorizeRequestAsync(HttpMessage message, TokenRequestContext context)    at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.AuthorizeRequestOnChallengeAsyncInternal(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken)    at Azure.Security.KeyVault.KeyVaultPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken)    at Azure.Security.KeyVault.KeyVaultPipeline.GetPageAsync[T](Uri firstPageUri, String nextLink, Func`1 itemFactory, String operationName, CancellationToken cancellationToken)    at Azure.Core.PageResponseEnumerator.FuncAsyncPageable`1.AsPages(String continuationToken, Nullable`1 pageSizeHint)+MoveNext()    at Azure.Core.PageResponseEnumerator.FuncAsyncPageable`1.AsPages(String continuationToken, Nullable`1 pageSizeHint)+System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult()    at Azure.Extensions.AspNetCore.Configuration.Secrets.AzureKeyVaultConfigurationProvider.LoadAsync()    at Azure.Extensions.AspNetCore.Configuration.Secrets.AzureKeyVaultConfigurationProvider.LoadAsync()    at Azure.Extensions.AspNetCore.Configuration.Secrets.AzureKeyVaultConfigurationProvider.Load()    at Microsoft.Extensions.Configuration.ConfigurationRoot..ctor(IList`1 providers)    at Microsoft.Extensions.Configuration.ConfigurationBuilder.Build()  ----- Inner Stack Trace -----    at System.IO.MemoryStream.set_Position(Int64 value)    at Azure.Identity.ManagedIdentitySource.GetMessageFromResponse(Response response, Boolean async, CancellationToken cancellationToken)    at Azure.Identity.ImdsManagedIdentitySource.HandleResponseAsync(Boolean async, TokenRequestContext context, Response response, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityClient.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)  To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Create an integration tests that call to Azure keyvault to retrieve some secrets.              var configBuilder = new ConfigurationBuilder()                 .AddEnvironmentVariables();              var builtConfig = configBuilder.Build();              Configuration = configBuilder                 .AddAzureKeyVault(new Uri(builtConfig[`key_vault_name`]), new DefaultAzureCredential())                 .Build();  Azure.Identity 1.5.0 beta (tested with beta 3 and beta 4) .NET Core 3.1.  Azure DevOps pipeline running on WIndows Server 2019
Client	Extensions	Add an AddBlobContainerClient similar to AddBlobServiceClient	Library or service name. Azure.Storage.Blobs Is your feature request related to a problem? Please describe. There is a DI extension method named AddBlobServiceClient() used to register a BlobServiceClient. My configuration contains a blobContainerUri, so in order to create a client using the DI extension method, I have to parse this configuration to split it up into a serviceUri plus a blobContainerName. I then have to register a BlobServiceClient in DI with the parsed serviceUri and in my classes I have to call GetBlobContainerClient() with the parsed blobContainerName. It would be much easier if I could add a BlobContainerClient directly to DI using the blobContainerUri I have in my configuration.
Client	Service Bus	It will take 10 minutes when a loop occurs for the number of cases set in PrefetchCount.	.NET SDK (Microsoft.Azure.ServiceBus) to receive messages from Azure Service Bus Topic. I have confirmed that the `subscriptionReceiver.PrefetchCount` property described in the following program takes 10 minutes when a loop occurs for the set number of cases. ・Program      try         {              subscriptionReceiver = new MessageReceiver(SbusConnectionString, subscriptionPath, ReceiveMode.PeekLock);             Console.WriteLine($`[{DateTime.Now:O}] Start Receive`);              // Set Prefetch             subscriptionReceiver.PrefetchCount = 6;  ============================= ・Explained as an example based on the information displayed in the console Msg 1 : [2021-08-10T14:13:37.4642259+09:00] Start Receive Msg 2 : [2021-08-10T14:13:40.1724492+09:00] Received Msg 3 : [2021-08-10T14:13:41.7225299+09:00] Received Msg 4 : [2021-08-10T14:13:43.2456619+09:00] Received Msg 5 : [2021-08-10T14:13:44.7809022+09:00] Received Msg 6 : [2021-08-10T14:13:46.3156828+09:00] Received Msg 7 : [2021-08-10T14:23:43.5556342+09:00] Received Msg 8 : [2021-08-10T14:23:45.0974040+09:00] Received Msg 9 : [2021-08-10T14:23:46.6341618+09:00] Received Msg 10 : [2021-08-10T14:23:48.1605786+09:00] Received Msg 11 : [2021-08-10T14:23:49.6840978+09:00] Received Msg 12 : [2021-08-10T14:33:47.1229598+09:00] Received Msg 13 : [2021-08-10T14:33:48.6569753+09:00] Received Msg 14 : [2021-08-10T14:33:50.1803312+09:00] Received Msg 15 : [2021-08-10T14:33:51.8161747+09:00] Received Msg 16 : [2021-08-10T14:33:53.3440673+09:00] Received Based on the above, I believe that `subscriptionReceiver.PrefetchCount` has the following behavior. ・After fetching the number of messages specified in PrefetchCount, when fetching messages in the next loop (for the next number of messages specified in PrefetchCount), the operation is to re-receive messages from the local buffer in order to fetch them again at the same time, which takes 10 minutes. I would like to confirm the following points regarding `subscriptionReceiver.PrefetchCount`. 【Question】  Whether or not it is a specification that it takes 10 minutes when `subscriptionReceiver.PrefetchCount` is set. If it is not a specification, it may not meet the requirement to take 10 minutes when setting `subscriptionReceiver.PrefetchCount`, I would appreciate it if you would consider modifying it to improve its functionality.
Client	Storage	[BUG] Caching and BlobClient.DownloadAsync() Response x-ms-client-request-id does not match the original expected request id	In an .netFramework-Project with requestCaching activated the second time a blob is requested, a RequestFailedException is thrown. Azure.RequestFailedException: 'Response x-ms-client-request-id '3742a081-3d05-493e-9b97-c5cbcd70c659' does not match the original expected request id, '890534a7-43be-46b7-bcd0-f6c3e3cfef12'. if caching is deactivated it works fine. <system.net>     <requestCaching isPrivateCache =`true` disableAllCaching=`false` defaultPolicyLevel=`CacheIfAvailable` unspecifiedMaximumAge=`7.00:00:00` />   </system.net>   Environment:  Name and version of the Library package used: Azure.Storage.Blobs 12.10.0 (newest) Hosting platform: .net Framework 4.7.2  AzureBlobBug.zip
Client	Event Hubs	[BUG] EventHubProducerClient SendAsync fails with EventHubsException(ClientClosed): Unable to create the items needed to communicate with the Event Hubs service	Describe the bug We randomly see an exception of EventHubsException(ClientClosed): Unable to create the items needed to communicate with the Event Hubs service being thrown from EventHubProducerClient.SendAsync. Expected behavior Not to fail with the error... Actual behavior (include Exception or Stack Trace) EventHubsException(ClientClosed): Unable to create the items needed to communicate with the Event Hubs service and also -  Exception while executing function: InventoryToRawEvents ---> System.Net.Sockets.SocketException (10048): Only one usage of each socket address (protocol/network address/port) is normally permitted. at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.CreateAndOpenConnectionAsync(Version amqpVersion, Uri serviceEndpoint, Uri connectionEndpoint, EventHubsTransportType transportType, IWebProxy proxy, Int32 sendBufferSizeBytes, Int32 receiveBufferSizeBytes, RemoteCertificateValidationCallback certificateValidationCallback, String scopeIdentifier, TimeSpan timeout) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout) at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenProducerLinkAsync(String partitionId, TransportProducerFeatures features, PartitionPublishingOptions options, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateLinkAndEnsureProducerStateAsync(String partitionId, PartitionPublishingOptions partitionOptions, TimeSpan timeout, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateLinkAndEnsureProducerStateAsync(String partitionId, PartitionPublishingOptions partitionOptions, TimeSpan timeout, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout) at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Amqp.AmqpProducer.CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Producer.EventHubProducerClient.CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken) at Azure.Messaging.EventHubs.Producer.EventHubProducerClient.CreateBatchAsync(CancellationToken cancellationToken) at Common.EventHub.EventHubSender.SendEventsAsync(IEnumerable`1 events) in C:\__w\1\s\src\Common.EventHub\EventHubSender.cs:line 30 at Processors.Functions.InventoryToRawEventsFunction.InventoryToRawEvents(IReadOnlyList`1 documents) in C:\__w\1\s\src\Processors\Functions\InventoryToRawEventsFunction.cs:line 77 at Microsoft.Azure.WebJobs.Host.Executors.VoidTaskMethodInvoker`2.InvokeAsync(TReflected instance, Object[] arguments) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\VoidTaskMethodInvoker.cs:line 20 at Microsoft.Azure.WebJobs.Host.Executors.FunctionInvoker`2.InvokeAsync(Object instance, Object[] arguments) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionInvoker.cs:line 52 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.InvokeWithTimeoutAsync(IFunctionInvoker invoker, ParameterHelper parameterHelper, CancellationTokenSource timeoutTokenSource, CancellationTokenSource functionCancellationTokenSource, Boolean throwOnTimeout, TimeSpan timerInterval, IFunctionInstance instance) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 572 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.ExecuteWithWatchersAsync(IFunctionInstanceEx instance, ParameterHelper parameterHelper, ILogger logger, CancellationTokenSource functionCancellationTokenSource) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 518 at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor.ExecuteWithLoggingAsync(IFunctionInstanceEx instance, FunctionStartedMessage message, FunctionInstanceLogEntry instanceLogEntry, ParameterHelper parameterHelper, ILogger logger, CancellationToken cancellationToken) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\Executors\FunctionExecutor.cs:line 296  To Reproduce The client is created and cached within the class - EventHubProducerClient eventHubProducerClient = eventHubProducerClientFactory.Create(                 options.Value.EventHubFqdn,                 options.Value.EventHubName,                 authenticationHelper.GetDefaultAzureCredential(options.Value.ClientId));  class EventHubProducerClientFactory : IEventHubProducerClientFactory {         public EventHubProducerClient Create(string fullyQualifiedNamespace, string eventHubName, TokenCredential credential) =>             new EventHubProducerClient(fullyQualifiedNamespace, eventHubName, credential); } Environment:  Name and version of the Library package used: Azure.Messaging.EventHubs 5.5.0 Hosting platform or OS and .NET runtime version: Windows Azure Function, .NET Core 3.1
Client	Container Registry	[QUERY] [ACR] Owner can't list tags? (possibly a bug)	Query/Question I've got an API that creates container instances in some situations. Before I send the call to create an instance I'd like to do some input validation and check that the image version and tag requested actually exists in the container registry. I'm running this locally under my user account using Azure.Identity.VisualStudioCredential (see code below). This will be replaced by a DefaultAzureCredential or ClientSecretCredential once I get it working locally. My account has 'Owner' RBAC role on the relevant container registry. I have double checked that, and the ACR url. Is there anything else needed? I have looked through docs, ACR roles and Azure.Containers.ContainerRegistry, but can't find mention of anything else needed.    I'm getting the following response: {`Service request failed.\r\nStatus: 401 (Unauthorized)\r\n\r\nContent:\r\n{\`errors\`: [ {\`code\`:\`UNAUTHORIZED\`,\`message\`:\`retrieving permissions failed\`} ] } \r\n\r\nHeaders:\r\nServer: openresty\r\nDate: Fri, 08 Oct 2021 13:27:56 GMT\r\nConnection: keep-alive\r\nX-Ms-Correlation-Request-Id: REDACTED\r\nx-ms-ratelimit-remaining-calls-per-second: REDACTED\r\nStrict-Transport-Security: REDACTED\r\nContent-Type: application/json\r\nContent-Length: 78\r\n` }     Stacktrace:    at Azure.Containers.ContainerRegistry.AuthenticationRestClient.<ExchangeAadAccessTokenForAcrRefreshTokenAsync>d__5.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()    at Azure.Containers.ContainerRegistry.ContainerRegistryRefreshTokenCache.<GetRefreshTokenFromCredentialAsync>d__15.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at Azure.Containers.ContainerRegistry.ContainerRegistryRefreshTokenCache.<GetAcrRefreshTokenAsync>d__11.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at Azure.Containers.ContainerRegistry.ContainerRegistryRefreshTokenCache.<GetAcrRefreshTokenAsync>d__11.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Threading.Tasks.ValueTask`1.get_Result()    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Containers.ContainerRegistry.ContainerRegistryChallengeAuthenticationPolicy.<AuthorizeRequestOnChallengeAsyncInternal>d__10.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy.<ProcessAsync>d__11.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.Pipeline.RedirectPolicy.<ProcessAsync>d__5.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__11.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__11.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter.GetResult()    at Azure.Containers.ContainerRegistry.ContainerRegistryRestClient.<GetTagPropertiesAsync>d__32.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()    at Azure.Containers.ContainerRegistry.RegistryArtifact.<GetDigestAsync>d__17.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()    at Azure.Containers.ContainerRegistry.RegistryArtifact.<>c__DisplayClass25_0.<<GetTagPropertiesCollectionAsync>g__FirstPageFunc|0>d.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at Azure.Core.PageableHelpers.FuncAsyncPageable`1.<AsPages>d__4.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.GetResult(Int16 token)    at Azure.Core.PageableHelpers.FuncAsyncPageable`1.<AsPages>d__4.System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult(Int16 token)    at Azure.AsyncPageable`1.<GetAsyncEnumerator>d__6.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at Azure.AsyncPageable`1.<GetAsyncEnumerator>d__6.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.GetResult(Int16 token)    at Azure.AsyncPageable`1.<GetAsyncEnumerator>d__6.System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult(Int16 token)    at System.Runtime.CompilerServices.ValueTaskAwaiter`1.GetResult()    at DataAccess.ContainerRegistry.ContainerRegistryService.<ValidateImageExistsAsync>d__4.MoveNext() in E:\Prog\Path\To\MyProject\Api\DataAccess.ContainerRegistry\ContainerRegistryService.cs:line 34    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at DataAccess.ContainerRegistry.ContainerRegistryService.<ValidateImageExistsAsync>d__4.MoveNext() in E:\Prog\Path\To\MyProject\Api\DataAccess.ContainerRegistry\ContainerRegistryService.cs:line 34      Code, condensed for brevity:         public async Task<bool> ValidateImageExistsAsync(string imageTag)         {             var defaultCreds = new VisualStudioCredential();                          var uri = new Uri($`https://{containerConfig.RegistryServer}`);             var client = new ContainerRegistryClient(uri, defaultCreds,                 new ContainerRegistryClientOptions()                 {                     Audience = ContainerRegistryAudience.AzureResourceManagerPublicCloud                 });             try             {                 var repository = client.GetArtifact(containerConfig.ImageName, imageTag);                 var tagsWithPropertiesPagable = repository.GetTagPropertiesCollectionAsync();                  bool foundTag = false;                 await foreach (var tagWithProperties in tagsWithPropertiesPagable)                 {                     if (tagWithProperties.Name == imageTag)                         foundTag = true;                 }                   return foundTag;             }             catch (Exception ex)             {                 throw new ApiBadRequestException($`Unable to locate proxy image '{containerConfig.ImageName}:{imageTag}'`, ex);             }         }  Environment:  Azure.Containers.ContainerRegistry 1.1.0-beta.1 Azure.Identity 1.4.1 Microsoft.AspNetCore.App 3.1.19 (also have 3.1.18 installed) Visual Studio 16.11.2
Client	Tables	[FEATURE REQ] Support for Azure Active Directory (AAD) for TableClient backed by CosmosDB	Library or service name. I'm using the Azure.Data.Tables library. Is your feature request related to a problem? Please describe. I'd like to authenticate to my Cosmos DB backed TableAPI with a user-assigned managed identity. In the changelog it appears that support for AAD has been added in version 12.1.0 but that `only Azure Storage API endpoints currently support AAD authorization`. However, according to managed identity documentation, CosmosDB also supports AAD. I'm not sure if this is a recent development, but it seems to me that TableClient should now support AAD for CosmosDB API endpoints too. Currently, when I try using AAD authentication, I get the following error which is, I assume, explained by the explicit lack of support for CosmosDB AAD authorization.  Azure.RequestFailedException: Authorization header doesn't confirm to the required format. Please verify and try again. ActivityId: 42c03e1e-2d7a-4a58-9a84-116f0db443cc, documentdb-dotnet-sdk/2.14.0 Host/64-bit MicrosoftWindowsNT/6.2.9200.0 RequestID:42c03e1e-2d7a-4a58-9a84-116f0db443cc Status: 401 (Unauthorized) ErrorCode: Unauthorized Content: {`odata.error`:{`code`:`Unauthorized`,`message`:{`lang`:`en-us`,`value`:`Authorization header doesn't confirm to the required format. Please verify and try again.\r\nActivityId: 42c03e1e-2d7a-4a58-9a84-116f0db443cc, documentdb-dotnet-sdk/2.14.0 Host/64-bit MicrosoftWindowsNT/6.2.9200.0\nRequestID:42c03e1e-2d7a-4a58-9a84-116f0db443cc\n`}}}  Thanks for considering this feature request!
Mgmt	Container Instances	[BUG] Timeout in Fluent Library for Azure Container Instance Creation	Describe the bug I get a timeout while creating Azure Container Instances Expected behavior Being able to configure the timeout Actual behavior (include Exception or Stack Trace)       An unhandled exception has occurred while executing the request. Microsoft.Rest.Azure.CloudException: Long running operation failed with status 'Canceled'.    at Microsoft.Rest.ClientRuntime.Azure.LRO.AzureLRO`2.CheckForErrors()    at Microsoft.Rest.ClientRuntime.Azure.LRO.PutLRO`2.CheckForErrors()    at Microsoft.Rest.ClientRuntime.Azure.LRO.AzureLRO`2.StartPollingAsync()    at Microsoft.Rest.ClientRuntime.Azure.LRO.AzureLRO`2.BeginLROAsync()    at Microsoft.Rest.Azure.AzureClientExtensions.GetLongRunningOperationResultAsync[TBody,THeader](IAzureClient client, AzureOperationResponse`2 response, Dictionary`2 customHeaders, CancellationToken cancellationToken)    at Microsoft.Rest.Azure.AzureClientExtensions.GetLongRunningOperationResultAsync[TBody](IAzureClient client, AzureOperationResponse`1 response, Dictionary`2 customHeaders, CancellationToken cancellationToken)    at Microsoft.Rest.Azure.AzureClientExtensions.GetPutOrPatchOperationResultAsync[TBody](IAzureClient client, AzureOperationResponse`1 response, Dictionary`2 customHeaders, CancellationToken cancellationToken)    at Microsoft.Azure.Management.ContainerInstance.Fluent.ContainerGroupsOperations.CreateOrUpdateWithHttpMessagesAsync(String resourceGroupName, String containerGroupName, ContainerGroupInner containerGroup, Dictionary`2 customHeaders, CancellationToken cancellationToken)    at Microsoft.Azure.Management.ContainerInstance.Fluent.ContainerGroupsOperationsExtensions.CreateOrUpdateAsync(IContainerGroupsOperations operations, String resourceGroupName, String containerGroupName, ContainerGroupInner containerGroup, CancellationToken cancellationToken)    at Microsoft.Azure.Management.ContainerInstance.Fluent.ContainerGroupImpl.CreateResourceAsync(CancellationToken cancellationToken)    at Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceActions.Creatable`4.Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceActions.IResourceCreator<IResourceT>.CreateResourceAsync(CancellationToken cancellationToken)    at Microsoft.Azure.Management.ResourceManager.Fluent.Core.DAG.CreatorTaskItem`1.ExecuteAsync(CancellationToken cancellationToken)    at Microsoft.Azure.Management.ResourceManager.Fluent.Core.DAG.TaskGroupBase`1.ExecuteNodeTaskAsync(DAGNode`1 node, CancellationToken cancellationToken)    at ServerScaling.Controllers.HostingController.DeployAsync(Guid guid) in C:\source\hosting\api\ServerScaling\ServerScaling\Controllers\HostingController.cs:line 169    at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.TaskOfIActionResultExecutor.Execute(IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)    at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.<InvokeActionMethodAsync>g__Awaited|12_0(ControllerActionInvoker invoker, ValueTask`1 actionResultValueTask)    at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.<InvokeNextActionFilterAsync>g__Awaited|10_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)    at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)    at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)    at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.<InvokeInnerFilterAsync>g__Awaited|13_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeFilterPipelineAsync>g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Awaited|17_0(ResourceInvoker invoker, Task task, IDisposable scope)    at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)    at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)    at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)  To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)    var azure = new AsyncLazy<IAzure>(() => Microsoft.Azure.Management.Fluent.Azure     .Configure()     .WithLogLevel(HttpLoggingDelegatingHandler.Level.BodyAndHeaders)     .Authenticate(credentials)     .WithDefaultSubscriptionAsync());  IAzure az = await azure.GetValueAsync();  await az.ContainerGroups.Define()....CreateAsync(); Environment:  Microsoft.Azure.Management.Fluent 1.38.0 dotnet 5.0.4 VS 16.11.2
Client	Tables	[BUG] GetTableClient and CreateIfNotExistsAsync fails silently	Describe the bug TableServiceClient.GetTableClient fails to work then table already exists. Expected behavior It writes to the table, or throws an exception (Should not hide System.ArgumentNullException) Actual behavior (include Exception or Stack Trace)  When table doesn't exists then it succeeds to write. When table already exists then it fails silently.  To Reproduce Using the following code: var client = new TableServiceClient(connectionString); var table = client.GetTableClient(tableName); var tableExists = await table.CreateIfNotExistsAsync(cancellationToken); await table.SubmitTransactionAsync(tableTransaction, cancellationToken); This is the EventSource-output from GetTableClient when table already exists: _client.GetTableClient(tableName) {Azure.Data.Tables.TableClient} AccountName [string]:'_client.GetTableClient(tableName).AccountName' threw an exception of type 'System.ArgumentNullException' Data [IDictionary]:{System.Collections.ListDictionaryInternal} HResult [int]:-2147467261 HelpLink [string]:null InnerException [Exception]:null Message [string]:`Value cannot be null. (Parameter 'uri')` ParamName [string]:`uri` Source [string]:`Azure.Data.Tables` StackTrace [string]:`   at Azure.Data.Tables.TableUriBuilder..ctor(Uri uri)\r\n   at Azure.Data.Tables.TableClient.get_AccountName()` TargetSite [MethodBase]:{Void .ctor(System.Uri)} Static members Non-Public members Name [string]:`Bar` Static members  This is the EventSource-output from GetTableClient when table doesn't exists: [Informational] Azure-Core: Request [3f5b9cd9-1496-467f-8f15-b0ddbc244b98] POST https://xxxx.table.core.windows.net/Tables?$format=REDACTED x-ms-version:REDACTED DataServiceVersion:3.0 Accept:application/json; odata=minimalmetadata x-ms-client-request-id:3f5b9cd9-1496-467f-8f15-b0ddbc244b98 x-ms-return-client-request-id:true User-Agent:azsdk-net-Data.Tables/12.1.0,(.NET Core 3.1.19; Microsoft Windows 10.0.19043) x-ms-date:REDACTED Authorization:REDACTED Content-Type:application/json; odata=nometadata client assembly: Azure.Data.Tables [Informational] Azure-Core: Response [3f5b9cd9-1496-467f-8f15-b0ddbc244b98] 201 Created (00.4s) Cache-Control:no-cache Transfer-Encoding:chunked Location:REDACTED Server:Windows-Azure-Table/1.0,Microsoft-HTTPAPI/2.0 x-ms-request-id:30bb81b9-5002-006a-01a5-b69cc7000000 x-ms-client-request-id:3f5b9cd9-1496-467f-8f15-b0ddbc244b98 x-ms-version:REDACTED X-Content-Type-Options:REDACTED Date:Fri, 01 Oct 2021 09:18:49 GMT Content-Type:application/json; odata=minimalmetadata; streaming=true; charset=utf-8  [Informational] Azure-Core: Request [1b4f4534-eca4-4d01-832e-1c0e8c675b79] POST https://xxx.table.core.windows.net/$batch x-ms-version:REDACTED DataServiceVersion:3.0 x-ms-client-request-id:1b4f4534-eca4-4d01-832e-1c0e8c675b79 x-ms-return-client-request-id:true User-Agent:azsdk-net-Data.Tables/12.1.0,(.NET Core 3.1.19; Microsoft Windows 10.0.19043) x-ms-date:REDACTED Authorization:REDACTED Content-Type:multipart/mixed; boundary=batch_79059028-c4b9-4edf-811f-3a2c358774c1 client assembly: Azure.Data.Tables [Informational] Azure-Core: Response [1b4f4534-eca4-4d01-832e-1c0e8c675b79] 202 Accepted (00.1s) Cache-Control:no-cache Transfer-Encoding:chunked Server:Windows-Azure-Table/1.0,Microsoft-HTTPAPI/2.0 x-ms-request-id:30bb823a-5002-006a-7aa5-b69cc7000000 x-ms-client-request-id:1b4f4534-eca4-4d01-832e-1c0e8c675b79 x-ms-version:REDACTED X-Content-Type-Options:REDACTED Date:Fri, 01 Oct 2021 09:18:50 GMT Content-Type:multipart/mixed; boundary=batchresponse_d5018bfe-dd0f-4f6a-a7a8-ae553efa5bf4  Environment:  Azure.Data.Tables version 12.1.0
Client	EngSys	[QUERY] Can not run test project because ambiguous between Assert.That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint)' and 'Assert.That<TActual>(TActual, IResolveConstraint)'	Query/Question I can not run test project because of below ambiguous error.  CS0121 The call is ambiguous between the following methods or properties: 'Assert.That(ActualValueDelegate, IResolveConstraint)' and 'Assert.That(TActual, IResolveConstraint)'   Environment:   Name and version of the Library package used: current main branch    Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects):    IDE
Client	Event Hubs	[QUERY] Is there guidance on checkpointing on PartitionClosingAsync when using the EventProcessorClient?	Query/Question Our scenario is that we checkpoint given an interval (X number of seconds) and we want to safely checkpoint an event when the partition is closing, due to a shutdown or perhaps when ownership of the partition changes. What is the recommended approach to creating a checkpoint when a partition is closing? Should we be creating a concurrent dictionary to checkpoint the last event for the particular partition before it is closed, similar to the example in https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/eventhub/Azure.Messaging.EventHubs.Processor/samples/Sample04_ProcessingEvents.md#checkpointing-while-processing? Instead of a ConcurrentDictionary<string, int>, a ConcurrentDictionary<string, ProcessEventArgs> would be used to checkpoint the last event processed but not checkpointed? Would the OnPartitionProcessingStoppedAsync handler for the current processor instance be executed before a new processor instance calls its OnInitializingPartitionAsync handler? Environment:  Name and version of the Library package used: Azure.Messaging.EventHubs.Processor v5.6.1 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): .NET 5 IDE and version : VS 16.11.2
Client	Azure.Core	[BUG] BlobServiceClient constructor fails with AzureCoreEventSource exception on Android	Describe the bug Given this line of code: var service = new BlobServiceClient($`BlobEndpoint={myBlobEndpoint};SharedAccessSignature={myBlobSAS}`);  When running locally in Windows Environment (e.g. in Console or Unit Test Application) it runs fine and I can use the service object afterwards to access my Blobs successfully. But when I run exactly the same line on Android (Xamarin.Forms) an AzureCoreEventSource exception is thrown from the constructor and my application crashes. When I now explicitly disable logging, it works fine also in Android Application: var options = new BlobClientOptions { Diagnostics = { IsLoggingEnabled = false } }; var service = new BlobServiceClient($`BlobEndpoint={myBlobEndpoint};SharedAccessSignature={myBlobSAS}`, options);  Expected behavior Creating a BlobServiceClient is also possible in a Xamarin.Forms application on Android without explicitly disable logging. Default configurations should not lead to strange exceptions. Actual behavior (include Exception or Stack Trace) When running on Android without explicitly disabled logging, the constructor throws the following exception and the application crashes. System.TypeInitializationException: The type initializer for 'Azure.Core.Diagnostics.AzureCoreEventSource' threw an exception.  ---> System.NotImplementedException: The method or operation is not implemented.  at System.Diagnostics.Tracing.EventSource.GetSources () [0x00000] in /Users/builder/jenkins/workspace/archive-mono/2020-02/android/release/mcs/class/corlib/System.Diagnostics.Tracing/EventSource.cs:318   at Azure.Core.Diagnostics.AzureEventSource.DeduplicateName (System.String eventSourceName) [0x00010] in <0aa90fe0646d47bc95bff520717dbf16>:0   at Azure.Core.Diagnostics.AzureEventSource..ctor (System.String eventSourceName) [0x00000] in <0aa90fe0646d47bc95bff520717dbf16>:0   at Azure.Core.Diagnostics.AzureCoreEventSource..ctor () [0x00000] in <0aa90fe0646d47bc95bff520717dbf16>:0   at Azure.Core.Diagnostics.AzureCoreEventSource..cctor () [0x00000] in <0aa90fe0646d47bc95bff520717dbf16>:0    --- End of inner exception stack trace ---  at Azure.Core.Pipeline.LoggingPolicy..cctor () [0x00000] in <0aa90fe0646d47bc95bff520717dbf16>:0   To Reproduce Try to create a BlobServiceClient instance in an Xamarin.Forms / Xamarin application on Android. When no explicit logging behavior is configured, the constructor crashes. When logging is explicitly disabled via BlobClientOptions everything works fine Environment:  Azure.Storage.Blobs 12.10.0 with Azure.Core 1.19.0 Xamarin.Forms 5.0.0.2125 Application on Android 11 Emulator / Android 9 Device Visual Studio 2019 16.11.3
Client	Azure.Identity	[BUG] Unable to use DefaultAzureCredential in the local environment over the VPN	Describe the bug When internet connection is over the VPN the DefaultAzureCredential fails to iterate credential chain when it tries to get credentials via ManagedIdentityClient. Expected behavior DefaultAzureCredential should skip ManagedIdentityClient if it's not available or not reachable. And for the local environment it should fallback to other methods e.g. AzureCliCredential Actual behavior (include Exception or Stack Trace) ImdsManagedIdentitySource tests connectivity to host 169.254.169.254 for port 80, and over the VPN it's available, something like this: nc -zv 169.254.169.254 80 Connection to 169.254.169.254 port 80 [tcp/http] succeeded! Under the VPN this address/port apparently used by VPN service itself. When ManagedIdentityClient tries to get actual data from the http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fvault.azure.net it fails. e.g. curl -H Metadata:true `http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fvault.azure.net` curl: (56) Recv failure: Connection reset by peer Unhandled exception. Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: Retry failed after 4 tries. Retry settings can be adjusted in ClientOptions.Retry. (An error occurred while sending the request.) (An error occurred while sending the request.) (An error occurred while sending the request.) (An error occurred while sending the request.)  ---> System.AggregateException: Retry failed after 4 tries. Retry settings can be adjusted in ClientOptions.Retry. (An error occurred while sending the request.) (An error occurred while sending the request.) (An error occurred while sending the request.) (An error occurred while sending the request.)  ---> Azure.RequestFailedException: An error occurred while sending the request.  ---> System.Net.Http.HttpRequestException: An error occurred while sending the request.  ---> System.IO.IOException: Unable to read data from the transport connection: Connection reset by peer.  ---> System.Net.Sockets.SocketException (54): Connection reset by peer    --- End of inner exception stack trace ---    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.GetResult(Int16 token)    at System.Net.Http.HttpConnection.FillAsync(Boolean async)    at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean async, Boolean foldedHeadersAllowed)    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)    at System.Net.Http.HttpClient.SendAsyncCore(HttpRequestMessage request, HttpCompletionOption completionOption, Boolean async, Boolean emitTelemetryStartStop, CancellationToken cancellationToken)    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Identity.ManagedIdentitySource.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityClient.AuthenticateAsync(Boolean async, TokenRequestContext context, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)  ---> (Inner Exception #1) Azure.RequestFailedException: An error occurred while sending the request.  ---> System.Net.Http.HttpRequestException: An error occurred while sending the request.  ---> System.IO.IOException: Unable to read data from the transport connection: Connection reset by peer.  ---> System.Net.Sockets.SocketException (54): Connection reset by peer    --- End of inner exception stack trace ---    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.GetResult(Int16 token)    at System.Net.Http.HttpConnection.FillAsync(Boolean async)    at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean async, Boolean foldedHeadersAllowed)    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)    at System.Net.Http.HttpClient.SendAsyncCore(HttpRequestMessage request, HttpCompletionOption completionOption, Boolean async, Boolean emitTelemetryStartStop, CancellationToken cancellationToken)    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)<---   ---> (Inner Exception #2) Azure.RequestFailedException: An error occurred while sending the request.  ---> System.Net.Http.HttpRequestException: An error occurred while sending the request.  ---> System.IO.IOException: Unable to read data from the transport connection: Connection reset by peer.  ---> System.Net.Sockets.SocketException (54): Connection reset by peer    --- End of inner exception stack trace ---    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.GetResult(Int16 token)    at System.Net.Http.HttpConnection.FillAsync(Boolean async)    at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean async, Boolean foldedHeadersAllowed)    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)    at System.Net.Http.HttpClient.SendAsyncCore(HttpRequestMessage request, HttpCompletionOption completionOption, Boolean async, Boolean emitTelemetryStartStop, CancellationToken cancellationToken)    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)<---   ---> (Inner Exception #3) Azure.RequestFailedException: An error occurred while sending the request.  ---> System.Net.Http.HttpRequestException: An error occurred while sending the request.  ---> System.IO.IOException: Unable to read data from the transport connection: Connection reset by peer.  ---> System.Net.Sockets.SocketException (54): Connection reset by peer    --- End of inner exception stack trace ---    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.GetResult(Int16 token)    at System.Net.Http.HttpConnection.FillAsync(Boolean async)    at System.Net.Http.HttpConnection.ReadNextResponseHeaderLineAsync(Boolean async, Boolean foldedHeadersAllowed)    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    --- End of inner exception stack trace ---    at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)    at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)    at System.Net.Http.HttpClient.SendAsyncCore(HttpRequestMessage request, HttpCompletionOption completionOption, Boolean async, Boolean emitTelemetryStartStop, CancellationToken cancellationToken)    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.HttpClientTransport.ProcessAsync(HttpMessage message, Boolean async)    at Azure.Core.Pipeline.ResponseBodyPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)<---     --- End of inner exception stack trace ---    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex)    at Azure.Identity.ManagedIdentityCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.ManagedIdentityCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenFromSourcesAsync(TokenCredential[] sources, TokenRequestContext requestContext, Boolean async, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex)    at Azure.Identity.DefaultAzureCredential.GetTokenImplAsync(Boolean async, TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Identity.DefaultAzureCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)    at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.AuthenticateRequestAsync(HttpMessage message, Boolean async)    at Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy.ProcessCoreAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RedirectPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.RetryPolicy.ProcessAsync(HttpMessage message, ReadOnlyMemory`1 pipeline, Boolean async)    at Azure.Core.Pipeline.HttpPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken)    at Azure.Security.KeyVault.KeyVaultPipeline.SendRequestAsync(Request request, CancellationToken cancellationToken)    at Azure.Security.KeyVault.KeyVaultPipeline.GetPageAsync[T](Uri firstPageUri, String nextLink, Func`1 itemFactory, String operationName, CancellationToken cancellationToken)    at Azure.Core.PageResponseEnumerator.FuncAsyncPageable`1.AsPages(String continuationToken, Nullable`1 pageSizeHint)+MoveNext()    at Azure.Core.PageResponseEnumerator.FuncAsyncPageable`1.AsPages(String continuationToken, Nullable`1 pageSizeHint)+System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult()    at Azure.Extensions.AspNetCore.Configuration.Secrets.AzureKeyVaultConfigurationProvider.LoadAsync()    at Azure.Extensions.AspNetCore.Configuration.Secrets.AzureKeyVaultConfigurationProvider.LoadAsync()    at Azure.Extensions.AspNetCore.Configuration.Secrets.AzureKeyVaultConfigurationProvider.Load()    at Microsoft.Extensions.Configuration.ConfigurationRoot..ctor(IList`1 providers)    at Microsoft.Extensions.Configuration.ConfigurationBuilder.Build()    at AkvTest.Program.Main(String[] args) in /Users/ipcholko/Documents/__RND/__akv-test/AkvTest/Program.cs:line 15    at AkvTest.Program.<Main>(String[] args)   To Reproduce Consider following code: using System; using System.Threading.Tasks; using Azure.Identity; using Microsoft.Extensions.Configuration;  namespace AkvTest {     class Program     {         static async Task Main(string[] args)         {             var builder = new ConfigurationBuilder();             builder.AddAzureKeyVault(new Uri(`https://some-kv.vault.azure.net/`), new DefaultAzureCredential());                          IConfiguration configuration = builder.Build();             Console.WriteLine($`ConnectionString: {configuration[`SomeSecret`]}`);         }     } } <Project Sdk=`Microsoft.NET.Sdk`>    <PropertyGroup>     <OutputType>Exe</OutputType>     <TargetFramework>net5.0</TargetFramework>   </PropertyGroup>    <ItemGroup>     <PackageReference Include=`Azure.Extensions.AspNetCore.Configuration.Secrets` Version=`1.2.1` />     <PackageReference Include=`Azure.Identity` Version=`1.4.1` />     <PackageReference Include=`Microsoft.Extensions.Configuration` Version=`5.0.0` />   </ItemGroup>  </Project> Simulate service for the host 169.254.169.254 port 80 which resets connection.
Client	Event Hubs	EventProcessorClient Not receiving events when connected to the $Default ConsumerGroup	Describe the bug I am using the Basic Processing Code example here: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/eventhub/Azure.Messaging.EventHubs.Processor/samples/Sample04_ProcessingEvents.md#basic-event-processing I can receive eventhub Events when I use a non-default consumer group, but when using the $Default consumer group no events are received. I can use ServiceBus Explorer and connect to the $Default Consumer Group and receive data Expected behavior When Connecting to the $Default consumer Group using EventProcessorClient or EventHubConsumerClient we should receive events from the eventhub Actual behavior (include Exception or Stack Trace) The processEventHandler is not triggered to process data no data is received To Reproduce  Use this code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/eventhub/Azure.Messaging.EventHubs.Processor/samples/Sample04_ProcessingEvents.md#basic-event-processing  Environment:  MSVS version: Microsoft Visual Studio Professional 2019 Version 16.11.1 VisualStudio.16.Release/16.11.1+31613.86 Microsoft .NET Framework Version 4.8.04084 Installed Version: Professional ADL Tools Service Provider   1.0 This package contains services used by Data Lake tools ASA Service Provider   1.0 ASP.NET and Web Tools 2019   16.11.75.64347 ASP.NET and Web Tools 2019 ASP.NET Web Frameworks and Tools 2019   16.11.75.64347 For additional information, visit https://www.asp.net/ Azure App Service Tools v3.0.0   16.11.75.64347 Azure App Service Tools v3.0.0 Azure Data Lake Node   1.0 This package contains the Data Lake integration nodes for Server Explorer. Azure Data Lake Tools for Visual Studio   2.6.1000.0 Microsoft Azure Data Lake Tools for Visual Studio Azure Functions and Web Jobs Tools   16.11.75.64347 Azure Functions and Web Jobs Tools Azure Stream Analytics Tools for Visual Studio   2.6.1000.0 Microsoft Azure Stream Analytics Tools for Visual Studio C# Tools   3.11.0-4.21403.6+ae1fff344d46976624e68ae17164e0607ab68b10 C# components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used. Common Azure Tools   1.10 Provides common services for use by Azure Mobile Services and Microsoft Azure Tools. Fabric.DiagnosticEvents   1.0 Fabric Diagnostic Events IntelliCode Extension   1.0 IntelliCode Visual Studio Extension Detailed Info Microsoft Azure HDInsight Azure Node   2.6.1000.0 HDInsight Node under Azure Node Microsoft Azure Hive Query Language Service   2.6.1000.0 Language service for Hive query Microsoft Azure Service Fabric Tools for Visual Studio   16.10 Microsoft Azure Service Fabric Tools for Visual Studio Microsoft Azure Stream Analytics Language Service   2.6.1000.0 Language service for Azure Stream Analytics Microsoft Azure Stream Analytics Node   1.0 Azure Stream Analytics Node under Azure Node Microsoft Azure Tools for Visual Studio   2.9 Support for Azure Cloud Services projects Microsoft Continuous Delivery Tools for Visual Studio   0.4 Simplifying the configuration of Azure DevOps pipelines from within the Visual Studio IDE. Microsoft JVM Debugger   1.0 Provides support for connecting the Visual Studio debugger to JDWP compatible Java Virtual Machines Microsoft Library Manager   2.1.113+g422d40002e.RR Install client-side libraries easily to any web project Microsoft MI-Based Debugger   1.0 Provides support for connecting Visual Studio to MI compatible debuggers Microsoft Visual Studio Tools for Containers   1.2 Develop, run, validate your ASP.NET Core applications in the target environment. F5 your application directly into a container with debugging, or CTRL + F5 to edit & refresh your app without having to rebuild the container. Node.js Tools   1.5.30526.3 Commit Hash:c09c81113bcbc86d57943fcdd67e82434263d61d Adds support for developing and debugging Node.js apps in Visual Studio NuGet Package Manager   5.11.0 NuGet Package Manager in Visual Studio. For more information about NuGet, visit https://docs.nuget.org/ ProjectServicesPackage Extension   1.0 ProjectServicesPackage Visual Studio Extension Detailed Info Razor (ASP.NET Core)   16.1.0.2122504+13c05c96ea6bdbe550bd88b0bf6cdddf8cde1725 Provides languages services for ASP.NET Core Razor. SQL Server Data Tools   16.0.62107.28140 Microsoft SQL Server Data Tools ToolWindowHostedEditor   1.0 Hosting json editor into a tool window TypeScript Tools   16.0.30526.2002 TypeScript Tools for Microsoft Visual Studio Visual Basic Tools   3.11.0-4.21403.6+ae1fff344d46976624e68ae17164e0607ab68b10 Visual Basic components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used. Visual F# Tools   16.11.0-beta.21322.6+488cc578cafcd261d90d748d8aaa7b8b091232dc Microsoft Visual F# Tools Visual Studio Code Debug Adapter Host Package   1.0 Interop layer for hosting Visual Studio Code debug adapters in Visual Studio Visual Studio Container Tools Extensions   1.0 View, manage, and diagnose containers within Visual Studio. Visual Studio Tools for Containers   1.0 Visual Studio Tools for Containers Visual Studio Tools for Kubernetes   1.0 Visual Studio Tools for Kubernetes  Nugets: Using the nugets: https://www.nuget.org/packages/Azure.Messaging.EventHubs/5.6.1 and https://www.nuget.org/packages/Azure.Messaging.EventHubs.Processor/5.6.1 Windows: OS Name Microsoft Windows 10 Pro Version 10.0.19041 Build 19041
Client	Event Hubs	[FEATURE REQ] Better support for batch processing in Event Hubs SDK	Library or service name. [Azure.Messaging.EventHubs] Is your feature request related to a problem? Please describe. (This issue is prompted by the following twitter thread) Batch-processing when receiving events in the new EventHubs SDK is much, much more difficult than in the previous SDK. When switching over I had to re-implement a lot of the functionality you used to get out of the box. My batching workflow. Just to sum up what sort of workflow I'm working with in regards to batching.  I would like to process messages in batches of n. If n messages haven't been received within 1sec, I'd like to batch process the events that are already lying around. (We have some data sources that are intermittent and we can't just leave messeages around because new ones aren't coming in)  I've followed the example here in regards to batch processing lead me to the following issues. Problem: Managing Partition State We have to manually manage state per-partition. You used to be able to have the SDK do that for you for batching cases. In the example listed above it seems pretty easy - you just add a ConcurrentDictionary with the partition id and whatever you want to store right? However let's take an example where it's not so simple.  Processor 1 acquires partition 1 and batches up 10 messages. This is below the processing limit. Processor 1 loses partition 1. The messages are still batched. At some later point in time, Processor 1 reacquires partition 1. The old messages that are left will then be reprocessed.  To avoid these sort of circumstances you'll need to listen to all of the PartitionClosing events and ensure that you synchronize your state with it. Problem: Heartbeat messages do not allow checkpointing. Next up - the case where I want to process my messages after n seconds without any activity. Luckily there's the heartbeat message for this. Unfortunately the heartbeat message doesn't allow us to do e.g. checkpointing or read lastEnqueuedTime, so I have to build up a structure that forces me to retrieve that from the last message I've enqueued. private async Task ProcessHeartbeatEvent(IProcessEventArgs args, string partitionId, ICheckpointer checkpointer) { var data = _partitionedMessageBatcher.Drain(partitionId); // If there is already no messages on the partition, this means we've gotten multiple // heartbeat messages in a row, and there's no need to send a list of empty // messages any further. if (data.Count == 0) {     return; }  // The updateCheckpoint we get from Azure Event Hub are coupled to the event. // When batching we always provide the updateCheckpoint from the latest event, except // for when we receive heartbeat messages, in which case we use the updateCheckPoint from the last `real` event var lastRealEvent = data.Last(); Func<CancellationToken, Task> lastUpdateCheckpointAsync = lastRealEvent.UpdateCheckpointAsync; var lastPartitionContext =     lastRealEvent         .Partition; // Use partitionContext from last event as well, as the heartbeat message doesn't have the correct properties such as LastEnqueuedTime   var eventData = data     .Select(args =>     {         Debug.Assert(args.Data != null,             `args.Data != null`); // Args with null data shouldn't make it into the batcher         return args.Data!;     })     .ToList();  Log.Debug(`Flushing {messageCount} messages due to heartbeat message`, data.Count); var receivedEventDataBatch =     new ReceivedEventDataBatch(lastPartitionContext, eventData, lastUpdateCheckpointAsync); await _processEvent(receivedEventDataBatch, checkpointer); } Perhaps this is because my codebase is shaped by the old SDK where checkpointing was done on a batch basis rather than as a function provided by each event received. Summing up   Batching is harder than it needs to be. I imagine this use-case is common and I would prefer if something was provided that helped you do batching, similar to the old-style SDK.   However I think in lieu of that, something that will help you manage partition state would be nice. I'm not quite sure how that would work however.   I would also like if you were able to call UpdateCheckpointAsync on a heartbeat message, and that would then checkpoint all the previous messages.   If nothing else, a more involved example in the documentation would be nice.
Client	Tables	[QUERY] Recommendations to replace IQueryable functionality?	Query/Question I'm looking at upgrading from older versions of the SDK, but I see that this version doesn't include IQueryable support. That's fine for simple queries, but I have a number of places in my code where we have something to the effect of: var query = CreateQuery<MyEntity>(); query = query.Where(e => e.PartitionKey == `whatever`);  if (startDate.HasValue) {     query = query.Where(e => e.CreatedDate >= startDate.Value); }  if (endDate.HasValue) {     query = query.Where(e => e.CreatedDate <= endDate.Value); }  var result = await query.ExecuteSegmentedAsync(); If I understand the new library correctly, the only way I could replicate this kind of code is to build the OData strings myself. Is there a better way to handle this? Would you consider including some kind of query builder, even if it's not based on IQueryable? Environment:  Name and version of the Library package used: Azure.Data.Tables 12.2.0 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): Azure Cloud Services, .NET Framework 4.7.2 IDE and version : Visual Studio
Client	Service Bus	[QUERY] Clarify behaviour for ServiceBus PrefetchCount with Sessions	Hi, When working with Sessions and MaxConcurrentSessions  is set to 1 along with PrefetchCount set to a big number, let's say 500. The processor is not configured for a specific session id, rather it randomly picks the next available session id in the pipe. Does the prefetch respects the sessions, taking into consideration balancing the load between multiple nodes? For example, let's say we have 500 message in the queue and 5 machines (nodes) each with a subscriber configured to be a session with max concurrent sessions 1 and prefetch count 500. The 500 message are grouped into 10 unique session ids (50 message per sessions id) What will happen? Does the first node prefetch all 500 message regardless of the session id which render the other machines useless and slow's down the whole process? I couldn't find docs on the matter and our quick & dirty field test was inconclusive. I would expect it to fail when trying to access session id's that does not belong to the machine but if the prefetch run before, it might lock all sessions to that machine (assume first run, no sessions bound to any machine) Since a lot of the behaviour occurs in the low level AMQP implementation it's hard to follow and understand just from looking at the source... Also bit related to #23704 Thanks!
Client	Event Hubs	[QUERY] Is there a way to set the batch size for an EventProcessorClient?	Query/Question Is there a way to set the batch size for an EventProcessorClient? I've been trying to figure it out as the remarks mention that events in the batch may be between 0 and a batch size? https://docs.microsoft.com/en-us/dotnet/api/azure.messaging.eventhubs.eventprocessorclient.onprocessingeventbatchasync?view=azure-dotnet#remarks Environment:  Name and version of the Library package used: Azure.Messaging.EventHubs.Processor v5.6.1 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): .NET 5 IDE and version : VS 16.11.2
Client	Azure.Core	[FEATURE REQ] Azure.Core.AccessToken should have a ToString() that returns the base64 token	Library or service name. Azure.Core.AccessToken Is your feature request related to a problem? Please describe. Add a tostring, so that it can more easily be used in applications like PowerShell without having to call the .token member instead. This will make pipelines and whatnot work much more efficiently.
Client	Extensions	[FEATURE REQ] Support for customizing load process of SecretProperties	Azure.Extensions.AspNetCore.Configuration.Secrets Currently, when using the AzureKeyVaultConfigurationProvider, it always loads all secrets from the Azure Key Vault. Sometimes, multiple services are using the same Azure Key Vault and only one secret is needed. By allowing to customize the loading process for the secrets properties, it's possible to load only a specific secret or a subset of secrets. In conjunction with JsonKeyVaultSecretManager is very easy to have one secret with JSON document, where all secrets for a particular service are stored.
Client	Event Hubs	[BUG] Event Hub - EventProcessorClient - partitions are changing very often	Describe the bug We use EventProcessorClient to consume events from the event hub. The event processing runs on 8 instances and event hub has 32 partitions. I can see in logs that partitions are changing the processing instances very often. One partition change the processing instance 17 times per hour. There is no reason to change the instance as the amount of processing instances is stable all the time. I observed the behavior in version 5.4.1. I updated to 5.6.1 as there were some bug fixes related to balancing but the issue is not fixed. Expected behavior Partitions should stay on the same processing instance after initial load balancing. Actual behavior (include Exception or Stack Trace) See description. To Reproduce See description. Sample of consumer: var clientOptions = new EventProcessorClientOptions() {     MaximumWaitTime = TimeSpan.FromMilliseconds(150),     LoadBalancingStrategy = LoadBalancingStrategy.Greedy };  var eventProcessorClient = new EventProcessorClient(blobContainerClient,                 consumerGroupName, eventHubConnectionString, eventHubOptions.HubName, clientOptions); We use the Greedy strategy to reduce delays in processing during service restarts. Environment:  Azure.Messaging.EventHubs.Processor 5.6.1 .NET 5/Linux container running in Kubernetes We use premium BLOB storage for the checkpoint store.
Client	Event Hubs	Azure Event Hub - How to consume events parallelly using the official SDK?	Describe the bug I've setup the following test:  Created a azure event hub with 10 partitions Created a single storage account Created a single consumer group Filled the hub with 10k messages Created 2 containers (on AKS) that would basically consume those events (using the same consumer group) and log them azure application insights.  Expected behavior Running traces | where message == `Event received` | summarize count() by bin(timestamp,1s), cloud_RoleInstance | render timechart   I was expecting to see something like:  Actual behavior What is the actual behavior?  (red line is pod 1, blue line is pod 2) this is a 3x 10k run, to eliminate the `pod was not warmed up` variable To Reproduce protected override async Task ExecuteAsync(CancellationToken stoppingToken) {     _processor = new EventProcessorClient(_storageClient, _consumerGroup, _hubConnection, _eventHubName);     _processor.ProcessEventAsync += ProcessEventHandler;     _processor.ProcessErrorAsync += ProcessErrorHandler;      // Start the processing     await _processor.StartProcessingAsync(stoppingToken); }  internal async Task ProcessEventHandler(ProcessEventArgs eventArgs) {     _logger.LogTelemetry(`Event received`);      await eventArgs.UpdateCheckpointAsync(eventArgs.CancellationToken); } Environment:  `Azure.Messaging.EventHubs` Version=`5.6.1` `Azure.Messaging.EventHubs.Processor` Version=`5.6.1` Pod image: mcr.microsoft.com/dotnet/runtime:5.0 AKS, Kube version 1.19.7
Client	KeyVault	Sign JWT token using Azure Key Vault	Hi. Apologies if it's bad form to link straight to my StackOverflow question - I thought I'd save on the duplication. I'm happy to copy across the content if that's preferred. Basically, I'm having trouble signing a JWT via Azure Key Vault. It works fine if I don't use Azure Key Vault. I put code example and full description in the Stackovlow question... https://stackoverflow.com/questions/69117288/sign-jwt-token-using-azure-key-vault Environment:  Name and version of the Library package used: Azure.Security.KeyVault.Keys 4.2.0 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): LINQPad 6 (which I believe is .NET 5 runtime) IDE and version : LINQPad 6
Client	Storage	[BUG] Memory leak when uploading large file (~500mb) to blob storage from Blazor WASM	Describe the bug Following the advice on the ASP.NET Core Blazor file uploads, passing a stream from IBrowserFile.OpenReadStream to BlobClient.UploadAsync results in the file being loaded into memory and remains even after upload process was completed. Expected behavior Memory usage on page should return to pre-upload levels. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Check memory heap using browser's memory profiler tool Upload a large file on Blazor WASM that uses Azure.Storage.Blobs SDK to upload to Blob Storage Check memory heap again. The heap usage remains at a high level, relative to the size of the file uploaded.  Environment:  Azure.Storage.Blobs 12.9.1 Blazor WASM .NET 5
Client	KeyVault	[QUERY]KeyVault secrets caching- using keyvaultproxy	Query/Question I am trying cache the response from keyvault sdk. I understand keyvaultproxy in the samples provide an option to cache the response in  HttpPipelinePolicy.  Can I use keyvaultproxy reference for my production grade application. since the keyvault proxy reference says it is just an sample. Environment:  Azure.Security.KeyVault.Secrets;[4.2.0] / AzureSamples.Security.KeyVault.Proxy Azure AppService .NET Framework 4.8 Visual Studio 2019
Client	Event Grid	Azure Messaging Eventgrid (4.6.0) issue with JObject in data property	We have been using Microsoft.Azure.Eventgrid 3.2.x package for quite a while now in our function projects to publish messages. When publishing, we use a JObject to fill the data property of the EventGridEvent, works like a charm as shown in the following example var data = new JObject { {`fileId`, fileId}, {`fileName`, fileName} }; and later on this JObject is used as var eventGridEvent = new EventGridEvent( Guid.NewGuid().ToString(), subject, **someJObject**, eventType, DateTime.Now, `1.0` ); Last week we saw that this nuget package has been deprecated and we needed to move to the new Azure Messaging Eventgrid 4.6.x nuget package so we did. When using empty JObjects in some cases (just sending a notification that something is ready for processing), we also use the above code, which breaks (new method signature isn't reflected in above example). In run time, we get the error: The collection type 'Newtonsoft.Json.Linq.JObject' is not supported. When we do some modifications to use a json string instead, all quotation marks get translated to unicode formatting (even when specifying the formatter to None). The Microsoft Docs example to use objects and serialize them might be an option, but requires quite some code changes. In the end, this left us in a non working situation on production, where we had to rollback to the old package. Any idea if JObject support for the data element will be back into support? Is this just some bug that needs to be resolved, or is this by design? Awaiting your responses.
Client	Service Bus	[QUERY] What is the replacement for ServiceBus' ExtractActivity?	Query/Question I'm in the process of upgrading code that has a dependency on Microsoft.Azure.ServiceBus (Track 1) to Azure.Messaging.ServiceBus (Track 2). It seems that there is no equivalent for MessageDiagnosticsExtensions.ExtractActivity What is it replaced with? Where can I find upgrade documentation? I've looked into https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Azure.Messaging.ServiceBus/MigrationGuide.md and can't find anything there.
Client	Event Hubs	[BUG] Incompatibility between Microsoft.Spark and Azure.Messaging.EventHubs	Describe the bug Please provide the description of issue you're seeing.  An error occurs when we try to publish an application containing both the two following dependencies:  Microsoft.Spark Azure.Messaging.EventHubs  It is possible to compile the project, but an error occurs during the publication phase (Publish).  Expected behavior What is the expected behavior?  The `Publish` operation should work.  Actual behavior (include Exception or Stack Trace) What is the actual behavior?  The 'Publish' operation fails with the following error message: ``` Publish has encountered an error. Publish has encountered an error. We were unable to determine the cause of the error. Check the output log for more details. A diagnostic log has been written to the following location: `C:\Users...\AppData\Local\Temp\tmp6A08.tmp` ```  To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Create a new .NET 5 project (Console) In the 'Solution Explorer' tab, right click on 'Packages' and 'Manage Nuget packages' Add the two dependencies: `Microsoft.Spark` and `Azure.Messaging.EventHubs` Try to publish the application --> it will fail whatever the parameters that you use  Environment:  Name and version of the Library package used: [e.g. Azure.Storage.Blobs 12.2.0]    Azure.Messaging.EventHubs 5.4.0 Microsoft.Spark 2.0.0    Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8]    Windows 10 .NET 5    IDE and version : [e.g. Visual Studio 16.3]    Visual studio 2019
Client	Service Bus	[BUG] Azure ServiceBusReceiver maxWaitTime doesn't always work	Describe the bug Azure ServiceBusReceiver maxWaitTime isn't always respected. Expected behavior When the maxWaitTime is set, the receiver will return a result no matter what upon expiration of the wait time. Actual behavior (include Exception or Stack Trace) Occasionally the receiver goes past the wait time before returning a result. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) var sw = new Stopwatch(); sw.Restart(); var message = await messageReceiver.ReceiveMessageAsync(TimeSpan.FromSeconds(30)); _logger.LogInformation($`Message Received ({message != null}) in {sw.Elapsed.TotalSeconds}s`);  Environment:  Azure.Messaging.ServiceBus` Version=`7.2.1` docker container: mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim VS 2019
Client	KeyVault	Cannot control HttpClient disposal in KeyVaultClient	The constructor at                azure-sdk-for-net/sdk/keyvault/Microsoft.Azure.KeyVault/src/Customized/KeyVaultClient.cs                    Line 62       in       882eab0                                                 public KeyVaultClient(KeyVaultCredential credential, HttpClient httpClient)                     accepts a KeyVaultCredential (based on ServiceClientCredentials) and an HttpClient. For our use, this is valuable in that it allows us to manage the HttpClient externally as a singleton (and avoid the HttpClient.Dispose() antipattern). So, this constructor clones the credential and calls the chained constructor at                azure-sdk-for-net/sdk/keyvault/Microsoft.Azure.KeyVault/src/Generated/KeyVaultClient.cs                    Line 111       in       882eab0                                                 public KeyVaultClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)                     (at least I believe it does, this is the closest constructor overload that accepts a KeyVaultCredential or ancestor). This constructor calls the chained constructor accepting just handlers at                azure-sdk-for-net/sdk/keyvault/Microsoft.Azure.KeyVault/src/Generated/KeyVaultClient.cs                    Line 80       in       882eab0                                                 protected KeyVaultClient(params DelegatingHandler[] handlers) : base(handlers)                     This constructor calls the chained base constructor at                azure-sdk-for-net/sdk/mgmtcommon/ClientRuntime/ClientRuntime/ServiceClient.cs                    Line 301       in       882eab0                                                 protected ServiceClient(params DelegatingHandler[] handlers)                     Finally, this constructor calls the chained constructor at                azure-sdk-for-net/sdk/mgmtcommon/ClientRuntime/ClientRuntime/ServiceClient.cs                    Line 315       in       882eab0                                                 private ServiceClient(HttpClient serviceHttpClient, HttpClientHandler rootHandler, bool disposeHttpClient, params DelegatingHandler[] delHandlers)                     where the initialization work gets done - note that disposeHttpClient defaults to true here. I believe that KeyVaultClient (or any ServiceClient implementor) that exposes an HttpClient parameter in its constructor needs to also expose a disposeHttpClient property, and use it to control the ServiceClient instantiation via                azure-sdk-for-net/sdk/mgmtcommon/ClientRuntime/ClientRuntime/ServiceClient.cs                    Line 315       in       882eab0                                                 private ServiceClient(HttpClient serviceHttpClient, HttpClientHandler rootHandler, bool disposeHttpClient, params DelegatingHandler[] delHandlers)                     I also believe that ServiceClient ought to have the ability to control HttpClient creation via factory, but that's a topic for another day.
Client	Storage	Azure.Storage.Queues proxy config	Query/Question There was an option with the previous library version to implement a proxy https://stackoverflow.com/questions/55927663/connect-to-azure-storage-queue-behind-proxy but it doesn't seem to be possible with the latest one, is there any guidance on this? Environment:  Azure.Storage.Queues, 12.7.0 dotnet 5 Visual Studio 16.11.2
Client	Tables	[BUG] TableClient.DeleteAsync returns while the table still can be queried	Describe the bug TableClient.DeleteAsync returns successfully while the table still can be queried shortly after. Expected behavior After successfully awaiting TableClient.DeleteAsync, any calls to QueryAsync are supposed to fail with ErrorCode == TableErrorCode.TableNotFound. Actual behavior (include Exception or Stack Trace) About to delete tables... [aTable3] Success after 1 attempts [aTable0] Success after 1 attempts [aTable4] Success after 1 attempts [aTable5] Success after 1 attempts [aTable1] Success after 1 attempts [aTable2] Success after 1 attempts All tables have been deleted. About to create tables... All tables have been created. About to delete tables... [aTable0] Success after 1 attempts [aTable3] Success after 1 attempts [aTable4] Success after 1 attempts [aTable5] Success after 1 attempts [aTable1] Success after 1 attempts [aTable2] Success after 2 attempts At least one table exists, while all should have been deleted To Reproduce Run the attached RecreateTableRepro.zip after having provided a valid connection string to a Table Storage. Environment: Windows 10 Pro, .NET 5.0/.NET 4.8
Client	Search	[FEATURE REQ] Azure Search Working with Complex Collections	Our data structure is similar to HotelId 1 example in the link https://docs.microsoft.com/en-us/azure/search/search-howto-complex-data-types Our requirement is as follows: Input: City = New York, StateProvince = NY, BaseRate = $100 Select fields: HotelId, HotelName, Description, Tags, Address, Rooms Filter: Only rooms where BaseRate is less than or equal to Input rate and Address City and State matches input values. In this example, it should only select the first room from Rooms, not all Rooms. Desired output: { `HotelId`: `1`, `HotelName`: `Secret Point Motel`, `Description`: `Ideally located on the main commercial artery of the city in the heart of New York.`, `Tags`: [`Free wifi`, `on-site parking`, `indoor pool`, `continental breakfast`] `Address`: {     `StreetAddress`: `677 5th Ave`,     `City`: `New York`,     `StateProvince`: `NY`   }, `Rooms`: [     {       `Description`: `Budget Room, 1 Queen Bed (Cityside)`,       `RoomNumber`: 1105,       `BaseRate`: 96.99,     }   ] }  Currently, the .NET Client Library, as well as REST API, doesn't support this. This might be how the service is designed currently and so wanted to draw the attention of the larger group that this would be helpful for a lot of devs like me. In SQL query or Cosmos Db query, I can get the desired result by joining and selecting a particular subelement. I had posted this even on Stack Overflow at https://stackoverflow.com/questions/66553125/azure-search-working-with-complex-collections and also on the UserVoice site which is now taken offline. Any help or direction on how to write a query for this or any pointers would be welcome.
Client	Schema Registry	Schema registry corrupt	library: Azure.Data.SchemaRegistry.ApacheAvro(version 1.0.0-beta.2) While using the schema registry avro extension, I noticed that SchemaRegistryAvroObjectSerializer(with auto-register-schema=True) accepts any schema groups and Event-Hub resource, which sometimes when users have misconfigured, it can register new version on a different resources from other product environments. It's important to restrict the auto register feature, only if the producer Event-Hub resource is the same the Serializer endpoint when registering new Avro schemas.
Client	Service Bus	[BUG] Azure ServiceBus The UTC time represented when the offset is applied must be between year 0 and 10,000. (Parameter 'offset')	Describe the bug When receiving a message from the service bus after updating from Azure.Messaging.ServiceBus 7.1.2 to 7.2.x, throws the exception: The UTC time represented when the offset is applied must be between year 0 and 10,000. (Parameter 'offset') Expected behavior Message should be received and processed normally. Actual behavior (include Exception or Stack Trace) The ServiceBusProcessor throws the error: The UTC time represented when the offset is applied must be between year 0 and 10,000. (Parameter 'offset')    at System.DateTimeOffset.ValidateDate(DateTime dateTime, TimeSpan offset) in /_/src/libraries/System.Private.CoreLib/src/System/DateTimeOffset.cs:line 780    at System.DateTimeOffset..ctor(DateTime dateTime) in /_/src/libraries/System.Private.CoreLib/src/System/DateTimeOffset.cs:line 78    at Azure.Messaging.ServiceBus.Amqp.AmqpMessageConverter.AmqpMessageToSBMessage(AmqpMessage amqpMessage, Boolean isPeeked) in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Amqp/AmqpMessageConverter.cs:line 334    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<ReceiveMessagesAsyncInternal>d__39.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Amqp/AmqpReceiver.cs:line 397    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<ReceiveMessagesAsyncInternal>d__39.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Amqp/AmqpReceiver.cs:line 416    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 173    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 150    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 551    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<>c.<<ReceiveMessagesAsync>b__38_0>d.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Amqp/AmqpReceiver.cs:line 285    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 173    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 150    at System.Threading.Tasks.ValueTask`1.get_Result() in /_/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/ValueTask.cs:line 789    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ConfiguredValueTaskAwaitable.cs:line 156    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<RunOperation>d__21`2.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Primitives/ServiceBusRetryPolicy.cs:line 144    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy.<RunOperation>d__21`2.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Primitives/ServiceBusRetryPolicy.cs:line 159    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 173    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 150    at System.Threading.Tasks.ValueTask`1.get_Result() in /_/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/ValueTask.cs:line 789    at System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ConfiguredValueTaskAwaitable.cs:line 156    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver.<ReceiveMessagesAsync>d__38.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Amqp/AmqpReceiver.cs:line 282    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 173    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 150    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 551    at Azure.Messaging.ServiceBus.ServiceBusReceiver.<ReceiveMessagesAsync>d__38.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Receiver/ServiceBusReceiver.cs:line 269    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs:line 56    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs:line 173    at Azure.Messaging.ServiceBus.ReceiverManager.<ReceiveAndProcessMessagesAsync>d__14.MoveNext() in /_/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ReceiverManager.cs:line 88  To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) I have a snippet of a background worker that reproduces the error for me:  public class Worker : BackgroundService     {         private ServiceBusProcessor _processor;          public Worker()         {         }          protected override async Task ExecuteAsync(CancellationToken stoppingToken)         {             var client = new ServiceBusClient(`<insertyourconnectionstringhere>`);              _processor = client.CreateProcessor(`topic`, `subscription`);              _processor.ProcessMessageAsync += ProcessMessageAsync;             _processor.ProcessErrorAsync += ProcessErrorAsync;              await _processor.StartProcessingAsync(stoppingToken);         }          private Task ProcessErrorAsync(ProcessErrorEventArgs arg)         {             return Task.CompletedTask;         }          private Task ProcessMessageAsync(ProcessMessageEventArgs arg)         {             // perform your business logic to process messages              return Task.CompletedTask;         }          public Task StopAsync(CancellationToken cancellationToken)         {             return _processor.CloseAsync(cancellationToken: cancellationToken);         }     }       Environment:  Package version: Azure.Messaging.ServiceBus@7.2.1 OS: Windows 10 SDK: 5.0.400 Visual Studio 17.0.0 Preview 3.1  Additional Info In case it will help, I am in UTC−05:00.
Client	Service Bus	[BUG] Azure.Messaging.ServiceBus.ServiceBusException at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<RenewMessageLockInternalAsync>d__58.MoveNext	Describe the bug We have seen in logs an exception: Azure.Messaging.ServiceBus.ServiceBusException at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<RenewMessageLockInternalAsync>d__58.MoveNext Message: The lock supplied is invalid. Either the lock expired, or the message has already been removed from the queue. Reference:1287b55c-c3fc-4bef-990d-0cc3cbe8e26b, TrackingId:d4212684-5308-4d51-b3cb-07013a93de6f_B31, SystemTracker:messaginglivewesb:topic:claim~15|ossconsumer, Timestamp:2021-08-19T07:55:36 (MessageLockLost) We use the ServiceBusProcessor to receive messages from subscription. Expected behavior Lock should be renewed before it is lost. Actual behavior (include Exception or Stack Trace) Exception is thrown and it is handled by the ServiceBusProcessor error handler. {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<RenewMessageLockInternalAsync>d__58.MoveNext`,`level`:0,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:1,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`,`level`:2,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`,`level`:3,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult`,`level`:4,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<>c+<<RenewMessageLockAsync>b__57_0>d.MoveNext`,`level`:5,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:6,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`,`level`:7,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.ServiceBusRetryPolicy+<RunOperation>d__21`2.MoveNext`,`level`:8,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:9,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.ServiceBusRetryPolicy+<RunOperation>d__21`2.MoveNext`,`level`:10,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:11,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`,`level`:12,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`,`level`:13,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Threading.Tasks.ValueTask`1.get_Result`,`level`:14,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1+ConfiguredValueTaskAwaiter.GetResult`,`level`:15,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<RenewMessageLockAsync>d__57.MoveNext`,`level`:16,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:17,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`,`level`:18,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`,`level`:19,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult`,`level`:20,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.ServiceBusReceiver+<RenewMessageLockAsync>d__62.MoveNext`,`level`:21,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:22,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`,`level`:23,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification`,`level`:24,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult`,`level`:25,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.ServiceBusReceiver+<RenewMessageLockAsync>d__61.MoveNext`,`level`:26,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw`,`level`:27,`line`:0}, {`assembly`:`System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e`,`method`:`System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess`,`level`:28,`line`:0}, {`assembly`:`Azure.Messaging.ServiceBus, Version=7.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`,`method`:`Azure.Messaging.ServiceBus.ReceiverManager+<RenewMessageLock>d__18.MoveNext`,`level`:29,`line`:0}  To Reproduce Issue is random. I have seen it just once. Environment:  [Azure.Messaging.ServiceBus 7.2.1.0] Runs in Azure Kubernetes cluster in Linux based .NET 5 docker image
Mgmt	ARM	[BUG] ResourceManager - SubscriptionClient.Subscriptions.ListAsync() does not return Tag data	Describe the bug SubscriptionClient.Subscriptions.ListAsync() does not return Tag data, but according to docs page, it should. When requesting a single subscription, Tag values are returned as expected. I am not sure if this is an issue with the SDK or with the Azure API itself. Expected behavior Tag values should be returned. Actual behavior (include Exception or Stack Trace) Tag is always null, also if subscription has several tags. To Reproduce Code to request a list of subscriptions - subscription.Tags is always null:  // Query subscription list  using (var client = new SubscriptionClient(credentials))  {   IPage<Subscription> subscriptionsPage = await client.Subscriptions.ListAsync().ConfigureAwait(false);   while (true)   {    foreach (var subscription in subscriptionsPage)    {  When requesting a single subscription, subscription.Tags is returned as expected:  subscription = await client.Subscriptions.GetAsync(subscriptionGuid).ConfigureAwait(false);  Environment: Microsoft.Azure.Management.ResourceManager 3.14.0-preview
Client	Service Bus	[BUG] Microsoft.Azure.ServiceBus is restricted to namespaces with a fully quantified domain.	Describe the bug This is part way between a bug and a feature, so feel free to choose which. Currently, the Microsoft.Azure.ServiceBus client mandates that the namespace endpoint includes a . in it.  Therefore ensuring that only `real` domains can be used.  This precludes using something that is hosted on localhost.  This seems like something that shouldn't be there as locally contacting servicebus should be ok. Expected behavior A servicebus namespace can be specified without a . e.g. localhost Actual behavior (include Exception or Stack Trace) An exception is thrown on startup. To Reproduce Have a namespace that is localhost, start the client and you'll see it fail. Environment: All environment, there's nothing specific here. Notes: The line of code that does this is: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Microsoft.Azure.ServiceBus/src/ServiceBusConnectionStringBuilder.cs#L174 This restriction is not in Azure.Messaging.ServiceBus
Client	Synapse	[Synapse] [Spark] Feature To Specify The Spark Config Attributes In SparkSessionOptions	Currently the SparkSessionOptions does not have the feature to pass Spark config attributes when creating the Spark Session. But actual Synapse REST API allows that. Is this a feature that is already available in the SDK. The `Configuration` attribute in SparkSessionOptions is read -only.
Mgmt	Network - DNS	[QUERY] If the creation record is not in the dnsZone/activity logs, does it mean it failed?	Query/Question I do not see the creation record in the activity logs on Portal, but I see it was deleted successfully. How does that work? Is there any other way to check whether the creation succeeded or encountered any kind of issue? The operation id of the delete is: b9bd814f-b344-4e42-abda-952591d07528
Service	Service Bus	[QUERY] Azure Service Bus Sender Throttling	Query/Question I'm in the process of upgrading some client code from MS.Azure.ServiceBus to Azure.Messaging.ServiceBus. The code surrounding the previous SDK added a throttling behaviour of 5000 msg/s for all tiers. It has been claimed they have seen effects in the past on the premium tier even with 8 mu to be throttled when they surpassed that rate despite CPU and memory being fairly stable and below 50%. Now I wonder if I can replace the hard coded value with some better more dynamic behaviour or if this code is even still needed. If you could share some insights / ideas I would highly appreciate it Environment:  Name and version of the Library package used: Microsoft. Azure. ServiceBus 5.x (latest) Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): net5 IDE and version : [e.g. Visual Studio 16.3]
Client	Azure.Core	[Question] Is there any way to override the HttpMessage#CancellationToken?	Question I am trying to add a custom timeout HttpPipelinePolicy by leveraging Polly's Policy.TimeoutAsync policy but found out that there is no way to override the Cancellation token in the HttpMessage nor have the delegate (ProcessNextAsync) to honor the cancellation token generated by the Timeout policy, hence there is no way to use the Optimistic timeout strategy. Basically the problem is the same as https://stackoverflow.com/questions/55459962/how-to-enable-timeout-policy-with-polly Ideally if there is a way to reset the Cancellation token in the pipeline to the one that generated by the timeout policy then this should work. Alternatively, is there any existing timeout HttpPipelinePolicy provided by azure sdk that I can easily plug into random ClientOptions then it would also work but I just couldn't find any. Environment:  Azure.Core v1.17
Mgmt	Consumption - UsageDetailsAndExport	[BUG] ConsumptionManagementClient is using outdated apiVersion making request to fail	Describe the bug ConsumptionManagementClient is using outdated apiVersion (2018-01-31)for your latest release making request failing with message : Subscription scope usage is not supported for current api version. Please use api version after 2019-10-01 Expected behavior using newer api version so request will work Environment:  Name and version of the Library package used: Microsoft.Azure.Management.Consumption 3.0.2 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): Windows 10 .NET Framework 4.8 IDE and version : VisualStudio 2017 (15.9.25)
Client	KeyVault	Lacking of interface for SecretClient	Query/Question Hi team, We are migrating from the legacy KeyVault client to the new SecretClient and found out that, unlike the IKeyVaultClient, the new SecretClient doesn't have any abstraction which makes it pretty hard to unit-test our components that depends on it. Is there any plan to add an interface in the future? If not, what would be the right approach to unit-test the components that directly depends on the SecretClient? Thanks.
Client	Search	[BUG] ComplexType field with Facets throwing Azure.Core.dll errors during Document.Search	With this (partial) index in Azure Cognitive Search:     {       `name`: `tagdata`,       `type`: `Collection(Edm.ComplexType)`,       `analyzer`: null,       `synonymMaps`: [],       `fields`: [         {           `name`: `tagid`,           `type`: `Edm.Int32`,           `facetable`: true,           `filterable`: true,           `retrievable`: true,           `sortable`: false,           `analyzer`: null,           `indexAnalyzer`: null,           `searchAnalyzer`: null,           `synonymMaps`: [],           `fields`: []         },         {           `name`: `tag`,           `type`: `Edm.String`,           `facetable`: true,           `filterable`: true,           `key`: false,           `retrievable`: true,           `searchable`: false,           `sortable`: false,           `analyzer`: null,           `indexAnalyzer`: null,           `searchAnalyzer`: null,           `synonymMaps`: [],           `fields`: []         }       ]     },  And a varchar(2000, null) field in SQL Server that contains the following (along with some null rows): {`tagdata`:[{`tagid`:200,`tag`:`text1`},{`tagid`:84,`tag`:`text2`},{`tagid`:1785,`tag`:`text3`} We are getting random errors with this code: SearchResults<SearchDocument> response = client.Search<SearchDocument>(`test`, null); We cannot step into the code, they are being thrown on that line. The majority of the errors (tens or hundreds of them) are like this: Exception thrown: 'System.Text.Json.JsonException' in Azure.Core.dll Exception thrown: 'System.Text.Json.JsonException' in System.Text.Json.dll Exception thrown: 'System.Text.Json.JsonException' in System.Text.Json.dll Exception thrown: 'System.Text.Json.JsonException' in Azure.Core.dll Exception thrown: 'System.Text.Json.JsonException' in System.Text.Json.dll Exception thrown: 'System.Text.Json.JsonException' in System.Text.Json.dll Exception thrown: 'System.Text.Json.JsonException' in Azure.Core.dll Exception thrown: 'System.Text.Json.JsonException' in System.Text.Json.dll  I also have seen a few `error working with GeoJSON`  - this field has nothing to do with GeoJSON but that doesn't reliably throw an error. This has got to be a bug? We've tried everything, the errors stop if we remove that field from the index and rebuild it.
Client	Service Bus	[BUG] ServiceBusSender.SendMessageAsync erratic performance	Describe the bug Application Insights is reporting large swings in 95th percentile timing for ServiceBusSender.Send Expected behavior Consistent sub-second timing for publishing a message Actual behavior (include Exception or Stack Trace) 95th percentile is reporting peaks at or above 1.5 seconds To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) public interface ICloudEventGateway {     Task Publish(CloudEvent cloudEvent, CancellationToken cancellationToken); }  public class AzureServiceBusCloudEventGateway : ICloudEventGateway {   private readonly Configuration.CloudEvents _config;   private readonly ServiceBusClient _client;   private readonly Dictionary<string, ServiceBusSender> _senderDictionary;    public AzureServiceBusCloudEventGateway(       IOptions<Configuration.CloudEvents> configOptions   )   {       _config = configOptions.Value;       _client = new ServiceBusClient(           _config.ConnectionString,           new ServiceBusClientOptions           {               TransportType = ServiceBusTransportType.AmqpWebSockets,           }       );        _senderDictionary = new Dictionary<string, ServiceBusSender>();        Lookups.CloudEvents.Collection.ForEach(ce =>       {           _senderDictionary.Add(ce.Type, _client.CreateSender(ce.Topic));       });   }    public async Task Publish(CloudEvent cloudEvent, CancellationToken cancellationToken)   {       var cloudEventConfig = Lookups.CloudEvents.Collection           .Where(ce => ce.Type.Equals(cloudEvent.Type, System.StringComparison.OrdinalIgnoreCase))           .FirstOrDefault();        if (cloudEventConfig is null)       {           throw new System.ArgumentNullException(nameof(Lookups.CloudEvents.CloudEventConfig), $`Configuration for [{cloudEvent.Type}] not found.`);       }        var sender = _senderDictionary[cloudEventConfig.Type];        var json = new JsonEventFormatter().EncodeStructuredEvent(cloudEvent, out var contentType);        var message = new ServiceBusMessage(json)       {           ContentType = contentType.MediaType,           CorrelationId = System.Guid.NewGuid().ToString(),           MessageId = cloudEvent.Id,           Subject = cloudEvent.Type,       };        await sender.SendMessageAsync(message, cancellationToken);   } } services.AddSingleton<Gateways.ICloudEventGateway, Gateways.AzureServiceBusCloudEventGateway>();  CPU and Memory are holding steady Environment:  Name and version of the Library package used: Azure.Messaging.ServiceBus@7.1.2 Hosting platform or OS and .NET runtime version: docker mcr.microsoft.com/dotnet/aspnet:5.0 IDE and version : VS Code 1.59.0
Client	KeyVault	[QUERY]KeyVault Certificate/Secret Client- Response for expired certificate	Query/Question What will be the response from Certificate /Secret client when a request is issued for expired certificate? Consider the certificate in keyvault is expired already and request is made for the certificate. Environment:  Azure.security.keyvault.certificate 4.2.0 Azure AppService  .NET Framework 4.8] Visual Studio 2019
Mgmt	SQL	[QUERY] Is there a way to get Sql Database connection strings with the SDK?	Query/Question Is there a way to get Sql Database connection strings with the SDK? I see that I can get SQL Server Keys with the SDK, but I'm not seeing any properties or methods that would get me the SQL DB connection string. Is this only available through the portal? Environment:  Name and version of the Library package used: [Microsoft.Azure.Management.Fluent 1.37.0] Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [.NET Core 3.1] IDE and version : [Visual Studio 16.4]
Client	Storage	[QUERY] Unable to copy to ShareFileClient from BlockBlobClient with URI	Query I'm attempting to make (what I think should be) a rudimentary copy: An existing block blob to a new share file. My understanding is the API should be capable of performing this purely on the storage account. But I cannot for the life of me work this out. My simplified code: var blobClient = new BlockBlobClient(storageAccountDetails, `temp`, blobName);  var shareClient = new ShareClient(storageAccountDetails, shareName); await shareClient.CreateIfNotExistsAsync(); var fileClient = shareClient.GetRootDirectoryClient().GetFileClient(fileName);  await fileClient.StartCopyAsync(blobClient.Uri); This occurs after the block blob is committed, and confirmed it exists. The same connection string are used for blob and share operations. But upon attempting to start the copy, it throws `The specified resource does not exist` for the sourceUri. Is this not possible? Am I missing something? Environment:  Name and version of the Library package used: Azure.Storage.Blobs 12.9.1, Azure.Storage.Files.Shares 12.6.0 Hosting platform: Windows 10 .NET Core 3.1 IDE and version : Visual Studio 16.10.4
Client	CodeGen	How to view raw request uri and content before sending (for debuging)	I am debugging a few endpoints and I would like to view the request content (json).  For the life of me, I cannot seem to figure out how to do this.  I am most interested in looking at the Request content. Sorry I meant to post this to autorest.csharp,  This is for a C# generated client.
Client	Service Bus	MaxAutoLockRenewalDuration is not working for Azure Service Bus	MaxAutoLockRenewalDuration is not working on the ServiceBusProcessor. I have a queue which is configured as lock duration 5 min, and running two concurrent listeners for the queue, Message processing will take more than 5min(assume that it takes 8min),then lock renewal should happen automatically but message is available for the other consumer/listener after 5 min. code sample to configure ServiceBusProcessor       public void ReceiveMessages()     {                           var client =  CreateQueueClient(`managedQueue`);         var serviceBusProcessorOptions = new  ServiceBusProcessorOptions         {             MaxConcurrentCalls = 2,             AutoCompleteMessages = false,             MaxAutoLockRenewalDuration = new TimeSpan(0, 10, 0),         };         var proc = client.CreateProcessor(`managedQueue`, options: serviceBusProcessorOptions);         proc.ProcessMessageAsync += MessageHandler;         proc.ProcessErrorAsync += ErrorHandler;         // start processing          proc.StartProcessingAsync().GetAwaiter().GetResult();           }  Expected behavior as per the documentation message should be auto renewal after message lock duration expires Doc:  // Summary: //     Gets or sets the maximum duration within which the lock will be renewed automatically. //     This value should be greater than the longest message lock duration; for example, //     the LockDuration Property. Actual behavior (include Exception or Stack Trace) auto renewal not happening and message is available for the other consumer.  Name and version of the Library package: Azure.Messaging.ServiceBus (2.7.2)  Can please any one help me regarding this
Client	Service Bus	[BUG] : Not able to insert messages in a Service bus queue after reading message from the same queue using ServiceBusClient defined methods	Describe the bug We have use cases like read the messages from the service bus queue and then insert different messages into the same queue But unfortunately, we were not able to insert messages in a Service bus queue after reading a message from the same queue using  ServiceBusClient defined methods Expected behavior ServiceBusClient should insert messages into the queue once we execute the SendMessagesAsync/SendMessageAsync Actual behavior (include Exception or Stack Trace) Immediately not inserting messages into the service bus queue. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) class Program  {   static string connectionString = `Pass_service_bus_connectionstring`;   static string QueueName = `queue_name`;   static async Task Main(string[] args)   {    ////1.Reading messages from the queue    //// Create  service bus client    var sbc = new ServiceBusClient(connectionString);    var receiver = sbc.CreateReceiver(QueueName, new ServiceBusReceiverOptions() { ReceiveMode = ServiceBusReceiveMode.ReceiveAndDelete });    ////Try to read messages from the queue using receiver    var result = await receiver.ReceiveMessagesAsync(maxMessages: 10);     //// 2. Sending messages to the queue.    var sbc1 = new ServiceBusClient(connectionString);    var sender = sbc1.CreateSender(QueueName);    //// Try to send single message    await sender.SendMessageAsync(new ServiceBusMessage(`Test`), default);    var messages = new List<ServiceBusMessage>() { new ServiceBusMessage(`Test2`), new ServiceBusMessage(`Test3`) };    /// Try to send multiple messages     await sender.SendMessagesAsync(messages, default).ContinueWith(_ =>     {      });   }  } Environment:  Name and version of the Library package used: [Azure.Messaging.ServiceBus 7.2.1/7.2.0] Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): Runtime Environment: OS Name:     Windows OS Version:  10.0.19043 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\5.0.400-preview.21328.4\  Host (useful for support): Version: 5.0.8 Commit:  35964c9215 .NET SDKs installed: 3.1.411 [C:\Program Files\dotnet\sdk] 5.0.205 [C:\Program Files\dotnet\sdk] 5.0.301 [C:\Program Files\dotnet\sdk] 5.0.302 [C:\Program Files\dotnet\sdk] 5.0.400-preview.21328.4 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.17 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.17 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.17 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.8 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  IDE and version : [Microsoft Visual Studio Enterprise 2019 Version 16.10.3] ConsoleApp1.zip
Client	Search	Azure.Search.Documents Unable to Parse Documents containing DateTime.MaxValue	We have been migrating to Azure.Search.Documents from the deprecated Microsoft.Azure.Search. Our documents contain date fields which could have been populated with .Net's DateTime.MaxValue. Whilst this was not a problem in Microsoft.Azure.Search, Azure.Search.Documents results in the following error: `The DateTime represented by the string '9999-12-31T23:59:59.999Z' is out of range.`     at System.DateTimeParse.Parse(ReadOnlySpan`1 s, DateTimeFormatInfo dtfi, DateTimeStyles styles)\r\n       at Azure.Search.Documents.SearchDateTimeConverter.Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)\r\n       at System.Text.Json.JsonPropertyInfoNotNullable`4.OnRead(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)\r\n       at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)\r\n       at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state)\r\n       at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)\r\n       at System.Text.Json.JsonSerializer.ReadCore(JsonReaderState& readerState, Boolean isFinalBlock, ReadOnlySpan`1 buffer, JsonSerializerOptions options, ReadStack& readStack)\r\n       at System.Text.Json.JsonSerializer.<ReadAsync>d__14`1.MoveNext()\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n       at System.Threading.Tasks.ValueTask`1.get_Result()\r\n       at Azure.Search.Documents.Models.SearchResult`1.<DeserializeAsync>d__13.MoveNext()\r\n       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n       at Azure.Search.Documents.Models.SearchResults`1.<DeserializeAsync>d__33.MoveNext()\r\n       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n       at Azure.Search.Documents.SearchClient.<SearchInternal>d__37`1.MoveNext()\r\n       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n       at Azure.Search.Documents.SearchClient.<SearchInternal>d__36`1.MoveNext()\r\n       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n       at Azure.Search.Documents.SearchClient.<SearchAsync>d__35`1.MoveNext()\r\n       at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n       at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()  Is this intentional?  If so, what is the appropriate maximum date value to use please? edit: formatted the call stack
Client	Event Hubs	Max values for maxBatchSize and prefetchCount	What is the maximum value for maxBatchSize? I wasn't able to find the constraints in the docs.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 47f65d3b-7b17-223e-2ffa-caff402d0e57 Version Independent ID: 3a7e1ff6-06f6-672f-b9bc-05c642d94593 Content: EventProcessorOptions.MaxBatchSize Property (Microsoft.Azure.EventHubs.Processor) - Azure for .NET Developers Content Source: xml/Microsoft.Azure.EventHubs.Processor/EventProcessorOptions.xml Service: event-hubs GitHub Login: @rloutlaw Microsoft Alias: routlaw
Central-EngSys	EngSys	[QUERY] How do step through the SDK code in Visual Studio when debugging?	I've looked over issues #6239 and #9757 but I'm unable to figure out how to step through the project source in VS (in my case, for Azure.Storage.Blobs.dll specifically). It looks like the published symbols don't have source information (see below). Am I using the wrong symbol server? Or is this level of symbols info just not available? Any guidance on how to step through the project source without needing to enlist and build the SDK locally would be appreciated. (FYI: I'm using the Azure.Storage.Blobs NuGet package 12.9.1).  Output in VS from fetching the symbols below: SYMSRV:  HTTPGET: /download/symbols/Azure.Storage.Blobs.pdb/4A120B30DB51487DA8F54A28C1C4B656ffffffff/Azure.Storage.Blobs.pdb SYMSRV:  HttpQueryInfo: 801900c8 - HTTP_STATUS_OK SYMSRV:  Azure.Storage.Blobs.pdb from https://msdl.microsoft.com/download/symbols: 297868 bytes  SYMSRV:  PATH: C:\symbols\Azure.Storage.Blobs.pdb\4A120B30DB51487DA8F54A28C1C4B656ffffffff\Azure.Storage.Blobs.pdb SYMSRV:  RESULT: 0x00000000 https://msdl.microsoft.com/download/symbols: Symbols downloaded from symbol server. C:\symbols\Azure.Storage.Blobs.pdb\4A120B30DB51487DA8F54A28C1C4B656ffffffff\Azure.Storage.Blobs.pdb: Symbols loaded.
Client	Service Bus	[FEATURE REQ] Make ServiceBusConnectionStringBuilder available in Azure.Messaging.ServiceBus	Library or service name. Azure.Messaging.ServiceBus Is your feature request related to a problem? Please describe. Microsoft.Azure.ServiceBus has a connection string builder, which is useful for assembling the connection string from various IConfiguration sources. Please bring this functionality to the new package. For example, I want to store the SharedAccessKey in Azure Key Vault and then store the rest of the connection string in plaintext application settings. My code then assembles the complete connection string using the ServiceBusConnectionStringBuilder .
Mgmt	ARM	[QUERY] - How do I mock an IPage<DeploymentOperation> for my unit tests	Query/Question I saw this blog post which provides an example of making a Page using the .FromValues method but with the Azure Resource Manager SDK, I don't see this exposed as an option when trying to mock a DeploymentOperations object. We are specifically trying to setup a moq for this method:  ResourceManagerClient.DeploymentOperations.ListAtScopeWithHttpMessagesAsync  This method returns an object of type Task<AzureOperationResponse<IPage<DeploymentOperation>>>  We have tried a number of things and been unable to create a Mock object of this type for unit testing.  How do we convert our test response object into a Paged version?  Note: making an AzureOperationResponce isn't too hard, it's the Page/IPage that is giving us grief. var operationProperties = new DeploymentOperationProperties(                 provisioningOperation: ProvisioningOperation.Create,                 provisioningState:`complete`,                 DateTime.UtcNow,                 duration:`2 minutes`,                  serviceRequestId:null,                  statusCode: `OK`,                  statusMessage: new StatusMessage(`OK`));              var myOperation = new DeploymentOperation(                 id:`someid123`, operationId:`hello`,                 properties: operationProperties);              var l = myOperation as Page<DeploymentOperation>;  This gives an error of:  Cannot convert type 'Microsoft.Azure.Management.ResourceManager.Models.DeploymentOperation' to 'Microsoft.Azure.Management.ResourceManager.Models.Page<Microsoft.Azure.Management.ResourceManager.Models.DeploymentOperation>' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion  Documentation for this shows people using Page<T>.FromValues which we do not see as available. Environment:  Name and version of the Library package used: Microsoft.Azure.Management.ResourceManager. 3.13.1-preview Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8] IDE and version : [e.g. Visual Studio 16.3]
Client	Storage	[BUG] StatusMessage:The uncommitted block count cannot exceed the maximum limit of 100,000 blocks. ErrorCode:BlockCountExceedsLimit	
Client	Azure.Identity	TaskCanceledException caused by ManagedIdentityCredential authentication failure when calling BlobContainerClient.CreateIfNotExists	Query/Question We tried to connect to storage container and queues with Managed Identity (system assigned) in our Webjob. Our Webjob tasks failed randomly but frequently for TaskCanceledException caused by ManagedIdentityCredential authentication failure. According the ApplicationInsights, it seems the exceptions were thrown when calling BlobContainerClient.CreateIfNotExists(). We assigned Storage Queue Data Contributor and Storage Blob Data Contributor roles to the AppService. We don't think this is a permission issue since we didn't see the failure constantly. The errors happened on different target storage containers in the same storage account.  Retry a failed Webjob task may or may not get the same error. The same error may or may not happen during the next Webjob task with the same target storage account. (More error details are attached below. ) Our current walk around is reverting to normal authentication (i.e. connect with connection string). We cannot reproduce the same error in our test environment. We are wondering what's the cause of this error and how to fix it. Environment:  Packege version:  Azure.Storage.Blobs 12.9.1 Azure.Identity 1.4.0   Hosting platform: Azure AppService (ASP.NET V4.8) IDE and version : Version 16.10.2  Screen Shot  Error for ManagedIdentityCredential.GetToken Azure.Identity.AuthenticationFailedException: ManagedIdentityCredential authentication failed: Retry failed after 4 tries. Retry settings can be adjusted in ClientOptions.Retry. ---> System.AggregateException: Retry failed after 4 tries. Retry settings can be adjusted in ClientOptions.Retry. ---> System.Threading.Tasks.TaskCanceledException: The operation was cancelled because it exceeded the configured timeout of 0:01:40. Network timeout can be adjusted in ClientOptions.Retry.NetworkTimeout. ---> System.Threading.Tasks.TaskCanceledException: The operation was canceled.    at Azure.Core.CancellationHelper.ThrowIfCancellationRequested(CancellationToken cancellationToken)    at Azure.Core.Pipeline.HttpWebRequestTransport.<ProcessInternal>d__7.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.Pipeline.HttpWebRequestTransport.<ProcessAsync>d__6.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.Pipeline.RequestActivityPolicy.<ProcessAsync>d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Core.Pipeline.ResponseBodyPolicy.<ProcessAsync>d__5.MoveNext()    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout(CancellationToken originalToken, CancellationToken timeoutToken, Exception inner, TimeSpan timeout)    at Azure.Core.Pipeline.ResponseBodyPolicy.<ProcessAsync>d__5.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully()    at Azure.Core.Pipeline.LoggingPolicy.<ProcessAsync>d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully()    at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__11.MoveNext()    --- End of inner exception stack trace ---    at Azure.Core.Pipeline.RetryPolicy.<ProcessAsync>d__11.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Identity.ManagedIdentitySource.<AuthenticateAsync>d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Identity.ManagedIdentityClient.<AuthenticateAsync>d__12.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Identity.ManagedIdentityCredential.<GetTokenImplAsync>d__9.MoveNext()    --- End of inner exception stack trace ---    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow(Exception ex)    at Azure.Identity.ManagedIdentityCredential.<GetTokenImplAsync>d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Identity.ManagedIdentityCredential.<GetTokenAsync>d__7.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Azure.Identity.DefaultAzureCredential.<GetTokenFromSourcesAsync>d__14.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Threading.Tasks.ValueTask`1.get_Result()    at Azure.Identity.DefaultAzureCredential.<GetTokenImplAsync>d__12.MoveNext()  Full StackTrace from ApplicationInsights Microsoft.Azure.WebJobs.Host.FunctionInvocationException:    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor+<ExecuteWithLoggingAsync>d__20.MoveNext (Microsoft.Azure.WebJobs.Host, Version=3.0.27.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor+<TryExecuteAsync>d__15.MoveNext (Microsoft.Azure.WebJobs.Host, Version=3.0.27.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35) Inner exception System.AggregateException handled at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw:    at System.Threading.Tasks.Task.ThrowIfExceptional (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.Task.Wait (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at O365DC_WJ_CombineFiles.Functions.CombineFilesO365ForSpecificPrefix (O365DC-WJ-CombineFiles, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\Users\panjerry\source\repos\DT-SIP-DPlat-SIP\CustomCollectors\O365DataCollection\O365DC-WJ-CombineFiles\Functions.cs:53)    at lambda_method (Anonymously Hosted DynamicMethods Assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null)    at Microsoft.Azure.WebJobs.Host.Executors.VoidMethodInvoker`2.InvokeAsync (Microsoft.Azure.WebJobs.Host, Version=3.0.27.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at Microsoft.Azure.WebJobs.Host.Executors.FunctionInvoker`2+<InvokeAsync>d__10.MoveNext (Microsoft.Azure.WebJobs.Host, Version=3.0.27.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor+<ExecuteWithWatchersAsync>d__26.MoveNext (Microsoft.Azure.WebJobs.Host, Version=3.0.27.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Microsoft.Azure.WebJobs.Host.Executors.FunctionExecutor+<ExecuteWithLoggingAsync>d__20.MoveNext (Microsoft.Azure.WebJobs.Host, Version=3.0.27.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35) Inner exception Azure.Identity.AuthenticationFailedException handled at System.Threading.Tasks.Task.ThrowIfExceptional:    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Identity.ManagedIdentityCredential+<GetTokenImplAsync>d__9.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Identity.ManagedIdentityCredential+<GetTokenAsync>d__7.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Identity.DefaultAzureCredential+<GetTokenFromSourcesAsync>d__14.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask`1.get_Result (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Identity.DefaultAzureCredential+<GetTokenImplAsync>d__12.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Identity.DefaultAzureCredential+<GetTokenImplAsync>d__12.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Identity.DefaultAzureCredential+<GetTokenAsync>d__11.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+AccessTokenCache+<GetHeaderValueFromCredentialAsync>d__12.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask`1.get_Result (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+AccessTokenCache+<GetHeaderValueAsync>d__8.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+AccessTokenCache+<GetHeaderValueAsync>d__8.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+<AuthenticateAndAuthorizeRequestAsync>d__12.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.BearerTokenAuthenticationPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.HttpPipelineSynchronousPolicy+<<ProcessAsync>g__ProcessAsyncInner|4_0>d.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Storage.Blobs.ContainerRestClient+<CreateAsync>d__6.MoveNext (Azure.Storage.Blobs, Version=12.9.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Storage.Blobs.BlobContainerClient+<CreateInternal>d__53.MoveNext (Azure.Storage.Blobs, Version=12.9.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Storage.Blobs.BlobContainerClient+<CreateIfNotExistsInternal>d__52.MoveNext (Azure.Storage.Blobs, Version=12.9.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Storage.Blobs.BlobContainerClient+<CreateIfNotExistsAsync>d__50.MoveNext (Azure.Storage.Blobs, Version=12.9.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at O365DC_WJ_CombineFiles.Functions+<CompressAndUploadToBlob>d__7.MoveNext (O365DC-WJ-CombineFiles, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\Users\panjerry\source\repos\DT-SIP-DPlat-SIP\CustomCollectors\O365DataCollection\O365DC-WJ-CombineFiles\Functions.cs:226)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at O365DC_WJ_CombineFiles.Functions+<CombineJSONFilesBlob>d__5.MoveNext (O365DC-WJ-CombineFiles, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\Users\panjerry\source\repos\DT-SIP-DPlat-SIP\CustomCollectors\O365DataCollection\O365DC-WJ-CombineFiles\Functions.cs:139) Inner exception System.AggregateException handled at Azure.Identity.CredentialDiagnosticScope.FailWrapAndThrow:    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Identity.ManagedIdentitySource+<AuthenticateAsync>d__9.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Identity.ManagedIdentityClient+<AuthenticateAsync>d__12.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Identity.ManagedIdentityCredential+<GetTokenImplAsync>d__9.MoveNext (Azure.Identity, Version=1.4.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception System.Threading.Tasks.TaskCanceledException handled at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext:    at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.LoggingPolicy+<ProcessAsync>d__9.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception System.Threading.Tasks.TaskCanceledException handled at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout:    at Azure.Core.CancellationHelper.ThrowIfCancellationRequested (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Core.Pipeline.HttpWebRequestTransport+<ProcessInternal>d__7.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.HttpWebRequestTransport+<ProcessAsync>d__6.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.RequestActivityPolicy+<ProcessAsync>d__9.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception System.Threading.Tasks.TaskCanceledException handled at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext:    at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.LoggingPolicy+<ProcessAsync>d__9.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception System.Threading.Tasks.TaskCanceledException handled at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout:    at Azure.Core.CancellationHelper.ThrowIfCancellationRequested (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Core.Pipeline.HttpWebRequestTransport+<ProcessInternal>d__7.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.HttpWebRequestTransport+<ProcessAsync>d__6.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.RequestActivityPolicy+<ProcessAsync>d__9.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception System.Threading.Tasks.TaskCanceledException handled at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext:    at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.LoggingPolicy+<ProcessAsync>d__9.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully (System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51)    at Azure.Core.Pipeline.RetryPolicy+<ProcessAsync>d__11.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception System.Threading.Tasks.TaskCanceledException handled at Azure.Core.Pipeline.ResponseBodyPolicy.ThrowIfCancellationRequestedOrTimeout:    at Azure.Core.CancellationHelper.ThrowIfCancellationRequested (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at Azure.Core.Pipeline.HttpWebRequestTransport+<ProcessInternal>d__7.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.HttpWebRequestTransport+<ProcessAsync>d__6.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.RequestActivityPolicy+<ProcessAsync>d__9.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089)    at Azure.Core.Pipeline.ResponseBodyPolicy+<ProcessAsync>d__5.MoveNext (Azure.Core, Version=1.16.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8) Inner exception Microsoft.ApplicationInsights.DataContracts.InnerExceptionCountExceededException handled at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw:
Client	Synapse	[Synapse] Deserializer is not Deserializing the arguments for pipeline in spark job definition activity.	azure-sdk-for-net/sdk/synapse/Azure.Analytics.Synapse.Artifacts/src/Generated/Models/SynapseSparkJobDefinitionActivity.Serialization.cs                    Line 160       in       4162f6f                                                 foreach (var property0 in property.Value.EnumerateObject())
Client	Event Grid	Support serialization option to ignore nulls in EventGridPublisherClient	It would be useful to allow some serialization options such as ignoring nulls. This can significantly reduce the payload size in many cases.                azure-sdk-for-net/sdk/eventgrid/Azure.Messaging.EventGrid/src/Customization/EventGridPublisherClient.cs                    Line 180       in       3b0d98e                                                 request.Content = RequestContent.Create(JsonSerializer.Serialize(events));
Client	Tables	AuthenticationFailed when using SAS token based authentication to read Azure Table	I have been using the snippet below to create and Azure.Data.Tables:12.1.0 and having intermittent authentication failure. I have tried to setup start date to -1 day and also tried without start date. It works once out of 4 times. Error: Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature. RequestId:cf1c3480-2002-0069-32cf-7c6cb1000000 Time:2021-07-19T18:52:47.4799506Z Status: 403 (Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature.) ErrorCode: AuthenticationFailed  Content: {`odata.error`:{`code`:`AuthenticationFailed`,`message`:{`lang`:`en-US`,`value`:`Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature.\nRequestId:cf1c3480-2002-0069-32cf-7c6cb1000000\nTime:2021-07-19T18:52:47.4799506Z`}}}  Headers: x-ms-request-id: cf1c3480-2002-0069-32cf-7c6cb1000000 x-ms-error-code: REDACTED Content-Length: 299 Content-Type: application/json Date: Mon, 19 Jul 2021 18:52:46 GMT Server: Microsoft-HTTPAPI/2.0  Snippet:               private static string connectionString(string sasKey)         {             string tableEndpoint = $`https://{StorageAccountName}.{TableStorageBaseURI}/`;             string connecitonString1 = $`TableEndpoint={tableEndpoint};SharedAccessSignature={sasKey}`;              return connecitonString1;         }          private static string GetAccountSASToken(StorageSharedKeyCredential key)         {             // Create a SAS token that's valid for one hour.             AccountSasBuilder sasBuilder = new AccountSasBuilder()             {                 Services = AccountSasServices.Tables,                 ResourceTypes = AccountSasResourceTypes.All,                 ExpiresOn = DateTimeOffset.UtcNow.AddHours(1),                 Protocol = SasProtocol.Https,                 StartsOn = DateTimeOffset.UtcNow.AddDays(-1)             };              sasBuilder.SetPermissions(AccountSasPermissions.Read |                 AccountSasPermissions.Write);              // Use the key to get the SAS token.             string sasToken = sasBuilder.ToSasQueryParameters(key).ToString();              Console.WriteLine(`SAS token for the storage account is: {0}`, sasToken);             Console.WriteLine();              return sasToken;         }
Client	Search	[BUG] The type initializer for `Azure.Search.Documents.Constants` threw an exception.	Describe the bug I had a problem getting Exceptions when using the Azure.Search.Documents 11.2.1 NuGet package. I'm working on an Azure Function integration project using .net core 3.1 and Azure Functions v. 3. When developing and debugging locally, everything works fine, but when publishing to the Azure function and calling the endpoints I'm getting Exceptions with the message: `The type initializer for 'Azure.Search.Documents.Constants' threw an exception.` This happens when executing a search call like this: SearchResults response = await _searchClient.SearchAsync(queryText, options); Expected behavior I expected that the search would succeed in the Azure Function App, in the same way it does on my local development environment. Actual behavior (include Exception or Stack Trace) Exception with the message text is thrown: `The type initializer for 'Azure.Search.Documents.Constants' threw an exception.` When investigating my Application insights logs further, i found the following from the stack trace: System.MissingMethodException: Method not found: 'System.Text.Json.JsonEncodedText System.Text.Json.JsonEncodedText.Encode(System.String, System.Text.Encodings.Web.JavaScriptEncoder)'. at Azure.Search.Documents.Constants..cctor() To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Setup an Azure function v3 project using .net core 3.1 Add NuGet package: Azure.Search.Documents 11.2.1 Setup search client Setup a Http triggered Azure function Make call to search using: SearchResults response = await _searchClient.SearchAsync(queryText, options); Publish to Azure Function App Invoke Http triggered Azure function  Environment:  Name and version of the Library package used: Azure.Search.Documents 11.2.1 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): Azure Function App v3, .net core 3.1. IDE and version : Microsoft Visual Studio Professional 2019 - Version 16.8.6  Suggested fix I can see that the Azure.Search.Documents NuGet package has a dependency to System.Text.Json >= 4.6.0 Azure.Search.Documents is using a method that is implemented in a later version of System.Text.Json. I fixed the issue in my project by manually installing System.Text.Json v5.0.2. I recommend that you update System.Text.Json depencency in the Azure.Search.Documents to version 5.0.2 or a version that implements the missing method.
Client	Event Hubs	AmqpAnnotatedMessageExtensions - CopyDictionary forces allocation of Keys-collection	azure-sdk-for-net/sdk/eventhub/Azure.Messaging.EventHubs/src/Amqp/AmqpAnnotatedMessageExtensions.cs                   Lines 402 to 405       in       7be25e8                                                 foreach (var key in source.Keys)                                           {                                               destination[key] = source[key];                                           }                     Instead it should just be this: foreach (var item in source) {    destination[item.Key] = item.Value; }
Client	Azure.Core	[BUG]All authentication failures produce ObjectDisposedException	Describe the bug Failing to authenticate using ClientSecretCredentials produces ObjectDisposedException instead of a meaningful error message Expected behavior A meaningful error message is produced Actual behavior (include Exception or Stack Trace) Unhandled exception. System.ObjectDisposedException: Cannot access a closed Stream.    at System.IO.MemoryStream.Write(ReadOnlySpan`1 buffer)    at System.IO.StreamWriter.Flush(Boolean flushStream, Boolean flushEncoder)    at System.IO.StreamWriter.Dispose(Boolean disposing)    at System.IO.TextWriter.Dispose()    at System.Xml.XmlTextWriter.Close()    at System.Xml.XmlWriter.Dispose(Boolean disposing)    at System.Xml.XmlWriter.Dispose()    at Azure.Core.XmlWriterContent.Dispose()    at Azure.Core.Pipeline.HttpClientTransport.PipelineRequest.Dispose()    at Azure.Core.HttpMessage.Dispose()    at Azure.Storage.Blobs.ServiceRestClient.GetUserDelegationKeyAsync(KeyInfo keyInfo, Nullable`1 timeout, CancellationToken cancellationToken)    at Azure.Storage.Blobs.BlobServiceClient.GetUserDelegationKeyInternal(Nullable`1 startsOn, DateTimeOffset expiresOn, Boolean async, CancellationToken cancellationToken)    at Azure.Storage.Blobs.BlobServiceClient.GetUserDelegationKeyAsync(Nullable`1 startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken)    at AzureSdkBadErrorMessage.Program.Main(String[] args) in /home/mark/proto/AzureSdkBadErrorMessage/Program.cs:line 21    at AzureSdkBadErrorMessage.Program.<Main>(String[] args)  To Reproduce Run the code in: https://github.com/blushingpenguin/AzureSdkBadErrorMessage This contains `credentials`, which don't work and fails with the above stack trace. It also enables the diagnostics which do produce a meaningful error: [Informational] Azure-Identity: ClientSecretCredential.GetToken invoked. Scopes: [ https://storage.azure.com/.default ] ParentRequestId: 8109abc0-218c-43d7-989d-d042441f41f5 [Informational] Azure-Core: Request [7a5a014b-c971-4164-b6ba-a5e15581b832] GET https://login.microsoftonline.com/common/discovery/instance?api-version=REDACTED&authorization_endpoint=REDACTED x-client-SKU:REDACTED x-client-Ver:REDACTED x-client-OS:REDACTED client-request-id:REDACTED return-client-request-id:REDACTED x-app-name:REDACTED x-app-ver:REDACTED x-ms-client-request-id:7a5a014b-c971-4164-b6ba-a5e15581b832 x-ms-return-client-request-id:true User-Agent:azsdk-net-Identity/1.4.0,(.NET 5.0.7; Linux 5.11.0-22-generic #23-Ubuntu SMP Thu Jun 17 00:34:23 UTC 2021) client assembly: Azure.Identity [Informational] Azure-Core: Response [7a5a014b-c971-4164-b6ba-a5e15581b832] 200 OK (00.4s) Cache-Control:max-age=86400, private Strict-Transport-Security:REDACTED X-Content-Type-Options:REDACTED Access-Control-Allow-Origin:REDACTED Access-Control-Allow-Methods:REDACTED P3P:REDACTED client-request-id:REDACTED x-ms-request-id:a952e285-bc6f-4517-a432-79f8903d1701 x-ms-ests-server:REDACTED Set-Cookie:REDACTED Date:Thu, 08 Jul 2021 07:58:27 GMT Content-Type:application/json; charset=utf-8 Content-Length:980  [Informational] Azure-Core: Request [9b317bf4-49a1-4f5a-b095-7d57561b3491] POST https://login.microsoftonline.com/274d3ec0-04a4-43aa-9db3-7e8b8deaebc3/oauth2/v2.0/token x-client-SKU:REDACTED x-client-Ver:REDACTED x-client-OS:REDACTED x-client-current-telemetry:REDACTED x-client-last-telemetry:REDACTED x-ms-PKeyAuth:REDACTED x-ms-lib-capability:REDACTED client-request-id:REDACTED return-client-request-id:REDACTED x-app-name:REDACTED x-app-ver:REDACTED x-ms-client-request-id:9b317bf4-49a1-4f5a-b095-7d57561b3491 x-ms-return-client-request-id:true User-Agent:azsdk-net-Identity/1.4.0,(.NET 5.0.7; Linux 5.11.0-22-generic #23-Ubuntu SMP Thu Jun 17 00:34:23 UTC 2021) Content-Type:application/x-www-form-urlencoded client assembly: Azure.Identity [Warning] Azure-Core: Error response [9b317bf4-49a1-4f5a-b095-7d57561b3491] 400 Bad Request (00.0s) Cache-Control:no-store, no-cache Pragma:no-cache Strict-Transport-Security:REDACTED X-Content-Type-Options:REDACTED P3P:REDACTED client-request-id:REDACTED x-ms-request-id:e76ad7bd-48fe-480e-8097-f4469224bb01 x-ms-ests-server:REDACTED x-ms-clitelem:REDACTED Set-Cookie:REDACTED Date:Thu, 08 Jul 2021 07:58:27 GMT Content-Type:application/json; charset=utf-8 Expires:-1 Content-Length:652  [Informational] Azure-Identity: ClientSecretCredential.GetToken was unable to retrieve an access token. Scopes: [ https://storage.azure.com/.default ] ParentRequestId: 8109abc0-218c-43d7-989d-d042441f41f5 Exception: Azure.Identity.AuthenticationFailedException (0x80131500): ClientSecretCredential authentication failed: AADSTS90002: Tenant '274d3ec0-04a4-43aa-9db3-7e8b8deaebc3' not found. This may happen if there are no active subscriptions for the tenant. Check to make sure you have the correct tenant ID. Check with your subscription administrator. Trace ID: e76ad7bd-48fe-480e-8097-f4469224bb01 Correlation ID: a1ad1ff1-137d-4d33-ab94-7f4a61f6b75c Timestamp: 2021-07-08 07:58:27Z  ---> Microsoft.Identity.Client.MsalServiceException (0x80131500): AADSTS90002: Tenant '274d3ec0-04a4-43aa-9db3-7e8b8deaebc3' not found. This may happen if there are no active subscriptions for the tenant. Check to make sure you have the correct tenant ID. Check with your subscription administrator. Trace ID: e76ad7bd-48fe-480e-8097-f4469224bb01 Correlation ID: a1ad1ff1-137d-4d33-ab94-7f4a61f6b75c Timestamp: 2021-07-08 07:58:27Z  Environment:  Azure.Storage.Blobs 12.9.1, Azure.Identity 1.4.0 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8]   .NET SDK (reflecting any global.json):  Version:   5.0.301  Commit:    cc8c0abb32  Runtime Environment:  OS Name:     ubuntu  OS Version:  21.04  OS Platform: Linux  RID:         ubuntu.21.04-x64  Base Path:   /usr/share/dotnet/sdk/5.0.301/  Host (useful for support):   Version: 5.0.7   Commit:  556582d964  .NET SDKs installed:   2.1.816 [/usr/share/dotnet/sdk]   3.1.410 [/usr/share/dotnet/sdk]   5.0.301 [/usr/share/dotnet/sdk]  .NET runtimes installed:   Microsoft.AspNetCore.All 2.1.28 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]   Microsoft.AspNetCore.App 2.1.28 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.16 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 5.0.7 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]   Microsoft.NETCore.App 2.1.28 [/usr/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.16 [/usr/share/dotnet/shared/Microsoft.NETCore.App]   Microsoft.NETCore.App 5.0.7 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
Mgmt	SQL	SqlServer entity missing data compared to CLI response	I'm using the SDK to retrieve SqlServer entities - IAzure.SqlServers.ListAsync(). I'm seeing a difference between the response given by the SDK and the response given by the CLI az sql server list command. Example for missing fields:  minimalTlsVersion privateEndpointConnections publicNetworkAccess identity  Looking at the entity response documentation, I can't see any fields that can correlate to the fields I stated above. Same regarding the ServerInner entity, which also lacks these parameters. Am I missing some other API in which I can retrieve the fields that are returned by the Azure CLI? Environment:  Microsoft.Azure.Management.Fluent 1.36.1 Mac OS X 10.16, Microsoft.NETCore.App 3.1.4
Mgmt	Event Hubs	[FEATURE REQ] Azure.Management.EventHub allow MaximumThroughputUnits of 40	Azure.Management.EventHub We are using the .Net SDK for the creation of EHs and we have notices that the allowed maximumThroughputUnits is validated between 0 and 20 even though in the Azure portal EHs can have maximumThroughputUnits of 40. I can see that there is a validation here is that intentionally not synced with the portal behavior?
Client	Tables	[QUERY] ToOdataAnnotatedDictionary should skip dictionary lookup	Query/Question Curious why having code like this in TableEntityExtensions.cs: annotatedDictionary[prop.Name] = prop.GetValue(entity); switch (annotatedDictionary[prop.Name]) Would this not be more optimal: var propertyValue = prop.GetValue(entity); annotatedDictionary[prop.Name] = propertyValue; switch (propertyValue)  // Skip dictionary lookup                azure-sdk-for-net/sdk/tables/Azure.Data.Tables/src/Extensions/TableEntityExtensions.cs                    Line 17       in       4162f6f                                                 internal static Dictionary<string, object> ToOdataAnnotatedDictionary<T>(this T entity) where T : class, ITableEntity                                    azure-sdk-for-net/sdk/tables/Azure.Data.Tables/src/Extensions/DictionaryTableExtensions.cs                    Line 26       in       4162f6f                                                 internal static Dictionary<string, object> ToOdataAnnotatedDictionary(this IDictionary<string, object> tableEntityProperties)
Service	Search	[QUERY] Search: Using DateTimeOffset in POST body for azure search filter	Query/Question I am trying to implement azure search via POST that involves a DateTimeOffset field. My filter run fine if I don't have the DateTimeOffset field added. Below is the query that works fine: POST:BODY: {`filter`:`statusCode eq 'ACTIVE'`,`top`:100,`skip`:0,`orderby`:`code asc`,`count`:true,`search`:``} but this doesn't work: POST:BODY: {`filter`:`statusCode eq 'ACTIVE' and DateTimeOffset ge 2010-01-01T00:00:00Z`,`top`:100,`skip`:0,`orderby`:`code asc`,`count`:true,`search`:``} Same query with DateTimeOffset  works fine when I use GET instead of POST. These is no documentation available in how to use azure serach using POST verbs. Azure portal also allows testing only via query string (GET). Environment: Azure search API - api-version=2017-11-11 and above
Client	Event Hubs	Azure.Messaging.EventHubs: Recover event hub if received error	Query/Question We are looking for coding examples to recover from .net event hub SDK exceptions. See Below the exception we are receiving from time to time. Can you advise what can be a good way to recover from it? 2021-05-15 03:53:57.9280|ERROR|EventHub Service||An exception was thrown while in messages consumer: Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs . Operation Reading events from the Event Hubs service. on partition 3 2021-05-15 03:53:57.9724|ERROR|Processor||An error occured in the processor {`PartitionId`:`3`,`Operation`:`Reading events from the Event Hubs service.`,`Exception`:{`IsTransient`:false,`Reason`:1,`EventHubName`:`***`,`Message`:`Unable to create the items needed to communicate with the Event Hubs service. (***)`,`StackTrace`:`   at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.CreateConsumerLinkAsync(String consumerGroup, String partitionId, EventPosition eventStartingPosition, UInt32 prefetchCount, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, TimeSpan timeout, CancellationToken cancellationToken)\r\n   at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1.OnCreateAsync(TimeSpan timeout)\r\n   at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout)\r\n   at Microsoft.Azure.Amqp.Singleton`1.GetOrCreateAsync(TimeSpan timeout)\r\n   at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.ReceiveAsync(Int32 maximumMessageCount, Nullable`1 maximumWaitTime, CancellationToken cancellationToken)\r\n   at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.ReceiveAsync(Int32 maximumMessageCount, Nullable`1 maximumWaitTime, CancellationToken cancellationToken)\r\n   at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.<>c__DisplayClass61_0.<<CreatePartitionProcessor>g__performProcessing|1>d.MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at Azure.Messaging.EventHubs.Primitives.EventProcessor`1.<>c__DisplayClass61_0.<<CreatePartitionProcessor>g__performProcessing|1>d.MoveNext()`,`Data`:{},`InnerException`:{`ClassName`:`System.ObjectDisposedException`,`Message`:`Cannot access a disposed object.`,`Data`:null,`InnerException`:null,`HelpURL`:null,`StackTraceString`:`   at Microsoft.Azure.Amqp.AmqpCbsLink.BeginSendToken(ICbsTokenProvider tokenProvider, Uri namespaceAddress, String audience, String resource, String[] requiredClaims, TimeSpan timeout, AsyncCallback callback, Object state)\r\n   at Microsoft.Azure.Amqp.AmqpCbsLink.<>c__DisplayClass4_0.<SendTokenAsync>b__0(AsyncCallback c, Object s)\r\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl(Func`3 beginMethod, Func`2 endFunction, Action`1 endAction, Object state, TaskCreationOptions creationOptions)\r\n   at Microsoft.Azure.Amqp.TaskHelpers.CreateTask[T](Func`3 begin, Func`2 end, Object state)\r\n--- End of stack trace from previous location ---\r\n   at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.CreateReceivingLinkAsync(AmqpConnection connection, Uri endpoint, EventPosition eventPosition, TimeSpan timeout, UInt32 prefetchCount, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, CancellationToken cancellationToken)\r\n   at Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope.OpenConsumerLinkAsync(String consumerGroup, String partitionId, EventPosition eventPosition, TimeSpan timeout, UInt32 prefetchCount, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, CancellationToken cancellationToken)\r\n   at Azure.Messaging.EventHubs.Amqp.AmqpConsumer.CreateConsumerLinkAsync(String consumerGroup, String partitionId, EventPosition eventStartingPosition, UInt32 prefetchCount, Nullable`1 ownerLevel, Boolean trackLastEnqueuedEventProperties, TimeSpan timeout, CancellationToken cancellationToken)`,`RemoteStackTraceString`:null,`RemoteStackIndex`:0,`ExceptionMethod`:null,`HResult`:-2146232798,`Source`:`Microsoft.Azure.Amqp`,`WatsonBuckets`:null,`ObjectName`:`$cbs`},`HelpLink`:null,`Source`:`System.Private.CoreLib`,`HResult`:-2146233088},`CancellationToken`:{`IsCancellationRequested`:false,`CanBeCanceled`:false,`WaitHandle`:{`Handle`:{`value`:3040},`SafeWaitHandle`:{`IsInvalid`:false,`IsClosed`:false}}}}  Environment:  Azure.Messaging.EventHubs 5.2.0 Windows 10 .NET Core 5.0.6
Client	Event Hubs	[BUG] - EventProcessorHost got stuck throwing ObjectDisposedException	Describe the bug After calling EventProcessorHost.UnregisterEventProcessorAsync it started to throw Exceptions in a loop Expected behavior Stop the processor host without errors. Actual behavior (include Exception or Stack Trace) System.ObjectDisposedException: Cannot access a disposed object. Object name: 'System.Net.WebSockets.ClientWebSocket'. at System.Net.WebSockets.ClientWebSocket.ThrowIfNotConnected() at System.Net.WebSockets.ClientWebSocket.SendAsync(ArraySegment1 buffer, WebSocketMessageType messageType, Boolean endOfMessage, CancellationToken cancellationToken) at Microsoft.Azure.Amqp.Transport.WebSocketTransport.WriteAsync(TransportAsyncCallbackArgs args) at Microsoft.Azure.Amqp.AsyncIO.AsyncBufferWriter.Write(TransportAsyncCallbackArgs args) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.EventHubs.Amqp.AmqpEventHubClient.<CreateConnectionAsync>d__31.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.d__6.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.Amqp.Singleton1.<GetOrCreateAsync>d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.Amqp.Singleton1.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.d__15.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.Amqp.FaultTolerantAmqpObject1.<OnCreateAsync>d__6.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.Amqp.Singleton1.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.Amqp.Singleton`1.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.EventHubs.PartitionReceiver.d__30.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.d__18.MoveNext() To Reproduce I can't reproduce. It only happened once Environment:  Microsoft.Azure.EventHubs.Processor 4.2.0 .NET Framework 4.7.2 Windows Server 2019
Client	Search	Search SDK: MergeOrUpload - skip nullable properties	Query/Question Hi, we have duplicate sources populating/updating Azure Search Index. Source 1 is updating the index with MergeOrUpload with all properties filled out for our typed model, except for PopularityScore. public class IndexModel {        [SimpleField(IsKey = true, IsFilterable = true)]        public string Id { get; set; }         [SimpleField(IsFilterable = true, IsSortable = true, IsFacetable = true)]        public double? PopularityScore { get; set; }         //.... more properties }  Source 2 is updating with Merge, ie: SearchDocument()  {         [Id] = `123`,         [`PopularityScore`] = 4.5  }   We are populating/updating with source 1 Source 2 is updating popularity score Source 1 is updating again.  When we update our index in step 3, PopularityScore ends up null. How do we update the index from source 1 without ending up with PopularityScore is NULL? (with typed model) Environment: Azure.Search.Documents 11.2.0
Client	Cognitive - Text Analytics	Missing classes in Azure.AI.TextAnalytics .Net SDK in 5.1.0-Beta.7	Query/Question ExtractKeyPhrasesAction, RecognizeEntitiesAction, and AnalyzeActionsOperation are not available, but the below document says otherwise. how to resolve it? Documentation URL: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/textanalytics/Azure.AI.TextAnalytics/samples/Sample_AnalyzeActions.md Environment:  5.1.0-Beta.7 `Azure.AI.TextAnalytics` .Net core 3.1 IDE and version : Visual Studio 16.3.x
Client	Service Bus	[BUG] ReceiveMessageAsync hangs if Queue is empty	Describe the bug ReceiveMessageAsync() method hangs infinitely if Queue is empty. Expected behavior It should return null as in description. Actual behavior (include Exception or Stack Trace) hangs infinitely. To Reproduce Snippet ServiceBusReceiverOptions options = new ServiceBusReceiverOptions()            {                ReceiveMode = ServiceBusReceiveMode.PeekLock,            };            _serviceBusReceiver = _serviceBusClient.CreateReceiver(queueOrTopicName, options); ServiceBusReceiver receiver = _serviceBusReceiver; ServiceBusReceivedMessage serviceBusReceivedMessage = await receiver.ReceiveMessageAsync();  Environment: Windows 10, VS 2019 latest as of today.  <PackageReference  Include=`Azure.Messaging.ServiceBus`  Version=`7.1.2` />
Client	KeyVault	Create Certificate Policy with SAN	Hi All, I am currently using the Nuget package Azure.Security.KeyVault.Certificate version 4.2.0.0 to create some certs in C# and have questions with SANs. I'm creating a cert with SAN using the list of DNS names, however, when I do so, all the fields in the SubjectAlternativeNames are read-only. In this case, how can we input SANs in the cert creation time? Please advise. Thanks for your help.
Client	Service Bus	ServiceBusClient.AcceptNextSessionAsync throws exception for topic subscriptions	azure-sdk-for-net/sdk/servicebus/Azure.Messaging.ServiceBus/src/Client/ServiceBusClient.cs                    Line 393       in       7254284                                                 ValidateEntityName(topicName);                     When having a ServiceBusClient for a subscription topic, the EntityPath is a combination like `TopicName/Subscriptions/SubscriptionName`. When someone calls ServiceBusClient.AcceptNextSessionAsync(`topicName`, `subscriptionName`), the first thing that method does is call ValidateEntityName(topicName).  But ValidateEntityName tries to validate that the passed-in-parameter == EntityPath.  In this case, ValidateEntityName() always throws an exception since `topicName` != `topicName/subscriptions/subscriptionName`. The fix: Either don't call ValidateEntityName(), or call it with $`{topicName}/Subscriptions/{subscriptionName}`.
Client	Service Bus	DataContractBinarySerializer equivalent in Azure.Messaging.ServiceBus	When we previously migrated from WindowsAzure.ServiceBus to Microsoft.Azure.ServiceBus we had to use DataContractBinarySerializer provided in Microsoft.Azure.ServiceBus.InteropExtensions to make sure that messages are backward compatible during rollout. It appears that there is no such serializer in Azure.Messaging.ServiceBus 7.1.2. I would like to confirm that just to make sure I did not miss anything. We are trying to migrate to Azure.Messageing.ServiceBus but in order to be compatible with existing services we need to serialize our messages in the old format so they can be deserialized by services not yet upgraded to Azure.Messaging.ServiceBus. I could do it in one step instead of two steps if there is an equivalent to DataContractBinarySerializer in 7.1.2
Client	Event Hubs	[QUERY] Any recommend way to handle Eventhub Checkpoint file change during migration to sdk v5？	Query/Question Eventhub Checkpoint saved style changes during migration to sdk v5. Checkpoint is stored in metadata in new SDK while the old one is stored just in file. Does any code tools or client option I can use to help the migration process ? Or I just need to create the checkpoint file manually myself if I do not want to redo the message? #17474 I found this issue, has it be done?
Mgmt	Websites	[BUG] WebSiteManagementClient.Certificates.CreateOrUpdateAsync fails with InternalServerError	Describe the bug WebSiteManagementClient.Certificates.CreateOrUpdateAsync fails with Microsoft.Azure.Management.WebSites.Models.DefaultErrorResponseException : Operation returned an invalid status code 'InternalServerError'. Expected behavior The operation should succeed or fail with a 4xx status code indicating what the client needs to correct. Actual behavior (include Exception or Stack Trace) The operation fails with an InternalServerError and no way to figure out what is wrong. Stack trace: CertificatesOperations.CreateOrUpdateWithHttpMessagesAsync(String resourceGroupName, String name, Certificate certificateEnvelope, Dictionary`2 customHeaders, CancellationToken cancellationToken) CertificatesOperationsExtensions.CreateOrUpdateAsync(ICertificatesOperations operations, String resourceGroupName, String name, Certificate certificateEnvelope, CancellationToken cancellationToken) CloudWebSitesContext.CreateOrUpdateCertificateAsync(String subscriptionId, Site site, Certificate certificate, CancellationToken cancellationToken) line 146  Fiddler trace: PUT https://management.azure.com/subscriptions/[REDACTED]/resourceGroups/[REDACTED]/providers/Microsoft.Web/certificates/[REDACTED]?api-version=2020-12-01 HTTP/1.1 Host: management.azure.com x-ms-client-request-id: 500808da-4138-45fb-b97b-d13355f2ad8a Accept-Language: en-US Authorization: Bearer [REDACTED] User-Agent: FxVersion/5.0.721.25508 OSName/Windows OSVersion/Microsoft.Windows.10.0.19042 Microsoft.Azure.Management.WebSites.WebSiteManagementClient/3.1.1 Content-Type: application/json; charset=utf-8 Content-Length: 3670  {   `properties`: {     `pfxBlob`: `[REDACTED]`,     `serverFarmId`: `/subscriptions/[REDACTED]/resourceGroups/[REDACTED]/providers/Microsoft.Web/serverfarms/[REDACTED]`   },   `location`: `West US 2` }  HTTP/1.1 500 Internal Server Error Cache-Control: no-cache Pragma: no-cache Content-Length: 36 Content-Type: application/json; charset=utf-8 Expires: -1 Strict-Transport-Security: max-age=31536000; includeSubDomains Server: Microsoft-IIS/10.0 X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET x-ms-failure-cause: service x-ms-ratelimit-remaining-subscription-writes: 1199 x-ms-request-id: 23cae620-86a3-4963-afbe-e6cd55d51279 x-ms-correlation-request-id: 23cae620-86a3-4963-afbe-e6cd55d51279 x-ms-routing-request-id: WESTUS3:20210614T210724Z:23cae620-86a3-4963-afbe-e6cd55d51279 X-Content-Type-Options: nosniff Date: Mon, 14 Jun 2021 21:07:23 GMT Connection: close  {`Message`:`An error has occurred.`}  To Reproduce WebSiteManagementClient client = await this.GetClientAsync(subscriptionId).ConfigureAwait(false);  certificate = await client.Certificates.CreateOrUpdateAsync(     site.ResourceGroup,     certificate.Name,     certificate,     cancellationToken: cancellationToken).ConfigureAwait(false);  Environment:   Name and version of the Library package used: Microsoft.Azure.Management.WebSites 3.1.1   Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): .NET SDK (reflecting any global.json): Version:   5.0.204 Commit:    84d1fe1bb7 Runtime Environment: OS Name:     Windows OS Version:  10.0.19042 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\5.0.204\ Host (useful for support): Version: 5.0.7 Commit:  556582d964 .NET SDKs installed: 2.2.207 [C:\Program Files\dotnet\sdk] 3.1.116 [C:\Program Files\dotnet\sdk] 3.1.300 [C:\Program Files\dotnet\sdk] 5.0.100 [C:\Program Files\dotnet\sdk] 5.0.104 [C:\Program Files\dotnet\sdk] 5.0.201 [C:\Program Files\dotnet\sdk] 5.0.203 [C:\Program Files\dotnet\sdk] 5.0.204 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.14 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.14 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.14 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.16 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.6 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   IDE and version : Visual Studio Professional 16.9.5
Client	Service Bus	[FEATURE REQ] - Service bus processing handler and error handler under the same logical thread	Service Bus Is your feature request related to a problem? Please describe. When registering to the processor via ProcessMessageAsync and ProcessErrorAsync it appears that the library wrap the invocation of ProcessMessageAsync in a logical thread context which does not follow to fire ProcessErrorAsync when error occur. Instead the library internally catch and will move on to fire ProcessErrorAsync in a different async flow which is not the child of the async flow in ProcessMessageAsync Since there are a lot of approaches in the eco-system to use AsyncLocal for things like logging, tracing, etc... It might be confusing to some why those does no longer work. The error handler signature does not include the original args from the receiver handler, which for me imply that this design is intended since there are not helpers there to settle the message. However, it is not clear at first sight and might make it harder for developers to integrate. If it's possible to invoke the error within the logical context of the message handler it will be great. However, I suspect it won't be the case, so I suggest more clear documentation on this subject, explaining the relationships between both handler and making it more clear for users to use. If I've misses such documentation, my apologies in advance. Thanks
Mgmt	Storage	[QUERY] How to check if blob versioning is enabled for a storage account?	Query/Question We've been using Azure.Storage.Blobs to manage customers' data using connection string with account name and key. Now we need to know if blob versioning is enabled. We've looked at the following options:  BlobServiceClient.GetProperties() - unfortunately it has information about soft delete but not versioning. StorageManagementClient.StorageAccounts.GetProperties (from Microsoft.Azure.Management.Storage) - this would work if I could authenticate with account name and key but it seems this isn't possible. The newer Azure.ResourceManager.Storage seems to have the same problem. We could upload a test blob and check if the response contains a version id but this not ideal.  Environment:  Name and version of the Library package used: Azure.Storage.Blobs 12.8.0, Microsoft.Azure.Management.Storage 22.0.0 Hosting platform or OS and .NET runtime version Windows 10, .NET Framework 4.6.1  EDIT: Having a way to enable versioning would be ideal but we can live with just checking and directing users to enable it manually.
Client	Service Bus	Searching a recommendation to which Azure Service bus package to install	Query/Question Hi there! We're the infrastructure team in the company and we built our infrastructure using the Microsoft.Azure.ServiceBus package of yours which last maintained in April, I see all your documentation examples for Azure service bus are using the Azure.Messaging.ServiceBus package which also last maintained in April this year. I wonder which package are you maintaining from them and of course, which package should we use? Do you recommend to plan a migration to the Azure.Messaging.ServiceBus package or to stay for now with the package we already integrated?
Client	Service Bus	[QUERY] Service Bus Transaction Difficulties	Query/Question Can transaction scopes be used with Azure Service bus? Stack Overflow question: https://stackoverflow.com/questions/67892423/azure-service-bus-with-transaction-scope  (SEE BELOW) Environment: Azure.Messaging.ServiceBus 7.1.0 Hosting platform or OS and .NET runtime version: Windows 10.0.19042, .NET 5.0.103 IDE and version : Visual Studio 16.8.2
Client	Batch	[FEATURE REQ] Make batchClient Mockable	Library or service name. What library or service is this request related to? [e.g. Azure.Storage.Blobs] Azure.Batch.BatchClient Is your feature request related to a problem? Please describe. What feature would you like to get added? What problem is it solving? Currently it is not possible to Mock a BatchClient using Moq due to batchClient having no  Interface or public constructor. Would it be possible to make the private constructor public, or add an interface for this. Example of error when mocking batchClient: _mockBatchClient = new Mock<BatchClient>(); _mockBatchClientFactory                     .Setup(_ => _.CreateBatchClient(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()))                     .Returns(_mockBatchClient.Object); This results in the error previously mentioned: Castle.DynamicProxy.InvalidProxyConstructorArgumentsException : Can not instantiate proxy of class: Microsoft.Azure.Batch.BatchClient. Could not find a parameterless constructor.
Client	Service Bus	[BUG] To property of ServiceBusMessage in Azure.Messaging.ServiceBus v7.1.2 cannot be null	Describe the bug Dear Azure SDK team, ServiceBusMessage.To property cannot have null value. It is a breaking change against Microsoft.Azure.ServiceBus v5.1.2. This breaking change complicates our effort to migrate to the new SDK. We use To property in our SQL rules like this: $`AND (sys.To IS NULL OR sys.To = '{subscriptionSettings.SubscriptionName}')`;. Now I never get NULL in the To property when the message is sent by the new SDK so I will never get messages to my subscription. Expected behavior var message = new ServiceBusMessage(); Assert.IsNull(message.To); Actual behavior (include Exception or Stack Trace) var message = new ServiceBusMessage(); Assert.AreEqual(message.To, ``); Underlying object has nullable struct AmqpAddress for To property but Nullable<T>.ToString() returns an empty string when null. To Reproduce As described above. Environment:  Name and version of the Library package used: Azure.Messaging.ServiceBus v7.1.2
Client	Synapse	[BUG] Synapse artifact resource serialization does not preserve artifact name	Describe the bug When serializing an artifact resource, e.g. a LinkedServiceResource, the name of the artifact is not emitted in the JSON. (This is likely to affect the other properties on SubResource, e.g. etag, id and type.) Expected behavior I would expect the name property to be emitted to the JSON, preserving the information that was deserialized. Actual behavior (include Exception or Stack Trace) None of the properties on the base SubResource class are written to the JSON. To Reproduce .NET Fiddle using System; using System.Text.Json;      using Azure.Analytics.Synapse.Artifacts.Models;  public class Program {  public static void Main()  {   var linkedService = JsonSerializer.Deserialize<LinkedServiceResource>(@`{   'name': 'MyKeyVault',   'properties': {     'annotations': [],     'type': 'AzureKeyVault',     'typeProperties': {       'baseUrl': 'https://myvault.vault.azure.net/'     }   } }`.Replace(`'`, `\``));      // Outputs MyKeyVault   Console.WriteLine(linkedService.Name);      var serialized = JsonSerializer.Serialize(linkedService);      // Outputs {`properties`:{`type`:`AzureKeyVault`,`annotations`:[],`typeProperties`:{`baseUrl`:`https://myvault.vault.azure.net/`}}}   Console.WriteLine(serialized);  } } Environment:  Azure.Analytics.Synapse.Artifacts 1.0.0-preview.10  .NET SDK (reflecting any global.json): Version:   5.0.300 Commit:    2e0c8c940e Runtime Environment: OS Name:     Windows OS Version:  10.0.19043 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\5.0.300\ Host (useful for support): Version: 5.0.6 Commit:  478b2f8c0e  Visual Studio 16.10.0
Mgmt	Service Bus	Fetching topics having slashes raises an Argument exception	Describe the bug Having a topic endpoint with slashes in the name under a service bus namespace, while fetching it with IServiceBusNamespace.Topics it gives an ArgumentException with message The specified ID is not a valid Azure resource ID. Expected behavior I can fetch all the topics regardless of having slashes in their names. Actual behavior (include Exception or Stack Trace) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceId..ctor(String id) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceId.FromString(String id) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.IndependentChildImpl7.SetParentName(InnerResourceT inner) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.IndependentChildImpl7.SetInner(InnerResourceT inner) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceActions.IndexableRefreshableWrapper2..ctor(String name, InnerResourceT innerObject) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceActions.Creatable4..ctor(String name, InnerResourceT innerObject) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.ResourceActions.CreatableUpdatable5..ctor(String name, InnerResourceT innerObject) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.IndependentChildImpl7..ctor(String name, InnerResourceT innerObject, ManagerT manager) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.IndependentChildResourceImpl7..ctor(String name, InnerModelT innerObject, ManagerT manager) at Microsoft.Azure.Management.ServiceBus.Fluent.TopicImpl..ctor(String resourceGroupName, String namespaceName, String name, Region region, TopicInner inner, IServiceBusManager manager) at Microsoft.Azure.Management.ServiceBus.Fluent.TopicsImpl.WrapModel(TopicInner inner) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.PagedCollection2.<>c__DisplayClass15_0.<b__0>d.MoveNext() --- End of stack trace from previous location where exception was thrown --- at Microsoft.Azure.Management.ResourceManager.Fluent.Core.PagedCollection2.<>c__DisplayClass21_0.<<AddCollection>b__0>d.MoveNext() --- End of stack trace from previous location where exception was thrown --- at Microsoft.Azure.Management.ResourceManager.Fluent.Core.PagedCollection2.AddCollection(IPage1 currentPage, PagedCollection2 pagedCollection, CancellationToken cancellationToken) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.PagedCollection2.LoadPageWithWrapModelAsync(Func2 listInnerAsync, Func3 listInnerNext, Func3 wrapModelAsync, Boolean loadAllPages, CancellationToken cancellationToken) at Microsoft.Azure.Management.ResourceManager.Fluent.Core.PagedCollection2.LoadPage(Func2 listInnerAsync, Func3 listInnerNext, Func2 wrapModel, Boolean loadAllPages, CancellationToken cancellationToken) at Microsoft.Azure.Management.ServiceBus.Fluent.ServiceBusChildResourcesImpl`6.ListAsync(Boolean loadAllPages, CancellationToken cancellationToken) To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Create a topic under an azure service bus namespace with slashes in the name (e.g sample/topic) Then fetch the topics with IServiceBusNamespace.Topics and then you get an error  Environment:  Microsoft.Azure.Management.ServiceBus.Fluent 1.37.1
Client	Service Bus	[BUG] Service Bus: Unknown error after calling GetNamespaceInfo	Describe the bug When I call client.GetNamespaceInfoAsync it is returning an exception. The message shows an `unknown error`. Expected behavior Throw an error that is not unknown or successful. Actual behavior (include Exception or Stack Trace) Returning unknown error. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  start the clientManagement call GetNamespaceInfoAsync     at Microsoft.Azure.ServiceBus.Management.NamespaceInfoExtensions.ParseFromContent(String xml)    at Microsoft.Azure.ServiceBus.Management.ManagementClient.<GetNamespaceInfoAsync>d__9.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()  Environment:  Name and version of the Library package used: Microsoft.Azure.ServiceBus 5.1.3 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8] netstandard2.1, called by netcoreapp3.1 IDE and version : [e.g. Visual Studio 16.3] VS16.10
Client	Communication	Get search/purchase operation by ID	Can SDK expose a method to get SearchAvailablePhoneNumbersOperation and PurchasePhoneNumbersOperation by ID? Since these are long-running operations, we don't want to `await` for their completion because that would block our client/UI. Instead, we want to run them and schedule a task that, once arrived, looks up if the operation is completed or still running. Since we don't have the operation in the memory at this point, we can't use .HasCompleted property of the operation itself - we need to fetch it and look up it's state.
Client	Event Hubs	[QUERY/Feature Request] Determining payload size on EventDataBatch before adding to batch.	I am wondering if there is an API to determine the payload size on the EventDataBatch. We have noticed so far that there is some 16byte overhead per each message added meaning that the byte[].Length property cannot be used to determine the payload size on batch. Are there any other peculiarities that should be taken into account besides the 16 byte overhead? If that is that, this is something that we could consider hardcoding at the moment. The reason why I'd like to know the size in bytes on the batch beforehand is that I am consuming messages from a message queue and a single queue message contains multiple events. In order to prevent any data loss all events must fit onto the batch and reach the hub safe and sound before popping the message of the queue. For that I need to know the size of an event on batch before adding it to the batch as there is no api to remove events of the batch. p.s. not sure what is the API design process, but as far as the code is concerned I could raise a PR with a couple of hints from you guys on where to look at.
Client	Synapse	[BUG] Synapse LibraryClient AppendAsync results in 409 conflict instead of 201 created	Describe the bug When trying to upload a synapse workspace library using the following calls, the AppendAsync fails with 409 conflict: LibraryAlreadyExists. However it looks like it is missing the query string comp=appendblock parameter here which if supplied, allows a library to be uploaded directly against REST API (i.e. not via SDK). Expected behavior Expect 201 Created response. Actual behavior (include Exception or Stack Trace) Azure.RequestFailedException: Service request failed. Status: 409 (Conflict)  Content: {`code`:`LibraryAlreadyExists`,`message`:`The LibraryArtifact my_library-0.0.32-py3-none-any.whl already exists.`}  Headers: Server: Microsoft-HTTPAPI/2.0 Strict-Transport-Security: REDACTED x-ms-request-id: REDACTED x-ms-client-request-id: 36fa6ca1-08ec-4124-b90c-de1b71661a1c Date: Tue, 04 May 2021 14:35:23 GMT Content-Length: 132 Content-Type: application/json; charset=utf-8     at Azure.Analytics.Synapse.Artifacts.LibraryRestClient.AppendAsync(String libraryName, Stream content, Nullable`1 xMsBlobConditionAppendpos, CancellationToken cancellationToken)    at Azure.Analytics.Synapse.Artifacts.LibraryClient.AppendAsync(String libraryName, Stream content, Nullable`1 xMsBlobConditionAppendpos, CancellationToken cancellationToken)  To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) var uri = new Uri($`https://{workspace}.dev.azuresynapse.net`); var options = new ArtifactsClientOptions() {                                 };  var filename = Path.GetFileName(file);  var cred = new ClientSecretCredential(     Environment.GetEnvironmentVariable(`AZURE_TENANT_ID`),     Environment.GetEnvironmentVariable(`AZURE_CLIENT_ID`),     Environment.GetEnvironmentVariable(`AZURE_CLIENT_SECRET`));  var client = new LibraryClient(uri, cred, options);  var startResponse = await client.StartCreateAsync(filename, cancellationToken); await startResponse.WaitForCompletionAsync();  using (Stream s = File.OpenRead(file)) {     var response = await client.AppendAsync(filename, s);     Console.WriteLine(`Append status code is ` + response.Status); }  var flush = await client.StartFlushAsync(filename, cancellationToken);             var flushWaitResponse = await flush.WaitForCompletionAsync(); Environment:  Name and version of the Library package used: Azure.Analytics.Synapse.Artifacts 1.0.0-preview.8 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8]  .NET Core SDK (reflecting any global.json): Version:   3.1.406 Commit:    f42e6b201a  Runtime Environment: OS Name:     Windows OS Version:  10.0.19042 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\3.1.406\  Host (useful for support):  Version: 3.1.12  Commit:  0267ad09c6  .NET Core SDKs installed:  2.1.602 [C:\Program Files\dotnet\sdk]  2.1.700 [C:\Program Files\dotnet\sdk]  2.1.803 [C:\Program Files\dotnet\sdk]  3.1.101 [C:\Program Files\dotnet\sdk]  3.1.406 [C:\Program Files\dotnet\sdk]  .NET Core runtimes installed:  Microsoft.AspNetCore.All 2.1.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]  Microsoft.AspNetCore.All 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]  Microsoft.AspNetCore.All 2.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]  Microsoft.AspNetCore.App 2.1.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]  Microsoft.AspNetCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]  Microsoft.AspNetCore.App 2.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]  Microsoft.AspNetCore.App 3.1.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]  Microsoft.AspNetCore.App 3.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]  Microsoft.NETCore.App 2.1.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]  Microsoft.NETCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]  Microsoft.NETCore.App 2.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]  Microsoft.NETCore.App 3.1.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]  Microsoft.NETCore.App 3.1.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]  Microsoft.WindowsDesktop.App 3.1.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  Microsoft.WindowsDesktop.App 3.1.12 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   IDE and version : [e.g. Visual Studio 16.3] n/a
Service	Event Hubs	[QUERY] Event Hubs. Partition Keys, Event Batching and Load Balancing	By sending out event batches with partitionId assigned, I suspect, it can get into the situations where the load is not distributed evenly across all of the partitions. What if the batches were sent out with partitionKey set instead of the partitionId and let's say there are 12 different partitionKey values possible and 6 partitions available. Would this lead to a more evenly balanced load i.e. 2 keys per 1 partition? I was not able to find any documentation on what happens when there are more keys than partitions, if there is any load balancing under the hood. Thanks!
Client	Extensions	Azure.Extensions.AspNetCore.DataProtection.Blobs should create container if not exists	Library or service name. Azure.Extensions.AspNetCore.DataProtection.Blobs Is your feature request related to a problem? Please describe. I call PersistKeysToAzureBlobStorage in Startup and expect everything should work out of box, but I have to create container manually.
Client	Cognitive - Text Analytics	[FEATURE REQ] Azure.Ai.TextAnalytics - supported languages for sentiment analysis	Azure.Ai.TextAnalytics I would like to add an endpoint to get the list of supported languages for sentiment analysis. Also, it would be helpful to get the detected language for each document in the response of TextAnalyticsClient.AnalyzeSentiment method. Thank you! This is a great tool! Eduardo
Service	Event Hubs	[FEATURE REQ] Provide system property identifying party that inserted the event	We are using Azure.Messaging.EventHubs to produce events at various apps and consume them in other app. We primarily use AAD to authenticate against Event Hubs despite there are other authentication schemas. Now because there are multiple producers, we would like to verify the authenticity of the producer. This cannot be achieved by adding additional property to event (properties) by producers itself as there is no authority guaranteeing its authenticity. Because AAD authentication validation happens server side and is the only authority, we would like the EventHub service to fill SystemProperties server side with App Id / Tenant Id or other sort of information related to that authentication. I don't see an issue to have it only for certain scenarios (AAD app auth). Is there anything like this possible?
Service	Data Factory	[BUG] AzureDatafactory log send to EventHub results in an incorrect JSON Format	I have plug the diagnostic reports to be sent to an event hub (try basic and standard tier). I choose only `ActivityRuns`, `PipelineRuns`, `TriggersRun` because we don't have any SSIS. When I access the hub, and and want to see the preview of the log in JSON, there is a message : ` Source '<unknown_location>' had 1 occurrences of kind 'InputDeserializerError.InvalidData' between processing times '2021-04-20T12:20:35.9747529Z' and '2021-04-20T12:20:35.9747529Z'. Could not deserialize the input event(s) from resource 'Partition: [0], Offset: [114888], SequenceNumber: [62]' as Json. Some possible reasons: 1) Malformed events 2) Input source configured with incorrect serialization format ` even in CSV, the file is not fomat correctly. But if I export in a blob storage, json file is correctly formatted. I've put a zip with csv file out from eventhub. eventHub_sample.zip    Thanks for your help
Mgmt	SQL	[QUERY] How to use the Microsoft.Azure.Management.Sql.Fluent to pause database	Query/Question I noticed there is a PauseAsync in Microsoft.Azure.Management.Sql.Fluent.DatabasesOperationsExtensions. And it expects an IDatabasesOperations. I googled lots of places: Microsoft.com, github etc., even reading through the source code of the sdk, could not find out what exact object I should pass that implements that interface. I tried: FooIAzure.SqlServers.Inner And I tried: var sqlServer = azure.SqlServers.GetByResourceGroup(`FooRG`, `FooServer`);  var sqlDatabase = azure.SqlServers.Databases.GetById(`FooDatabase');  sqlDatabase.PauseAsync(); //not the right interface sqlDatabase.Inner.PauseAsync(); //not the right interface   Environment:  Name and version of the Library package used: [Microsoft.Azure.Management.Fluent 1.37.1] Hosting platform or OS and .NET runtime version   .NET SDK (reflecting any global.json): Version:   5.0.201 Commit:    a09bd5c86c Runtime Environment: OS Name:     Windows OS Version:  10.0.17763 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\5.0.201\ Host (useful for support): Version: 5.0.4 Commit:  f27d337295 .NET SDKs installed: 2.1.809 [C:\Program Files\dotnet\sdk] 5.0.201 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.21 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.21 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.1.26 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.13 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] To install additional .NET runtimes or SDKs: https://aka.ms/dotnet-download   IDE and version : [Visual Studio 16.9.2]
Client	Search	[FEATURE REQ] Azure Search Geo.Distance in Select result	Currently, we can filter or sort Azure Search documents by geo.distance but not able to get the distance in the Select result. There is a UserVoice request at https://feedback.azure.com/forums/263029-azure-search/suggestions/17760211-support-geo-distance-in-select-result to add Geo.Distance in Select result. Azure Cosmos Db supports returning distance between two points in Select query so it would be great if we can implement the same in Azure Search too.
Client	Azure.Core	[BUG] Erroneous warning logs when performing CreateIfNotExistsAsync	Describe the bug The following code logs a warning: var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(b => b.AddConsole()); serviceCollection.AddAzureClients(ab => ab.AddBlobServiceClient(`UseDevelopmentStorage=true`)); var serviceProvider = serviceCollection.BuildServiceProvider();  var client = serviceProvider.GetRequiredService<BlobServiceClient>(); var container = client.GetBlobContainerClient(Guid.NewGuid().ToString()); await container.CreateIfNotExistsAsync(); await container.CreateIfNotExistsAsync(); // here  Expected behavior No warning is logged, we're not doing anything out of the ordinary which should trigger a warning for our operators. Actual behavior (include Exception or Stack Trace) It logs a warning, sample: warn: Azure-Core[8]       Error response [e5d2b146-8b40-47dc-8e0a-f12a623487d4] 409 The specified container already exists. (00.0s)       Server:Windows-Azure-Blob/1.0,Microsoft-HTTPAPI/2.0       x-ms-request-id:01ffe3d0-ee47-44d7-a35d-9303d108d19e       x-ms-version:2020-04-08       x-ms-error-code:ContainerAlreadyExists       Date:Wed, 31 Mar 2021 07:31:06 GMT       Content-Length:230       Content-Type:application/xml  To Reproduce See example above. Environment:  Name and version of the Library package used: Azure.Storage.Blobs 12.8.1 (but earlier versions as well) Hosting platform or OS and .NET runtime version: up-to-date Windows 10 at least in NET Framework 4.8 and .NET Core 3.1 IDE and version : up-to-date Visual Studio 2019
Client	Cognitive - Form Recognizer	[BUG] AI.FormRecognizer SDK not parsing date correctly	Describe the bug Even though the form recognizer service is returning the correct date from a form, the SDK is failing at parsing it. Expected behavior I expect the DateTime to be parsed in the right format, or at least to have some control over the locale which should be used for parsing. Actual behavior (include Exception or Stack Trace) The ValueData property holds the string with the correct datetime value (nl-NL locale format), but the operation FormField.Value.AsDate() returns the error from line                azure-sdk-for-net/sdk/formrecognizer/Azure.AI.FormRecognizer/src/FieldValue.cs                    Line 266       in       b752803                                                 throw new InvalidOperationException($`Field value is null.`);                    . This indicates the string value was not correctly parsed to a valid DateTime object. Example:  This perfectly valid date will throw the above error when trying to retrieve it using AsDate(). To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Recognize a document in another locale than en-US Try to exact a DateTime field as mentioned  Environment:  Azure.AI.FormRecognizer Windows 10, .NET SDK 5.0.201, Host version 5.0.4 Visual Studio 16.9.2
Client	Tables	[FEATURE REQ] Allow specific properties to be ignored on ITableEntity implementation	Library or service name. Azure.Data.Tables Is your feature request related to a problem? Please describe. Currently all public instance properties on an ITableEntity implementation are serialized to Azure Table Storage.                azure-sdk-for-net/sdk/tables/Azure.Data.Tables/src/Extensions/TableEntityExtensions.cs                    Line 24       in       533ee25                                                 var properties = typeof(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);                     For my scenario, I have several read-only (no setter), convenience properties that I do not want serialized to Table Storage. Also, I have other properties that have both getters and setters than I do not want serialized. This latter case are nullable enum properties that are workarounds for #19769. In both { get; } and { get; set; } cases, I want to be able to mark specific properties as ignored. In WindowsAzure.Storage, you can do this with an [IgnoreProperty] attribute. There are also analogies in Newtonsoft.Json, System.Text.Json, etc. One question is whether { get; } only properties should ever be serialized considering they fail round-tripping with this exception: Result Message: System.ArgumentException : Property set method not found. Result StackTrace:  at System.Reflection.RuntimePropertyInfo.SetValue(Object obj, Object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)    at System.Reflection.RuntimePropertyInfo.SetValue(Object obj, Object value, Object[] index)    at Azure.Data.Tables.DictionaryTableExtensions.ToTableEntity[T](IDictionary`2 entity, PropertyInfo[] properties)    at Azure.Data.Tables.DictionaryTableExtensions.ToTableEntityList[T](IReadOnlyList`1 entityList)    at Azure.Data.Tables.TableClient.<>c__DisplayClass33_0`1.<<QueryAsync>b__0>d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at Azure.Core.PageableHelpers.FuncAsyncPageable`1.AsPages(String continuationToken, Nullable`1 pageSizeHint)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+MoveNext()    at Azure.AsyncPageable`1.GetAsyncEnumerator(CancellationToken cancellationToken)+System.Threading.Tasks.Sources.IValueTaskSource<System.Boolean>.GetResult()    at System.Linq.AsyncEnumerable.<ToListAsync>g__Core|620_0[TSource](IAsyncEnumerable`1 source, CancellationToken cancellationToken) in /_/Ix.NET/Source/System.Linq.Async/System/Linq/Operators/ToList.cs:line 36    at System.Linq.AsyncEnumerable.<ToListAsync>g__Core|620_0[TSource](IAsyncEnumerable`1 source, CancellationToken cancellationToken) in /_/Ix.NET/Source/System.Linq.Async/System/Linq/Operators/ToList.cs:line 36    at Knapcode.ExplorePackages.Worker.BaseCatalogScanIntegrationTest.AssertEntityOutputAsync[T](TableClient table, String dir, Action`1 cleanEntity) in C:\z\Git\joelverhagen\ExplorePackages\test\ExplorePackages.Worker.Logic.Test\TestSupport\BaseCatalogScanIntegrationTest.cs:line 90    at Knapcode.ExplorePackages.Worker.FindLatestCatalogLeafScan.FindLatestCatalogLeafScanIntegrationTest.AssertOutputAsync(String dir) in C:\z\Git\joelverhagen\ExplorePackages\test\ExplorePackages.Worker.Logic.Test\CatalogScan\Drivers\Internal_FindLatestCatalogLeafScan\FindLatestCatalogLeafScanIntegrationTest.cs:line 118    at Knapcode.ExplorePackages.Worker.FindLatestCatalogLeafScan.FindLatestCatalogLeafScanIntegrationTest.Internal_FindLatestCatalogLeafScan.Execute() in C:\z\Git\joelverhagen\ExplorePackages\test\ExplorePackages.Worker.Logic.Test\CatalogScan\Drivers\Internal_FindLatestCatalogLeafScan\FindLatestCatalogLeafScanIntegrationTest.cs:line 35 --- End of stack trace from previous location where exception was thrown ---  Workarounds:  Implement these properties as GetFoo() or SetFoo(...) methods for ignored properties. Implement an IDictionary<string, object> instead of ITableEntity and manage the dictionary building yourself.
Client	Service Bus	Service Bus: System.ObjectDisposedException when opening a receiver link	Hi,  I am getting thousands of ObjectDisplosedException a day throw out of Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope.OpenReceiverLinkAsync() at line 312.  By looking into the servicebus source code, the problem is the ActiveConnection was disposed. The version of Azure.Messaging.ServiceBus is 7.1.0.0.  Is this an issue of servicebus code? Any suggestion? My sample code is provided at the end. Thanks Exception Detail: {`HResult`:-2146232798,`Message`:`Cannot access a disposed object.\r\nObject name: 'FaultTolerantAmqpObject1'.`,`Source`:`Microsoft.Azure.Amqp`,`ObjectName`:`FaultTolerantAmqpObject1`,`Type`:`System.ObjectDisposedException`} Call Stack: System.ObjectDisposedException:    at Microsoft.Azure.Amqp.Singleton`1+<GetOrCreateAsync>d__13.MoveNext (Microsoft.Azure.Amqp, Version=2.4.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.Amqp.AmqpConnectionScope+<OpenReceiverLinkAsync>d__54.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<OpenReceiverLinkAsync>d__30.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Microsoft.Azure.Amqp.FaultTolerantAmqpObject`1+<OnCreateAsync>d__6.MoveNext (Microsoft.Azure.Amqp, Version=2.4.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Microsoft.Azure.Amqp.Singleton`1+<GetOrCreateAsync>d__13.MoveNext (Microsoft.Azure.Amqp, Version=2.4.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Microsoft.Azure.Amqp.Singleton`1+<GetOrCreateAsync>d__13.MoveNext (Microsoft.Azure.Amqp, Version=2.4.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<ReceiveMessagesAsyncInternal>d__34.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<ReceiveMessagesAsyncInternal>d__34.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<>c__DisplayClass33_0+<<ReceiveMessagesAsync>b__0>d.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy+<RunOperation>d__20.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.ServiceBusRetryPolicy+<RunOperation>d__20.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.Amqp.AmqpReceiver+<ReceiveMessagesAsync>d__33.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.ServiceBusReceiver+<ReceiveMessagesAsync>d__37.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.ServiceBusReceiver+<ReceiveMessageAsync>d__39.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)    at Azure.Messaging.ServiceBus.ReceiverManager+<ReceiveAndProcessMessagesAsync>d__19.MoveNext (Azure.Messaging.ServiceBus, Version=7.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8)  My sample code:     public class QueueWorker<TMessage> : BackgroundService where TMessage : class     {         private readonly IProcessQueueMessages<TMessage> _messageProcessor;          private readonly ServiceBusClient _serviceBusClient;          protected ILogger<QueueWorker<TMessage>> Logger { get; }          public QueueWorker(ILogger<QueueWorker<TMessage>> logger, IProcessQueueMessages<TMessage> messageProcessor, ServiceBusClient serviceBusClient)         {             Logger = logger;             _messageProcessor = messageProcessor;             _serviceBusClient = serviceBusClient;         }          protected override async Task ExecuteAsync(CancellationToken stoppingToken)         {             var queueName = _messageProcessor.QueueName;             if(string.IsNullOrWhiteSpace(queueName))             {                 Logger.LogWarning(_messageProcessor.QueueNameMissingWarningMessage);                 return;             }              var messageProcessor = CreateServiceBusProcessor(queueName);             messageProcessor.ProcessMessageAsync += HandleMessageAsync;             messageProcessor.ProcessErrorAsync += HandleReceivedExceptionAsync;              Logger.LogInformation($`Starting message pump on queue {queueName} in namespace {messageProcessor.FullyQualifiedNamespace}`);             await messageProcessor.StartProcessingAsync(stoppingToken);             Logger.LogInformation(`Message pump started`);              while (!stoppingToken.IsCancellationRequested)             {                 await Task.Delay(TimeSpan.FromSeconds(1));             }              Logger.LogInformation(`Closing message pump`);              messageProcessor.ProcessMessageAsync -= HandleMessageAsync;             messageProcessor.ProcessErrorAsync -= HandleReceivedExceptionAsync;              await messageProcessor.CloseAsync(cancellationToken: stoppingToken);             Logger.LogInformation(`Message pump closed : {Time}`, DateTimeOffset.UtcNow);         }          private ServiceBusProcessor CreateServiceBusProcessor(string queueName)         {             return _serviceBusClient.CreateProcessor(queueName);         }          private async Task HandleMessageAsync(ProcessMessageEventArgs processMessageEventArgs)         {             TMessage deserializedMessage = null;             try             {                 var rawMessageBody = Encoding.UTF8.GetString(processMessageEventArgs.Message.Body.ToArray());                 Logger.LogInformation(`Received message {MessageId} with body {MessageBody}`,                     processMessageEventArgs.Message.MessageId, rawMessageBody);                  deserializedMessage = JsonConvert.DeserializeObject<TMessage>(rawMessageBody);                 if (deserializedMessage != null)                 {                     await _messageProcessor.ProcessMessage(deserializedMessage, processMessageEventArgs.Message.MessageId,                         processMessageEventArgs.Message.ApplicationProperties,                         processMessageEventArgs.CancellationToken);                 }                 else                 {                     Logger.LogError(                         `Unable to deserialize to message contract {ContractName} for message {MessageBody}`,                         typeof(TMessage), rawMessageBody);                 }                  Logger.LogInformation(`Message {MessageId} processed`, processMessageEventArgs.Message.MessageId);                  await processMessageEventArgs.CompleteMessageAsync(processMessageEventArgs.Message);             }             catch (Exception ex)             {                 Logger.LogError(ex, `Unable to handle message: {ProcessMessageEventArgs}`, processMessageEventArgs);                  if(!_messageProcessor.CanRetry(ex, processMessageEventArgs.Message?.Body, deserializedMessage))                 {                     await processMessageEventArgs.DeadLetterMessageAsync(processMessageEventArgs.Message);                 }             }         }          private Task HandleReceivedExceptionAsync(ProcessErrorEventArgs exceptionEvent)         {             Logger.LogError(exceptionEvent.Exception, `Unable to process message`);             return Task.CompletedTask;         }     }
Mgmt	Network - Front Door	[BUG] Cannot create a Frontend within Front Door with HTTPS configuration via CreateOrUpdate method	Describe the bug Unable to create HTTPS configuration for a new Frontend endpoint in Azure Front Door via the CreateOrUpdate API. Expected behavior I would expect to be able to create a Frontend endpoint, specify its HTTPS configuration and have it created all in one go via the CreateOrUpdate method.  Looking at the docs for the CreateOrUpdate REST API it looks like this should be possible. Actual behavior What's actually happening is that my Frontend endpoint is being created, but the HTTPS configuration is missing.  I did some digging and I think I found the root cause.  Here in FrontdoorOperations.cs we serialize the object that contains the request body for the CreateOrUpdate REST API.  On that line you can see that we're passing the Client.SerializationSettings to our serialization library. Here in FrontendManagementClient.cs you can see that the serialization settings include the use of the ReadOnlyJsonContractResolver. Here in ReadOnlyJsonContractResolver you can see that we will NOT serialize any properties that have a private setter. In this scenario, the class that we're serializing is Microsoft.Azure.Management.FrontDoor.Models.FrontendEndpoint.  On this line you can see that the setter for the CustomHttpsConfiguration property is private.  Therefore, the ReadOnlyJsonContractResolver excludes that property from being serialized and included in the request body sent to the CreateOrUpdate REST API. Since the CustomHttpsConfiguration object is never being serialized and sent to the CreateOrUpdate REST API then it makes sense that the HTTPS configuration is not being applied for the newly created Frontend endpoint.  To Reproduce I've been trying to create Frontend endpoints via Powershell, but I believe that I have tracked down the root cause of the issue within the C# Azure SDK.  Here is the Powershell that I've been using: $new_front_end = New-AzFrontDoorFrontendEndpointObject `      -Name $title_host_name.Replace('.', '-') `      -HostName $title_host_name `      -CertificateSource AzureKeyVault `      -Vault $key_vault_resource_id `      -SecretName `my_ssl_cert` `      -MinimumTlsVersion `1.0`  $front_door.FrontendEndpoints += $new_front_end  Set-AzFrontDoor -InputObject $front_door If you're running Fiddler and grab the request being made to the CreateOrUpdate REST API you will see that the request body does not contain the properties.CustomHttpsConfiguration field in the new Frontend endpoint object. Environment:  Using Azure Powershell Az Modules version 5.6.0 I'm using Powershell version 5.1.19041.610.  I'm new to Powershell, but I think that means I'm running on .NET Full Framework.
Client	Search	Are attributes mandatory when reading from Azure Cognitive Search	Do I have to specify attributes like SimpleField on properties? I've copied my data by indexing from cosmos db, and I'm using the same model when trying to upload the documents but I'm getting 400. Copying over the object with those attributes included obviously works. @Mohit-Chakraborty
Client	Service Bus	[BUG] Deadletter Async causes a MessageLockLost Exception	Describe the bug We register a message handler. When an exception is thrown, because we cannot process the file, there is no point in retrying, so we catch the exception, and call DeadLetterAsync to move the message to the deadletter queue. This works as expected. However, it also throws an lockexpired exception from within Microsoft.Azure.ServiceBus Expected behavior Message is deadlettered, without exeptions Actual behavior (include Exception or Stack Trace) Message is deadlettered, with exception: EXCEPTION: Microsoft.Azure.ServiceBus.MessageLockLostException: The lock supplied is invalid. Either the lock expired, or the message has already been removed from the queue, or was received by a different receiver instance. at Microsoft.Azure.ServiceBus.Core.MessageReceiver.DisposeMessagesAsync(IEnumerable1 lockTokens, Outcome outcome) at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func1 operation, TimeSpan operationTimeout) at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func1 operation, TimeSpan operationTimeout) at Microsoft.Azure.ServiceBus.Core.MessageReceiver.AbandonAsync(String lockToken, IDictionary2 propertiesToModify) at Microsoft.Azure.ServiceBus.MessageReceivePump.AbandonMessageIfNeededAsync(Message message)    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.DisposeMessagesAsync(IEnumerable`1 lockTokens, To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue) public Task StartAsync(CancellationToken cancellationToken)         {             queueClient = new QueueClient(_config.ConnectionString, QueueName);              queueClient.RegisterMessageHandler(async (message, token) =>             {                 var messageBody = Encoding.UTF8.GetString(message.Body);                 var messageToHandle = JsonConvert.DeserializeObject<Message>(messageBody);                  try                 {                     await _customService.ProcessAsync(messageToHandle.Id, messageToHandle.Path)                         .ConfigureAwait(false);                      await queueClient.CompleteAsync(message.SystemProperties.LockToken)                         .ConfigureAwait(false);                 }                 catch (SystemException ex) when (ex is ArgumentNullException                         || ex is NotSupportedException                         || ex is System.IO.IOException)                 {                     await queueClient.DeadLetterAsync(message.SystemProperties.LockToken)                         .ConfigureAwait(false);                      throw;                 }               }, new MessageHandlerOptions(ExceptionReceivedHandlerAsync)             {                 MaxConcurrentCalls = 1,                 AutoComplete = false             });              return Task.CompletedTask;         }          /// <summary>         /// Stop listening to the service-bus queue.         /// </summary>         public async Task StopAsync(CancellationToken cancellationToken)         {             await queueClient.CloseAsync().ConfigureAwait(false);         }          private Task ExceptionReceivedHandlerAsync(ExceptionReceivedEventArgs exceptionDetails)         {             _logger.LogError(exceptionDetails.Exception);             return Task.CompletedTask;         } Environment:  Microsoft.Azure.ServiceBus (5.1.1) Windows Server 2016 IDE: Visual Studio Enterprise 2019, v16.8 .Net Standard 2.1
Client	Cognitive - Anomaly Detector	[BUG] AnomalyDetectorClient creates invalid url for ChangePointDetect	Describe the bug AnomalyDetectorClient creates following url for ChangePointDetect:  var _url = _baseUrl + (_baseUrl.EndsWith(`/`) ? `` : `/`) + `timeseries/changePoint/detect`; which then causes the Anomaly Detection API to respond with NotFound Expected behavior Url for ChangePointDetect should be created in lowercase: var _url = _baseUrl + (_baseUrl.EndsWith(`/`) ? `` : `/`) + `timeseries/changepoint/detect`; Actual behavior (include Exception or Stack Trace) SDK is responding with 404 for every ChangePointDetect request To Reproduce        public async Task ChangePointDetectAsync(ChangePointDetectRequest request)        {             request.Validate();             ChangePointDetectResponse response = await _anomalyDetectorClient.ChangePointDetectAsync(request);             response.Validate();         }
Mgmt	Network - Front Door	[BUG] FrontDoorModel maps 'Cname' to wrong property and is always null	Describe the bug The FrontDoorModel.Cname property is mapped to the JSON property properties.cname, which is wrong, resulting in FrontDoorModel.Cname always being null. Expected behavior It should be mapped to the JSON property properties.cName. FrontDoorModel.Cname should not be null. Actual behavior (include Exception or Stack Trace) It is not mapped to the JSON property properties.cName. FrontDoorModel.Cname is always null. To Reproduce Use FrontDoorManagementClient to retrieve any Front Door instance. The FrontDoorModel.Cname property will be null. Environment:  Microsoft.Azure.Management.FrontDoor 4.0.0
Client	Docs	This is not documentation	There are no descriptions about anything in this whole library, it may as well not exist.  Document Details ⚠ Do not edit this section. It is required for docs.microsoft.com ➟ GitHub issue linking.  ID: 47aaa95f-a9c8-73ff-76d3-9075503b7c77 Version Independent ID: b34449e4-12f0-1910-7778-3a67fd1eef11 Content: ServiceClientTracing.NextInvocationId Property (Microsoft.Rest) - Azure for .NET Developers Content Source: xml/Microsoft.Rest/ServiceClientTracing.xml GitHub Login: @CamSoper Microsoft Alias: casoper
Client	Azure.Core	[BUG] Cannot access a disposed object.  Object name: 'SslStream' when when downloading files asynchronously using a blobClient in batch through a proxy	Creating an issue as a response to @pakrym: #17527 (comment) Describe the bug When reusing a BlobClient to download multiple files through a proxy(10 files that are around 18Mb each) in batch I hit an error that I can not access a disposed SslStream. Expected behavior I should be able to reuse a blobClient to asynchronously download blobs in batch. Actual behavior (include Exception or Stack Trace) The following error: System.ObjectDisposedException: Cannot access a disposed object.  Object name: 'SslStream'.     at System.Net.ConnectStream.EndRead(IAsyncResult asyncResult) at System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.Complete(TInstance thisRef, Func`3 endMethod, IAsyncResult asyncResult, Boolean requiresSynchronization)  --- End of stack trace from previous location where exception was thrown ---     at  System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at  System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at  System.Net.Http.HttpClientHandler.WebExceptionWrapperStream.<ReadAsync>d__4.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at  System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at  System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)     at  Azure.Core.Pipeline.ReadTimeoutStream.<ReadAsync>d__5.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at  System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at  Azure.Core.Pipeline.RetriableStream.RetriableStreamImpl.<ReadAsync>d__12.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at  System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at  Azure.Core.Pipeline.RetriableStream.RetriableStreamImpl.<RetryAsync>d__13.MoveNext()  --- End of stack trace from previous location where exception was thrown ---     at  System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()     at  Azure.Core.Pipeline.RetriableStream.RetriableStreamImpl.<ReadAsync>d__12.MoveNext()  --- End of stack trace from previous location where exception was thrown ---  To Reproduce private async Task Main(string[] args) {  var uri = new UriBuilder(`myUrl`)  {   Query =    `mySas`  }.Uri;  var options = new BlobClientOptions  {   Transport = new HttpClientTransport(new HttpClientHandler   {    Proxy = new WebProxy    {     Address = new Uri(`myProxy`)    }   })  };  var azureBlobClient = new BlobServiceClient(uri, options);  var containerClient = azureBlobClient.GetBlobContainerClient(`myContainer`);  var azureBlobNames = new List<string>();  // GetBlobAsync itself is not awaitable, but enumerating items is an awaitable action  foreach (var blob in containerClient.GetBlobs(    prefix:    @`myPrefix`)   )   if (blob.Name.EndsWith(`.parquet`))    azureBlobNames.Add(blob.Name);  using (var semaphore = new SemaphoreSlim(10))  {   var fileDownloadTasks = azureBlobNames.Select(azureBlobName => Task.Run(async () =>   {    // claim one    await semaphore.WaitAsync(CancellationToken.None);    try    {     await DownloadFileAsync(      containerClient,      azureBlobName     );    }    finally    {     // ensure we always release     semaphore.Release();    }   }, CancellationToken.None)).ToArray();   await Task.WhenAll(fileDownloadTasks);  } } private async Task DownloadFileAsync(  BlobContainerClient containerClient,  string blobName ) {  // strip out the relative path from blobName since DownloadToAsync does not generate directories  var destinationFilePath = $@`{Path.GetFileName(blobName)}`;  var blobClient = containerClient.GetBlobClient(blobName);  using (var stream = new FileStream(destinationFilePath, FileMode.OpenOrCreate))  {         // fails here   var download = await blobClient.DownloadAsync(CancellationToken.None);   using (var downloadInfo = download.Value)   {    await downloadInfo.Content.CopyToAsync(stream);   }  } } We can get around this by not using a Semaphore and doing downloads sequentially or instantiating a new blobClient for each blob file, but neither solution is desirable.  The example below is instantiating a new blobClient for each blob file which works, but opens up sockets that aren't immediatly reclaimed or reused, hence our hesitance to use this since our production machines might serve multiple requests (with multiple blobs) which doesn't scale using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Net; using System.Net.Http; using System.Threading; using System.Threading.Tasks; using Azure.Core.Pipeline; using Azure.Storage.Blobs; namespace ConsoleApp1 {  public class Program  {   public static async Task Main(string[] args)   {    var azureBlobNames = new List<string>();    using (var handler = new HttpClientHandler    {     Proxy = new WebProxy     {      Address = new Uri(`myProxy`)     }    })    {     var options = new BlobClientOptions     {      Transport = new HttpClientTransport(handler)     };     var uri = new UriBuilder(`myUrl`)     {      Query =       `mySas`     }.Uri;     var azureBlobClient = new BlobServiceClient(uri, options);     var containerClient = azureBlobClient.GetBlobContainerClient(`myContainer`);     // GetBlobAsync itself is not awaitable, but enumerating items is an awaitable action     foreach (var blob in containerClient.GetBlobs(       prefix:       @`myPrefix`)      )      if (blob.Name.EndsWith(`.parquet`))       azureBlobNames.Add(blob.Name);    }    using (var semaphore = new SemaphoreSlim(int.Parse(args[0])))    {     var fileDownloadTasks = azureBlobNames.Select(azureBlobName => Task.Run(async () =>     {      // claim one      await semaphore.WaitAsync(CancellationToken.None);      try      {       await DownloadFileAsync(        azureBlobName       );      }      finally      {       // ensure we always release       semaphore.Release();      }     }, CancellationToken.None)).ToArray();     await Task.WhenAll(fileDownloadTasks);    }   }   private static async Task DownloadFileAsync(    string blobName   )   {    // strip out the relative path from blobName since DownloadToAsync does not generate directories    var destinationFilePath = $@`{Path.GetFileName(blobName)}`;    using (var handler = new HttpClientHandler    {     Proxy = new WebProxy     {      Address = new Uri(`myProxy`)     }    })    {     var options = new BlobClientOptions     {      Transport = new HttpClientTransport(handler)     };     var uri = new UriBuilder(`myUrl`)     {      Query =       `mySas`     }.Uri;     var azureBlobClient = new BlobServiceClient(uri, options);     var containerClient = azureBlobClient.GetBlobContainerClient(`container`);     var blobClient = containerClient.GetBlobClient(blobName);     using (var stream = new FileStream(destinationFilePath, FileMode.OpenOrCreate))     {      var download = await blobClient.DownloadAsync(CancellationToken.None);      using (var downloadInfo = download.Value)      {       await downloadInfo.Content.CopyToAsync(stream);      }     }    }   }  } Environment:  Name and version of the Library package used: Azure.Storage.Blobs 12.7.0 Hosting platform or OS and .NET runtime version: Windows 10, .NET Framework 4.7.2 IDE and version : VS2019 version 16.5.0
Client	Search	[BUG] Search: GetIndexAsync fails when azure search profile has weights, but doesn't have a scoring function	Describe the bug I have a scoring profile setup on my index in Azure. The scoring profile has weights on two fields, but does not have a scoring function defined. After upgrade to client 11, SearchIndexClient.GetIndexAsync throws error: Unknown scoring function aggregation value. (Parameter 'value') Expected behavior Index is loaded without errors. Actual behavior (include Exception or Stack Trace) SearchIndexClient.GetIndexAsync throws error: Unknown scoring function aggregation value. (Parameter 'value') To Reproduce Setup an index in azure cloud. Set scoring profile to use weight, but to not use any scoring function. SearchIndexClient.GetIndexAsync on that index. Environment:  Azure.Search.Documents v11 .NET SDK 5.0.200-preview.20614.14 IDE and version : Visual Studio Version 16.9.0 Preview 3.0
Mgmt	API Management	[BUG] Microsoft.Azure.Management.ApiManagement UserOperations CreateOrUpdate does not contain notify parameter	Describe the bug According to documentation ApiManagement.UserOperations.CreateOrUpdate must contain notify parameter which should trigger welcome email. This parameter is missing in the latest version of Microsoft.Azure.Management.ApiManagement package Expected behavior I expect to be able to pass notify parameter to apiManagement.User.CreateOrUpdateAsync Actual behavior (include Exception or Stack Trace) There is no such parameter in apiManagement.User.CreateOrUpdateAsync To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Install package Microsoft.Azure.Management.ApiManagement -Version 6.0.0-preview Create ApiManagementClient Check apiManagement.User.CreateOrUpdateAsync  Environment:  Name and version of the Library package used: Microsoft.Azure.Management.ApiManagement -Version 6.0.0-preview dotnet Version:   5.0.200-preview.20601.7 Commit:    b3b934bbf2 OS Name:     Windows OS Version:  10.0.19041 OS Platform: Windows IDE and version: Visual Studio 16.3
Client	Azure.Core	[FEATURE REQ] Provide Task equivalents to IAsyncEnumerable methods	Related to Azure.Storage.Blobs, but may be more widespread. The SDK library exposes methods that return data e.g. GetBlobsAsync as either pages or through single items, both times via IAsyncEnumerable. Unfortunately, F# doesn't have any built-in way to consume these. You can sort of work around it by writing some code that flattens the result into a Task and returns the array of all blobs i.e. IAsyncEnumerable<'T> -> Task<'T array>. However, this changes the semantics of the query (rather than lazily returning items, it eagerly retrieves all of them). I propose either introducing something similar to the old storage SDK where you had a continuation token, or some other way to yield out a page of data e.g. skip / take (although I appreciate this might not really fit with the nature of e.g. blobs). Alternatively, provide methods which returns Task<T []> as well as IAsyncEnumerable<T>.
Client	Search	[BUG] Azure.Search throws when retreiving a SearchIndexer	Describe the bug Retrieving a SearchIndexer using Azure.Search.Documents.Indexes.SearchIndexerClient.GetIndexerAsync throws an exception Expected behavior No exception should be thrown You can see the problem is `mappingFunction`: { `name`: `base64Encode`, `parameters`: null } which has `parameters`: null and: https://github.com/Azure/azure-sdk-for-net/blob/Azure.Search.Documents_11.1.1/sdk/search/Azure.Search.Documents/src/Generated/Models/FieldMappingFunction.Serialization.cs if (property.NameEquals(`parameters`)) {     Dictionary<string, object> dictionary = new Dictionary<string, object>();     foreach (var property0 in property.Value.EnumerateObject())     { has this accessed without a check, which throws the exception below. (In the version on the master branch there is an additional check which will still throw an exception). This file is tagged as autogenerated, but I'm not clear how so I haven't sent a PR (feel free to point me in the right direction). Actual behavior (include Exception or Stack Trace) System.InvalidOperationException HResult=0x80131509 Message=The requested operation requires an element of type 'Object', but the target element has type 'Null'. Source=System.Text.Json StackTrace: at System.Text.Json.JsonElement.EnumerateObject() at Azure.Search.Documents.Indexes.Models.FieldMappingFunction.DeserializeFieldMappingFunction(JsonElement element) at Azure.Search.Documents.Indexes.Models.FieldMapping.DeserializeFieldMapping(JsonElement element) at Azure.Search.Documents.Indexes.Models.SearchIndexer.DeserializeSearchIndexer(JsonElement element) at Azure.Search.Documents.IndexersRestClient.d__19.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable1.ConfiguredTaskAwaiter.GetResult() at Azure.Search.Documents.Indexes.SearchIndexerClient.<GetIndexerAsync>d__48.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter1.GetResult() To Reproduce I do not know exactly how to reproduce this -- the indexer was created using the old Microsoft.Azure* libraries. Since this is an actual object that exists in Azure I believe I should be able to retrieve it however it was created. Here is the request and response as logged for the GetIndexerAsync call: [Informational] Azure-Core: Request [a01498a3-1a94-47c0-a207-4aaa9d976cb6] GET https://xxx.search.windows.net/indexers('file-upload-indexer')?api-version=2020-06-30 Accept:application/json; odata.metadata=minimal api-key:REDACTED x-ms-client-request-id:a01498a3-1a94-47c0-a207-4aaa9d976cb6 x-ms-return-client-request-id:true User-Agent:azsdk-net-Search.Documents/11.1.1,(.NET 5.0.2; Microsoft Windows 10.0.19042) client assembly: Azure.Search.Documents [Informational] Azure-Core: Response [a01498a3-1a94-47c0-a207-4aaa9d976cb6] 200 OK (00.3s) Cache-Control:no-cache Pragma:no-cache ETag:W/`0x8D85A6D49BB7052` client-request-id:a01498a3-1a94-47c0-a207-4aaa9d976cb6 x-ms-client-request-id:a01498a3-1a94-47c0-a207-4aaa9d976cb6 request-id:a01498a3-1a94-47c0-a207-4aaa9d976cb6 elapsed-time:228 OData-Version:4.0 Preference-Applied:REDACTED Strict-Transport-Security:REDACTED Date:Thu, 21 Jan 2021 16:43:04 GMT Content-Type:application/json; odata.metadata=minimal Expires:-1 Content-Length:1204 [Verbose] Azure-Core: Response [a01498a3-1a94-47c0-a207-4aaa9d976cb6] content: {`@odata.context`:`https://xxx.search.windows.net/$metadata#indexers/$entity`,`@odata.etag`:`\`0x8D85A6D49BB7052\``,`name`:`file-upload-indexer`,`description`:null,`dataSourceName`:`file-upload-datasource`,`skillsetName`:null,`targetIndexName`:`file-upload-index`,`disabled`:false,`schedule`:{`interval`:`PT2H`,`startTime`:`0001-01-01T00:00:00Z`},`parameters`:{`batchSize`:null,`maxFailedItems`:-1,`maxFailedItemsPerBatch`:null,`base64EncodeKeys`:null,`configuration`:{`failOnUnsupportedContentType`:false,`failOnUnprocessableDocument`:false,`indexStorageMetadataOnlyForOversizedDocuments`:true}},`fieldMappings`:[{`sourceFieldName`:`metadata_storage_size`,`targetFieldName`:`fileSize`,`mappingFunction`:null},{`sourceFieldName`:`metadata_storage_path`,`targetFieldName`:`key`,`mappingFunction`:{`name`:`base64Encode`,`parameters`:null}},{`sourceFieldName`:`metadata_storage_content_type`,`targetFieldName`:`contentType`,`mappingFunction`:null},{`sourceFieldName`:`metadata_storage_last_modified`,`targetFieldName`:`lastModified`,`mappingFunction`:null},{`sourceFieldName`:`metadata_storage_name`,`targetFieldName`:`name`,`mappingFunction`:null}],`outputFieldMappings`:[],`encryptionKey`:null} Environment:  Name and version of the Library package used: Azure.Search.Documents 11.1.1, Azure.Storage.Blobs 12.8.0 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects):  The project is targeting .NET Core 5 PS C:\Users\mark> dotnet --info .NET SDK (reflecting any global.json): Version:   5.0.102 Commit:    71365b4d42 Runtime Environment: OS Name:     Windows OS Version:  10.0.19042 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\5.0.102\ Host (useful for support): Version: 5.0.2 Commit:  cb5f173b96 .NET SDKs installed: 3.1.100 [C:\Program Files\dotnet\sdk] 3.1.101 [C:\Program Files\dotnet\sdk] 3.1.400 [C:\Program Files\dotnet\sdk] 3.1.404 [C:\Program Files\dotnet\sdk] 5.0.101 [C:\Program Files\dotnet\sdk] 5.0.102 [C:\Program Files\dotnet\sdk] .NET runtimes installed: Microsoft.AspNetCore.All 2.1.24 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.All 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.24 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.10 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 5.0.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.24 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 5.0.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.10 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 3.1.11 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App] Microsoft.WindowsDesktop.App 5.0.2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  IDE and version : Visual Studio 16.8.4
Client	Search	Cognitive Search: How to field map complex types	Query/Question I am setting up an index/indexer with the C# SDK.  I have documents with images.  I am using the ImageAnalysisSkill to get image captions.  I want to then use the MergeSkill to merge the captions with the rest of the text. I can merge simple fields, and I can see the captions in my index, but I cannot get the merge to work on the complex field. The index is: new ComplexField(`description`, true) {     Fields =     {         new SearchableField(`tags`, true) { IsFilterable = true, IsFacetable = true, IsSortable = false},         new ComplexField(`captions`, true)         {             Fields =             {                 new SearchableField(`text`) { IsFilterable = false, IsFacetable = false, IsSortable = false},                 new SimpleField(`confidence`, SearchFieldDataType.Double) { IsFilterable = false, IsFacetable = false, IsSortable = false}             }         }     } }, The mapping in the skill I am trying to use is: inputMappings.Add(new InputFieldMappingEntry(`itemsToInsert`) {     Source = @`/document/normalized_images/*/text` }); With a mapping in the indexer of: new FieldMapping(@`/document/normalized_images/*/text`) {TargetFieldName = `text`}, I have also tried to use as a mapping parameter: `/document/normalized_images/*description/captions/text, for both the skill and indexer. We don't seem to have any complex examples documented, although we actually have this exact case mentioned in the document as a use for the MergeSkill. Thanks. Environment:   Name and version of the Library package used: Azure.Search.Documents v11.2.0-beta2    Hosting platform or OS and .NET runtime version: azure functions runtime, but the same occurs if I run the code in VS Studio locally for debugging (Microsoft.Net.Sdk.Functions 3.0.11)   IDE and version : Visual Studio 16.8.3
Client	Search	Azure.Search.Document How to specify headers to capture telemetry	I'm currently using Azure.Search.Document v11.2.0-beta.2 with c# and I can't seem to be able to pass customHeaders in the Search method as suggested here: https://docs.microsoft.com/en-us/azure/search/search-traffic-analytics#step-2-request-a-search-id-for-correlation Is there another method that should be used to achieve this? Also, the procedure on the Azure Portal seems to refer to the previous Microsoft.Azure.Search package which I think has been deprecated in favor of Azure.Search.Document. Is that correct?
Client	Search	Azure.Search.Documents (11.2.0-beta.1) / Common SerializePropertyNamesAsCamelCase not available	Unable to use the SerializePropertyNamesAsCamelCase  attribute as a matching assembly/nuget Azure.Search.Common which contains the attribute is not available
Mgmt	Network - Application Gateway	[BUG] Problem While Creating a Basic Application Gateway Using the New Azure.ResourceManager.Network Library	Describe the bug An exception is thrown when trying to create a basic Application Gateway. Expected behavior Application Gateway should be created successfully. Actual behavior (include Exception or Stack Trace) Message: Service request failed. Status: 400 (Bad Request)  Content: {   `error`: {     `code`: `InvalidRequestFormat`,     `message`: `Cannot parse the request.`,     `details`: [       {         `code`: `MissingJsonReferenceId`,         `message`: `Value for reference id is missing. Path properties.httpListeners[0].properties.frontendIPConfiguration.`       },       {         `code`: `MissingJsonReferenceId`,         `message`: `Value for reference id is missing. Path properties.httpListeners[0].properties.frontendPort.`       },       {         `code`: `MissingJsonReferenceId`,         `message`: `Value for reference id is missing. Path properties.httpListeners[1].properties.frontendIPConfiguration.`       },       {         `code`: `MissingJsonReferenceId`,         `message`: `Value for reference id is missing. Path properties.httpListeners[1].properties.frontendPort.`       }     ]   } }  Headers: Cache-Control: no-cache Pragma: no-cache x-ms-request-id: REDACTED x-ms-client-request-id: cb9a5f00-31f7-461e-bf25-626042581094 Strict-Transport-Security: REDACTED Server: Microsoft-HTTPAPI/2.0,Microsoft-HTTPAPI/2.0 x-ms-ratelimit-remaining-subscription-writes: REDACTED x-ms-correlation-request-id: REDACTED x-ms-routing-request-id: REDACTED X-Content-Type-Options: REDACTED Date: Sat, 05 Dec 2020 19:12:09 GMT Content-Length: 859 Content-Type: application/json; charset=utf-8 Expires: -1  Stack Trace:    at Azure.ResourceManager.Network.ApplicationGatewaysRestOperations.<CreateOrUpdateAsync>d__12.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()    at Azure.ResourceManager.Network.ApplicationGatewaysOperations.<StartCreateOrUpdateAsync>d__31.MoveNext()    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()    at Cladular.Platform.Backend.Adapters.Azure.AzureAdapter.<CreateBasicGatewayAsync>d__11.MoveNext() in C:\Users\itayp\Source\Repos\cladular\platform\src\Backend\Adapters\AzureAdapter.cs:line 233  To Reproduce The problem seems to be related to the HttpListeners requiring the IDs of the frontend IP configuration and front port, which at that point don't exist, as they are created as part of the Application Gateway, as the HTTP listeners are. appGatewayConfig.HttpListeners.Add(new() {     Name = $`MyHttpListener`,     FrontendIPConfiguration = appGatewayConfig.FrontendIPConfigurations[0],     Protocol = ApplicationGatewayProtocol.Http,     FrontendPort = appGatewayConfig.FrontendPorts[0], });  I think it is similar to #3359 and #3361. Environment:  Name and version of the Library package used: Azure.ResourceManager.Network 1.0.0-preview.2
Client	Service Bus	[QUERY] Payload sent to the DiagnosticListeners	Query/Question The payload sent to the DiagnosticListerne differs in the packages Azure.Messaging.ServiceBus and Microsoft.Azure.ServiceBus, is this by design? In the Microsoft.Azure.ServiceBus package, the payload is the message received from the servicebus upon receiving messages shown here This is very usable when the object is, for instance, to adhere to the OpenTelemtry standards and export to any OpenTelemetry comtatible technology, not just ApplicationInsigths, However, in the new Microsoft.Azure.ServiceBus package, this information is not available in the current for, since the payload is just a copy of the activity used from here and not the received message, is this on purpose? Environment: Azure.Messaging.ServiceBus - current version Microsoft.Azure.ServiceBus - current version
Client	App Configuration	[QUERY] ConfigurationClient: How to check if requests number is throttled?	Query/Question I'm using ConfigurationClient to retrieve key values from Azure AppConfiguration store. But GetConfigurationSetting method just hangs when requests limit is reached. So, when I use GetConfigurationSetting/GetConfigurationSettings methods, how can I check if store responses with 429 error?
Mgmt	Kusto	[Kusto/ADX] Database principal assignment fails constantly if tried too early after app registration is created	My team is attempting to create ADX databases for customers onboarded to our solution. What that entails is the following:  Create the database Create an app registration in Azure AD Assign the app registration Viewer permission to the database  We have all of the logic for this in place and it works. The only problem that we have is that if we attempt to assign the database permission for the newly created app registration immediately after it is created then we get an error saying `System.Private.CoreLib: Exception while executing function: AssignDatabasePrincipal. Microsoft.Azure.Management.Kusto: [BadRequest] Entity ID '{app-registration-guid}' of type 'AAD Application Id' was not found in AAD tenant '{tenant-id}'. If we add a sleep for 30 seconds before calling our class that is attempting to assign the permission this works perfectly. This code resides on our OnboardingService.cs: Thread.Sleep(TimeSpan.FromSeconds(30));  await this.adxManagementService.AssignDatabasePrincipalPermissionAsync(databaseName, appRegistrationId, appRegistrationName, databasePrincipalRole, databasePrincipalType); So we decided to add a retry mechanism (simple for loop with try catch) to the code where we are assigning the permission This code resides on our AdxManagementService, which has a KustoManagementClient member variable. This is along the lines of what we were attempting to do: for (int i = 0; i < 5; i++) {    try    {       await client.DatabasePrincipalAssignments.CreateOrUpdateAsync(this.targetAzureDataExplorer.ResourceGroupName, this.targetAzureDataExplorer.ClusterName, databaseName, principalName, databasePrincipalAssignment);    }    catch (Exception ex)    {       logger.LogInformation(ex, ex.Message);       Thread.Sleep(TimeSpan.FromSeconds(30)); } The former fix works perfectly while the second retry implementation never works. Any subsequent calls to CreateOrUpdateAsync will fail if the first one did. We thought it was likely that there was some caching going on in the KustoManagementClient so we tried wrapping all usage of it in using(var client = new KustoManagementClient...) but to no avail. Can we invalidate some caching or force a clean retry somehow?
Mgmt	Monitor	[BUG] ApplicationInsightsManagementClient throws exception on WebTestLocations.ListAsync	Describe the bug Unable to deserialize the response ApplicationInsightsManagementClient.WebTestLocations.ListAsync Expected behavior I would not expect an errors Actual behavior (include Exception or Stack Trace) Microsoft.Rest.SerializationException HResult=0x80131500 Message=Unable to deserialize the response. Source=Microsoft.Azure.Management.ApplicationInsights StackTrace: at Microsoft.Azure.Management.ApplicationInsights.Management.WebTestLocationsOperations.d__5.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable1.ConfiguredTaskAwaiter.GetResult() at Microsoft.Azure.Management.ApplicationInsights.Management.WebTestLocationsOperationsExtensions.<ListAsync>d__1.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter1.GetResult() at AppInsightsApi.Program.d__0.MoveNext() in C:\Users\sesa220553\source\repos\AppInsightsApi\AppInsightsApi\Program.cs:line 55 This exception was originally thrown at this call stack: [External Code] Inner Exception 1: JsonSerializationException: Cannot deserialize the current JSON array (e.g. [1,2,3]) into type 'Microsoft.Azure.Management.ApplicationInsights.Management.Models.Page1`1[Microsoft.Azure.Management.ApplicationInsights.Management.Models.ApplicationInsightsComponentWebTestLocation]' because the type requires a JSON object (e.g. {`name`:`value`}) to deserialize correctly. To fix this error either change the JSON to a JSON object (e.g. {`name`:`value`}) or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array. Path '', line 1, position 1. It does return an expected response just seems like the sdk can't deal with it. The response is similar to [{`DisplayName`:`North Central US`,`Tag`:`us-il-ch1-azr`},{`DisplayName`:`West Europe`,`Tag`:`emea-nl-ams-azr`},{`DisplayName`:`Southeast Asia`,`Tag`:`apac-sg-sin-azr`},{`DisplayName`:`West US`,`Tag`:`us-ca-sjc-azr`},{`DisplayName`:`South Central US`,`Tag`:`us-tx-sn1-azr`},{`DisplayName`:`East US`,`Tag`:`us-va-ash-azr`},{`DisplayName`:`East Asia`,`Tag`:`apac-hk-hkn-azr`},{`DisplayName`:`North Europe`,`Tag`:`emea-gb-db3-azr`},{`DisplayName`:`Japan East`,`Tag`:`apac-jp-kaw-edge`},{`DisplayName`:`Australia East`,`Tag`:`emea-au-syd-edge`},{`DisplayName`:`France Central (Formerly France South)`,`Tag`:`emea-ch-zrh-edge`},{`DisplayName`:`France Central`,`Tag`:`emea-fr-pra-edge`},{`DisplayName`:`UK South`,`Tag`:`emea-ru-msa-edge`},{`DisplayName`:`UK West`,`Tag`:`emea-se-sto-edge`},{`DisplayName`:`Brazil South`,`Tag`:`latam-br-gru-edge`},{`DisplayName`:`Central US`,`Tag`:`us-fl-mia-edge`}] I can get this info by using ServiceClientTracing and intercepting the response and calling response.Content.ReadAsStringAsync().Result. To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Create new ApplicationInsightsManagementClient  var creds = SdkContext.AzureCredentialsFactory.FromServicePrincipal(_azureClientId, _azureClientSecret, _directoryId, _azureGlobalCloud); AppInsights = new ApplicationInsightsManagementClient(creds){SubscriptionId = _subscriptionId}; // Will throw on the below line var locations = await AppInsights.WebTestLocations.ListAsync(`common`, `MyAppinsights Instance`); Environment:  Microsoft.Azure.Management.ApplicationInsight 0.3.0-preview Net core 3.1 or Framework 4.8 IDE and version :  Visual Studio 16.7.2
Mgmt	Network - Network Watcher	[BUG] api-version for NetworkClient.ConnectionMonitors is invalid	The api-version '2020-04-01' is invalid. The supported versions are '2020-07-01,2020-06-01,2020-05-01,2020-01-01,2019-11-01,2019-10-01,2019-09-01,2019-08-01,2019-07-01,2019-06-01,2019-05-10,2019-05-01,2019-03-01,2018-11-01,2018-09-01,2018-08-01,2018-07-01,2018-06-01,2018-05-01,2018-02-01,2018-01-01,2017-12-01,2017-08-01,2017-06-01,2017-05-10,2017-05-01,2017-03-01,2016-09-01,2016-07-01,2016-06-01,2016-02-01,2015-11-01,2015-01-01,2014-04-01-preview,2014-04-01,2014-01-01,2013-03-01,2014-02-26,2014-04'.                 azure-sdk-for-net/sdk/network/Azure.ResourceManager.Network/src/Generated/ConnectionMonitorsRestOperations.cs                    Line 61       in       d9e73da                                                 uri.AppendQuery(`api-version`, `2020-04-01`, true);                                 var monitor = await network                 .ConnectionMonitors                 .StartCreateOrUpdateAsync(``, ``, `asdf`, new ConnectionMonitor                 {                     AutoStart = true,                     Destination = new ConnectionMonitorDestination                     {                         Address = `google.nl`,                         Port = 80                     },                      Location = `westeurope`,                     MonitoringIntervalInSeconds = 30,                      Source = new ConnectionMonitorSource(`/subscriptions/###/resourceGroups/asdf/providers/Microsoft.Compute/virtualMachines/###`),                                      });              await monitor.WaitForCompletionAsync(); <PackageReference Include=`Azure.ResourceManager.Network` Version=`1.0.0-preview.2` />
Mgmt	API Management	Microsoft.Azure.Management.ApiManagement -  create new Products programatically	Question How to create new Products for Azure API management instance using  Microsoft.Azure.Management.ApiManagement ? Environment:  I'm using Microsoft.Azure.Management.ApiManagement 6.0.0-preview Hosting platform or OS and .NET runtime version:  dotnet --info .NET Core SDK (reflecting any global.json):  Version:   3.1.402  Commit:    9b5de826fd  Runtime Environment:  OS Name:     Windows  OS Version:  10.0.18363  OS Platform: Windows  RID:         win10-x64  Base Path:   C:\Program Files\dotnet\sdk\3.1.402\  Host (useful for support):   Version: 3.1.8   Commit:  9c1330dedd  .NET Core SDKs installed:   2.2.110 [C:\Program Files\dotnet\sdk]   2.2.207 [C:\Program Files\dotnet\sdk]   3.1.101 [C:\Program Files\dotnet\sdk]   3.1.401 [C:\Program Files\dotnet\sdk]   3.1.402 [C:\Program Files\dotnet\sdk]  .NET Core runtimes installed:   Microsoft.AspNetCore.All 2.1.22 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]   Microsoft.AspNetCore.All 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]   Microsoft.AspNetCore.All 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]   Microsoft.AspNetCore.App 2.1.22 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.AspNetCore.App 3.1.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]   Microsoft.NETCore.App 2.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 2.1.22 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 2.2.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.NETCore.App 3.1.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]   Microsoft.WindowsDesktop.App 3.1.7 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]   Microsoft.WindowsDesktop.App 3.1.8 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  IDE and version :  Visual Studio Entreprise 2019 v 16.7.5  No where I see documentation for implementation. I started form this post to get a valid token by implementing ServiceClientCredentials after that I tired this code: public async Task<ProductContract> CreateAPIMroducts(myContract myData)         {             var serviceCredentials = new AzureApiManagementServiceCredentials(); //in this class I implement ServiceClientCredentials              ApiManagementClient myClient = new ApiManagementClient(serviceCredentials);              ProductContract productContract = new ProductContract(`displayName`);              ProductContract result =await myClient .Product.CreateOrUpdateAsync(myData.ResourceGroupName, myData.ServiceName, myData.ProductId, productContract);             return result;         } So I'm trying to create new Product into my APIM instance but I got this error: Microsoft.Rest.ValidationException: 'this.Client.SubscriptionId' cannot be null. What I understand is to assign my subscription with the client I use but I don't know if I'm right or not and how to do it Can you please challenge me with your ideas? thank you! 😊
Mgmt	ARM	IResourceGroupsOperations::ListAsync issues with Top clause	Describe the bug I use a service principal that can only access a single resource group. Using top=10 (ODataFilter) does not behave as I would expect. I get an empty result with a next link. The next link has an empty result with a next link and so on. Looping like this I can get the unique RG that is accessible from my service principle but it involves a lot of requests where I would expect being able to do so in a single request. Expected behavior Single request needed when using top=10 and when only 1 item is returned Actual behavior (include Exception or Stack Trace) Multiple requests needed to retrieve a single item To Reproduce Steps to reproduce the behavior (include a code snippet, screenshot, or any additional information that might help us reproduce the issue)  Use a service principal scoped to a specific resource group call IResourceManagementClient.ListAsync with a ODataFilter with top 10              var rgs = new List<string>();             var resp = await azureClient.ResourceGroups.ListAsync(new ODataQuery<ResourceGroupFilter>()             {                 Top = 10             }, cancellationToken: cancellationToken);             rgs.AddRange(resp.Select(x => x.Name));              while (resp.NextPageLink != null)             {                 resp = await azureClient.ResourceGroups.ListNextAsync(resp.NextPageLink, cancellationToken: cancellationToken);                 rgs.AddRange(resp.Select(x => x.Name));             }  Environment:  Name and version of the Library package used: Microsoft.Azure.Management.ResourceManager 3.10.0-preview Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8] IDE and version : [e.g. Visual Studio 16.3]
Mgmt	API Management	[BUG] `ODataQuery` incorrectly adds quotes to dates when building the query from an expression	Either ODataQuery incorrectly adds quotes to dates when building the query from an expression, or API-M cannot handle quoted date-values in it's queries. The result of ToString() for the following two values should be identical, but instead the variable queryFromExpression add quotes and encodes the values. The encoding of values isn't the problem, but the addition of quotes causing API-M to throw an exception. For context, this is when we are making Report requests from Azure API-M. var start = (DateTime.UtcNow - TimeSpan.FromDays(1)); var end = (DateTime.UtcNow - TimeSpan.FromSeconds(1));  var queryFromExpression = new ODataQuery<RequestReportRecordContract>(i => i.Timestamp >= start && i.Timestamp <= end); var queryFromString = new ODataQuery<RequestReportRecordContract>($`timestamp ge {start:o} and timestamp le {end:o}`); Expected behavior new ODataQuery<RequestReportRecordContract>(i => i.Timestamp >= start && i.Timestamp <= end).ToString() should equal $filter=timestamp ge 2020-09-30T16:47:41.9064247Z and timestamp le 2020-10-01T16:47:40.9064355Z  This is based upon what the Azure Portal makes as a request when you use the Analytics component within Azure API-M. Actual behavior (include Exception or Stack Trace) Instead new ODataQuery<RequestReportRecordContract>(i => i.Timestamp >= start && i.Timestamp <= end).ToString() equals $filter=timestamp ge '2020-09-30T16%3A47%3A41Z' and timestamp le '2020-10-01T16%3A47%3A40Z'  which leads to the Microsoft.Rest.Azure.CloudError exception  Invalid filter clause specified: 'timestamp ge '2020-09-30T17:01:09Z' and timestamp le '2020-10-01T17:01:08Z''. being thrown. To Reproduce The line new ODataQuery<RequestReportRecordContract>(i => i.Timestamp >= start && i.Timestamp <= end) shouldn't contain quoted dates, or the issue is that API-M cannot support quoted dates. I also checked the following: new ODataQuery<RequestReportRecordContract>($`timestamp ge 2020-09-30T16%3A35%3A52Z and timestamp le 2020-10-01T16%3A35%3A51Z`) is Valid, which means that the encoding isn't the issue. new ODataQuery<RequestReportRecordContract>($`timestamp ge '2020-09-30T16%3A35%3A52Z' and timestamp le '2020-10-01T16%3A35%3A51Z'`) is Invalid, which means it's the quotes that's causing the problem. Environment:  Microsoft.Azure.Management.ApiManagement (6.0.0-preview) Windows 10 Microsoft.NETCore.App (2.1.0) Visual Studio 16.7.5
Client	Monitor	customDimensions missing in Microsoft.Azure.Management.ApplicationInsights	I'm using Microsoft.Azure.Management.ApplicationInsights package to get data from application insight. customDimensions are alwasy null. I can see customDimensions in azure portal but when I get data using this package in .net core then they are alwasy null . The class EventsResultDataCustomDimensions has AdditionalProperties but our customDimensions are without AdditionalProperties property. is there any way to parse the customDimensions?
Mgmt	Compute - VMSS	[BUG] IVirtualMachineScaleSetVMsOperations.ListAsync doesn't allow expands, but REST API does	Apologies if this is a feature request and not a bug. Just thought it may have been an oversight. Using the REST API, it's possible to supply expands to Virtual Machine Scale Set VMs - List (link). The dotnet SDK only allows for filter (using ODataQuery) and select (link). Also related, but the select lists instanceView as the only valid option, but instanceView needs to be expanded, which isn't possible when using ListAsync. Environment: Microsoft.Azure.Management.Compute Version=`38.0.0` Dotnet Core 3.1.301
Client	KeyVault	Add support for JWE to Azure.Security.KeyVault 4.1+ or guidance on safely rolling keys	Library or service name. Azure.Security.KeyVault Is your feature request related to a problem? Please describe. Key Vault has features that make creating new versions of certificates and secrets easy.  However, it order to be able to safely expire a keys or certificate, you need to be able to keep track of which keys you have used to encrypt and sign data you already have.  From my research it would seem that JWE offers this ability.  It seems that all of the base components already exist in the Key Vault client libraries so it would be possible to create your own implementation, but this is an area where it would be easy to make a mistake, so having a dependable implementation would be beneficial. If using JWE in this way is a terrible idea, then some documented guidance on how to deal with rolling keys would be a good alternative.
Mgmt	Container Service	Add Start/Stop/properties.PowerState to ManagedClusters	Library or service name: Microsoft.Azure.Management.ContainerService Description: The API docs for ManagedClusters include the following:  starting: https://docs.microsoft.com/en-us/rest/api/aks/managedclusters/start stopping: https://docs.microsoft.com/en-us/rest/api/aks/managedclusters/stop a properties.PowerState property, indicating the running/stopped state of the cluster: https://docs.microsoft.com/en-us/rest/api/aks/managedclusters/get#managedcluster  Please add methods to start & stop clusters, and add and populate the properties.PowerState property in the Microsoft.Azure.Management.ContainerService.Models.ManagedCluster class.
Mgmt	API Management	Add option for remote VNET peer name	Library or service name. What library or service is this request related to? Microsoft.Azure.Management.Network.Fluent Is your feature request related to a problem? Please describe. No way to define name of the peering from remote virtual network using Azure Management API Actual Result While running below code it is establishing the peer with random name at remote vnet end. hubVNet.Peerings                 .Define(`hub-to-spoke1-peering`)                 .WithRemoteNetwork(spoke1VNet.Id)                 .Create();   Expected Result While defining  .Define(`hub-to-spoke1-peering`) is showing this value as source VNet peer name. User should be able to define the peer name for remote VNet as well. Or, Management API should also work as az cli i.e it should not auto establish the peering between two VNet, while using az network vnet peering create -g `sandbox` -n `spoke1-to-hub-peering` --vnet-name `spoke1-vnet` --remote-vnet `/subscriptions/xxx/resourceGroups/sandbox/providers/Microsoft.Network/virtualNetworks/hub-vnet` --allow-vnet-access it only initiate the peer request from source vnet and to establish the connection user needs to create another peering from destination.
Mgmt	Network - Virtual Network	[FEATURE REQ] Add CidrBlock logic to Azure SDK	Library or service name. What library or service is this request related to? Azure Networking as well as any other service that uses CIDR notation for ACLs. Is your feature request related to a problem? Please describe. What feature would you like to get added? What problem is it solving? I have an object that I use to provision Address space across multiple resources by doing CIDR logic on top of System.Net.IPAddress class and the use of a couple new structs (IP4Numeric and IP6Numeric) to be able to do the arithmetic on the data.  Code is `complete` for my use cases, unit tests are in place for `happy-path` and some failure conditions. dotnet rejected the feature, but I'm sure this logic will be very useful for Azure implementations. dotnet Issue: dotnet/runtime#36428 note... i've added these two methods to CidrBlockExtensions since that issue was created: public static CidrBlock NextBlock(this CidrBlock cidrBlock; public static IEnumerable Subnet(this CidrBlock cidrBlock, int howMany) an example use of this for the use case where I have a `cloud data center` and I want to cut it up into subnets per resource group... then i can cut that up into VNets and Subnets. Resource Group -> VNet subnetting (sorry for the overloading of term, but the VNet is a subnet of the overall data center supernet):             var rgAddressSpace = new Dictionary<string, CidrBlock>(StringComparer.OrdinalIgnoreCase);             List<string> resourceGroupNames = GetResourceGroupNames();             var subnets = (supernetAddressSpace?.Subnet(resourceGroupNames.Count) ?? Enumerable.Empty<CidrBlock>()).ToList();             for(int i = 0; i < resourceGroupNames.Count; i++)             {                 var rgName = resourceGroupNames[i];                 var subnet = subnets[i];                 rgAddressSpace.Add(rgName, subnet);             } Subnetting the VNET into the ISubnet address space(s).             var subnetAddressSpaces = vnetAddressSpace.Subnet(subnetCount).ToList();             var vnetName = GetResourceNameByGroupNameAndSuffix(resourceGroup.Name, VnetResourceSuffix);             var subnets = Enumerable.Range(1, subnetCount) // ordinal based... make sure to subtract by one in the value selector in .ToDictionary                 .Select(i => Tuple.Create(i, GetResourceNameByGroupNameAndSuffix(resourceGroup.Name, SubnetSuffix, i)))                 .ToDictionary(t => t.Item2,                              (t =>                              {                                  var name = t.Item2;                                  var i = t.Item1 - 1;                                  var subnetSpace = subnetAddressSpaces.ElementAt<CidrBlock>(i);                                  _logger.LogDebug($`Will provision {name} with address space {subnetSpace}`);                                  return subnetSpace.ToString();                              }));
Client	Storage	[FEATURE REQ] Align with azcopy retry settings (20 attempts)	Library or service name. All of Azure.Storage Is your feature request related to a problem? Please describe. I have ran into timeouts that look like this, trying to upload ~400MB files using slow connections: System.AggregateException: Retry failed after 6 tries. (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.) (Error while copying content to a stream.)  ---> Azure.RequestFailedException: Error while copying content to a stream.  ---> System.Net.Http.HttpRequestException: Error while copying content to a stream.  ---> System.IO.IOException: Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host..  ---> System.Net.Sockets.SocketException (10054): An existing connection was forcibly closed by the remote host.  I suspect azcopy has more optimized retry parameters, especially for upload. Looking at their code, the main difference seems to be the retry count of 20 (for uploads):  https://github.com/Azure/azure-storage-azcopy/blob/2c30af330b681d3a1f31db32e11245eafce9c5c3/ste/xfer.go#L36 Compare this to the Azure SDK retry count of 5 (which translates to a total of 6 attempts):                azure-sdk-for-net/sdk/storage/Azure.Storage.Common/src/Shared/Constants.cs                    Line 15       in       00d31be                                                 public const int MaxReliabilityRetries = 5;
Client	Azure.Core	[QUERY] Distributed Tracing in EventHub - example?	Query/Question Now that EventHub supports distributed tracing and submits the Diagnostics-id in a similar way to what Service Bus already did, do you have a corresponding example how to use that ID in the processor? This show it for Service Bus messages: https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-end-to-end-tracing#trace-message-processing private readonly TelemetryClient telemetryClient;  async Task ProcessAsync(Message message) {     var activity = message.ExtractActivity();          // If you are using Microsoft.ApplicationInsights package version 2.6-beta or higher, you should call StartOperation<RequestTelemetry>(activity) instead     using (var operation = telemetryClient.StartOperation<RequestTelemetry>(`Process`, activity.RootId, activity.ParentId))     {         telemetryClient.TrackTrace(`Received message`);         try          {            // process message         }         catch (Exception ex)         {              telemetryClient.TrackException(ex);              operation.Telemetry.Success = false;              throw;         }          telemetryClient.TrackTrace(`Done`);    } }  Environment:  Name and version of the Library package used:  Azure.Messaging.EventHubs.Processor 5.2.0-preview.1 Microsoft.ApplicationInsights 2.15.0-beta2   Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): [e.g. Azure AppService or Windows 10 .NET Framework 4.8] .NET Core 3.1
Client	Monitor	Query ApplicationInisights - proper library	Query/Question Hello, I'm a little bit confused about Azure libraries. I want to query the application insights (using kusto) from .net application. Right now I'm using Microsoft.Azure.ApplicationInsights library. This works fine, but what bothers me is this library latest version is 0.9.0-preview and it is from April 2018. Is there a newer version of this library? Did they migrate somewhere? If no, is there any library that I can use which will provide me with the same functionality (authentication with the token and query the logs of application insights)? I cannot find any information about it on the Web. _ Environment:  Microsoft.Azure.ApplicationInsights 0.9.0-preview .NET Core SDK Version:   3.1.302 IDE and version: Visual Studio 16.6.4
Client	Monitor	[QUERY] C# Application Insights Data Library?	Am I missing something or has the C# Application Insights Data Library not been published for over 2 years? Is it likely to become generally available or is there some alternative I should be using?
Mgmt	Network - DNS	[QUERY] Preview DNS package	Query/Question Presently, there's a preview available for Azure.ResourceManager.Compute intended to be the next take on working with VM and VMSS resources. There isn't yet a new preview available for Azure.ResourceManager.Dns despite being included on this list. Is there any timeline on producing the DNS package? Unfortunately, I'm in a sticky spot of having to use the new preview bits to modify VM profiles since that wasn't available in prior non-preview releases and using the older tooling to manage DNS. It's getting a little hairy having two separate takes on Azure resource management in the same package and I'd like to simplify things. Thanks! Environment: Windows 1010.0.19041 .NET Core SDK 3.1.301 Visual Studio Pro 16.6.3
Mgmt	Network - Virtual Network	[Bug] PrivateEndpoints.DeleteAsync throws NullReferenceException	Describe the bug When calling into this method, it throws a NullReferenceException, while polling for the deletion of the private endpoint. The call actually succeeds with no error, but if you watch for this exception, it hits twice before the call finishes. Microsoft.Azure.Management.Network.NetworkManagementClient.PrivateEndpoints.DeleteAsync Using 20.0.2-preview: <PackageReference Include=`Microsoft.Azure.Management.Network` Version=`20.0.2-preview` />  Exception or Stack Trace System.NullReferenceException HResult=0x80004003 Message=Object reference not set to an instance of an object. Source=Microsoft.Rest.ClientRuntime.Azure StackTrace: at Microsoft.Rest.ClientRuntime.Azure.LRO.LROPollState2.DeserializeToObject[TDeserializedBodyType](Func1 deserializDelegate) Steps to reproduce behavior:  Attempt to delete private endpoint with DeleteAsync extension method.  Code Snippet var networkClient = await azureClientFactory.CreateNetworkClient(subscriptionId);  await networkClient.PrivateEndpoints.DeleteAsync(resourceGroupName, privateEndpointName);  Expected behavior Task completes without any exception thrown Setup (please complete the following information):  OS: Windows 10 IDE: Visual Studio Enterprise 2019 Version 16.5.4 20.0.2-preview  Information Checklist   Bug Description Added  Repro Steps Added  Setup information Added  Additional context The exception seems to be effectively the same as found here: #9770 , with a different initiate call but same failure of the internal polling call.
Client	Functions	[BUG] Event Hub Processor Host through Azure Function Extension starves two partitions regularly	Describe the bug I'm using the Event hub trigger in Azure functions and I'm seeing some partitions getting starved of consumption. A lease is set up on a partition, and then nothing happens until that lease expires at which point a new consumer will setup the lease and start consuming the data. This can take up to an hour to happen. Expected behavior I expect all partitions to get the same amount of love, give or take the configuration on the Processor Host. Actual behavior (include Exception or Stack Trace) The problem is that the Azure function consistently starves 2 partitions, a lease is taken and then they are just left there until the lease breaks (an hour or something later). Then two other partitioned are left to be starved. Whenever I redeploy the function it grabs all of them, but then soon starts to ignore two of them. It takes about 2 minutes for this problem to start. I'm running an Azure function (v3 - project config below) that gets data from an event hub with 16 partitions. This is running on a App Service Plan with around 11 nodes (plenty of CPU to spare), but I've upped the node count to 16 now, with no difference in behavior. I've redeployed the function in question, I've messed with every (the 3) setting in the host.json, I've even cycled the machines on the app service plan (set scale to 1 and then to 11 again).  I've even tested creating a new consumer group, but the problem persists. I have a second function that doesn't show this issue to the same degree but even though I've tried my best to make them operate the same the issue remains in this function. So my guess is that there is something in the extension that's causing this - but maybe you guys see something else. Blow are pictures of the the event hub checkpoints as well as what the graph of delay from message enqueued on the event hub looks like.     (Y-axis in seconds) var lastTimestamp = (DateTime)eventStream.Last().SystemProperties[`x-opt-enqueued-time`]; var lastDelay = DateTime.UtcNow - lastTimestamp;  To Reproduce I'm running the following (with some internal packages removed)   <PropertyGroup>     <TargetFramework>netcoreapp3.0</TargetFramework>     <AzureFunctionsVersion>v3</AzureFunctionsVersion>   </PropertyGroup>   <ItemGroup>     <PackageReference Include=`GeoCoordinate.NetCore` Version=`1.0.0.1` />     <PackageReference Include=`GeoLibrary` Version=`1.1.0` />     <PackageReference Include=`Microsoft.ApplicationInsights` Version=`2.14.0` />     <PackageReference Include=`Microsoft.Azure.Functions.Extensions` Version=`1.0.0` />     <PackageReference Include=`Microsoft.Azure.WebJobs.Extensions.EventHubs` Version=`4.1.1` />     <PackageReference Include=`Microsoft.NET.Sdk.Functions` Version=`3.0.7` />     <PackageReference Include=`TaskTupleAwaiter` Version=`1.2.0` />   </ItemGroup>   <ItemGroup>     <None Update=`host.json`>       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>     </None>     <None Update=`local.settings.json`>       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>       <CopyToPublishDirectory>Never</CopyToPublishDirectory>     </None>   </ItemGroup>   <ItemGroup>     <Folder Include=`Properties\PublishProfiles\` />   </ItemGroup>   <ItemGroup>     <ProjectReference Include=`..\..\Service\Service.csproj` />   </ItemGroup> </Project>  And here is the host.json config {   `extensions`: {     `eventHubs`: {       `batchCheckpointFrequency`: 1,       `eventProcessorOptions`: {         `maxBatchSize`: 64,         `prefetchCount`: 256       }     }   },   `version`: `2.0` }  Environment:  Name and version of the Library package used: Microsoft.Azure.EventHub.Processor Version 3.0.0 via Microsoft.Azure.Extensions.EventHub V 4.1.1 Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): Azure Function V3 running on windows, Runtime version : 3.0.13353.0, .Net Core 3.0 IDE and version : Visual Studio Version 16.5.4  Here is a link to the bug I've reported with azure-functions-eventhubs-extension: Issue 63
Mgmt	Websites	[Question] WebApp SDK - configure storage account	Hi, I'm exploring the SDK docs, and I cannot find - is it possible to transform the following bash command to be used with the SDK (myWebApp.Update()....):  az webapp config storage-account add  --resource-group <some_rg>  --name <some_service_name>  --custom-id GrafanaData  --storage-type AzureBlob  --share-name <some_share_name>  --account-name <some_name>  --access-key <some_key>  --mount-path <some_path>  --output none  I was investigating the source code, and I found the class  AzureStorageInfoValue  which contains the same properties as the bash command. The dependencies chain looks like this:  AzureStoragePropertyDictionaryResourceInner (ctor) UpdateAzureStorageAccountsSlotWithHttpMessagesAsync UpdateAzureStorageAccountsSlotAsync  and the last method is not being used anywhere. Setup Version of the Library used (.Net Core 3.1):  Microsoft.Azure.Management.Fluent v1.32.0 Microsoft.Azure.Management.ResourceManager.Fluent v1.32.0 WindowsAzure.Storage v9.3.3
Client	Storage	[FEATURE REQ] Make ConnectionString class public	Azure.Core Make ConnectionString class public so developers can leverage it broadly, as `Key=Value;` format is widely adopted in Azure. For example, Storage SDK used to have CloudStorageAccount.Parse. It doesn't exist in v12, and it's Storage-specific. Now, in order to use Azure.Storage.StorageSharedKeyCredential with a connection string (together with BlobSasBuilder, for example) , they have to extract AccountKey value from the connection string themselves.
Client	Service Bus	[BUG] Service Bus .NET SDK randomly fails to complete messages for long running process	Describe the bug When a Service Bus topic message requires a long time to be processed (in my case between 15 and 20 minutes) and the respective MessageHandlerOptions was initialized as: new MessageHandlerOptions(HandleException) {     MaxAutoRenewDuration = TimeSpan.FromMinutes(30),     AutoComplete = false } when the processing has finished (always sooner than the TimeSpan set for MaxAutoRenewDuration, in my case processing took 18 mins and the MaxAutoRenewDuration  was set to 30 mins) and attempting to complete the message an error occurs, as if the message lock has expired or the message has been already removed. Only a single process is working with the Service Bus topic at the given time. Expected behavior My understanding is that based on the value of MaxAutoRenewDuration, the expected behavior would be to keep the message locked and automatically renew the lock for the duration value defined. When the processing is finished and before this duration expires, the message lock should be automatically renewed and valid to complete the message. Actual behavior (include Exception or Stack Trace) When trying to complete the message after the long running process the exception was the following: Microsoft.Azure.ServiceBus.MessageLockLostException: The lock supplied is invalid. Either the lock expired, or the message has already been removed from the queue, or was received by a different receiver instance.    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.DisposeMessagesAsync(IEnumerable`1 lockTokens, Outcome outcome)    at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func`1 operation, TimeSpan operationTimeout)    at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func`1 operation, TimeSpan operationTimeout)    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.CompleteAsync(IEnumerable`1 lockTokens)    at ServiceBusHandler.Program.HandleLongRunningMessage(Message message, CancellationToken cancellationToken) in C:\[PROGRAM_LOCATION]\Program.cs:line 46    at Microsoft.Azure.ServiceBus.MessageReceivePump.MessageDispatchTask(Message message)  and sometimes in the middle of the processing I got the following exception (slightly different, when trying to renew the lock I would guess): Microsoft.Azure.ServiceBus.MessageLockLostException: The lock supplied is invalid. Either the lock expired, or the message has already been removed from the queue. Reference:38e353cf-423a-4421-bdc0-207ca76c7244, TrackingId:1474382e-1a29-4800-b599-c176d1559804_B1, SystemTracker:gsis-einvoice:Topic:longtopic|longsub, Timestamp:2020-04-23T06:26:07    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.OnRenewLockAsync(String lockToken)    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.<>c__DisplayClass74_0.<<RenewLockAsync>b__0>d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func`1 operation, TimeSpan operationTimeout)    at Microsoft.Azure.ServiceBus.RetryPolicy.RunOperation(Func`1 operation, TimeSpan operationTimeout)    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.RenewLockAsync(String lockToken)    at Microsoft.Azure.ServiceBus.Core.MessageReceiver.RenewLockAsync(Message message)    at Microsoft.Azure.ServiceBus.MessageReceivePump.RenewMessageLockTask(Message message, CancellationToken renewLockCancellationToken)  To Reproduce I am including a console program code in NET Core 3.1 in the following gist using which I was able to reproduce the problem a couple of times when I ran it for 10 messages: https://gist.github.com/nianton/a1b64094d79c0da4f15037ce301d1b23 Environment:  Azure Service Bus resource  Location: West Europe Tier: Standard Message time to live: 14 days Message lock duration: 5 mins   Microsoft.Azure.ServiceBus v4.1.3 Windows 10, .NET Core v3.1.3 Visual Studio 16.5.2
Mgmt	SQL	[BUG] CloudException is thrown with status code 200 when using SqlManagementClient.Databases.CreateOrUpdateAsync(...)	Description/To Reproduce  Get database properties from azure, keep it in memory as a backup. Move the database out of standard elastic pool to premium standalone within same database server. Try to copy the database to another server, but stop it because it took too long. Revert database to original settings using SqlManagementClient.Databases.CreateOrUpdateAsync(...) and passing original database properties received from the 1st step. Request throws CloudException with message The operation could not be completed because the read scale value specified is not supported for a 'Standard' database.. The response object in the CloudException returns status code 200. Repeat steps 4 and 5 with retry logic.  Eventually, the code exhausts all the retries and fails, however in Azure everything seems to have worked fine and the database is in its original state. Expected behavior CloudException should not be thrown for status code 200. Actual behavior (include Exception or Stack Trace) CloudException is thrown with status code 200 and message  The operation could not be completed because the read scale value specified is not supported for a 'Standard' database.. Operation seems to be successful when checked on azure portal. Environment:  Name and version of the Library package used: <PackageReference Include=`Microsoft.Azure.Management.Sql` Version=`1.19.0-preview` /> Hosting platform or OS and .NET runtime version (dotnet --info output for .NET Core projects): Windows Server 2016 DataCenter - Service Fabric 7.0.470.9590 - net472
Client	Service Bus	ManagementClient - Check if a rule exists on subscription	Description  In service bus SDK, it would be nice to have a method, that would check if a named rule exists on the a service bus topic. There are rules which include GetRuleAsync, UpdateRuleAsync and UpdateRuleAsync. Actual Behavior  To programmatically create/update/delete a subscription rule the relevant SDK methods are to be used. However, if the rule does not exist, the SDK raises MessagingEntityNotFoundException.  To check if a rule exists, a check as below needs to be done by an developer. private static async Task<bool> RuleExistsAsync(             ManagementClient managementClient,              string topicPath,              string subscriptionName,              string ruleName)         {             // There is no method in the SDK to check if a particular rule exists.             try             {                 if (await managementClient.GetRuleAsync                     (topicPath, subscriptionName, ruleName) != null)                 {                     return false;                 }             }             catch (MessagingEntityNotFoundException){}              return true;         }  Proposed Behavior  Expose a method in the ManagementClient named RuleExistsAsync, similar to TopicExistsAsync or SubscriptionExistsAsync.
Mgmt	Event Hubs	[Feature Request] Additional Event Hub Properties for the Management Library	Query/Question When using the WindowsAzure.ServiceBus nuget package, in the Microsoft.ServiceBus namespace we have a class NamespaceManager. It has some methods like GetEventHub and GetEventHubPartition. It helps to retrieve many properties for existing Event Hubs. In .NET core, I think the equivalent is Microsoft.Azure.Management.EventHub & Azure.Messaging.EventHubs namespace. But some of the Event Hub properties that can be retrieved in  .NET Framework are not retrievable in .net core.      .NET Framework   .NET Core               Class Name Property Name Class Name Property Name   PartitionDescription PartitionId       PartitionDescription EventHubPath       PartitionDescription ConsumerGroupName       PartitionDescription EndSequenceNumber       PartitionDescription BeginSequenceNumber PartitionProperties BeginningSequenceNumber   PartitionDescription SizeInBytes       PartitionDescription IncomingBytesPerSecond       PartitionDescription OutgoingBytesPerSecond       PartitionDescription LastEnqueuedOffset PartitionProperties LastEnqueuedOffset   PartitionDescription LastEnqueuedTimeUtc PartitionProperties LastEnqueuedTime             EventHubDescription Path       EventHubDescription MessageRetentionInDays Eventhub MessageRetentionInDays   EventHubDescription Authorization       EventHubDescription Status       EventHubDescription CreatedAt Eventhub CreatedAt   EventHubDescription UpdatedAt Eventhub UpdatedAt   EventHubDescription UserMetadata       EventHubDescription PartitionCount Eventhub PartitionCount   EventHubDescription PartitionIds Eventhub PartitionIds    The ones in bold are the ones I am specifically looking for. Environment:  Microsoft.Azure.Management.EventHub 2.5.0 .NET Core SDK (reflecting any global.json): Version:   3.1.101 Commit:    b377529961  Runtime Environment: OS Name:     Windows OS Version:  10.0.17763 OS Platform: Windows RID:         win10-x64 Base Path:   C:\Program Files\dotnet\sdk\3.1.101\ Host (useful for support): Version: 3.1.1 Commit:  a1388f194c .NET Core SDKs installed: 3.1.101 [C:\Program Files\dotnet\sdk] .NET Core runtimes installed: Microsoft.AspNetCore.All 2.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All] Microsoft.AspNetCore.App 2.1.15 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.AspNetCore.App 3.1.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App] Microsoft.NETCore.App 2.1.15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.NETCore.App 3.1.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App] Microsoft.WindowsDesktop.App 3.1.1 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]  IDE and version : Visual Studio 16.4.5
Mgmt	SQL	Management.Sql has inconsistent MaxSizeBytes type	Not high priority by any means, but this seemed inconsistent. string Microsoft.Azure.Management.Sql.Models.ImportRequest.MaxSizeBytes long Microsoft.Azure.Management.Sql.Models.Database.MaxSizeBytes
Mgmt	App Services	Add Application permission support for user_impersonation in Azure Service Management	Question To take use of Azure SDK via Azure App Registrations, only delegated permissions for user_impersonation is supported which means that a sign-in user is needed when taking use of those APIs and it reduces the capabilities to build up an automation application on it. Requirement It is obviously that the Application permission can provide the possibility to make related actions more automatically and support more meaningful and realistic use-cases. For example, in my case, I need to take use of this Azure SDK to create a register Bot automatically by a custom application.
Client	Search	Provide helper method to parse a query string into SearchParameters	Query/Question Before i can classify this as a bug or feature request, i would like to understand if there is a way to achieve my need. So, i followed the documentation with examples of OData queries. I used one of the examples using the $orderby parameter in the Azure portal, running the query in the Search explorer. When i tried to map the exact same query to the Search Index Client, setting the query in the query field ($orderby=BaseRate asc), i was not getting the same results. Then looking to the documentation, i saw some examples using the SearchParameters object and the OrderBy property. So then i tried to create an instance of the SearchParameters and pass it in the search, and it worked. So, now my question is if it would be possible to use the query parameter, as it is in the Search explorer in the portal (for the query string), instead of being required to build a SearchParameters object. So if i have the following query: `$orderby=BaseRate asc, LastModifiedDate desc, ItemID asc, Location desc` Instead of parsing the $orderby parameters and create the collection for the Orderby property of the SearchParameters, i could just forward the query to the search query and run the search. So, instead of having this code: var results = searchIndexClient.Documents.Search<Items>(`*`, new SearchParameters { OrderBy = new string[] {  `BaseRate asc`, `LastModifiedDate desc`, `ItemID asc`, `Location desc`} }); i could have the following, without the need to parse the query coming from the client var results = searchIndexClient.Documents.Search<Items>(`$orderby=BaseRate asc, LastModifiedDate desc, ItemID asc, Location desc`); If the SearchParameters object is required in these scenarios when we have orderby or filter parameters, then the SDK could be able behind the scenes to parse the query and fill the parameters. Why is this not a Bug or a feature Request? For now i am trying to understand if this is already available somehow, and i just missed it.
Client	Service Bus	[Service Bus] Detect connection status	Right now it does not seem possible to detect the connection state with Azure Service Bus. There is no property that indicates if we are connected or if there is some connectivity issue (or other issue, like subscription deleted etc). Describe the solution you'd like I want a boolean property on the SubscriptionClient that tells me if it is connected. And I want an event on connection changes, i.e. Connected and Disconnected. Describe alternatives you've considered The alternative I'm using now uses Reflection, which is fragile. It does a little bit like this: var subscriptionClient = new SubscriptionClient(connStr, topic, subscription, ReceiveMode.PeekLock); var conn = subscriptionClient.ServiceBusConnection; FaultTolerantAmqpObject<AmqpConnection> connectionManager = (FaultTolerantAmqpObject<AmqpConnection>)typeof(ServiceBusConnection).GetProperty(`ConnectionManager`, BindingFlags.Instance | BindingFlags.NonPublic).GetMethod.Invoke(conn, null); var amqpConnection = await connectionManager.GetOrCreateAsync(TimeSpan.FromSeconds(2)); var amqpSessionSettings = new AmqpSessionSettings { Properties = new Fields() }; while (true) {     var session = amqpConnection.CreateSession(amqpSessionSettings);     var connected = false;     try     {         await session.OpenAsync(TimeSpan.FromSeconds(2));         await session.CloseAsync(TimeSpan.FromSeconds(2));         connected = true;     }     catch (TimeoutException)     {     }     Console.WriteLine(connected);     Thread.Sleep(2000); } Additional context I'll use this to inform the healthcheck of a container on a Kubernetes environment. We shouldn't need to have to use reflection. And I get that the library is resilient and will reconnect. But I need to setup scaling, alerts and other infrastructure based on the fact that there is a worker doing what it is supposed to be doing. If for some reason a container gets disconnected from Service Bus, I need to know, I might setup infrastructure that will recreate it, setup alarms, etc. My queues/topics might be filling up, and I don't get to react to it.
Client	Service Bus	[BUG] SessionHandlerOptions.MessageWaitTimeout allows zero value, but throws on ReceiveAsync	Describe the bug SessionHandlerOptions.MessageWaitTimeout allows me to set the timeout to 0, using TimeSpan.FromSeconds(0) as an example. At runtime, the session receiver throws an ArgumentOutOfRangeException continuously during the ReceiveAsync operation. Exception or Stack Trace Message:  Argument operationTimeout must be a positive non-zero timeout value. The provided value was 00:00:00. (Parameter 'operationTimeout') Actual value was 00:00:00.  Trace:  at Microsoft.Azure.ServiceBus.Core.MessageReceiver.d__64.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult() at Microsoft.Azure.ServiceBus.Core.MessageReceiver.d__62.MoveNext() at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at Microsoft.Azure.ServiceBus.SessionReceivePump.d__21.MoveNext()  To Reproduce Set the SessionHandlerOptions.MessageWaitTimeout property to 0 and register a session handler against a queue/subscription with messages. Code Snippet     public static class Program     {         public static async Task Main(string[] args)         {             var sessionHandlerOptions = new SessionHandlerOptions(ExceptionReceivedHandler)             {                 AutoComplete = false,                 MaxAutoRenewDuration = TimeSpan.FromSeconds(60),                 MaxConcurrentSessions = 1,                 MessageWaitTimeout = TimeSpan.FromSeconds(0)             };              var queueClient = new QueueClient(<connection args>);              queueClient.RegisterSessionHandler(HandleSession, sessionHandlerOptions);              await Task.Delay(TimeSpan.FromHours(1));         }          private static Task ExceptionReceivedHandler(ExceptionReceivedEventArgs arg)         {             return Task.CompletedTask;         }          private static Task HandleSession(             IMessageSession session,             Message message,             CancellationToken ctx)         {             Console.WriteLine(session);             Console.WriteLine(message);             Console.WriteLine(ctx);              return Task.CompletedTask;         }     }  Expected behavior  Other properties in SessionHandlerOptions have guards in the setters against negative arguments, including the MessageWaitTimeout. MaxConcurrentSessions also guards against a zero value as it must be 1 or more. I would expect this property to have a similar guard if 0 is not valid. The implementation of `OperationTimeout` is confusing as compared to the full framework library. Using an explicit .Receive operation with TimeSpan.Zero historically meant `no wait`, as I recall. In the case of sessions, `MaxWaitTimeout` to me means `how long to wait for another message before closing the session`. Offhandedly, I would expect to be able to set this to 0 meaning `as soon as I'm done processing the message, if there are no more messages, close the session and get a new one`.  Additionally, the current version of the package does not provide a documentation file, so none of these properties have details explaining their usage or limitations. Setup (please complete the following information):  OS: Windows IDE : VS2019 Enterprise Version of the Library used: 4.1.0
Client	Service Fabric	[BUG] ServiceFabricProcessor throws an unexpected OperationCanceledException exception	This bug is similar to #7933 The difference is the type of the exception thrown (+ I have some more details now).  ProcessErrorAsync is called with the following exception:  System.OperationCanceledException: The operation was canceled.    at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result)    at Microsoft.Azure.Amqp.ReceivingAmqpLink.EndReceiveMessages(IAsyncResult result, IEnumerable`1& messages)    at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization) --- End of stack trace from previous location where exception was thrown ---    at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.OnReceiveAsync(Int32 maxMessageCount, TimeSpan waitTime)    at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.OnReceiveAsync(Int32 maxMessageCount, TimeSpan waitTime)    at Microsoft.Azure.EventHubs.PartitionReceiver.ReceiveAsync(Int32 maxMessageCount, TimeSpan waitTime)    at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.ReceivePumpAsync(CancellationToken cancellationToken, Boolean invokeWhenNoEvents) {`Type`:`System.OperationCanceledException`, `CancellationToken`:{`IsCancellationRequested`:false, `CanBeCanceled`:false, `WaitHandle`:{`Handle`:`2244`, `SafeWaitHandle`:{`IsInvalid`:false, `IsClosed`:false}​}}, `TargetSite`:`Void Throw()`, `StackTrace`:`   at Microsoft.Azure.Amqp.AsyncResult.End[TAsyncResult](IAsyncResult result)\r\n   at Microsoft.Azure.Amqp.ReceivingAmqpLink.EndReceiveMessages(IAsyncResult result, IEnumerable`1& messages)\r\n   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.OnReceiveAsync(Int32 maxMessageCount, TimeSpan waitTime)\r\n   at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.OnReceiveAsync(Int32 maxMessageCount, TimeSpan waitTime)\r\n   at Microsoft.Azure.EventHubs.PartitionReceiver.ReceiveAsync(Int32 maxMessageCount, TimeSpan waitTime)\r\n   at Microsoft.Azure.EventHubs.Amqp.AmqpPartitionReceiver.ReceivePumpAsync(CancellationToken cancellationToken, Boolean invokeWhenNoEvents)`, `Message`:`The operation was canceled.`, `Data`:{}, `Source`:`System.Private.CoreLib`, `HResult`:-2146233029}    CloseAsync is called with Reason = Cancelled   ServiceFabricProcessor.RunAsync throws   System.OperationCanceledException: The operation was canceled.    at Microsoft.Azure.EventHubs.ServiceFabricProcessor.ServiceFabricProcessor.RunAsync(CancellationToken fabricCancellationToken)    at MyClass.RunAsync(CancellationToken cancellationToken)  The important thing here is that the CancellationToken passed to ServiceFabricProcessor.RunAsync() is NOT cancelled. @JamesBirdsall Does this information help in any way?
Mgmt	Monitor	[BUG] MetricTrigger class should have MetricNamespace property	Describe the bug To setup auto-scaling rule based on Application Insights metric, I need to have the following trigger: `metricTrigger`: {     `metricName`: `<metric-name>`,     `metricNamespace`: `azure.applicationinsights`,     `metricResourceUri`: `/subscriptions/<sub-id>/resourceGroups/<resource-group>/providers/microsoft.insights/components/<app-insights-name>`,     `operator`: `GreaterThanOrEqual`,     `statistic`: `Max`,     `threshold`: 1,     `timeAggregation`: `Last`,     `timeGrain`: `PT1M`,     `timeWindow`: `PT5M`,     `Dimensions`: [] }  Unfortunately, MetricTrigger class does not have a MetricNamespace property. Code Snippet To workaround the issue, I created the following class:     internal class MetricTriggerWithMetricNamespace : MetricTrigger     {         public MetricTriggerWithMetricNamespace(string metricNamespace, MetricTrigger metricTrigger)             : base(metricTrigger.MetricName, metricTrigger.MetricResourceUri, metricTrigger.TimeGrain,                     metricTrigger.Statistic, metricTrigger.TimeWindow, metricTrigger.TimeAggregation, metricTrigger.OperatorProperty, metricTrigger.Threshold)         {             MetricNamespace = metricNamespace;         }          public MetricTriggerWithMetricNamespace(string metricNamespace, string metricName, string metricResourceUri, TimeSpan timeGrain, MetricStatisticType statistic, TimeSpan timeWindow, TimeAggregationType timeAggregation, ComparisonOperationType operatorProperty, double threshold)             : base(metricName, metricResourceUri, timeGrain, statistic, timeWindow, timeAggregation, operatorProperty, threshold)         {             MetricNamespace = metricNamespace;         }          [JsonProperty(PropertyName = `metricNamespace`)]         public string MetricNamespace         {             get;             set;         }     }  Here is the code that enables/disables auto-scale. I have to replace MetricTrigger with MetricTriggerWithMetricNamespace to workaround the problem:         private void UpdateAutoScaleInternal(string deploymentId, bool enable)         {             ManagementClientWrapper<MonitorManagementClient> clientWrapper = new ManagementClientWrapper<MonitorManagementClient>(m_subscriptionId, m_tenantId,                 (creds, subscriptionId) => new MonitorManagementClient(creds) { SubscriptionId = subscriptionId });              m_logger.Info(`Reading autoscale settings in the following resource group: {0}`, m_resourceGroupName);             List<AutoscaleSettingResource> autoscaleSettings = clientWrapper.WalkPagedResult(                 (client) => client.AutoscaleSettings.ListByResourceGroup(m_resourceGroupName),                 (client, nextPageLink) => client.AutoscaleSettings.ListByResourceGroupNext(nextPageLink));              m_logger.Info(`Found {0} auto scale setting(s).`, autoscaleSettings.Count);              foreach (AutoscaleSettingResource autoscaleSetting in autoscaleSettings)             {                 if (autoscaleSetting.Tags.TryGetValue(ServicingTokenConstants.DeploymentId, out string deploymentIdTag) &&                     string.Equals(deploymentIdTag, deploymentId, StringComparison.OrdinalIgnoreCase))                 {                     if (autoscaleSetting.Enabled != enable)                     {                         autoscaleSetting.Enabled = enable;  // THIS IS UGLY code 👎                          foreach (AutoscaleProfile profile in autoscaleSetting.Profiles)                         {                             for (int i = profile.Rules.Count - 1; i >= 0; --i)                             {                                 if (profile.Rules[i].MetricTrigger.MetricResourceUri.IndexOf(`Microsoft.insights`, StringComparison.OrdinalIgnoreCase) > 0)                                 {                                     profile.Rules[i].MetricTrigger = new MetricTriggerWithMetricNamespace(metricNamespace: `azure.applicationinsights`, profile.Rules[i].MetricTrigger);                                 }                             }                         }                         m_logger.Info(`{0} auto scale: {1}`, enable ? `Enabling` : `Disabling`, autoscaleSetting.Name);                         clientWrapper.Client.AutoscaleSettings.CreateOrUpdate(m_resourceGroupName, autoscaleSetting.Name, autoscaleSetting);                     }                 }             }         }  Expected behavior MetricTrigger should have MetricNamespace property
Mgmt	Storage	[QUERY] How do I enable the static website feature for azure storage blob containers via the sdk?	Query/Question How do I enable the static website feature for azure storage blob containers via the sdk? Why is this not a Bug or a feature Request? It may be a feature request im not sure if you can do it via the sdk or not. Setup (please complete the following information if applicable): I have made a new storage account using.  var resourceGroup = await azure.ResourceGroups.Define($`{uniqueId}`) .WithRegion(region) .CreateAsync(); var newstorage = await azure.StorageAccounts.Define($`{uniqueId}`) .WithRegion(region) .WithExistingResourceGroup(resourceGroup) .CreateAsync();  I want to toggle on the static website feature but I can only find doco on how to do it with the CLI / Powershell modules. Can it be done with the .net sdk? Powershell doco: https://docs.microsoft.com/en-us/powershell/module/az.storage/enable-azstoragestaticwebsite?view=azps-2.7.0&viewFallbackFrom=azps-1.3.0 Information Checklist Kindly make sure that you have added all the following information above and checkoff the required fields otherwise we will treat the issuer as an incomplete report  [/] Query Added [/] Setup information Added
Mgmt	Web Apps	ListHybridConnections didnt return list	Extension method WebAppsOperationsExtensions.ListHybridConnections(IWebAppsOperations, String, String) Method in Microsoft.Azure.Management.WebSites should return List of HybridConnection but it return one Hybrid with all null property. Something is wrongly implemented here.
Mgmt	Container Instances	ContainerState.State possible return values	Hello, I am wondering what are the possible return values of ContainerState.State that can be generated by the Azure SDK. I've looked around in the code to find more information but couldn't find any. The property itself can be found here : ./src/SDKs/ContainerInstance/Management.ContainerInstance/Generated/Models/ContainerState.cs line 60. The online documentation also seems to be lacking this information too (https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.management.containerinstance.models.containerstate.state?view=azure-dotnet#Microsoft_Azure_Management_ContainerInstance_Models_ContainerState_State) Since, the property is of type string, there can be a lot of possibility for the return value. Would it be possible to have more information on this and what are the possible return values? Thank you very much!
